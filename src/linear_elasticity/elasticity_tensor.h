//LIC// ====================================================================
//LIC// This file forms part of oomph-lib, the object-oriented, 
//LIC// multi-physics finite-element library, available 
//LIC// at http://www.oomph-lib.org.
//LIC// 
//LIC//           Version 0.90. August 3, 2009.
//LIC// 
//LIC// Copyright (C) 2006-2009 Matthias Heil and Andrew Hazel
//LIC// 
//LIC// This library is free software; you can redistribute it and/or
//LIC// modify it under the terms of the GNU Lesser General Public
//LIC// License as published by the Free Software Foundation; either
//LIC// version 2.1 of the License, or (at your option) any later version.
//LIC// 
//LIC// This library is distributed in the hope that it will be useful,
//LIC// but WITHOUT ANY WARRANTY; without even the implied warranty of
//LIC// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//LIC// Lesser General Public License for more details.
//LIC// 
//LIC// You should have received a copy of the GNU Lesser General Public
//LIC// License along with this library; if not, write to the Free Software
//LIC// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
//LIC// 02110-1301  USA.
//LIC// 
//LIC// The authors may be contacted at oomph-lib@maths.man.ac.uk.
//LIC// 
//LIC//====================================================================
//Header file for objects representing the fourth-rank elasticity tensor
//for linear elasticity problems

//Include guards to prevent multiple inclusion of the header
#ifndef OOMPH_ELASTICITY_TENSOR_HEADER
#define OOMPH_ELASTICITY_TENSOR_HEADER

// Config header generated by autoconfig
#ifdef HAVE_CONFIG_H
  #include <oomph-lib-config.h>
#endif

#include "../generic/oomph_utilities.h"

namespace oomph
{
 //=====================================================================
 /// A base class that represents the fourth-rank elasticity tensor
 /// \f$c_{ijkl}\f$ defined such that
 /// \f[\tau_{ij} = c_{ijkl} e_{kl},\f]
 /// where \f$e_{ij}\f$ is the infinitessimal (Cauchy) strain tensor
 /// and \f$\tau_{ij}\f$ is the stress tensor. The symmetries of the 
 /// tensor are such that
 /// \f[c_{ijkl} = c_{jikl} = c_{ijlk} = c_{klij}\f]
 /// and thus there are relatively few independent components. These
 /// symmetries are included in the definition of the object so that
 /// non-physical symmetries cannot be accidentally imposed.
 //=====================================================================
class ElasticityTensor
 {
  
  ///\short Translation table from the four indices to the corresponding
  ///independent component
  static const unsigned Index[3][3][3][3];

   protected:

  ///Member function that returns the i-th independent component of the
  ///elasticity tensor
  virtual inline double independent_component(const unsigned &i) const 
   {return 0.0;}


  ///\short Helper range checking function
  void range_check(const unsigned &i, const unsigned &j,
                   const unsigned &k, const unsigned &l) const
   {
    if((i >= 3) || (j >= 3) || (k>= 3) || (l>=3))
     {
      std::ostringstream error_message;
      if(i >= 3)
       {
        error_message << "Range Error : Index 1 " << i 
                      << " is not in the range (0,3)";
       }
      if(j >= 3)
       {
        error_message << "Range Error : Index 2 " << j 
                      << " is not in the range (0,3)";
       }

      if(k >= 3)
       {
        error_message << "Range Error : Index 3 " << k 
                      << " is not in the range (0,3)";
       }

      if(l >= 3)
       {
        error_message << "Range Error : Index 4 " << l 
                      << " is not in the range (0,3)";
       }
      
      //Throw the error
      throw OomphLibError(error_message.str(),
                          "ElasticityTensor::range_check()",
                          OOMPH_EXCEPTION_LOCATION);
     }
   }


  ///Empty Constructor
  ElasticityTensor() {}

 public:

  ///Empty virtual Destructor 
  virtual ~ElasticityTensor() {}

   public:
  
  ///\short Return the appropriate independent component
  ///via the index translation scheme (const version).
  double operator()(const unsigned &i, const unsigned &j,
                    const unsigned &k, const unsigned &l) const
   {
    //Range check
#ifdef PARANOID
    range_check(i,j,k,l);
#endif
    return independent_component(Index[i][j][k][l]);
   } 
 };


//===================================================================
/// An isotropic elasticity tensor using the Lame moduli
//===================================================================
 class IsotropicElasticityTensor : public ElasticityTensor
  {
   //Storage for the independent components of the elasticity tensor
  double C[4];

  //Translation scheme between the 21 independent components of the general
  //elasticity tensor and the isotropic case
  static const unsigned StaticIndex[21];
  
    public:
  
  ///Constructor, Passing in the values of the Lame moduli (lambda and mu)
  IsotropicElasticityTensor(const double &lambda,
                            const double &mu) : ElasticityTensor()
   {
    //Set the three indepdent components
    C[0] = 0.0;
    this->set_lame_coefficients(lambda,mu);
   }
    
  //Set the values of the lame coefficients
  void set_lame_coefficients(const double &lambda, const double &mu)
   {
    C[1] = lambda + 2.0*mu;
    C[2] = lambda;
    C[3] = mu;
   }

  ///Overload the independent coefficient function
  inline double independent_component(const unsigned &i) const
   {return C[StaticIndex[i]];}
    
 };

}
#endif
