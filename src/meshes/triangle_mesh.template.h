//LIC// ====================================================================
//LIC// This file forms part of oomph-lib, the object-oriented, 
//LIC// multi-physics finite-element library, available 
//LIC// at http://www.oomph-lib.org.
//LIC// 
//LIC//           Version 0.90. August 3, 2009.
//LIC// 
//LIC// Copyright (C) 2006-2009 Matthias Heil and Andrew Hazel
//LIC// 
//LIC// This library is free software; you can redistribute it and/or
//LIC// modify it under the terms of the GNU Lesser General Public
//LIC// License as published by the Free Software Foundation; either
//LIC// version 2.1 of the License, or (at your option) any later version.
//LIC// 
//LIC// This library is distributed in the hope that it will be useful,
//LIC// but WITHOUT ANY WARRANTY; without even the implied warranty of
//LIC// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//LIC// Lesser General Public License for more details.
//LIC// 
//LIC// You should have received a copy of the GNU Lesser General Public
//LIC// License along with this library; if not, write to the Free Software
//LIC// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
//LIC// 02110-1301  USA.
//LIC// 
//LIC// The authors may be contacted at oomph-lib@maths.man.ac.uk.
//LIC// 
//LIC//====================================================================
#ifndef OOMPH_TRIANGLE_MESH_HEADER
#define OOMPH_TRIANGLE_MESH_HEADER
// Config header generated by autoconfig
#ifdef HAVE_CONFIG_H
#include <oomph-lib-config.h>
#endif


#ifdef OOMPH_HAS_MPI
//mpi headers
#include "mpi.h"
#endif

//Standards
#include<float.h>
#include <iostream>
#include <fstream>
#include <string.h>

#include "../generic/problem.h" 
#include "../generic/triangle_scaffold_mesh.h" 
#include "../generic/triangle_mesh.h"
#include "../generic/refineable_mesh.h"

// Interface to triangulate function
extern "C" {
 void triangulate(char *triswitches, struct oomph::TriangulateIO *in,
                  struct oomph::TriangulateIO *out, 
                  struct oomph::TriangulateIO *vorout);
}


namespace oomph
{
 
//============start_of_triangle_class===================================
/// Triangle mesh build with the help of the scaffold mesh coming  
/// from the triangle mesh generator Triangle.
/// http://www.cs.cmu.edu/~quake/triangle.html
//======================================================================
 template <class ELEMENT>
  class TriangleMesh : public virtual TriangleMeshBase
 {
   public:
  
   /// \short Empty constructor 
  TriangleMesh()
   {
    // Using this constructor no Triangulateio object is built
    Triangulateio_exists=false;
   }
  
  /// \short Constructor with the input files
  TriangleMesh(const std::string& node_file_name,
               const std::string& element_file_name,
               const std::string& poly_file_name,
               TimeStepper* time_stepper_pt=
               &Mesh::Default_TimeStepper,
               const bool &use_attributes=false)   
   {
    //Store the attributes
    Use_attributes = use_attributes;

    // Store Timestepper used to build elements
    Time_stepper_pt=time_stepper_pt;
    
    // Using this constructor build the triangulatio
    TriangleHelper::create_triangulateio_from_polyfiles(node_file_name,
                                                        element_file_name,
                                                        poly_file_name,
                                                        Triangulateio);
    //Record that the triangulateio object has been created      
    Triangulateio_exists=true;

    // Build scaffold
    Tmp_mesh_pt= new 
     TriangleScaffoldMesh(node_file_name,
                          element_file_name,
                          poly_file_name);
    
    // Convert mesh from scaffold to actual mesh
    build_from_scaffold(time_stepper_pt,use_attributes);
    
    // Kill the scaffold
    delete Tmp_mesh_pt;
    Tmp_mesh_pt=0;
    
    // Setup boundary coordinates for boundaries
    unsigned nb=nboundary();
    for (unsigned b=0;b<nb;b++)
     {
      this->setup_boundary_coordinates(b);
     }
   }
  
  
  /// \short Constructor based on TriangulateIO object 
  TriangleMesh(TriangulateIO& triangulate_io,
               TimeStepper* time_stepper_pt=
               &Mesh::Default_TimeStepper,
               const bool &use_attributes=false)  
   {
    //Store the attributes flag
    Use_attributes = use_attributes;

    // Store Timestepper used to build elements
    Time_stepper_pt=time_stepper_pt;
    
    // Build scaffold
    Tmp_mesh_pt= new TriangleScaffoldMesh(triangulate_io);
    
    // Initialize TriangulateIO structure
    TriangleHelper::initialise_triangulateio(Triangulateio);
    
    // Triangulation has been created -- remember to wipe it!
    Triangulateio_exists=true;
    
    // Deep-copy triangulateio data into the Triangulateio private object
    bool quiet=true;
    Triangulateio=TriangleHelper::deep_copy_of_triangulateio_representation(
     triangulate_io,quiet);
    
    // Convert mesh from scaffold to actual mesh
    build_from_scaffold(time_stepper_pt,use_attributes);
    
    // Kill the scaffold
    delete Tmp_mesh_pt;
    Tmp_mesh_pt=0;
    
    // Setup boundary coordinates for boundaries
    unsigned nb=nboundary();
    for (unsigned b=0;b<nb;b++)
     {
      this->setup_boundary_coordinates(b);
     }
   }
  
  /// \short Build mesh, based on TriangleMeshPolygon that specifies
  /// the outer boundary of the domain and any number of internal
  /// holes, specified by TriangleMeshHolePolygons. Also specify
  /// target area for uniform element size.
  TriangleMesh(TriangleMeshPolygon* &outer_boundary_pt,
               Vector<TriangleMeshHolePolygon*> &inner_hole_pt,
               const double &element_area,
               TimeStepper* time_stepper_pt=
               &Mesh::Default_TimeStepper,
               std::set<unsigned> &fill_index
               = Empty_fill_index,
               const bool &use_attributes=false) 
   {
    //Find out how many boundaries there are before we get to the holes
    unsigned boundary_index = outer_boundary_pt->nsegment();
    
    //So loop over the remaning boundaries
    unsigned n_total_boundary = boundary_index;
    
    //Loop over the holes
    unsigned n_hole = inner_hole_pt.size();
    for(unsigned h=0;h<n_hole;++h)
     {
      //Add the number of boundaries to the total
      //Each boundary is assumed to be a separate polyline
      n_total_boundary += inner_hole_pt[h]->npolyline();
     }

    //Now resize the storage for the boundary geometric objects
    this->Boundary_geom_object_pt.resize(n_total_boundary,0);
    this->Boundary_coordinate_limits.resize(n_total_boundary);

    //Loop over the holes again and store the associated geometric objects
    //and coordinates
    for(unsigned h=0;h<n_hole;h++)
     {
      //Can the Polygon be cast to a geometric object incarnation
      GeomObject* bound_geom_obj_pt 
       = dynamic_cast<GeomObject*>(inner_hole_pt[h]);
      
      //If cast successful set up the coordinates 
      if(bound_geom_obj_pt!=0) 
       {
        unsigned n_poly = inner_hole_pt[h]->npolyline();
        for(unsigned p=0;p<n_poly;p++)
         {
          //Read out the index of the boundary from the polyline
          unsigned b_index = inner_hole_pt[h]->polyline_pt(p)->boundary_id();
          //Set the geometric object
          this->Boundary_geom_object_pt[b_index] = bound_geom_obj_pt;
          //The coordinates along each polyline boundary are scaled to
          //of unit length so the total coordinate limits are simply
          //(p,p+1)
          this->Boundary_coordinate_limits[b_index].resize(2);
          this->Boundary_coordinate_limits[b_index][0] = p;
          this->Boundary_coordinate_limits[b_index][1] = p + 1.0;
         }
       }
     }


    Vector<GeomObject*> hole_geom_object_pt;
    Vector<Vector<double> > split_coord;

    this->generic_constructor(outer_boundary_pt,
                              inner_hole_pt,
                              hole_geom_object_pt,
                              split_coord,
                              fill_index,
                              element_area,
                              time_stepper_pt,
                              use_attributes);

    // Setup boundary coordinates for boundaries
    unsigned nb=nboundary();
    for (unsigned b=0;b<nb;b++)
     {
      this->setup_boundary_coordinates(b);
     }
   }

  /// \short Build mesh, based on a TriangleMeshPolygon that specifies
  /// the outer boundary of the domain and any number of internal
  /// holes, specified by geometric objects. Boundary numbers will
  /// be assigned based on the split coordinates of the geometric objects.
  /// The assumption is that the geometric objects are closed.
  /// Also specify target area for uniform element size.
  TriangleMesh(TriangleMeshPolygon* &outer_boundary_pt,
               Vector<GeomObject*> &hole_geom_object_pt,
               Vector<Vector<double> > &split_coord,
               const double &element_area,
               TimeStepper* time_stepper_pt=
               &Mesh::Default_TimeStepper,
               std::set<unsigned> &fill_index
               = Empty_fill_index,
               const bool &use_attributes=false) 
   {
    //Create the PolyLine representation of the boundary and
    //then call an alternative constructor
    
    // Number of points defining hole (should be passed in)
    unsigned ppoints = 8; 

    //Set the id of the first hole boundary (the number of segments 
    //in the boundary plus one)
    unsigned hole_id = outer_boundary_pt->nsegment() + 1;
    
    //Find the number of holes
    unsigned n_hole = hole_geom_object_pt.size();

    Vector<double> x_centre(2);
    Vector<double> y_centre(2);

    x_centre[0] = 0.0; x_centre[1] = 0.5;
    y_centre[0] = 0.0; y_centre[1] = 0.6;                     
                        
    // Define the vector of angle value to build the hole
    Vector<double> zeta(1);
    // Initialize the vector of coordinates
    Vector<double> coord(2); 

    //Storage for the triangle polygons that define the boundary
    Vector<TriangleMeshHolePolygon*> inner_hole_pt(n_hole);

    
    //Find out the total number of boundaries so far
    unsigned n_total_boundary = hole_id - 1;
    
    //Loop over the number of holes
    for(unsigned h=0;h<n_hole;++h)
     {
      //How many segments are there
      unsigned n_seg = split_coord.size();
      //Add to the total number of boundaries
      n_total_boundary += n_seg;

      // Each hole is bounded by  distinct boundaries, each
      // represented by its own polyline
      Vector<TriangleMeshPolyLine*> hole_segment_pt(n_seg);    
      
      //Loop over the segments
      for(unsigned s=0;s<n_seg;s++)
       {
        // Vertex coordinates
        Vector<Vector<double> > bound_hole(ppoints);
        
        //Read the values of the coordinates, assuming equal
        //spacing of the nodes
        double zeta_initial = split_coord[s][0];
        double zeta_increment = 
         (split_coord[s][1] - split_coord[s][0])/(double)(ppoints-1);
        
        // Create points on boundary
        for(unsigned ipoint=0; ipoint<ppoints;ipoint++)
         {
          // Resize the vector 
          bound_hole[ipoint].resize(2);
          
          // Get the coordinates
          zeta[0]= zeta_initial + zeta_increment*double(ipoint);
          
          hole_geom_object_pt[h]->position(zeta,coord);
          bound_hole[ipoint][0]=coord[0];
          bound_hole[ipoint][1]=coord[1];
         }
        
        // Build the 1st hole polyline
        hole_segment_pt[s] = 
         new TriangleMeshPolyLine(bound_hole,hole_id);
        
        //Increment the boundary id
        ++hole_id;
       } //end of loop over segments
      
      // Inner hole center coordinates
      Vector<double> hole_center(2);
      hole_center[0]=x_centre[h];
      hole_center[1]=y_centre[h];
      
      // Fill in the vector of holes. Specify data that define centre's
      // displacement
      inner_hole_pt[h] = new TriangleMeshHolePolygon(
       hole_center,hole_segment_pt);
     }
    
    //now resize the storage
    this->Boundary_geom_object_pt.resize(n_total_boundary,0);
    this->Boundary_coordinate_limits.resize(n_total_boundary);
    
    //Initialise the boudary counter
    unsigned boundary_index = outer_boundary_pt->nsegment();
    //Loop over the holes again and store the associated geometric objects
    //and coordinates

    for(unsigned h=0;h<n_hole;h++)
     {
      unsigned n_seg = split_coord.size();
      for(unsigned s=0;s<n_seg;s++)
       {
        //Set the boundary geometric object and limits
        Boundary_geom_object_pt[boundary_index] = hole_geom_object_pt[h];
        Boundary_coordinate_limits[boundary_index] = split_coord[s];
        ++boundary_index;
       }
     }

    //Call the method used in the alternative constructor
    this->generic_constructor(outer_boundary_pt,
                              inner_hole_pt,
                              hole_geom_object_pt,
                              split_coord,
                              fill_index,
                              element_area,
                              time_stepper_pt,
                              use_attributes);

    // Setup boundary coordinates for boundaries
    unsigned nb=nboundary();
    for (unsigned b=0;b<nb;b++)
     {
      this->setup_boundary_coordinates(b);
     }

   }
  

  /// \short Build mesh, based on GeometricObject that specifies
  /// the outer boundary of the domain and any number of internal
  /// holes, specified by TriangleMeshHolePolygons. Also specify
  /// target area for uniform element size.
  TriangleMesh(GeomObject* &outer_geom_object_pt,
               Vector<Vector<double> > &outer_split_coord,
               Vector<TriangleMeshHolePolygon*> &inner_hole_pt,
               const double &element_area,
               TimeStepper* time_stepper_pt=
               &Mesh::Default_TimeStepper,
               std::set<unsigned> &fill_index
               = Empty_fill_index,
               const bool &use_attributes=false) 
   {
    //Find the number of boundaries 
    unsigned boundary_index = outer_split_coord.size();
     
    // Number of points defining hole (should be passed in)
    unsigned ppoints = 21;//11; 

    //Set the id of the first outer segment (1)
    unsigned outer_id = 1;
                        
    // Define the vector of angle value to build the hole
    Vector<double> zeta(1);
    // Initialize the vector of coordinates
    Vector<double> coord(2); 
    
    //How many segments are there
    unsigned n_outer_seg = outer_split_coord.size();
    
    //Each segment is represented by a polyline
    Vector<TriangleMeshPolyLine*> outer_boundary_segment_pt(n_outer_seg);    
    
    //Loop over the segments
    for(unsigned s=0;s<n_outer_seg;s++)
     {
      // Vertex coordinates
      Vector<Vector<double> > bound_outer(ppoints);
      
      //Read the values of the coordinates, assuming equal
      //spacing of the nodes
      double zeta_initial = outer_split_coord[s][0];
      double zeta_increment = 
       (outer_split_coord[s][1] - outer_split_coord[s][0])/(double)(ppoints-1);
        
      // Create points on boundary
      for(unsigned ipoint=0; ipoint<ppoints;ipoint++)
       {
        // Resize the vector 
        bound_outer[ipoint].resize(2);
        
        // Get the coordinates
        zeta[0]= zeta_initial + zeta_increment*double(ipoint);
        
        outer_geom_object_pt->position(zeta,coord);
        bound_outer[ipoint][0]=coord[0];
        bound_outer[ipoint][1]=coord[1];
       }
        
      // Build the outer boundary polyline
      outer_boundary_segment_pt[s] = 
       new TriangleMeshPolyLine(bound_outer,outer_id);
      
      //Increment the boundary id
      ++outer_id;
     } //end of loop over segments
      

    //Now make the polygon
    TriangleMeshPolygon* outer_boundary_pt 
     = new TriangleMeshPolygon(outer_boundary_segment_pt);

    //So loop over the remaning boundaries
    unsigned n_total_boundary = boundary_index;
    
    //Loop over the holes
    unsigned n_hole = inner_hole_pt.size();
    for(unsigned h=0;h<n_hole;++h)
     {
      //Add the number of boundaries to the total
      //Each boundary is assumed to be a separate polyline
      n_total_boundary += inner_hole_pt[h]->npolyline();
     }

    //Now resize the storage for the boundary geometric objects
    this->Boundary_geom_object_pt.resize(n_total_boundary,0);
    this->Boundary_coordinate_limits.resize(n_total_boundary);

    //Set the boundary objects and limits for the outer boundary
    for(unsigned s=0;s<n_outer_seg;s++)
     {
      this->Boundary_geom_object_pt[s] = outer_geom_object_pt;
      this->Boundary_coordinate_limits[s] = outer_split_coord[s];
     }


    //Loop over the holes again and store the associated geometric objects
    //and coordinates
    for(unsigned h=0;h<n_hole;h++)
     {
      //Can the Polygon be cast to a geometric object incarnation
      GeomObject* bound_geom_obj_pt 
       = dynamic_cast<GeomObject*>(inner_hole_pt[h]);
      
      //If cast successful set up the coordinates 
      if(bound_geom_obj_pt!=0) 
       {
        unsigned n_poly = inner_hole_pt[h]->npolyline();
        for(unsigned p=0;p<n_poly;p++)
         {
          //Read out the index of the boundary from the polyline
          unsigned b_index = inner_hole_pt[h]->polyline_pt(p)->boundary_id();
          //Set the geometric object
          this->Boundary_geom_object_pt[b_index] = bound_geom_obj_pt;
          //The coordinates along each polyline boundary are scaled to
          //of unit length so the total coordinate limits are simply
          //(p,p+1)
          this->Boundary_coordinate_limits[b_index].resize(2);
          this->Boundary_coordinate_limits[b_index][0] = p;
          this->Boundary_coordinate_limits[b_index][1] = p + 1.0;
         }
       }
     }

    Vector<GeomObject*> hole_geom_object_pt;
    Vector<Vector<double> > split_coord;

    this->generic_constructor(outer_boundary_pt,
                              inner_hole_pt,
                              hole_geom_object_pt,
                              split_coord,
                              fill_index,
                              element_area,
                              time_stepper_pt,
                              use_attributes);

    // Setup boundary coordinates for boundaries
    unsigned nb=nboundary();
    for (unsigned b=0;b<nb;b++)
     {
      this->setup_boundary_coordinates(b);
     }


    //Excatly map the outer boundary onto the geometric object
    //This may be overwritten later in the driver
    /*for(unsigned s=0;s<n_outer_seg;s++)
     {
      Vector<double> b_coord(1);
      Vector<double> new_x(2);
      const unsigned n_boundary_node = this->nboundary_node(s);
      for(unsigned n=0;n<n_boundary_node;++n)
       {
        //Can do this from the standard boundary_node interfaces 
        //because there is only one
        //region that neighbours the outer boundary
        Node* const nod_pt = this->boundary_node_pt(s,n);
        nod_pt->get_coordinates_on_boundary(s,b_coord);
        //Get the position according to the underlying geometric object
        outer_geom_object_pt->position(b_coord,new_x);
        for(unsigned i=0;i<2;i++)
         {
          nod_pt->x(i) = new_x[i];
         }
       }
       }*/
    this->snap_nodes_onto_geometric_objects();
   }

  
  
  /// Build mesh from poly file, with specified target
  /// area for all elements.
  TriangleMesh(const std::string& poly_file_name,
               const double& element_area,
               TimeStepper* time_stepper_pt=
               &Mesh::Default_TimeStepper,
               const bool &use_attributes=false)
   
   {  

    // Disclaimer
    std::string message=
     "This constructor hasn't been tested since last cleanup.\n";
    OomphLibWarning(message,
                    "TriangleMesh::TriangleMesh()",
                    OOMPH_EXCEPTION_LOCATION);
    
    //Store the attributes flag
    Use_attributes = use_attributes;

    // Store Timestepper used to build elements
    Time_stepper_pt=time_stepper_pt;
    
    // Create the data structures required to call the triangulate function
    TriangulateIO triangle_in;
    
    // Input string for triangle
    std::stringstream input_string_stream;
    input_string_stream<<"-p-a" << element_area << "q30";
    
    // Convert to a *char required by the triangulate function
     char triswitches[100];
     sprintf(triswitches,"%s",input_string_stream.str().c_str());
     
    // Build the input triangulateio object from the .poly file
    build_triangulateio(poly_file_name, triangle_in);
    
    // Build the triangulateio out object
    triangulate(triswitches, &triangle_in, &Triangulateio, 0);
    
    // Build scaffold
    Tmp_mesh_pt= new TriangleScaffoldMesh(Triangulateio);
    
    // Convert mesh from scaffold to actual mesh
    build_from_scaffold(time_stepper_pt,use_attributes);
    
    // Kill the scaffold
    delete Tmp_mesh_pt;
    Tmp_mesh_pt=0;
    
    // Cleanup but leave hole alone
    bool clear_hole_data=false;
    TriangleHelper::clear_triangulateio(triangle_in,clear_hole_data);

    // Setup boundary coordinates for boundaries
    unsigned nb=nboundary();
    for (unsigned b=0;b<nb;b++)
     {
      this->setup_boundary_coordinates(b);
     }
   }
  
  /// Broken copy constructor
  TriangleMesh(const TriangleMesh& dummy) 
   { 
    BrokenCopy::broken_copy("TriangleMesh");
   } 
  
  /// Broken assignment operator
  void operator=(const TriangleMesh&) 
   {
    BrokenCopy::broken_assign("TriangleMesh");
   }
  
  /// Destructor 
  virtual ~TriangleMesh() 
   {     
    if (Triangulateio_exists) 
     {
      TriangleHelper::clear_triangulateio(Triangulateio);
     }
   }
  
  /// \short Setup boundary coordinate on boundary b.
  /// Boundary coordinate increases continously along
  /// polygonal boundary. It's zero at the lowest left
  /// smallest node on the boundary.
  void setup_boundary_coordinates(const unsigned& b)
  {
   // Dummy file
   std::ofstream some_file;
   setup_boundary_coordinates(b,some_file);
  }
  
  /// \short Setup boundary coordinate on boundary b. Doc Faces
  /// in outfile.
  /// Boundary coordinate increases continously along
  /// polygonal boundary. It's zero at the lowest left
  /// node on the boundary.
  void setup_boundary_coordinates(const unsigned& b,
                                  std::ofstream& outfile);
  
  /// Return the number of elements adjacent to boundary b in region r
  inline unsigned nboundary_element_in_region(const unsigned &b,
                                        const unsigned &r) const
   {
    //Need to use a constant iterator here to keep the function "const"
    //Return an iterator to the appropriate entry, if we find it
    std::map<unsigned,Vector<FiniteElement*> >::const_iterator it =
     Boundary_region_element_pt[b].find(r);
    if(it!=Boundary_region_element_pt[b].end())
     {
      return (it->second).size();
     }
    //Otherwise there are no elements adjacent to boundary b in the region r
    else
     {
      return 0;
     }
   }

  /// Return pointer to the e-th element adjacent to boundary b in region r
  FiniteElement* boundary_element_pt_in_region(const unsigned &b, 
                                               const unsigned &r,
                                               const unsigned &e) const
   {
    //Use a constant iterator here to keep function "const" overall
    std::map<unsigned,Vector<FiniteElement*> >::const_iterator it =
     Boundary_region_element_pt[b].find(r);
    if(it!=Boundary_region_element_pt[b].end())
     {
      return (it->second)[e];
     }
    else
     {
      return 0;
     }
   }

  /// Return face index of the e-th element adjacent to boundary b in region r
  int face_index_at_boundary_in_region(const unsigned &b, 
                                       const unsigned &r,
                                       const unsigned &e) const
   {
    //Use a constant iterator here to keep function "const" overall
    std::map<unsigned,Vector<int> >::const_iterator it =
     Face_index_region_at_boundary[b].find(r);
    if(it!=Face_index_region_at_boundary[b].end())
     {
      return (it->second)[e];
     }
    else
     {
      std::ostringstream error_message;
      error_message << "Face indices not set up for boundary " 
                    << b << " in region " << r << "\n";
      error_message 
       << "This probably means that the boundary is not adjacent to region\n";
      throw OomphLibError(error_message.str(),
                          "TriangleMesh::face_index_at_boundary_in_region()",
                          OOMPH_EXCEPTION_LOCATION);
     }
   }



  /// Return the number of regions specified by attributes
  unsigned nregion() {return Region_element_pt.size();}
  
  /// Return the number of elements in region i
  unsigned nregion_element(const unsigned &i) 
  {return Region_element_pt[i].size();}
  
  /// Return the attribute associated with region i
  double region_attribute(const unsigned &i)
  {return Region_attribute[i];}
  
  /// Return the e-th element in the i-th region
  FiniteElement* region_element_pt(const unsigned &i,
                                   const unsigned &e)
  {return Region_element_pt[i][e];}
  

  /// \short Return the geometric object associated with the b-th boundary or
  /// null if the boundary has associated geometric object.
  GeomObject* boundary_geom_object_pt(const unsigned &b)
   {
    if(Boundary_geom_object_pt.size()==0) 
     {return 0;}
    else 
     {return Boundary_geom_object_pt[b];}
   }
  
  /// \short Return direct access to the geometric object storage
  Vector<GeomObject*> &boundary_geom_object_pt() 
   {return Boundary_geom_object_pt;}
  
  /// \short Return access to the vector of boundary coordinates associated
  ///with each geometric object
  Vector<Vector<double> > &boundary_coordinate_limits()
   {return Boundary_coordinate_limits;}
  
  /// \short Return access to the coordinate limits assocaieted with 
  /// the geometric object associated with boundary b
  Vector<double> &boundary_coordinate_limits(const unsigned &b)
   {
    if(Boundary_coordinate_limits.size()==0)
     {
      throw OomphLibError(
       "No coordinate limits associated with this boundary\n",
       "TESTER",
       OOMPH_EXCEPTION_LOCATION);
     }
    else
     {
      return Boundary_coordinate_limits[b];
     }
   }
  
  /// \short Update the TriangulateIO object to the current nodal position
  /// and the centre hole coordinates.
  void update_triangulateio(Vector<Vector<double> >&hole_centre)
  {
    // Move the hole center
    // Get number of holes
   unsigned nhole=Triangulateio.numberofholes;
   unsigned count_coord=0;
   for(unsigned ihole=0;ihole<nhole;ihole++)
    {
     Triangulateio.holelist[count_coord]+=hole_centre[ihole][0];  
     Triangulateio.holelist[count_coord+1]+=hole_centre[ihole][1]; 
     
     // Increment counter
     count_coord+=2;
    }
   
   // Do the update
   update_triangulateio();
  }
   
  /// \short Update the triangulateio object to the current nodal positions
  void update_triangulateio()
  {   
   // Get number of points
   unsigned nnode = Triangulateio.numberofpoints;
   double new_x=0;
   double new_y=0;
   
   // Loop over the points
   for(unsigned inod=0;inod<nnode;inod++)
    {      
     // Get the node Id to be updated
     unsigned count=Oomph_vertex_nodes_id[inod];
     
     // Update vertices using the vertex_node_id giving for the TriangulateIO
     // vertex enumeration the corresponding oomphlib mesh enumeration
     Node* mesh_node_pt=this->node_pt(inod);
     new_x=mesh_node_pt->x(0); 
     new_y=mesh_node_pt->x(1); 
     Triangulateio.pointlist[count*2] = new_x;  
     Triangulateio.pointlist[(count*2)+1] = new_y;       
    }
  }
  
  /// \short Completely regenerate the mesh from the trianglateio structure
  void remesh_from_internal_triangulateio()
   {
    //Remove all the boundary node information
    this->remove_boundary_nodes();

    //Delete exisiting nodes
    unsigned n_node = this->nnode();
    for(unsigned n=n_node;n>0;--n)
     {
      delete this->Node_pt[n-1];
      this->Node_pt[n-1] = 0;
     }
    //Delete exisiting elements
    unsigned n_element = this->nelement();
    for(unsigned e=n_element;e>0;--e)
     {
      delete this->Element_pt[e-1];
      this->Element_pt[e-1] = 0;
     }
    //Flush the storage
    this->flush_element_and_node_storage();

    //Delete all boundary element information
    //ALH: Kick up the object hierarchy?
    this->Boundary_element_pt.clear();
    this->Face_index_at_boundary.clear();
    this->Region_element_pt.clear();
    this->Region_attribute.clear();
    this->Boundary_region_element_pt.clear();
    this->Face_index_region_at_boundary.clear();

    //Now build the new scaffold
    Tmp_mesh_pt= new TriangleScaffoldMesh(this->Triangulateio);
        
    // Triangulation has been created -- remember to wipe it!
    Triangulateio_exists=true;
    
    // Convert mesh from scaffold to actual mesh
    build_from_scaffold(this->Time_stepper_pt,this->Use_attributes);
    
    // Kill the scaffold
    delete Tmp_mesh_pt;
    Tmp_mesh_pt=0;

    // Setup boundary coordinates for boundaries
    unsigned nb=nboundary();
    for (unsigned b=0;b<nb;b++)
     {
      this->setup_boundary_coordinates(b);
     }

    //Deform the boundary onto any geometric objects
    this->snap_nodes_onto_geometric_objects();
   }


  /// \short Get a map containing Vectors of sub-boundary IDs. One
  /// for each each Polyline boundary.
  std::map<unsigned,Vector<unsigned> >& sub_boundary_id()
   {
    // Check if the  sub-boundary enumeration exists or not
    if(Sub_boundary_id_exists)
     {
      return Sub_boundary_id;
     }
    else
     // Shout!
     {
      std::ostringstream error_stream;
      error_stream<<"Function sub_boundary_id()"
                   <<"cannot be called if\n no sub_boundary_id vector"
                  <<"has been built. Please call a different constructor.\n "
                  <<std::endl;
       throw OomphLibError(error_stream.str(),
                           "TriangleMesh<ELEMENT>::"
                           "sub_boundary_id()",
                           OOMPH_EXCEPTION_LOCATION); 
      }
   }
  
  
  /// Boolean defining if sub-boundary enumeration has been built or not
  bool sub_boundary_id_exists(){return Sub_boundary_id_exists;}
  
  /// Boolean defining if Triangulateio object has been built or not
  bool triangulateio_exists(){return Triangulateio_exists;}
  
  /// \short Return the vector that contains the oomph-lib node number
  /// for all vertex nodes in the TriangulateIO representation of the mesh
  Vector<unsigned> oomph_vertex_nodes_id(){return Oomph_vertex_nodes_id;}
    
  
    protected:

  /// Static empty set for use as a default argument
  /// to to constructor
  static std::set<unsigned> Empty_fill_index;

  /// Build mesh from scaffold
  void build_from_scaffold(TimeStepper* time_stepper_pt,
                           const bool &use_attributes);
  
  /// \short Build TriangulateIO object from TriangleMeshPolyLine and 
  /// TriangleMeshHolePolyLine
  void build_triangulateio(TriangleMeshPolygon* &outer_boundary_pt,
                           Vector<TriangleMeshHolePolygon*> &inner_hole,
                           std::set<unsigned> &fill_index,
                           TriangulateIO& triangulate_io);
  
  /// \short Helper function to create TriangulateIO object (return in
  /// triangulate_io) from the .poly file 
  void build_triangulateio(const std::string& poly_file_name,
                           TriangulateIO& triangulate_io);


   
  /// \short Snap the boundary nodes onto any curvilinear boundaries
  /// defined by geometric objects
  void snap_nodes_onto_geometric_objects();


  /// \short A general-purpose construction function that builds the
  /// mesh once the different specific constructors have assembled the
  /// appropriate information: in the case of curvilinear boundaries, the 
  /// PSLG must be generated; in the case of a PSLG input, the boundary
  /// geometric objects must be generated.
  void generic_constructor(TriangleMeshPolygon* &outer_boundary_pt,
                           Vector<TriangleMeshHolePolygon*> &inner_hole_pt,
                           Vector<GeomObject*> &hole_geom_object_pt,
                           Vector<Vector<double> > &split_coord,
                           std::set<unsigned> &fill_index,
                           const double &element_area,
                           TimeStepper* time_stepper_pt,
                           const bool &use_attributes) 
   {
    //Store the attribute flag
    Use_attributes = use_attributes;

    // Store Timestepper used to build elements
    Time_stepper_pt=time_stepper_pt;
    
    // Store outer polygon
    Outer_boundary_pt=outer_boundary_pt;
    
    // Store inner holes by copy constructor
    Inner_hole_pt=inner_hole_pt;
    
    // Store the fill index
    Fill_index = fill_index;

    // Create the data structures required to call the triangulate function
    TriangulateIO triangulate_io;
    
    // Initialize TriangulateIO structure
    TriangleHelper::initialise_triangulateio(triangulate_io);
    
    // Convert TriangleMeshPolyLine and TriangleMeshHolePolyLine
    // to a triangulateio object
    build_triangulateio(outer_boundary_pt,
                        inner_hole_pt,
                        fill_index,
                        triangulate_io);

    // Sub_boundary_id vector is generated using this constructor only
    // set the boolean to true
    Sub_boundary_id_exists=true;
    
    // Initialize TriangulateIO structure
    TriangleHelper::initialise_triangulateio(Triangulateio);
    
    // Triangulation has been created -- remember to wipe it!
    Triangulateio_exists=true;
    
    // Input string for triangle
    std::stringstream input_string_stream;
    input_string_stream<<"-pA-a" << element_area << "q30";
    
    // Convert the Input string in *char required by the triangulate function
     char triswitches[100];
     sprintf(triswitches,"%s",input_string_stream.str().c_str());
     
    // Build the mesh using triangulate function
    triangulate(triswitches, &triangulate_io, &Triangulateio, 0);   
    
    // Build scaffold
    Tmp_mesh_pt= new TriangleScaffoldMesh(Triangulateio);
    
    //If we have filled holes then we must use the attributes
    if(fill_index.size() > 0) 
     {
      // Convert mesh from scaffold to actual mesh
      build_from_scaffold(time_stepper_pt,true);
      //Record the attribute flag
      Use_attributes=true;
     }
    //Otherwise use what was asked
    else
     {
      // Convert mesh from scaffold to actual mesh
      build_from_scaffold(time_stepper_pt,use_attributes);
     }

    // Kill the scaffold
    delete Tmp_mesh_pt;
    Tmp_mesh_pt=0;
    
    // Cleanup but leave hole and regions alone since it's still used
    bool clear_hole_data=false;
    TriangleHelper::clear_triangulateio(triangulate_io,clear_hole_data);
   }
 
 
  /// Boolean defining if Triangulateio object has been built or not
  bool Triangulateio_exists;
  
  /// Boolean defining if sub-boundary lookup scheme has been built or not
  bool Sub_boundary_id_exists;
  
  /// \short Map of Vectors containing the sub-boundary IDs associated
  /// with each Polyline
  std::map<unsigned,Vector<unsigned> > Sub_boundary_id;
  
  /// Temporary scaffold mesh
  TriangleScaffoldMesh* Tmp_mesh_pt;
    
  /// \short Vector storing oomph-lib node number
  /// for all vertex nodes in the TriangulateIO representation of the mesh
  Vector<unsigned> Oomph_vertex_nodes_id;
  
  /// Vectors of elements in each region differentiated by attribute
  Vector<Vector<FiniteElement* > > Region_element_pt;
  
  /// Vector of attributes associated with the elements in each region
  Vector<double> Region_attribute;
  
  /// Polygon that defines outer boundaries
  TriangleMeshPolygon* Outer_boundary_pt;
  
  /// Vector to polygons that define inner holes
  Vector<TriangleMeshHolePolygon*> Inner_hole_pt;
  
  /// Storage for the geometric objects associated with any boundaries
  Vector<GeomObject*> Boundary_geom_object_pt;

  /// Storage of indices of any inner holes that should be filled
  std::set<unsigned> Fill_index;

  /// Storage for elements adjacent to a boundary in a particular region
  Vector<std::map<unsigned,Vector<FiniteElement*> > > 
   Boundary_region_element_pt;

  /// \short Storage for the face index adjacent to a boundary in a particular
  /// region
  Vector<std::map<unsigned,Vector<int> > > Face_index_region_at_boundary;

  /// \short  Storage for the limits of the boundary coordinates 
  /// defined by the of geometric objects
  Vector<Vector<double> > Boundary_coordinate_limits;

  /// Timestepper used to build elements
  TimeStepper* Time_stepper_pt;

  /// Boolean flag to indicate whether to use attributes or not
  /// (required for multidomain meshes
  bool Use_attributes;
  
 };


//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////

 
//=========================================================================
// Unstructured refineable Triangle Mesh 
//=========================================================================
template<class ELEMENT>
 class RefineableTriangleMesh : public virtual TriangleMesh<ELEMENT>,
  public virtual RefineableMeshBase
  {
   
    public:
   
   
   /// \short Build mesh, based on TriangleMeshPolygon that specifies
   /// the outer boundary of the domain and any number of internal
   /// holes, specified by TriangleMeshHolePolygons. Specify
   /// target area for uniform element size.
    RefineableTriangleMesh(TriangleMeshPolygon* &outer_boundary_polyline_pt,
                           Vector<TriangleMeshHolePolygon*> &inner_hole_pt,
                           const double& element_area,
                           TimeStepper* time_stepper_pt=
                           &Mesh::Default_TimeStepper,
                           std::set<unsigned> &fill_index
                           = TriangleMesh<ELEMENT>::Empty_fill_index,
                           const bool &use_attributes=false):
   TriangleMesh<ELEMENT>(outer_boundary_polyline_pt, 
                         inner_hole_pt, 
                         element_area,
                         time_stepper_pt,
                         fill_index,
                         use_attributes)
    {
     // Initialise the data associated with adaptation
     initialise();
    }
   
    /// \short Build mesh, based on TriangleMeshPolygon that specifies
    /// the outer boundary of the domain and any number of internal
    /// holes, specified by TriangleMeshHolePolygons. Specify
    /// target area for uniform element size.
    RefineableTriangleMesh(TriangleMeshPolygon* &outer_boundary_polyline_pt,
                           Vector<GeomObject*> &hole_geom_object_pt,
                           Vector<Vector<double> > &split_coord,
                           const double& element_area,
                           TimeStepper* time_stepper_pt=
                           &Mesh::Default_TimeStepper,
                           std::set<unsigned> &fill_index
                           = TriangleMesh<ELEMENT>::Empty_fill_index,
                           const bool &use_attributes=false):
     TriangleMesh<ELEMENT>(outer_boundary_polyline_pt, 
                           hole_geom_object_pt,
                           split_coord,
                           element_area,
                           time_stepper_pt,
                           fill_index,
                           use_attributes)
     {
      // Initialise the data associated with adaptation
      initialise();
     }

    /// \short Build mesh, based on geometric object that specifies
    /// the outer boundary of the domain and any number of internal
    /// holes, specified by TriangleMeshHolePolygons. Specify
    /// target area for uniform element size.
    RefineableTriangleMesh(GeomObject* &outer_geom_object_pt,
                          Vector<Vector<double> > &outer_split_coord,
                          Vector<TriangleMeshHolePolygon*> &inner_hole_pt,
                          const double &element_area,
                          TimeStepper* time_stepper_pt=
                          &Mesh::Default_TimeStepper,
                          std::set<unsigned> &fill_index
                          = TriangleMesh<ELEMENT>::Empty_fill_index,
                           const bool &use_attributes=false) :
     TriangleMesh<ELEMENT>(outer_geom_object_pt,
                           outer_split_coord,
                           inner_hole_pt,
                           element_area,
                           time_stepper_pt,
                           fill_index,
                           use_attributes)
     {
      // Initialise the data associated with adaptation
      initialise();
     }


   /// \short Build mesh from specified triangulation and
   /// associated target areas for elements in it
   RefineableTriangleMesh(const Vector<double> &target_area,
                          TriangulateIO& triangulate_io,
                          TimeStepper* time_stepper_pt=
                          &Mesh::Default_TimeStepper,
                          const bool &use_attributes=false)  
    {
     // Initialise the data associated with adaptation
     initialise();
     
     // Store Timestepper used to build elements
     this->Time_stepper_pt=time_stepper_pt;

     // Create triangulateio object to refine
     TriangulateIO triangle_refine;
     
     // Initialize triangulateio structure
     TriangleHelper::initialise_triangulateio(this->Triangulateio);
     
     // Triangulation has been created -- remember to wipe it!
     this->Triangulateio_exists=true;
     
     // Create refined  TriangulateIO structure based on target areas
     this->refine_triangulateio(triangulate_io,
                                target_area,
                                triangle_refine);

     // Input string for triangle
     std::stringstream input_string_stream;
     input_string_stream<<"-pq30-ra"; 
     
     // Convert to a *char required by the triangulate function
     char triswitches[100];
     sprintf(triswitches,"%s",input_string_stream.str().c_str());
     
     // Build triangulateio refined object
     triangulate(triswitches, &triangle_refine, &this->Triangulateio, 0);       
     // Build scaffold
     this->Tmp_mesh_pt=new TriangleScaffoldMesh(this->Triangulateio);

     // Convert mesh from scaffold to actual mesh
     this->build_from_scaffold(time_stepper_pt,use_attributes);
     
     // Kill the scaffold
     delete this->Tmp_mesh_pt;
     this->Tmp_mesh_pt=0;
     
     // Cleanup but leave hole alone as it's still used
     bool clear_hole_data=false;
     TriangleHelper::clear_triangulateio(triangle_refine,clear_hole_data);

     // Setup boundary coordinates for boundaries
     unsigned nb=nboundary();
     for (unsigned b=0;b<nb;b++)
      {
       this->setup_boundary_coordinates(b);
      }       
    }   
   
   /// Empty Destructor
   virtual ~RefineableTriangleMesh() {}
   
   /// \short Problem pointer (needed for multi-domain machinery during
   /// adaptation)
   Problem*& problem_pt(){return Problem_pt;}
   
   /// Max element size allowed during adaptation
   double& max_element_size(){return Max_element_size;}
   
   /// Min element size allowed during adaptation
   double& min_element_size(){return Min_element_size;}
   
   /// Min angle before remesh gets triggered
   double& min_permitted_angle(){return Min_permitted_angle;}
   
   /// Doc the targets for mesh adaptation
   void doc_adaptivity_targets(std::ostream &outfile)
   {
    outfile << std::endl;
    outfile << "Targets for mesh adaptation: " << std::endl;
    outfile << "---------------------------- " << std::endl;
    outfile << "Target for max. error: " << Max_permitted_error << std::endl;
    outfile << "Target for min. error: " << Min_permitted_error << std::endl;
    outfile << "Target min angle: " << Min_permitted_angle << std::endl;
    outfile << "Min. allowed element size: " << Min_element_size << std::endl;
    outfile << "Max. allowed element size: " << Max_element_size << std::endl;
    outfile << "Don't unrefine if less than " << Max_keep_unrefined 
            << " elements need unrefinement." << std::endl;
    outfile << std::endl;
   }
   
   
   /// Refine mesh uniformly and doc process
   void refine_uniformly(DocInfo& doc_info)
   {
    throw OomphLibError("refine_uniformly() not implemented yet",
                        "RefineableTriangleMesh::refine_uniformly()",
                        OOMPH_EXCEPTION_LOCATION); 
   }    
   
   
   /// \short Unrefine mesh uniformly: Return 0 for success,
   /// 1 for failure (if unrefinement has reached the coarsest permitted
   /// level)
   unsigned unrefine_uniformly(OomphCommunicator* comm_pt)
   {
    throw OomphLibError("unrefine_uniformly() not implemented yet",
                        "RefineableTriangleMesh::unrefine_uniformly()",
                        OOMPH_EXCEPTION_LOCATION); 
    // dummy return
    return 0;
   }
   
   /// Adapt mesh, based on elemental error provided
   void adapt(OomphCommunicator* comm_pt,
              const Vector<double>& elem_error); 
   

   
    protected:
   
   /// \short Helper function that updates the input polygon's PSLG
   /// by using the end-points of elements from FaceMesh(es) that are
   /// constructed for the boundaries associated with the segments of the
   /// polygon.
   void update_polygon_using_face_mesh(TriangleMeshPolygon* polygon_pt);
   
   /// \short Generate a new PSLG representation of the inner hole boundaries
   virtual void surface_remesh_for_inner_hole_boundaries(
    Vector<Vector<double> > &hole_centre_coord);
   
   
   /// \short Generate a new PSLG representation of the outer boundary
   virtual void surface_remesh_for_outer_boundary();
   
   
  /// \short Snap the boundary nodes onto any curvilinear boundaries
  void snap_nodes_onto_boundary(RefineableTriangleMesh<ELEMENT>* &new_mesh_pt,
                                const unsigned &b);

   
   /// Helper function to initialise data associated with adaptation
   void initialise()
   {
    // Set max and min targets for adaptation
    this->Max_element_size=1.0;
    this->Min_element_size=0.001;
    this->Min_permitted_angle=15.0;
    
    // Initialise problem pointer
    this->Problem_pt=0;
   }
   
   /// \short Build a new TriangulateIO object from previous TriangulateIO
   /// based on target area for each element
   void refine_triangulateio(TriangulateIO& triangulate_io, 
                             const Vector<double> &target_area,
                             TriangulateIO &triangle_refine);
   

   /// \short Compute target area based on the element's error and the
   /// error target; return minimum angle (in degrees)
   double compute_area_target(const Vector<double> &elem_error,
                              Vector<double> &target_area)
   {
    double min_angle=DBL_MAX;
    unsigned count_unrefined=0;
    unsigned count_refined=0;
    this->Nrefinement_overruled=0;
    
    unsigned nel=this->nelement();
    for (unsigned e=0;e<nel;e++)
     {
      
      // Get element
      FiniteElement* el_pt=this->finite_element_pt(e);
      
      // Area 
      double area=el_pt->size();


      // Min angle based on vertex coordinates
      // (vertices are enumerated first)
      double ax=el_pt->node_pt(0)->x(0);
      double ay=el_pt->node_pt(0)->x(1);
        
      double bx=el_pt->node_pt(1)->x(0);
      double by=el_pt->node_pt(1)->x(1);
        
      double cx=el_pt->node_pt(2)->x(0);
      double cy=el_pt->node_pt(2)->x(1);
        
      // Min angle
      double angle0=
       acos(((ax-cx)*(bx-cx)+(ay-cy)*(by-cy))/
            (sqrt((ax-cx)*(ax-cx)+(ay-cy)*(ay-cy))*
             sqrt((bx-cx)*(bx-cx)+(by-cy)*(by-cy))))*
       180.0/MathematicalConstants::Pi;
      min_angle=std::min(min_angle,angle0);
        
      double angle1=
       acos(((ax-bx)*(cx-bx)+(ay-by)*(cy-by))/
            (sqrt((ax-bx)*(ax-bx)+(ay-by)*(ay-by))*
             sqrt((cx-bx)*(cx-bx)+(cy-by)*(cy-by))))*
       180.0/MathematicalConstants::Pi;
      min_angle=std::min(min_angle,angle1);
        
      double angle2=180.0-angle0-angle1;
      min_angle=std::min(min_angle,angle2);
        
      // Mimick refinement in tree-based procedure: Target areas
      // for elements that exceed permitted error is 1/3 of their
      // current area, corresponding to a uniform sub-division.
      if (elem_error[e]>max_permitted_error())
       {
        target_area[e]=std::max(area/3.0,Min_element_size);
        if (target_area[e]!=Min_element_size)
         {
          count_refined++;
         }
        else
         {
          this->Nrefinement_overruled++;
         }
       }
      else if (elem_error[e]<min_permitted_error())
       {
        target_area[e]=std::min(3.0*area,Max_element_size);
        if (target_area[e]!=Max_element_size)
         {
          count_unrefined++;
         }
       }
      else
       {
        // Leave it alone
        target_area[e] = std::max(area,Min_element_size); 
       }
     }      
    
    // Tell everybody
    this->Nrefined=count_refined;
    this->Nunrefined=count_unrefined;
    
    return min_angle;
   }
   
   /// \short Problem pointer (needed for multi-domain machinery during
   /// adaptation
   Problem* Problem_pt;
   
   /// Max permitted element size
   double Max_element_size;
   
   /// Min permitted element size
   double Min_element_size;
   
   /// Min angle before remesh gets triggered
   double Min_permitted_angle;
   
  }; 

/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////



//=========================================================================
// Unstructured Triangle Mesh upgraded to solid mesh
//=========================================================================
 template<class ELEMENT>
  class SolidTriangleMesh : public virtual TriangleMesh<ELEMENT>,
  public virtual SolidMesh 
  {
   
    public:


   /// \short Build mesh, based on TriangleMeshPolygon that specifies
   /// the outer boundary of the domain and any number of internal
   /// holes, specified by TriangleMeshHolePolygons. Specify
   /// target area for uniform element size.
    SolidTriangleMesh(TriangleMeshPolygon* &outer_boundary_polyline_pt,
                      Vector<TriangleMeshHolePolygon*> &inner_hole_pt,
                      const double& element_area,
                      TimeStepper* time_stepper_pt=
                      &Mesh::Default_TimeStepper,
                      std::set<unsigned> &fill_index
                      = TriangleMesh<ELEMENT>::Empty_fill_index,
                      const bool &use_attributes=false):
   TriangleMesh<ELEMENT>(outer_boundary_polyline_pt, 
                         inner_hole_pt, 
                         element_area,
                         time_stepper_pt,
                         fill_index,
                         use_attributes)
    {
     //Assign the Lagrangian coordinates
     set_lagrangian_nodal_coordinates();
    }
   
   /// \short Build mesh, based on TriangleMeshPolygon that specifies
   /// the outer boundary of the domain and any number of internal
   /// holes, specified by TriangleMeshHolePolygons. Specify
   /// target area for uniform element size.
    SolidTriangleMesh(TriangleMeshPolygon* &outer_boundary_polyline_pt,
                      Vector<GeomObject*> &hole_geom_object_pt,
                      Vector<Vector<double> > &split_coord,
                      const double& element_area,
                      TimeStepper* time_stepper_pt=
                      &Mesh::Default_TimeStepper,
                      std::set<unsigned> &fill_index
                      = TriangleMesh<ELEMENT>::Empty_fill_index,
                      const bool &use_attributes=false):
     TriangleMesh<ELEMENT>(outer_boundary_polyline_pt, 
                           hole_geom_object_pt,
                           split_coord,
                           element_area,
                           time_stepper_pt,
                           fill_index,
                           use_attributes)
     {
      //Assign the Lagrangian coordinates
      set_lagrangian_nodal_coordinates();
     }
    
    /// \short Build mesh, based on geometrric object that specifies
    /// the outer boundary of the domain and any number of internal
    /// holes, specified by TriangleMeshHolePolygons. Specify
    /// target area for uniform element size.
    SolidTriangleMesh(GeomObject* &outer_geom_object_pt,
                      Vector<Vector<double> > &outer_split_coord,
                      Vector<TriangleMeshHolePolygon*> &inner_hole_pt,
                      const double &element_area,
                      TimeStepper* time_stepper_pt=
                      &Mesh::Default_TimeStepper,
                      std::set<unsigned> &fill_index
                      = TriangleMesh<ELEMENT>::Empty_fill_index,
                      const bool &use_attributes=false) :
     TriangleMesh<ELEMENT>(outer_geom_object_pt,
                           outer_split_coord,
                           inner_hole_pt,
                           element_area,
                           time_stepper_pt,
                           fill_index,
                           use_attributes)
     {
      //Assign the Lagrangian coordinates
      set_lagrangian_nodal_coordinates();
     }



  };


////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////


//=========================================================================
// Unstructured refineable Triangle Mesh upgraded to solid mesh
//=========================================================================
 template<class ELEMENT>
  class RefineableSolidTriangleMesh : 
 public virtual RefineableTriangleMesh<ELEMENT>,
  public virtual SolidMesh
  {
   
    public:
   
    /// \short Build mesh, based on TriangleMeshPolygon that specifies
    /// the outer boundary of the domain and any number of internal
    /// holes, specified by TriangleMeshHolePolygons. Specify
    /// target area for uniform element size.
   RefineableSolidTriangleMesh(TriangleMeshPolygon*&
                               outer_boundary_polyline_pt,
                               Vector<TriangleMeshHolePolygon*> &inner_hole_pt,
                               const double& element_area,
                               TimeStepper* time_stepper_pt=
                               &Mesh::Default_TimeStepper,
                               std::set<unsigned> &fill_index
                               = TriangleMesh<ELEMENT>::Empty_fill_index,
                               const bool &use_attributes=false):
    TriangleMesh<ELEMENT>(outer_boundary_polyline_pt, 
                          inner_hole_pt, 
                          element_area,
                          time_stepper_pt,
                          fill_index,
                          use_attributes),
    RefineableTriangleMesh<ELEMENT>(outer_boundary_polyline_pt, 
                                    inner_hole_pt, 
                                    element_area,
                                    time_stepper_pt,
                                    fill_index,
                                    use_attributes)
     {
      //Assign the Lagrangian coordinates
      set_lagrangian_nodal_coordinates();
     }
   
   
   
   /// \short Build mesh, based on TriangleMeshPolygon that specifies
   /// the outer boundary of the domain and any number of internal
   /// holes, specified by TriangleMeshHolePolygons. Specify
   /// target area for uniform element size.
   RefineableSolidTriangleMesh(TriangleMeshPolygon*&
                               outer_boundary_polyline_pt,
                               Vector<GeomObject*> &hole_geom_object_pt,
                               Vector<Vector<double> > &split_coord,
                               const double& element_area,
                               TimeStepper* time_stepper_pt=
                                 &Mesh::Default_TimeStepper,
                               std::set<unsigned> &fill_index
                               = TriangleMesh<ELEMENT>::Empty_fill_index,
                               const bool &use_attributes=false):
    TriangleMesh<ELEMENT>(outer_boundary_polyline_pt, 
                          hole_geom_object_pt,
                          split_coord,
                          element_area,
                          time_stepper_pt,
                          fill_index,
                          use_attributes),
    RefineableTriangleMesh<ELEMENT>(outer_boundary_polyline_pt, 
                                    hole_geom_object_pt,
                                    split_coord,
                                    element_area,
                                    time_stepper_pt,
                                    fill_index,
                                    use_attributes)
    {
     //Assign the Lagrangian coordinates
     set_lagrangian_nodal_coordinates();
    }


    /// \short Build mesh, based on geometric object that specifies
    /// the outer boundary of the domain and any number of internal
    /// holes, specified by TriangleMeshHolePolygons. Specify
    /// target area for uniform element size.
   RefineableSolidTriangleMesh(GeomObject* &outer_geom_object_pt,
                               Vector<Vector<double> > &outer_split_coord,
                               Vector<TriangleMeshHolePolygon*> &inner_hole_pt,
                               const double &element_area,
                               TimeStepper* time_stepper_pt=
                               &Mesh::Default_TimeStepper,
                               std::set<unsigned> &fill_index
                               = TriangleMesh<ELEMENT>::Empty_fill_index,
                               const bool &use_attributes=false) :
    TriangleMesh<ELEMENT>(outer_geom_object_pt,
                          outer_split_coord,
                          inner_hole_pt,
                          element_area,
                          time_stepper_pt,
                          fill_index,
                          use_attributes),
    RefineableTriangleMesh<ELEMENT>(outer_geom_object_pt,
                                    outer_split_coord,
                                    inner_hole_pt,
                                    element_area,
                                    time_stepper_pt,
                                    fill_index,
                                    use_attributes)
    {
     //Assign the Lagrangian coordinates
     set_lagrangian_nodal_coordinates();
    }

   
   /// \short Build mesh from specified triangulation and
   /// associated target areas for elements in it.
    RefineableSolidTriangleMesh(const Vector<double> &target_area,
                                TriangulateIO& triangulate_io,
                                TimeStepper* time_stepper_pt=
                                &Mesh::Default_TimeStepper,
                                const bool &use_attributes=false)  :
   RefineableTriangleMesh<ELEMENT>(target_area,
                                   triangulate_io,
                                   time_stepper_pt,
                                   use_attributes)
    {
     //Assign the Lagrangian coordinates
     set_lagrangian_nodal_coordinates();
    }
   
   /// Empty Destructor
   virtual ~RefineableSolidTriangleMesh() {}
   
  };
 
 
}

#endif
