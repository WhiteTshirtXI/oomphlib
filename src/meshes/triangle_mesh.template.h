//LIC// ====================================================================
//LIC// This file forms part of oomph-lib, the object-oriented, 
//LIC// multi-physics finite-element library, available 
//LIC// at http://www.oomph-lib.org.
//LIC// 
//LIC//           Version 0.90. August 3, 2009.
//LIC// 
//LIC// Copyright (C) 2006-2009 Matthias Heil and Andrew Hazel
//LIC// 
//LIC// This library is free software; you can redistribute it and/or
//LIC// modify it under the terms of the GNU Lesser General Public
//LIC// License as published by the Free Software Foundation; either
//LIC// version 2.1 of the License, or (at your option) any later version.
//LIC// 
//LIC// This library is distributed in the hope that it will be useful,
//LIC// but WITHOUT ANY WARRANTY; without even the implied warranty of
//LIC// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//LIC// Lesser General Public License for more details.
//LIC// 
//LIC// You should have received a copy of the GNU Lesser General Public
//LIC// License along with this library; if not, write to the Free Software
//LIC// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
//LIC// 02110-1301  USA.
//LIC// 
//LIC// The authors may be contacted at oomph-lib@maths.man.ac.uk.
//LIC// 
//LIC//====================================================================
#ifndef OOMPH_TRIANGLE_MESH_HEADER
#define OOMPH_TRIANGLE_MESH_HEADER
// Config header generated by autoconfig
#ifdef HAVE_CONFIG_H
#include <oomph-lib-config.h>
#endif


#ifdef OOMPH_HAS_MPI
//mpi headers
#include "mpi.h"
#endif

//Standards
#include<float.h>
#include <iostream>
#include <fstream>
#include <string.h>

#include "../generic/problem.h" 
#include "../generic/triangle_scaffold_mesh.h" 
#include "../generic/triangle_mesh.h"
#include "../generic/refineable_mesh.h"


// Interface to triangulate function
extern "C" {
 void triangulate(char *triswitches, struct oomph::TriangulateIO *in,
                  struct oomph::TriangulateIO *out, 
                  struct oomph::TriangulateIO *vorout);
}


namespace oomph
{
 
//============start_of_triangle_class===================================
/// Triangle mesh build with the help of the scaffold mesh coming  
/// from the triangle mesh generator Triangle.
/// http://www.cs.cmu.edu/~quake/triangle.html
//======================================================================
 template <class ELEMENT>
  class TriangleMesh : public virtual TriangleMeshBase
 {
  
   public:
  
   /// \short Empty constructor 
  TriangleMesh()
   {
    // Using this constructor no Triangulateio object is built
    Triangulateio_exists=false;
   }
  
  /// \short Constructor with the input files
  TriangleMesh(const std::string& node_file_name,
               const std::string& element_file_name,
               const std::string& poly_file_name,
               TimeStepper* time_stepper_pt=
               &Mesh::Default_TimeStepper,
               const bool &use_attributes=false)   
   {
    // Store Timestepper used to build elements
    Time_stepper_pt=time_stepper_pt;
    
    // Using this constructor no Triangulateio object is built
    Triangulateio_exists=false;
    
    // Build scaffold
    Tmp_mesh_pt= new 
     TriangleScaffoldMesh(node_file_name,
                          element_file_name,
                          poly_file_name);
    
    // Convert mesh from scaffold to actual mesh
    build_from_scaffold(time_stepper_pt,use_attributes);
    
    // Kill the scaffold
    delete Tmp_mesh_pt;
    Tmp_mesh_pt=0;
    
    // Setup boundary coordinates for boundaries
    unsigned nb=nboundary();
    for (unsigned b=0;b<nb;b++)
     {
      this->setup_boundary_coordinates(b);
     }
   }
  
  
  /// \short Constructor based on TriangulateIO object 
  TriangleMesh(TriangulateIO& triangulate_io,
               TimeStepper* time_stepper_pt=
               &Mesh::Default_TimeStepper,
               const bool &use_attributes=false)  
   {
    // Store Timestepper used to build elements
    Time_stepper_pt=time_stepper_pt;
    
    // Build scaffold
    Tmp_mesh_pt= new TriangleScaffoldMesh(triangulate_io);
    
    // Initialize TriangulateIO structure
    TriangleHelper::initialise_triangulateio(Triangulateio);
    
    // Triangulation has been created -- remember to wipe it!
    Triangulateio_exists=true;
    
    // Deep-copy triangulateio data into the Triangulateio private object
    bool quiet=true;
    Triangulateio=TriangleHelper::deep_copy_of_triangulateio_representation(
     triangulate_io,quiet);
    
    // Convert mesh from scaffold to actual mesh
    build_from_scaffold(time_stepper_pt,use_attributes);
    
    // Kill the scaffold
    delete Tmp_mesh_pt;
    Tmp_mesh_pt=0;
    
    // Setup boundary coordinates for boundaries
    unsigned nb=nboundary();
    for (unsigned b=0;b<nb;b++)
     {
      this->setup_boundary_coordinates(b);
     }
   }
  
  /// \short Build mesh, based on TriangleMeshPolygon that specifies
  /// the outer boundary of the domain and any number of internal
  /// holes, specified by TriangleMeshHolePolygons. Also specify
  /// target area for uniform element size.
  TriangleMesh(TriangleMeshPolygon* &outer_boundary_pt,
               Vector<TriangleMeshHolePolygon*> &inner_hole_pt,
               const double &element_area,
               TimeStepper* time_stepper_pt=
               &Mesh::Default_TimeStepper,
               const bool &use_attributes=false) 
   {     
    // Store Timestepper used to build elements
    Time_stepper_pt=time_stepper_pt;
    
    // Store outer polygon
    Outer_boundary_pt=outer_boundary_pt;
    
    // Store inner holes by copy constructor
    Inner_hole_pt=inner_hole_pt;
    
    // Create the data structures required to call the triangulate function
    TriangulateIO triangulate_io;
    
    // Initialize TriangulateIO structure
    TriangleHelper::initialise_triangulateio(triangulate_io);
    
    // Convert TriangleMeshPolyLine and TriangleMeshHolePolyLine
    // to a triangulateio object
    build_triangulateio(outer_boundary_pt,
                        inner_hole_pt,
                        triangulate_io);
    
    // Sub_boundary_id vector is generated using this constructor only
    // set the boolean to true
    Sub_boundary_id_exists=true;
    
    // Initialize TriangulateIO structure
    TriangleHelper::initialise_triangulateio(Triangulateio);
    
    // Triangulation has been created -- remember to wipe it!
    Triangulateio_exists=true;
    
    // Input string for triangle
    std::stringstream input_string_stream;
    input_string_stream<<"-pc-a" << element_area << "q30";
    
    // Convert the Input string in *char required by the triangulate function
     char triswitches[100];
     sprintf(triswitches,"%s",input_string_stream.str().c_str());
     
    // Build the mesh using triangulate function
    triangulate(triswitches, &triangulate_io, &Triangulateio, 0);   
    
    // Build scaffold
    Tmp_mesh_pt= new TriangleScaffoldMesh(Triangulateio);
    
    // Convert mesh from scaffold to actual mesh
    build_from_scaffold(time_stepper_pt,use_attributes);
    
    // Kill the scaffold
    delete Tmp_mesh_pt;
    Tmp_mesh_pt=0;
    
    // Cleanup but leave hole alone since it's still used
    bool clear_hole_data=false;
    TriangleHelper::clear_triangulateio(triangulate_io,clear_hole_data);

    // Setup boundary coordinates for boundaries
    unsigned nb=nboundary();
    for (unsigned b=0;b<nb;b++)
     {
      this->setup_boundary_coordinates(b);
     }
   }
  
  
  /// Build mesh from poly file, with specified target
  /// area for all elements.
  TriangleMesh(const std::string& poly_file_name,
               const double& element_area,
               TimeStepper* time_stepper_pt=
               &Mesh::Default_TimeStepper,
               const bool &use_attributes=false)
   
   {  

    // Disclaimer
    std::string message=
     "This constructor hasn't been tested since last cleanup.\n";
    OomphLibWarning(message,
                    "TriangleMesh::TriangleMesh()",
                    OOMPH_EXCEPTION_LOCATION);
    
    // Store Timestepper used to build elements
    Time_stepper_pt=time_stepper_pt;
    
    // Create the data structures required to call the triangulate function
    TriangulateIO triangle_in;
    
    // Input string for triangle
    std::stringstream input_string_stream;
    input_string_stream<<"-pc-a" << element_area << "q30";
    
    // Convert to a *char required by the triangulate function
     char triswitches[100];
     sprintf(triswitches,"%s",input_string_stream.str().c_str());
     
    // Build the input triangulateio object from the .poly file
    build_triangulateio(poly_file_name, triangle_in);
    
    // Build the triangulateio out object
    triangulate(triswitches, &triangle_in, &Triangulateio, 0);
    
    // Build scaffold
    Tmp_mesh_pt= new TriangleScaffoldMesh(Triangulateio);
    
    // Convert mesh from scaffold to actual mesh
    build_from_scaffold(time_stepper_pt,use_attributes);
    
    // Kill the scaffold
    delete Tmp_mesh_pt;
    Tmp_mesh_pt=0;
    
    // Cleanup but leave hole alone
    bool clear_hole_data=false;
    TriangleHelper::clear_triangulateio(triangle_in,clear_hole_data);

    // Setup boundary coordinates for boundaries
    unsigned nb=nboundary();
    for (unsigned b=0;b<nb;b++)
     {
      this->setup_boundary_coordinates(b);
     }
   }
  
  /// Broken copy constructor
  TriangleMesh(const TriangleMesh& dummy) 
   { 
    BrokenCopy::broken_copy("TriangleMesh");
   } 
  
  /// Broken assignment operator
  void operator=(const TriangleMesh&) 
   {
    BrokenCopy::broken_assign("TriangleMesh");
   }
  
  /// Destructor 
  virtual ~TriangleMesh() 
   {     
    if (Triangulateio_exists) 
     {
      TriangleHelper::clear_triangulateio(Triangulateio);
     }
   }
  
  /// \short Setup boundary coordinate on boundary b.
  /// Boundary coordinate increases continously along
  /// polygonal boundary. It's zero at the lowest left
  /// smallest node on the boundary.
  void setup_boundary_coordinates(const unsigned& b)
  {
   // Dummy file
   std::ofstream some_file;
   setup_boundary_coordinates(b,some_file);
  }
  
  /// \short Setup boundary coordinate on boundary b. Doc Faces
  /// in outfile.
  /// Boundary coordinate increases continously along
  /// polygonal boundary. It's zero at the lowest left
  /// node on the boundary.
  void setup_boundary_coordinates(const unsigned& b,
                                  std::ofstream& outfile);
  
  /// Return the number of regions specified by attributes
  unsigned nregion() {return Region_element_pt.size();}
  
  /// Return the number of elements in region i
  unsigned nregion_element(const unsigned &i) 
  {return Region_element_pt[i].size();}
  
  /// Access to the triangulateio representation of the mesh
  TriangulateIO& triangulateio_representation()
   {
    // Check if the triangulateio object exists or not
    if(Triangulateio_exists)
     {
      return Triangulateio;
     }
    else
     // Shout!
     {
      std::ostringstream error_stream;
      error_stream<<"Function triangulateio_representation()\n"
                  <<"cannot be called if no TriangulateIO object\n"
                  <<"has been built. Check if a wrong constructor\n"
                  <<"has been called or if the Triangulateio\n"
                  <<"has been alredy deleted."<<std::endl;
      throw OomphLibError(error_stream.str(),
                          "TriangleMesh<ELEMENT>::"
                          "triangulateio_representation()",
                          OOMPH_EXCEPTION_LOCATION); 
     }
   }
  
  
  /// Return the attribute associated with region i
  double region_attribute(const unsigned &i)
  {return Region_attribute[i];}
  
  /// Return the e-th element in the i-th region
  FiniteElement* region_element_pt(const unsigned &i,
                                   const unsigned &e)
  {return Region_element_pt[i][e];}
  

  /// \short Helper function. Write a TriangulateIO object file with all the 
  /// triangulateio fields. String s is add to assign a different value for
  /// the input and/or output structure
  void write_triangulateio(TriangulateIO& triangulate_io, std::string& s);
  
  /// \short Update the TriangulateIO object to the current nodal position
  /// and the centre hole coordinates.
  void update_triangulateio(Vector<Vector<double> >&hole_centre)
  {
    // Move the hole center
    // Get number of holes
   unsigned nhole=Triangulateio.numberofholes;
   unsigned count_coord=0;
   for(unsigned ihole=0;ihole<nhole;ihole++)
    {
     Triangulateio.holelist[count_coord]+=hole_centre[ihole][0];  
     Triangulateio.holelist[count_coord+1]+=hole_centre[ihole][1]; 
     
     // Increment counter
     count_coord+=2;
    }
   
   // Do the update
   update_triangulateio();
  }
   
  /// \short Update the triangulateio object to the current nodal positions
  void update_triangulateio()
  {   
   // Get number of points
   unsigned nnode = Triangulateio.numberofpoints;
   double new_x=0;
   double new_y=0;
   
   // Loop over the points
   for(unsigned inod=0;inod<nnode;inod++)
    {      
     // Get the node Id to be updated
     unsigned count=Oomph_vertex_nodes_id[inod];
     
     // Update vertices using the vertex_node_id giving for the TriangulateIO
     // vertex enumeration the corresponding oomphlib mesh enumeration
     Node* mesh_node_pt=this->node_pt(inod);
     new_x=mesh_node_pt->x(0); 
     new_y=mesh_node_pt->x(1); 
     Triangulateio.pointlist[count*2] = new_x;  
     Triangulateio.pointlist[(count*2)+1] = new_y;       
    }
  }
  
  /// \short Get a map containing Vectors of sub-boundary IDs. One
  /// for each each Polyline boundary.
  std::map<unsigned,Vector<unsigned> >& sub_boundary_id()
   {
    // Check if the  sub-boundary enumeration exists or not
    if(Sub_boundary_id_exists)
     {
      return Sub_boundary_id;
     }
    else
     // Shout!
     {
      std::ostringstream error_stream;
      error_stream<<"Function sub_boundary_id()"
                   <<"cannot be called if\n no sub_boundary_id vector"
                  <<"has been built. Please call a different constructor.\n "
                  <<std::endl;
       throw OomphLibError(error_stream.str(),
                           "TriangleMesh<ELEMENT>::"
                           "sub_boundary_id()",
                           OOMPH_EXCEPTION_LOCATION); 
      }
   }
  
  
  /// Boolean defining if sub-boundary enumeration has been built or not
  bool sub_boundary_id_exists(){return Sub_boundary_id_exists;}
  
  /// Boolean defining if Triangulateio object has been built or not
  bool triangulateio_exists(){return Triangulateio_exists;}
  
  /// \short Return the vector that contains the oomph-lib node number
  /// for all vertex nodes in the TriangulateIO representation of the mesh
  Vector<unsigned> oomph_vertex_nodes_id(){return Oomph_vertex_nodes_id;}
  
  
  
    protected:
  
  /// Build mesh from scaffold
  void build_from_scaffold(TimeStepper* time_stepper_pt,
                           const bool &use_attributes);
  
  /// \short Build TriangulateIO object from TriangleMeshPolyLine and 
  /// TriangleMeshHolePolyLine
  void build_triangulateio(TriangleMeshPolygon* &outer_boundary_pt,
                           Vector<TriangleMeshHolePolygon*> &inner_hole,
                           TriangulateIO& triangulate_io);
  
  /// \short Helper function to create TriangulateIO object (return in
  /// triangulate_io) from the .poly file 
  void build_triangulateio(const std::string& poly_file_name,
                           TriangulateIO& triangulate_io);
  
  /// Boolean defining if Triangulateio object has been built or not
  bool Triangulateio_exists;
  
  /// Boolean defining if sub-boundary lookup scheme has been built or not
  bool Sub_boundary_id_exists;
  
  /// \short Map of Vectors containing the sub-boundary IDs associated
  /// with each Polyline
  std::map<unsigned,Vector<unsigned> > Sub_boundary_id;
  
  /// Temporary scaffold mesh
  TriangleScaffoldMesh* Tmp_mesh_pt;
  
  /// TriangulateIO representation of the mesh
  TriangulateIO Triangulateio;
  
  /// \short Vector storing oomph-lib node number
  /// for all vertex nodes in the TriangulateIO representation of the mesh
  Vector<unsigned> Oomph_vertex_nodes_id;
  
  /// Vectors of elements in each region differentiated by attribute
  Vector<Vector<FiniteElement* > > Region_element_pt;
  
  /// Vector of attributes associated with the elements in each region
  Vector<double> Region_attribute;
  
  /// Polygon that defines outer boundaries
  TriangleMeshPolygon* Outer_boundary_pt;
  
  /// Vector to polygons that define inner holes
  Vector<TriangleMeshHolePolygon*> Inner_hole_pt;
  
  /// Timestepper used to build elements
  TimeStepper* Time_stepper_pt;
  
 };


//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////

 
//=========================================================================
// Unstructured refineable Triangle Mesh 
//=========================================================================
template<class ELEMENT>
 class RefineableTriangleMesh : public virtual TriangleMesh<ELEMENT>,
  public virtual RefineableMeshBase
  {
   
    public:
   
   
   /// \short Build mesh, based on TriangleMeshPolygon that specifies
   /// the outer boundary of the domain and any number of internal
   /// holes, specified by TriangleMeshHolePolygons. Specify
   /// target area for uniform element size.
    RefineableTriangleMesh(TriangleMeshPolygon* &outer_boundary_polyline_pt,
                           Vector<TriangleMeshHolePolygon*> &inner_hole_pt,
                           const double& element_area,
                           TimeStepper* time_stepper_pt=
                           &Mesh::Default_TimeStepper,
                           const bool &use_attributes=false):
   TriangleMesh<ELEMENT>(outer_boundary_polyline_pt, 
                         inner_hole_pt, 
                         element_area,
                         time_stepper_pt,
                         use_attributes)
    {
     // Initialise the data associated with adaptation
     initialise();
    }
   
   
   /// \short Build mesh from specified triangulation and
   /// associated target areas for elements in it
   RefineableTriangleMesh(const Vector<double> &target_area,
                          TriangulateIO& triangulate_io,
                          TimeStepper* time_stepper_pt=
                          &Mesh::Default_TimeStepper,
                          const bool &use_attributes=false)  
    {
     // Initialise the data associated with adaptation
     initialise();
     
     // Store Timestepper used to build elements
     this->Time_stepper_pt=time_stepper_pt;

     // Create triangulateio object to refine
     TriangulateIO triangle_refine;
     
     // Initialize triangulateio structure
     TriangleHelper::initialise_triangulateio(this->Triangulateio);
     
     // Triangulation has been created -- remember to wipe it!
     this->Triangulateio_exists=true;
     
     // Create refined  TriangulateIO structure based on target areas
     this->refine_triangulateio(triangulate_io,
                                target_area,
                                triangle_refine);
     
     // Input string for triangle
     std::stringstream input_string_stream;
     input_string_stream<<"-pcq30-ra"; 
     
     // Convert to a *char required by the triangulate function
     char triswitches[100];
     sprintf(triswitches,"%s",input_string_stream.str().c_str());
     
     // Build triangulateio refined object
     triangulate(triswitches, &triangle_refine, &this->Triangulateio, 0);       
     
     // Build scaffold
     this->Tmp_mesh_pt=new TriangleScaffoldMesh(this->Triangulateio);
     
     // Convert mesh from scaffold to actual mesh
     this->build_from_scaffold(time_stepper_pt,use_attributes);
     
     // Kill the scaffold
     delete this->Tmp_mesh_pt;
     this->Tmp_mesh_pt=0;
     
     // Cleanup but leave hole alone as it's still used
     bool clear_hole_data=false;
     TriangleHelper::clear_triangulateio(triangle_refine,clear_hole_data);

     // Setup boundary coordinates for boundaries
     unsigned nb=nboundary();
     for (unsigned b=0;b<nb;b++)
      {
       this->setup_boundary_coordinates(b);
      }       
    }   
   
   /// Empty Destructor
   virtual ~RefineableTriangleMesh() {}
   
   /// \short Problem pointer (needed for multi-domain machinery during
   /// adaptation)
   Problem*& problem_pt(){return Problem_pt;}
   
   /// Max element size allowed during adaptation
   double& max_element_size(){return Max_element_size;}
   
   /// Min element size allowed during adaptation
   double& min_element_size(){return Min_element_size;}
   
   /// Min angle before remesh gets triggered
   double& min_permitted_angle(){return Min_permitted_angle;}
   
   /// Doc the targets for mesh adaptation
   void doc_adaptivity_targets(std::ostream &outfile)
   {
    outfile << std::endl;
    outfile << "Targets for mesh adaptation: " << std::endl;
    outfile << "---------------------------- " << std::endl;
    outfile << "Target for max. error: " << Max_permitted_error << std::endl;
    outfile << "Target for min. error: " << Min_permitted_error << std::endl;
    outfile << "Target min angle: " << Min_permitted_angle << std::endl;
    outfile << "Min. allowed element size: " << Min_element_size << std::endl;
    outfile << "Max. allowed element size: " << Max_element_size << std::endl;
    outfile << "Don't unrefine if less than " << Max_keep_unrefined 
            << " elements need unrefinement." << std::endl;
    outfile << std::endl;
   }
   
   
   /// Refine mesh uniformly and doc process
   void refine_uniformly(DocInfo& doc_info)
   {
    throw OomphLibError("refine_uniformly() not implemented yet",
                        "RefineableTriangleMesh::refine_uniformly()",
                        OOMPH_EXCEPTION_LOCATION); 
   }    
   
   
   /// \short Unrefine mesh uniformly: Return 0 for success,
   /// 1 for failure (if unrefinement has reached the coarsest permitted
   /// level)
   unsigned unrefine_uniformly(OomphCommunicator* comm_pt)
   {
    throw OomphLibError("unrefine_uniformly() not implemented yet",
                        "RefineableTriangleMesh::unrefine_uniformly()",
                        OOMPH_EXCEPTION_LOCATION); 
    // dummy return
    return 0;
   }
   
   /// Adapt mesh, based on elemental error provided
   void adapt(OomphCommunicator* comm_pt,
              const Vector<double>& elem_error); 
   
   
    protected:
   
   /// Helper function to initialise data associated with adaptation
   void initialise()
   {
    // Set max and min targets for adaptation
    this->Max_element_size=1.0;
    this->Min_element_size=0.001;
    this->Min_permitted_angle=15.0;
    
    // Initialise problem pointer
    this->Problem_pt=0;
   }
   
   /// \short Build a new TriangulateIO object from previous TriangulateIO
   /// based on target area for each element
   void refine_triangulateio(TriangulateIO& triangulate_io, 
                             const Vector<double> &target_area,
                             TriangulateIO &triangle_refine);
   

   /// \short Compute target area based on the element's error and the
   /// error target; return minimum angle (in degrees)
   double compute_area_target(const Vector<double> &elem_error,
                              Vector<double> &target_area)
   {
    double min_angle=DBL_MAX;
    unsigned count_unrefined=0;
    unsigned count_refined=0;
    this->Nrefinement_overruled=0;
    
    unsigned nel=this->nelement();
    for (unsigned e=0;e<nel;e++)
     {
      
      // Get element
      FiniteElement* el_pt=this->finite_element_pt(e);
      
      // Area 
      double area=el_pt->size();


      // Min angle based on vertex coordinates
      // (vertices are enumerated first)
      double ax=el_pt->node_pt(0)->x(0);
      double ay=el_pt->node_pt(0)->x(1);
        
      double bx=el_pt->node_pt(1)->x(0);
      double by=el_pt->node_pt(1)->x(1);
        
      double cx=el_pt->node_pt(2)->x(0);
      double cy=el_pt->node_pt(2)->x(1);
        
      // Min angle
      double angle0=
       acos(((ax-cx)*(bx-cx)+(ay-cy)*(by-cy))/
            (sqrt((ax-cx)*(ax-cx)+(ay-cy)*(ay-cy))*
             sqrt((bx-cx)*(bx-cx)+(by-cy)*(by-cy))))*
       180.0/MathematicalConstants::Pi;
      min_angle=std::min(min_angle,angle0);
        
      double angle1=
       acos(((ax-bx)*(cx-bx)+(ay-by)*(cy-by))/
            (sqrt((ax-bx)*(ax-bx)+(ay-by)*(ay-by))*
             sqrt((cx-bx)*(cx-bx)+(cy-by)*(cy-by))))*
       180.0/MathematicalConstants::Pi;
      min_angle=std::min(min_angle,angle1);
        
      double angle2=180.0-angle0-angle1;
      min_angle=std::min(min_angle,angle2);
        
      // Mimick refinement in tree-based procedure: Target areas
      // for elements that exceed permitted error is 1/3 of their
      // current area, corresponding to a uniform sub-division.
      if (elem_error[e]>max_permitted_error())
       {
        target_area[e]=std::max(area/3.0,Min_element_size);
        if (target_area[e]!=Min_element_size)
         {
          count_refined++;
         }
        else
         {
          this->Nrefinement_overruled++;
         }
       }
      else if (elem_error[e]<min_permitted_error())
       {
        target_area[e]=std::min(3.0*area,Max_element_size);
        if (target_area[e]!=Max_element_size)
         {
          count_unrefined++;
         }
       }
      else
       {
        // Leave it alone
        target_area[e] = std::max(area,Min_element_size); 
       }
     }      
    
    // Tell everybody
    this->Nrefined=count_refined;
    this->Nunrefined=count_unrefined;
    
    return min_angle;
   }
   
   /// \short Problem pointer (needed for multi-domain machinery during
   /// adaptation
   Problem* Problem_pt;
   
   /// Max permitted element size
   double Max_element_size;
   
   /// Min permitted element size
   double Min_element_size;
   
   /// Min angle before remesh gets triggered
   double Min_permitted_angle;
   
  }; 

/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////



//=========================================================================
// Unstructured Triangle Mesh upgraded to solid mesh
//=========================================================================
 template<class ELEMENT>
  class SolidTriangleMesh : public virtual TriangleMesh<ELEMENT>,
  public virtual SolidMesh 
  {
   
    public:


   /// \short Build mesh, based on TriangleMeshPolygon that specifies
   /// the outer boundary of the domain and any number of internal
   /// holes, specified by TriangleMeshHolePolygons. Specify
   /// target area for uniform element size.
    SolidTriangleMesh(TriangleMeshPolygon* &outer_boundary_polyline_pt,
                      Vector<TriangleMeshHolePolygon*> &inner_hole_pt,
                      const double& element_area,
                      TimeStepper* time_stepper_pt=
                      &Mesh::Default_TimeStepper,
                      const bool &use_attributes=false):
   TriangleMesh<ELEMENT>(outer_boundary_polyline_pt, 
                         inner_hole_pt, 
                         element_area,
                         time_stepper_pt,
                         use_attributes)
    {
     //Assign the Lagrangian coordinates
     set_lagrangian_nodal_coordinates();
    }
   
  };


////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////


//=========================================================================
// Unstructured refineable Triangle Mesh upgraded to solid mesh
//=========================================================================
 template<class ELEMENT>
  class RefineableSolidTriangleMesh : 
 public virtual RefineableTriangleMesh<ELEMENT>,
  public virtual SolidMesh
  {
   
    public:
   
    /// \short Build mesh, based on TriangleMeshPolygon that specifies
    /// the outer boundary of the domain and any number of internal
    /// holes, specified by TriangleMeshHolePolygons. Specify
    /// target area for uniform element size.
    RefineableSolidTriangleMesh(TriangleMeshPolygon*&
                                outer_boundary_polyline_pt,
                                Vector<TriangleMeshHolePolygon*> &inner_hole_pt,
                                const double& element_area,
                                TimeStepper* time_stepper_pt=
                                &Mesh::Default_TimeStepper,
                                const bool &use_attributes=false):
   TriangleMesh<ELEMENT>(outer_boundary_polyline_pt, 
                         inner_hole_pt, 
                         element_area,
                         time_stepper_pt,
                         use_attributes),
    RefineableTriangleMesh<ELEMENT>(outer_boundary_polyline_pt, 
                                    inner_hole_pt, 
                                    element_area,
                                    time_stepper_pt,
                                    use_attributes)
     {
      //Assign the Lagrangian coordinates
      set_lagrangian_nodal_coordinates();
     }
   
   
   

   
   /// \short Build mesh from specified triangulation and
   /// associated target areas for elements in it.
    RefineableSolidTriangleMesh(const Vector<double> &target_area,
                                TriangulateIO& triangulate_io,
                                TimeStepper* time_stepper_pt=
                                &Mesh::Default_TimeStepper,
                                const bool &use_attributes=false)  :
   RefineableTriangleMesh<ELEMENT>(target_area,
                                   triangulate_io,
                                   time_stepper_pt,
                                   use_attributes)
    {
     //Assign the Lagrangian coordinates
     set_lagrangian_nodal_coordinates();
    }
   
   /// Empty Destructor
   virtual ~RefineableSolidTriangleMesh() {}
   
  };
 
 
}

#endif
