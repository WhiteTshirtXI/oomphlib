//LIC// ====================================================================
//LIC// This file forms part of oomph-lib, the object-oriented, 
//LIC// multi-physics finite-element library, available 
//LIC// at http://www.oomph-lib.org.
//LIC// 
//LIC//           Version 0.90. August 3, 2009.
//LIC// 
//LIC// Copyright (C) 2006-2009 Matthias Heil and Andrew Hazel
//LIC// 
//LIC// This library is free software; you can redistribute it and/or
//LIC// modify it under the terms of the GNU Lesser General Public
//LIC// License as published by the Free Software Foundation; either
//LIC// version 2.1 of the License, or (at your option) any later version.
//LIC// 
//LIC// This library is distributed in the hope that it will be useful,
//LIC// but WITHOUT ANY WARRANTY; without even the implied warranty of
//LIC// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//LIC// Lesser General Public License for more details.
//LIC// 
//LIC// You should have received a copy of the GNU Lesser General Public
//LIC// License along with this library; if not, write to the Free Software
//LIC// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
//LIC// 02110-1301  USA.
//LIC// 
//LIC// The authors may be contacted at oomph-lib@maths.man.ac.uk.
//LIC// 
//LIC//====================================================================
#ifndef OOMPH_TRIANGLE_MESH_HEADER
#define OOMPH_TRIANGLE_MESH_HEADER
// Config header generated by autoconfig
#ifdef HAVE_CONFIG_H
#include <oomph-lib-config.h>
#endif


#ifdef OOMPH_HAS_MPI
//mpi headers
#include "mpi.h"
#endif

//Standards
#include<float.h>
#include <iostream>
#include <fstream>
#include <string.h>

#include "../generic/problem.h" 
#include "../generic/triangle_scaffold_mesh.h" 
#include "../generic/triangle_mesh.h"
#include "../generic/refineable_mesh.h"

#ifdef OOMPH_HAS_TRIANGLE_LIB

// Interface to triangulate function
extern "C" {
 void triangulate(char *triswitches, struct oomph::TriangulateIO *in,
                  struct oomph::TriangulateIO *out, 
                  struct oomph::TriangulateIO *vorout);
}

#endif

namespace oomph
{
 
//============start_of_triangle_class===================================
/// Triangle mesh build with the help of the scaffold mesh coming  
/// from the triangle mesh generator Triangle.
/// http://www.cs.cmu.edu/~quake/triangle.html
//======================================================================
 template <class ELEMENT>
  class TriangleMesh : public virtual TriangleMeshBase
 {
   public:
  
   /// \short Empty constructor 
  TriangleMesh()
   {
#ifdef OOMPH_HAS_TRIANGLE_LIB  
    // Using this constructor no Triangulateio object is built
    Triangulateio_exists=false;
#endif
   }
  
  /// \short Constructor with the input files
  TriangleMesh(const std::string& node_file_name,
               const std::string& element_file_name,
               const std::string& poly_file_name,
               TimeStepper* time_stepper_pt=
               &Mesh::Default_TimeStepper,
               const bool &use_attributes=false)   
   {
    //Store the attributes
    Use_attributes = use_attributes;

    // Store Timestepper used to build elements
    Time_stepper_pt=time_stepper_pt;

#ifdef OOMPH_HAS_TRIANGLE_LIB  
    
    // Using this constructor build the triangulatio
    TriangleHelper::create_triangulateio_from_polyfiles(node_file_name,
                                                        element_file_name,
                                                        poly_file_name,
                                                        Triangulateio);
    //Record that the triangulateio object has been created      
    Triangulateio_exists=true;

#endif

    // Build scaffold
    Tmp_mesh_pt= new 
     TriangleScaffoldMesh(node_file_name,
                          element_file_name,
                          poly_file_name);
    
    // Convert mesh from scaffold to actual mesh
    build_from_scaffold(time_stepper_pt,use_attributes);
    
    // Kill the scaffold
    delete Tmp_mesh_pt;
    Tmp_mesh_pt=0;
    
    // Setup boundary coordinates for boundaries
    unsigned nb=nboundary();
    for (unsigned b=0;b<nb;b++)
     {
      this->setup_boundary_coordinates(b);
     }
   }
  
  
#ifdef OOMPH_HAS_TRIANGLE_LIB

  /// \short Constructor based on TriangulateIO object 
  TriangleMesh(TriangulateIO& triangulate_io,
               TimeStepper* time_stepper_pt=
               &Mesh::Default_TimeStepper,
               const bool &use_attributes=false)  
   {
    //Store the attributes flag
    Use_attributes = use_attributes;

    // Store Timestepper used to build elements
    Time_stepper_pt=time_stepper_pt;
    
    // Build scaffold
    Tmp_mesh_pt= new TriangleScaffoldMesh(triangulate_io);
    
    // Initialize TriangulateIO structure
    TriangleHelper::initialise_triangulateio(Triangulateio);
    
    // Triangulation has been created -- remember to wipe it!
    Triangulateio_exists=true;
    
    // Deep-copy triangulateio data into the Triangulateio private object
    bool quiet=true;
    Triangulateio=TriangleHelper::deep_copy_of_triangulateio_representation(
     triangulate_io,quiet);
    
    // Convert mesh from scaffold to actual mesh
    build_from_scaffold(time_stepper_pt,use_attributes);
    
    // Kill the scaffold
    delete Tmp_mesh_pt;
    Tmp_mesh_pt=0;
    
    // Setup boundary coordinates for boundaries
    unsigned nb=nboundary();
    for (unsigned b=0;b<nb;b++)
     {
      this->setup_boundary_coordinates(b);
     }
   }


  /// \short Build mesh, based on a TriangleMeshClosedCurve that specifies
  /// the outer boundary of the domain and any number of internal
  /// closed curves, specified by TriangleMeshInternalClosedCurves.
  /// Also specify target area for uniform element size.
  TriangleMesh(TriangleMeshClosedCurve* &outer_boundary_pt,
               Vector<TriangleMeshInternalClosedCurve*>& 
               internal_closed_curve_pt,
               const double &element_area,
               TimeStepper* time_stepper_pt=
               &Mesh::Default_TimeStepper,
               std::set<unsigned> &fill_index
               = Empty_fill_index,
               const bool &use_attributes=false) 
   {
    //Create the PolyLine representation of the boundary and
    //then call the generic constructor

    // Intrinsic coordinate along GeomObjects
    Vector<double> zeta(1);
    
    // Position vector to point on GeomObject
    Vector<double> posn(2); 

    // Initialise highest boundary id
    unsigned max_boundary_id = 0;

    // Storage for outer boundary in incarnation as polygon
    TriangleMeshPolygon* outer_boundary_polygon_pt=0;

    // What type of outer boundary is it? Try to cast
    TriangleMeshCurvilinearClosedCurve* curvilinear_boundary_pt=
     dynamic_cast<TriangleMeshCurvilinearClosedCurve*>(outer_boundary_pt);
    
    TriangleMeshPolygon* polygon_pt=
     dynamic_cast<TriangleMeshPolygon*>(outer_boundary_pt);
    
    // It's a curvilinear boundary
    if (curvilinear_boundary_pt!=0)
     {
      // How many separate boundaries do we have 
      unsigned nb=curvilinear_boundary_pt->ncurvilinear_boundary();

#ifdef PARANOID
      if (nb<2)
       {
        std::ostringstream error_message;
        error_message 
         << "TriangleMeshClosedCurve that defines outer boundary\n"
         << "must be made up of at least two "
         << "TriangleMeshCurvilinearClosedCurves\n"
         << "to allow the automatic set up boundary coordinates.\n"
         << "Yours only has " << nb << std::endl;
        throw OomphLibError(error_message.str(),
                            "TriangleMesh::TriangleMesh()",
                            OOMPH_EXCEPTION_LOCATION);
       }
#endif

      // Provide storage for accompanying polylines
      Vector<TriangleMeshPolyLine*> boundary_polyline_pt(nb);    
      
      // Loop over boundaries that make up this boundary
      for (unsigned b=0;b<nb;b++)
       {
        // Get pointer to curvilinear boundary that makes up this part
        // of the boundary
        TriangleMeshCurviLine* boundary_pt=
         curvilinear_boundary_pt->curvilinear_boundary_pt(b);

        // Create vertex coordinates for polygonal representation
        Vector<Vector<double> > bound;
        Vector<std::pair<double,double> > polygonal_vertex_arclength;
        create_vertex_coordinates_for_polyline(boundary_pt,
                                               bound,
                                               polygonal_vertex_arclength);
        // Boundary id
        unsigned bnd_id=boundary_pt->boundary_id();
        
        // Store
        Polygonal_vertex_arclength_info[bnd_id]=polygonal_vertex_arclength;

        // Build associated polyline
        boundary_polyline_pt[b] = new TriangleMeshPolyLine(bound,bnd_id);
        
        // Keep track...
        if (bnd_id>max_boundary_id) max_boundary_id=bnd_id;
        
       } //end of loop over boundaries
      
      // Create polygonal bundary from all the polylines
      outer_boundary_polygon_pt=new TriangleMeshPolygon(boundary_polyline_pt);
     }
    // It's a polygonal boundary
    else if (polygon_pt!=0)
     {
      // We're already a polygon
      outer_boundary_polygon_pt=polygon_pt;

      //Max boundary ID in outer boundary 
      max_boundary_id=polygon_pt->max_polygon_boundary_id();
     }
    // It's neither -- die on your arse
    else
     {
      std::ostringstream error_message;
      error_message 
       << "TriangleMeshClosedCurve that defines outer boundary\n"
       << "is neither a TriangleMeshCurvilinearClosedCurve\n"
       << "nor a TriangleMeshPolygon. This doesn't make sense.\n";
      throw OomphLibError(error_message.str(),
                          "TriangleMesh::TriangleMesh()",
                          OOMPH_EXCEPTION_LOCATION);
     }
    
    // Now deal with the internal closed curves

    //Find the number of internal closed curves
    unsigned n_internal_closed_curve = internal_closed_curve_pt.size();

    //Storage for the triangle polygons that define the internal boundaries
    Vector<TriangleMeshInternalPolygon*> 
     internal_polygon_pt(n_internal_closed_curve);
    
    //Loop over the number of internal closed curves
    for(unsigned h=0;h<n_internal_closed_curve;++h)
     {
      // What type of internal closed curve is it? Try to cast
      TriangleMeshInternalCurvilinearClosedCurve* curvilinear_hole_pt=
       dynamic_cast<TriangleMeshInternalCurvilinearClosedCurve*>(
        internal_closed_curve_pt[h]);

      TriangleMeshInternalPolygon* polygon_hole_pt=
       dynamic_cast<TriangleMeshInternalPolygon*>(internal_closed_curve_pt[h]);

      // It's a curvilinear curve
      if (curvilinear_hole_pt!=0)
       {
        // How many separate boundaries do we have 
        unsigned nb=curvilinear_hole_pt->ncurvilinear_boundary();

#ifdef PARANOID 
        if (nb<2)
         {     
          std::ostringstream error_message;
          error_message 
           << "TriangleMeshClosedCurve that defines internal closed curve\n"
           << "must be made up of at least two "
           << "TriangleMeshCurvilinearClosedCurves\n"
           << "to allow the automatic set up boundary coordinates.\n"
           << "The one defining your internal curve " << h << " only has " 
           << nb << std::endl;
          throw OomphLibError(error_message.str(),
                              "TriangleMesh::TriangleMesh()",
                              OOMPH_EXCEPTION_LOCATION);
         }
#endif

        // Provide storage for accompanying polylines
        Vector<TriangleMeshPolyLine*> hole_polyline_pt(nb);    
        
        // Loop over boundaries that make up this interal curve
        for (unsigned b=0;b<nb;b++)
         {
          // Get pointer to curvilinear boundary that makes up this part
          // of the closed curve
          TriangleMeshCurviLine* boundary_pt=
           curvilinear_hole_pt->curvilinear_boundary_pt(b);
          
          // Create vertex coordinates for polygonal represetation
          Vector<Vector<double> > bound_hole;
          Vector<std::pair<double,double> > polygonal_vertex_arclength;
          create_vertex_coordinates_for_polyline(boundary_pt,
                                                 bound_hole,
                                                 polygonal_vertex_arclength);
          
          // Boundary id
          unsigned bnd_id=boundary_pt->boundary_id();
          
          // Store
          Polygonal_vertex_arclength_info[bnd_id]=polygonal_vertex_arclength;

          // Build associated polyline
          hole_polyline_pt[b] = 
           new TriangleMeshPolyLine(bound_hole,bnd_id);

          // Keep track...
          if (bnd_id>max_boundary_id) max_boundary_id=bnd_id;
          
         } //end of loop over boundaries
        
        // Internal point coordinates by copy operation
        Vector<double> internal_point(curvilinear_hole_pt->internal_point());

        // Create polygonal hole from all the polylines
        internal_polygon_pt[h] = new TriangleMeshInternalPolygon(
         internal_point,hole_polyline_pt);
       }
      // It's polygon hole
      else if (polygon_hole_pt!=0)
       {
        // Get the max. boundary ID
        unsigned max_hole_boundary_id = 
         polygon_hole_pt->max_polygon_boundary_id();
        if (max_hole_boundary_id>max_boundary_id)
         {
          max_boundary_id=max_hole_boundary_id;
         }
        
        // Set pointer to Polygon representation (it is one already!)
        internal_polygon_pt[h]=polygon_hole_pt;
       }
      // Neither: Die on your arse!
      else
       {
        std::ostringstream error_message;
        error_message 
         << "TriangleMeshClosedCurve that defines the " << h 
         << "-th internal closed curve\n"
         << "is neither a TriangleMeshInternalCurvilinearClosedCurve\n"
         << "nor a TriangleMeshInternalPolygon. This doesn't make sense.\n";
         throw OomphLibError(error_message.str(),
                             "TriangleMesh::TriangleMesh()",
                             OOMPH_EXCEPTION_LOCATION);
       }
     }

    // Now resize the storage
    this->Boundary_geom_object_pt.resize(max_boundary_id+1,0);
    this->Boundary_coordinate_limits.resize(max_boundary_id+1);

    // If it's a curvilinear boundary store the associated geometric objects
    //and coordinates
    if (curvilinear_boundary_pt!=0)
     {
      // How many separate boundaries do we have 
      unsigned nb=curvilinear_boundary_pt->ncurvilinear_boundary();
      
#ifdef PARANOID
      if (nb<2)
       {
        std::ostringstream error_message;
        error_message 
         << "TriangleMeshClosedCurve that defines outer boundary\n"
         << "must be made up of at least two "
         << "TriangleMeshCurvilinearClosedCurves\n"
         << "to allow the automatic set up boundary coordinates.\n"
         << "Yours only has " << nb << std::endl;
        throw OomphLibError(error_message.str(),
                            "TriangleMesh::TriangleMesh()",
                            OOMPH_EXCEPTION_LOCATION);
       }
#endif

      // Loop over boundaries that make up this boundary
      for (unsigned b=0;b<nb;b++)
       {
        // Get pointer to curvilinear boundary that makes up this part
        // of the boundary
        TriangleMeshCurviLine* boundary_pt=
         curvilinear_boundary_pt->curvilinear_boundary_pt(b);
        
        //Read the values of the limiting coordinates
        Vector<double> zeta_bound(2);
        zeta_bound[0] = boundary_pt->zeta_start();
        zeta_bound[1] = boundary_pt->zeta_end(); 
        
        // Boundary id
        unsigned bnd_id=boundary_pt->boundary_id();
        
        //Set the boundary geometric object and limits
        Boundary_geom_object_pt[bnd_id] = boundary_pt->geom_object_pt();
        Boundary_coordinate_limits[bnd_id] = zeta_bound;        
       }
     }

    // Loop over the interla closed curves again and store the 
    // associated geometric objects and coordinates
    for(unsigned h=0;h<n_internal_closed_curve;h++)
     {
      // What type of internal curve is it? Try to cast
      TriangleMeshInternalCurvilinearClosedCurve* curvilinear_hole_pt=
       dynamic_cast<TriangleMeshInternalCurvilinearClosedCurve*>(
        internal_closed_curve_pt[h]);

      TriangleMeshInternalPolygon* polygon_hole_pt=
       dynamic_cast<TriangleMeshInternalPolygon*>(internal_closed_curve_pt[h]);
      
      // It's a curvilinear closed curve
      if (curvilinear_hole_pt!=0)
       {
        
        // How many separate boundaries do we have 
        unsigned nb=curvilinear_hole_pt->ncurvilinear_boundary();
        
#ifdef PARANOID
        if (nb<2)
         {
          std::ostringstream error_message;
          error_message 
           << "TriangleMeshClosedCurve that defines outer boundary\n"
           << "must be made up of at least two "
           << "TriangleMeshCurvilinearClosedCurves\n"
           << "to allow the automatic set up boundary coordinates.\n"
           << "Yours only has " << nb << std::endl;
          throw OomphLibError(error_message.str(),
                              "TriangleMesh::TriangleMesh()",
                              OOMPH_EXCEPTION_LOCATION);
         }
#endif

        // Loop over boundaries that make up this internal closed curve
        for (unsigned b=0;b<nb;b++)
         {
          // Get pointer to curvilinear boundary that makes up this part
          // of the internal closed curve
          TriangleMeshCurviLine* boundary_pt=
           curvilinear_hole_pt->curvilinear_boundary_pt(b);
          
          //Read the values of the limiting coordinates
          Vector<double> zeta_bound(2);
          zeta_bound[0] = boundary_pt->zeta_start();
          zeta_bound[1] = boundary_pt->zeta_end(); 
          
          // Boundary id
          unsigned bnd_id=boundary_pt->boundary_id();
          
          //Set the boundary geometric object and limits
          Boundary_geom_object_pt[bnd_id] = boundary_pt->geom_object_pt();
          Boundary_coordinate_limits[bnd_id] = zeta_bound;
         }
       }
      // It's polygon 
      else if (polygon_hole_pt!=0)
       {
        //Can the Polygon be cast to a geometric object incarnation
        GeomObject* bound_geom_obj_pt 
         = dynamic_cast<GeomObject*>(polygon_hole_pt);
        
        //If cast successful set up the coordinates 
        if(bound_geom_obj_pt!=0) 
         {
          unsigned n_poly = polygon_hole_pt->npolyline();
          for(unsigned p=0;p<n_poly;p++)
           {
            //Read out the index of the boundary from the polyline
            unsigned b_index = polygon_hole_pt->polyline_pt(p)->boundary_id();
            
            //Set the geometric object
            this->Boundary_geom_object_pt[b_index] = bound_geom_obj_pt;
            
            //The coordinates along each polyline boundary are scaled to
            //of unit length so the total coordinate limits are simply
            //(p,p+1)
            this->Boundary_coordinate_limits[b_index].resize(2);
            this->Boundary_coordinate_limits[b_index][0] = p;
            this->Boundary_coordinate_limits[b_index][1] = p + 1.0;
           }
         }
       }
      // Neither: Die on your arse!
      else
       {
        std::ostringstream error_message;
        error_message 
         << "TriangleMeshClosedCurve that defines the " << h 
         << "-th internal closed curve\n"
         << "is neither a TriangleMeshInternalCurvilinearClosedCurve\n"
         << "nor a TriangleMeshInternalPolygon. This doesn't make sense.\n";
         throw OomphLibError(error_message.str(),
                             "TriangleMesh::TriangleMesh()",
                             OOMPH_EXCEPTION_LOCATION);
       }
     }

    //Call the method used in the alternative constructor
    this->generic_constructor(outer_boundary_polygon_pt,
                              internal_polygon_pt,
                              fill_index,
                              element_area,
                              time_stepper_pt,
                              use_attributes);

    // Setup boundary coordinates for boundaries
    unsigned nb=nboundary();
    for (unsigned b=0;b<nb;b++)
     {
      this->setup_boundary_coordinates(b);
     }

    // Snap it!
    this->snap_nodes_onto_geometric_objects();
   }
  


  /// \short Build mesh from poly file, with specified target
  /// area for all elements.
  TriangleMesh(const std::string& poly_file_name,
               const double& element_area,
               TimeStepper* time_stepper_pt=
               &Mesh::Default_TimeStepper,
               const bool &use_attributes=false)
   {  
    // Disclaimer
    std::string message=
     "This constructor hasn't been tested since last cleanup.\n";
    OomphLibWarning(message,
                    "TriangleMesh::TriangleMesh()",
                    OOMPH_EXCEPTION_LOCATION);
    
    //Store the attributes flag
    Use_attributes = use_attributes;

    // Store Timestepper used to build elements
    Time_stepper_pt=time_stepper_pt;
    
    // Create the data structures required to call the triangulate function
    TriangulateIO triangle_in;
    
    // Input string for triangle
    std::stringstream input_string_stream;
    input_string_stream<<"-p-a" << element_area << "q30";
    
    // Convert to a *char required by the triangulate function
     char triswitches[100];
     sprintf(triswitches,"%s",input_string_stream.str().c_str());
     
    // Build the input triangulateio object from the .poly file
    build_triangulateio(poly_file_name, triangle_in);
    
    // Build the triangulateio out object
    triangulate(triswitches, &triangle_in, &Triangulateio, 0);
    
    // Build scaffold
    Tmp_mesh_pt= new TriangleScaffoldMesh(Triangulateio);
    
    // Convert mesh from scaffold to actual mesh
    build_from_scaffold(time_stepper_pt,use_attributes);
    
    // Kill the scaffold
    delete Tmp_mesh_pt;
    Tmp_mesh_pt=0;
    
    // Cleanup but leave hole alone
    bool clear_hole_data=false;
    TriangleHelper::clear_triangulateio(triangle_in,clear_hole_data);

    // Setup boundary coordinates for boundaries
    unsigned nb=nboundary();
    for (unsigned b=0;b<nb;b++)
     {
      this->setup_boundary_coordinates(b);
     }
   }

#endif

  
  /// Broken copy constructor
  TriangleMesh(const TriangleMesh& dummy) 
   { 
    BrokenCopy::broken_copy("TriangleMesh");
   } 
  
  /// Broken assignment operator
  void operator=(const TriangleMesh&) 
   {
    BrokenCopy::broken_assign("TriangleMesh");
   }
  
  /// Destructor 
  virtual ~TriangleMesh() 
   {     
#ifdef OOMPH_HAS_TRIANGLE_LIB
    if (Triangulateio_exists) 
     {
      TriangleHelper::clear_triangulateio(Triangulateio);
     }
#endif
   }
  
  /// \short Setup boundary coordinate on boundary b.
  /// Boundary coordinate increases continously along
  /// polygonal boundary. It's zero at the lowest left
  /// smallest node on the boundary.
  void setup_boundary_coordinates(const unsigned& b)
  {
   // Dummy file
   std::ofstream some_file;
   setup_boundary_coordinates(b,some_file);
  }
  
  /// \short Setup boundary coordinate on boundary b. Doc Faces
  /// in outfile.
  /// Boundary coordinate increases continously along
  /// polygonal boundary. It's zero at the lowest left
  /// node on the boundary.
  void setup_boundary_coordinates(const unsigned& b,
                                  std::ofstream& outfile);
  
  /// Return the number of elements adjacent to boundary b in region r
  inline unsigned nboundary_element_in_region(const unsigned &b,
                                        const unsigned &r) const
   {
    //Need to use a constant iterator here to keep the function "const"
    //Return an iterator to the appropriate entry, if we find it
    std::map<unsigned,Vector<FiniteElement*> >::const_iterator it =
     Boundary_region_element_pt[b].find(r);
    if(it!=Boundary_region_element_pt[b].end())
     {
      return (it->second).size();
     }
    //Otherwise there are no elements adjacent to boundary b in the region r
    else
     {
      return 0;
     }
   }

  /// Return pointer to the e-th element adjacent to boundary b in region r
  FiniteElement* boundary_element_pt_in_region(const unsigned &b, 
                                               const unsigned &r,
                                               const unsigned &e) const
   {
    //Use a constant iterator here to keep function "const" overall
    std::map<unsigned,Vector<FiniteElement*> >::const_iterator it =
     Boundary_region_element_pt[b].find(r);
    if(it!=Boundary_region_element_pt[b].end())
     {
      return (it->second)[e];
     }
    else
     {
      return 0;
     }
   }

  /// Return face index of the e-th element adjacent to boundary b in region r
  int face_index_at_boundary_in_region(const unsigned &b, 
                                       const unsigned &r,
                                       const unsigned &e) const
   {
    //Use a constant iterator here to keep function "const" overall
    std::map<unsigned,Vector<int> >::const_iterator it =
     Face_index_region_at_boundary[b].find(r);
    if(it!=Face_index_region_at_boundary[b].end())
     {
      return (it->second)[e];
     }
    else
     {
      std::ostringstream error_message;
      error_message << "Face indices not set up for boundary " 
                    << b << " in region " << r << "\n";
      error_message 
       << "This probably means that the boundary is not adjacent to region\n";
      throw OomphLibError(error_message.str(),
                          "TriangleMesh::face_index_at_boundary_in_region()",
                          OOMPH_EXCEPTION_LOCATION);
     }
   }



  /// Return the number of regions specified by attributes
  unsigned nregion() {return Region_element_pt.size();}
  
  /// Return the number of elements in region i
  unsigned nregion_element(const unsigned &i) 
  {return Region_element_pt[i].size();}
  
  /// Return the attribute associated with region i
  double region_attribute(const unsigned &i)
  {return Region_attribute[i];}
  
  /// Return the e-th element in the i-th region
  FiniteElement* region_element_pt(const unsigned &i,
                                   const unsigned &e)
  {return Region_element_pt[i][e];}
  

  /// \short Return the geometric object associated with the b-th boundary or
  /// null if the boundary has associated geometric object.
  GeomObject* boundary_geom_object_pt(const unsigned &b)
   {
    if(Boundary_geom_object_pt.size()==0) 
     {return 0;}
    else 
     {return Boundary_geom_object_pt[b];}
   }
  
  /// \short Return direct access to the geometric object storage
  Vector<GeomObject*> &boundary_geom_object_pt() 
   {return Boundary_geom_object_pt;}
  
  /// \short Return access to the vector of boundary coordinates associated
  ///with each geometric object
  Vector<Vector<double> > &boundary_coordinate_limits()
   {return Boundary_coordinate_limits;}
  
  /// \short Return access to the coordinate limits associated with 
  /// the geometric object associated with boundary b
  Vector<double> &boundary_coordinate_limits(const unsigned &b)
   {
    if(Boundary_coordinate_limits.size()==0)
     {
      throw OomphLibError(
       "No coordinate limits associated with this boundary\n",
       "TESTER",
       OOMPH_EXCEPTION_LOCATION);
     }
    else
     {
      return Boundary_coordinate_limits[b];
     }
   }
  
#ifdef OOMPH_HAS_TRIANGLE_LIB

  /// \short Update the TriangulateIO object to the current nodal position
  /// and the centre hole coordinates.
  void update_triangulateio(Vector<Vector<double> >&internal_point)
  {
    // Move the hole center
    // Get number of holes
   unsigned nhole=Triangulateio.numberofholes;
   unsigned count_coord=0;
   for(unsigned ihole=0;ihole<nhole;ihole++)
    {
     Triangulateio.holelist[count_coord]+=internal_point[ihole][0];  
     Triangulateio.holelist[count_coord+1]+=internal_point[ihole][1]; 
     
     // Increment counter
     count_coord+=2;
    }
   
   // Do the update
   update_triangulateio();
  }
   
  /// \short Update the triangulateio object to the current nodal positions
  void update_triangulateio()
  {   
   // Get number of points
   unsigned nnode = Triangulateio.numberofpoints;
   double new_x=0;
   double new_y=0;
   
   // Loop over the points
   for(unsigned inod=0;inod<nnode;inod++)
    {      
     // Get the node Id to be updated
     unsigned count=Oomph_vertex_nodes_id[inod];
     
     // Update vertices using the vertex_node_id giving for the TriangulateIO
     // vertex enumeration the corresponding oomphlib mesh enumeration
     Node* mesh_node_pt=this->node_pt(inod);
     new_x=mesh_node_pt->x(0); 
     new_y=mesh_node_pt->x(1); 
     Triangulateio.pointlist[count*2] = new_x;  
     Triangulateio.pointlist[(count*2)+1] = new_y;       
    }
  }
  
  /// \short Completely regenerate the mesh from the trianglateio structure
  void remesh_from_internal_triangulateio()
   {
    //Remove all the boundary node information
    this->remove_boundary_nodes();

    //Delete exisiting nodes
    unsigned n_node = this->nnode();
    for(unsigned n=n_node;n>0;--n)
     {
      delete this->Node_pt[n-1];
      this->Node_pt[n-1] = 0;
     }
    //Delete exisiting elements
    unsigned n_element = this->nelement();
    for(unsigned e=n_element;e>0;--e)
     {
      delete this->Element_pt[e-1];
      this->Element_pt[e-1] = 0;
     }
    //Flush the storage
    this->flush_element_and_node_storage();

    //Delete all boundary element information
    //ALH: Kick up the object hierarchy?
    this->Boundary_element_pt.clear();
    this->Face_index_at_boundary.clear();
    this->Region_element_pt.clear();
    this->Region_attribute.clear();
    this->Boundary_region_element_pt.clear();
    this->Face_index_region_at_boundary.clear();

    //Now build the new scaffold
    Tmp_mesh_pt= new TriangleScaffoldMesh(this->Triangulateio);
        
    // Triangulation has been created -- remember to wipe it!
    Triangulateio_exists=true;
    
    // Convert mesh from scaffold to actual mesh
    build_from_scaffold(this->Time_stepper_pt,this->Use_attributes);
    
    // Kill the scaffold
    delete Tmp_mesh_pt;
    Tmp_mesh_pt=0;

    // Setup boundary coordinates for boundaries
    unsigned nb=nboundary();
    for (unsigned b=0;b<nb;b++)
     {
      this->setup_boundary_coordinates(b);
     }

    //Deform the boundary onto any geometric objects
    this->snap_nodes_onto_geometric_objects();
   }

  /// Boolean defining if Triangulateio object has been built or not
  bool triangulateio_exists(){return Triangulateio_exists;}

#endif


  /// \short Return the vector that contains the oomph-lib node number
  /// for all vertex nodes in the TriangulateIO representation of the mesh
  Vector<unsigned> oomph_vertex_nodes_id(){return Oomph_vertex_nodes_id;}
   
  /// \short Snap the boundary nodes onto any curvilinear boundaries
  /// defined by geometric objects
  void snap_nodes_onto_geometric_objects();    
  
    protected:

  /// Static empty set for use as a default argument
  /// to to constructor
  static std::set<unsigned> Empty_fill_index;

  /// Build mesh from scaffold
  void build_from_scaffold(TimeStepper* time_stepper_pt,
                           const bool &use_attributes);

#ifdef OOMPH_HAS_TRIANGLE_LIB  
  
  /// \short Build TriangulateIO object from TriangleMeshPolyLine and 
  /// TriangleMeshInternalClosedCurvePolyLine
  void build_triangulateio(TriangleMeshPolygon* &outer_boundary_pt,
                           Vector<TriangleMeshInternalPolygon*>&
                           internal_closed_curve_pt,
                           std::set<unsigned> &fill_index,
                           TriangulateIO& triangulate_io);
  
  /// \short Helper function to create TriangulateIO object (return in
  /// triangulate_io) from the .poly file 
  void build_triangulateio(const std::string& poly_file_name,
                           TriangulateIO& triangulate_io);


  /// \short A general-purpose construction function that builds the
  /// mesh once the different specific constructors have assembled the
  /// appropriate information.
  void generic_constructor(TriangleMeshPolygon* &outer_boundary_pt,
                           Vector<TriangleMeshInternalPolygon*> &internal_polygon_pt,
                           std::set<unsigned> &fill_index,
                           const double &element_area,
                           TimeStepper* time_stepper_pt,
                           const bool &use_attributes) 
   {
    //Store the attribute flag
    Use_attributes = use_attributes;

    // Store Timestepper used to build elements
    Time_stepper_pt=time_stepper_pt;
    
    // Store outer polygon
    Outer_boundary_pt=outer_boundary_pt;
    
    // Store internal polygons by copy constructor
    Internal_polygon_pt=internal_polygon_pt;
    
    // Store the fill index
    Fill_index = fill_index;

    // Create the data structures required to call the triangulate function
    TriangulateIO triangulate_io;
    
    // Initialize TriangulateIO structure
    TriangleHelper::initialise_triangulateio(triangulate_io);
    
    // Convert TriangleMeshPolyLine and TriangleMeshInternalClosedCurvePolyLine
    // to a triangulateio object
    build_triangulateio(outer_boundary_pt,
                        internal_polygon_pt,
                        fill_index,
                        triangulate_io);
    
    // Initialize TriangulateIO structure
    TriangleHelper::initialise_triangulateio(Triangulateio);
    
    // Triangulation has been created -- remember to wipe it!
    Triangulateio_exists=true;
    
    // Input string for triangle
    std::stringstream input_string_stream;
    input_string_stream<<"-pA-a" << element_area << "q30";
    
    // Convert the Input string in *char required by the triangulate function
     char triswitches[100];
     sprintf(triswitches,"%s",input_string_stream.str().c_str());
     
    // Build the mesh using triangulate function
    triangulate(triswitches, &triangulate_io, &Triangulateio, 0);   
    
    // Build scaffold
    Tmp_mesh_pt= new TriangleScaffoldMesh(Triangulateio);
    
    //If we have filled holes then we must use the attributes
    if(fill_index.size() > 0) 
     {
      // Convert mesh from scaffold to actual mesh
      build_from_scaffold(time_stepper_pt,true);
      //Record the attribute flag
      Use_attributes=true;
     }
    //Otherwise use what was asked
    else
     {
      // Convert mesh from scaffold to actual mesh
      build_from_scaffold(time_stepper_pt,use_attributes);
     }

    // Kill the scaffold
    delete Tmp_mesh_pt;
    Tmp_mesh_pt=0;
    
    // Cleanup but leave hole and regions alone since it's still used
    bool clear_hole_data=false;
    TriangleHelper::clear_triangulateio(triangulate_io,clear_hole_data);
   }
  
  
  /// \short Helper function to create polyline vertex coordinates for 
  /// curvilinear boundary specified by boundary_pt, using either
  /// equal increments in zeta or in (approximate) arclength
  /// along the curviline. vertex_coord[i_vertex][i_dim] stores
  /// i_dim-th coordinate of i_vertex-th vertex. 
  /// polygonal_vertex_arclength_info[i_vertex] contains the pair of doubles
  /// made of the arclength of the i_vertex-th vertex along the polygonal 
  /// representation (.first), and the corresponding coordinate on the
  /// GeomObject (.second)
  void create_vertex_coordinates_for_polyline(
   TriangleMeshCurviLine* boundary_pt,
   Vector<Vector<double> >& vertex_coord,
   Vector<std::pair<double,double> >& polygonal_vertex_arclength_info)
  {
   
   // Intrinsic coordinate along GeomObjects
   Vector<double> zeta(1);
   
   // Position vector to point on GeomObject
   Vector<double> posn(2); 
   
   // Start coordinate
   double zeta_initial = boundary_pt->zeta_start();

   //How many segments do we want on this polyline?
   unsigned n_seg = boundary_pt->nsegment();
   vertex_coord.resize(n_seg+1);
   polygonal_vertex_arclength_info.resize(n_seg+1);
   polygonal_vertex_arclength_info[0].first=0.0;
   polygonal_vertex_arclength_info[0].second=zeta_initial;
  
  

   // Vertices placed in equal zeta increments
   if (!(boundary_pt->space_vertices_evenly_in_arclength()))
    {
     //Read the values of the limiting coordinates, assuming equal
     //spacing of the nodes
     double zeta_increment = 
      (boundary_pt->zeta_end()-boundary_pt->zeta_start())/(double(n_seg));
   
     //Loop over the n_seg+1 points bounding the segments
     for(unsigned s=0;s<n_seg+1;s++)
      {
       // Get the coordinates
       zeta[0]= zeta_initial + zeta_increment*double(s);            
       boundary_pt->geom_object_pt()->position(zeta,posn);
       vertex_coord[s]=posn;

       // Bump up the polygonal arclength
       if (s>0)
        {
         polygonal_vertex_arclength_info[s].first=
          polygonal_vertex_arclength_info[s-1].first+
          sqrt(pow(vertex_coord[s][0]-vertex_coord[s-1][0],2)+
               pow(vertex_coord[s][1]-vertex_coord[s-1][1],2));
         polygonal_vertex_arclength_info[s].second=zeta[0];

        }
      }
    }
   // Vertices placed in equal increments in (approximate) arclength
   else
    {
     // Number of sampling points to compute arclength and
     // arclength increments
     unsigned nsample_per_segment=100;
     unsigned nsample=nsample_per_segment*n_seg;
   
     // Work out start and increment
     double zeta_increment=(boundary_pt->zeta_end()-
                            boundary_pt->zeta_start())/(double(nsample));
   
     // Get coordinate of first point
     Vector<double> start_point(2);
     zeta[0]=zeta_initial;
     boundary_pt->geom_object_pt()->position(zeta,start_point);
   
     // Storage for coordinates of end point
     Vector<double> end_point(2);          
   
     // Compute total arclength
     double total_arclength=0.0;
     for (unsigned i=1;i<nsample;i++)
      {
       // Next point
       zeta[0]+=zeta_increment;
     
       // Get coordinate of end point
       boundary_pt->geom_object_pt()->position(zeta,end_point);
     
       // Increment arclength
       total_arclength+=sqrt(pow(end_point[0]-start_point[0],2)+
                             pow(end_point[1]-start_point[1],2));
     
       // Shift back
       start_point=end_point;
      }
   
     // Desired arclength increment
     double target_s_increment=total_arclength/(double(n_seg));

     // Get coordinate of first point again
     zeta[0]=zeta_initial;
     boundary_pt->geom_object_pt()->position(zeta,start_point);
   
     // Assign as coordinate
     vertex_coord[0]=start_point;
   
     // Start sampling point 
     unsigned i_lo=1;
   
     //Loop over the n_seg-1 internal points bounding the segments
     for(unsigned s=1;s<n_seg;s++)
      {
       // Visit potentially all sample points until we've found
       // the one at which we exceed the target arclength increment
       double arclength_increment=0.0;
       for (unsigned i=i_lo;i<nsample;i++)
        {
         // Next point
         zeta[0]+=zeta_increment;
       
         // Get coordinate of end point
         boundary_pt->geom_object_pt()->position(zeta,end_point);
       
         // Increment arclength increment
         arclength_increment+=sqrt(pow(end_point[0]-start_point[0],2)+
                                   pow(end_point[1]-start_point[1],2));
       
       
         // Shift back
         start_point=end_point;
       
         // Are we there yet?
         if (arclength_increment>target_s_increment)
          {
           // Remember how far we've got
           i_lo=i;

           // And bail out
           break;
          }
        }
     
       // Store the coordinates
       vertex_coord[s]=end_point;
       
       // Bump up the polygonal arclength
       if (s>0)
        {
         polygonal_vertex_arclength_info[s].first=
          polygonal_vertex_arclength_info[s-1].first+
          sqrt(pow(vertex_coord[s][0]-vertex_coord[s-1][0],2)+
               pow(vertex_coord[s][1]-vertex_coord[s-1][1],2));
         polygonal_vertex_arclength_info[s].second=zeta[0];
        }
      }
   
     // Final point
     unsigned s=n_seg;
     zeta[0]=boundary_pt->zeta_end();
     boundary_pt->geom_object_pt()->position(zeta,end_point);
     vertex_coord[s]=end_point;
     polygonal_vertex_arclength_info[s].first=
      polygonal_vertex_arclength_info[s-1].first+
      sqrt(pow(vertex_coord[s][0]-vertex_coord[s-1][0],2)+
           pow(vertex_coord[s][1]-vertex_coord[s-1][1],2));
     polygonal_vertex_arclength_info[s].second=zeta[0];    
    }
  }
 
  
  /// Boolean defining if Triangulateio object has been built or not
  bool Triangulateio_exists;

#endif
    
  /// Temporary scaffold mesh
  TriangleScaffoldMesh* Tmp_mesh_pt;
    
  /// \short Vector storing oomph-lib node number
  /// for all vertex nodes in the TriangulateIO representation of the mesh
  Vector<unsigned> Oomph_vertex_nodes_id;
  
  /// Vectors of elements in each region differentiated by attribute
  Vector<Vector<FiniteElement* > > Region_element_pt;
  
  /// Vector of attributes associated with the elements in each region
  Vector<double> Region_attribute;
  
  /// Polygon that defines outer boundaries
  TriangleMeshPolygon* Outer_boundary_pt;
  
  /// Vector to polygons that define internal polygons
  Vector<TriangleMeshInternalPolygon*> Internal_polygon_pt;
  
  /// \short Storage for the geometric objects associated with any boundaries
  /// hierher should this be a map?
  Vector<GeomObject*> Boundary_geom_object_pt;

  /// Storage of indices of any inner holes that should be filled
  std::set<unsigned> Fill_index;

  /// Storage for elements adjacent to a boundary in a particular region
  Vector<std::map<unsigned,Vector<FiniteElement*> > > 
   Boundary_region_element_pt;

  /// \short Storage for the face index adjacent to a boundary in a particular
  /// region
  Vector<std::map<unsigned,Vector<int> > > Face_index_region_at_boundary;

  /// \short  Storage for the limits of the boundary coordinates 
  /// defined by the of geometric objects. Only used for curvilinear
  /// boundaries. hierher should this be a map?
  Vector<Vector<double> > Boundary_coordinate_limits;

  /// \short Storage for pairs of doubles representing:
  /// .first: the arclength along the polygonal representation of
  ///         the curviline 
  /// .second: the corresponding intrinsic coordinate on the associated
  ///          geometric object
  /// at which the vertices on the specified boundary are located.
  /// Only used for boundaries represented by geom objects.
  std::map<unsigned,Vector<std::pair<double,double> > > 
   Polygonal_vertex_arclength_info;

  /// Timestepper used to build elements
  TimeStepper* Time_stepper_pt;

  /// Boolean flag to indicate whether to use attributes or not
  /// (required for multidomain meshes
  bool Use_attributes;
  
 };


//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////

#ifdef OOMPH_HAS_TRIANGLE_LIB  
 
//=========================================================================
// Unstructured refineable Triangle Mesh 
//=========================================================================
template<class ELEMENT>
 class RefineableTriangleMesh : public virtual TriangleMesh<ELEMENT>,
  public virtual RefineableMeshBase
  {
   
    public:

    /// \short Build mesh, based on closed curve that specifies
    /// the outer boundary of the domain and any number of internal
    /// closed curves, specified by TriangleMeshInternalClosedCurves. Specify
    /// target area for uniform element size.
    RefineableTriangleMesh(
     TriangleMeshClosedCurve* &outer_boundary_pt,
     Vector<TriangleMeshInternalClosedCurve*>& internal_closed_curve_pt,
     const double &element_area,
     TimeStepper* time_stepper_pt=&Mesh::Default_TimeStepper,
     std::set<unsigned> &fill_index=TriangleMesh<ELEMENT>::Empty_fill_index,
     const bool &use_attributes=false) :
     TriangleMesh<ELEMENT>(outer_boundary_pt,
                           internal_closed_curve_pt,
                           element_area,
                           time_stepper_pt,
                           fill_index,
                           use_attributes)
     {
      // Initialise the data associated with adaptation
      initialise_adaptation_data();
     }

   /// \short Build mesh from specified triangulation and
   /// associated target areas for elements in it
   RefineableTriangleMesh(const Vector<double> &target_area,
                          TriangulateIO& triangulate_io,
                          TimeStepper* time_stepper_pt=
                          &Mesh::Default_TimeStepper,
                          const bool &use_attributes=false)  
    {
     // Initialise the data associated with adaptation
     initialise_adaptation_data();
     
     // Store Timestepper used to build elements
     this->Time_stepper_pt=time_stepper_pt;

     // Create triangulateio object to refine
     TriangulateIO triangle_refine;
     
     // Initialize triangulateio structure
     TriangleHelper::initialise_triangulateio(this->Triangulateio);
     
     // Triangulation has been created -- remember to wipe it!
     this->Triangulateio_exists=true;
     
     // Create refined  TriangulateIO structure based on target areas
     this->refine_triangulateio(triangulate_io,
                                target_area,
                                triangle_refine);

     // Input string for triangle
     std::stringstream input_string_stream;
     input_string_stream<<"-pq30-ra"; 
     
     // Convert to a *char required by the triangulate function
     char triswitches[100];
     sprintf(triswitches,"%s",input_string_stream.str().c_str());
     
     // Build triangulateio refined object
     triangulate(triswitches, &triangle_refine, &this->Triangulateio, 0);       
     // Build scaffold
     this->Tmp_mesh_pt=new TriangleScaffoldMesh(this->Triangulateio);

     // Convert mesh from scaffold to actual mesh
     this->build_from_scaffold(time_stepper_pt,use_attributes);
     
     // Kill the scaffold
     delete this->Tmp_mesh_pt;
     this->Tmp_mesh_pt=0;
     
     // Cleanup but leave hole alone as it's still used
     bool clear_hole_data=false;
     TriangleHelper::clear_triangulateio(triangle_refine,clear_hole_data);

     // Setup boundary coordinates for boundaries
     unsigned nb=nboundary();
     for (unsigned b=0;b<nb;b++)
      {
       this->setup_boundary_coordinates(b);
      }       
    }   
   
   /// Empty Destructor
   virtual ~RefineableTriangleMesh() {}
   
   /// \short Problem pointer (needed for multi-domain machinery during
   /// adaptation)
   Problem*& problem_pt(){return Problem_pt;}
   
   /// Max element size allowed during adaptation
   double& max_element_size(){return Max_element_size;}
   
   /// Min element size allowed during adaptation
   double& min_element_size(){return Min_element_size;}
   
   /// Min angle before remesh gets triggered
   double& min_permitted_angle(){return Min_permitted_angle;}
   
   /// Doc the targets for mesh adaptation
   void doc_adaptivity_targets(std::ostream &outfile)
   {
    outfile << std::endl;
    outfile << "Targets for mesh adaptation: " << std::endl;
    outfile << "---------------------------- " << std::endl;
    outfile << "Target for max. error: " << Max_permitted_error << std::endl;
    outfile << "Target for min. error: " << Min_permitted_error << std::endl;
    outfile << "Target min angle: " << Min_permitted_angle << std::endl;
    outfile << "Min. allowed element size: " << Min_element_size << std::endl;
    outfile << "Max. allowed element size: " << Max_element_size << std::endl;
    outfile << "Don't unrefine if less than " << Max_keep_unrefined 
            << " elements need unrefinement." << std::endl;
    outfile << std::endl;
   }
   
   
   /// Refine mesh uniformly and doc process
   void refine_uniformly(DocInfo& doc_info)
   {
    throw OomphLibError("refine_uniformly() not implemented yet",
                        "RefineableTriangleMesh::refine_uniformly()",
                        OOMPH_EXCEPTION_LOCATION); 
   }    
   
   
   /// \short Unrefine mesh uniformly: Return 0 for success,
   /// 1 for failure (if unrefinement has reached the coarsest permitted
   /// level)
   unsigned unrefine_uniformly(OomphCommunicator* comm_pt)
   {
    throw OomphLibError("unrefine_uniformly() not implemented yet",
                        "RefineableTriangleMesh::unrefine_uniformly()",
                        OOMPH_EXCEPTION_LOCATION); 
    // dummy return
    return 0;
   }
   
   /// Adapt mesh, based on elemental error provided
   void adapt(OomphCommunicator* comm_pt,
              const Vector<double>& elem_error); 
   

   
    protected:
   
   /// \short Helper function that updates the input polygon's PSLG
   /// by using the end-points of elements from FaceMesh(es) that are
   /// constructed for the boundaries associated with the segments of the
   /// polygon.
   void update_polygon_using_face_mesh(TriangleMeshPolygon* polygon_pt);
   
   /// \short Generate a new PSLG representation of the inner hole
   /// boundaries
   virtual void surface_remesh_for_inner_hole_boundaries(
    Vector<Vector<double> > &internal_point_coord);
   
   
   /// \short Generate a new PSLG representation of the outer boundary
   virtual void surface_remesh_for_outer_boundary();
   
   
  /// \short Snap the boundary nodes onto any curvilinear boundaries
  void snap_nodes_onto_boundary(RefineableTriangleMesh<ELEMENT>* &new_mesh_pt,
                                const unsigned &b);

   
   /// Helper function to initialise data associated with adaptation
   void initialise_adaptation_data()
   {
    // Set max and min targets for adaptation
    this->Max_element_size=1.0;
    this->Min_element_size=0.001;
    this->Min_permitted_angle=15.0;
    
    // Initialise problem pointer
    this->Problem_pt=0;
   }
   
   /// \short Build a new TriangulateIO object from previous TriangulateIO
   /// based on target area for each element
   void refine_triangulateio(TriangulateIO& triangulate_io, 
                             const Vector<double> &target_area,
                             TriangulateIO &triangle_refine);
   

   /// \short Compute target area based on the element's error and the
   /// error target; return minimum angle (in degrees)
   double compute_area_target(const Vector<double> &elem_error,
                              Vector<double> &target_area)
   {
    double min_angle=DBL_MAX;
    unsigned count_unrefined=0;
    unsigned count_refined=0;
    this->Nrefinement_overruled=0;
    
    unsigned nel=this->nelement();
    for (unsigned e=0;e<nel;e++)
     {
      
      // Get element
      FiniteElement* el_pt=this->finite_element_pt(e);
      
      // Area 
      double area=el_pt->size();


      // Min angle based on vertex coordinates
      // (vertices are enumerated first)
      double ax=el_pt->node_pt(0)->x(0);
      double ay=el_pt->node_pt(0)->x(1);
        
      double bx=el_pt->node_pt(1)->x(0);
      double by=el_pt->node_pt(1)->x(1);
        
      double cx=el_pt->node_pt(2)->x(0);
      double cy=el_pt->node_pt(2)->x(1);
        
      // Min angle
      double angle0=
       acos(((ax-cx)*(bx-cx)+(ay-cy)*(by-cy))/
            (sqrt((ax-cx)*(ax-cx)+(ay-cy)*(ay-cy))*
             sqrt((bx-cx)*(bx-cx)+(by-cy)*(by-cy))))*
       180.0/MathematicalConstants::Pi;
      min_angle=std::min(min_angle,angle0);
        
      double angle1=
       acos(((ax-bx)*(cx-bx)+(ay-by)*(cy-by))/
            (sqrt((ax-bx)*(ax-bx)+(ay-by)*(ay-by))*
             sqrt((cx-bx)*(cx-bx)+(cy-by)*(cy-by))))*
       180.0/MathematicalConstants::Pi;
      min_angle=std::min(min_angle,angle1);
        
      double angle2=180.0-angle0-angle1;
      min_angle=std::min(min_angle,angle2);
        
      // Mimick refinement in tree-based procedure: Target areas
      // for elements that exceed permitted error is 1/3 of their
      // current area, corresponding to a uniform sub-division.
      if (elem_error[e]>max_permitted_error())
       {
        target_area[e]=std::max(area/3.0,Min_element_size);
        if (target_area[e]!=Min_element_size)
         {
          count_refined++;
         }
        else
         {
          this->Nrefinement_overruled++;
         }
       }
      else if (elem_error[e]<min_permitted_error())
       {
        target_area[e]=std::min(3.0*area,Max_element_size);
        if (target_area[e]!=Max_element_size)
         {
          count_unrefined++;
         }
       }
      else
       {
        // Leave it alone
        target_area[e] = std::max(area,Min_element_size); 
       }
     }      
    
    // Tell everybody
    this->Nrefined=count_refined;
    this->Nunrefined=count_unrefined;
    
    return min_angle;
   }
   
   /// \short Problem pointer (needed for multi-domain machinery during
   /// adaptation
   Problem* Problem_pt;
   
   /// Max permitted element size
   double Max_element_size;
   
   /// Min permitted element size
   double Min_element_size;
   
   /// Min angle before remesh gets triggered
   double Min_permitted_angle;
   
  }; 

#endif


/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////


#ifdef OOMPH_HAS_TRIANGLE_LIB  

//=========================================================================
// Unstructured Triangle Mesh upgraded to solid mesh
//=========================================================================
 template<class ELEMENT>
  class SolidTriangleMesh : public virtual TriangleMesh<ELEMENT>,
  public virtual SolidMesh
  {
   
    public:
   
  /// \short Build mesh, based on closed curve that specifies
  /// the outer boundary of the domain and any number of internal
  /// clsed curves. Specify target area for uniform element size.
   SolidTriangleMesh(
    TriangleMeshClosedCurve* &outer_boundary_pt,
    Vector<TriangleMeshInternalClosedCurve*>& internal_closed_curve_pt,
    const double &element_area,
    TimeStepper* time_stepper_pt=&Mesh::Default_TimeStepper,
    std::set<unsigned> &fill_index=TriangleMesh<ELEMENT>::Empty_fill_index,
    const bool &use_attributes=false) :
    TriangleMesh<ELEMENT>(outer_boundary_pt,
                          internal_closed_curve_pt,
                          element_area,
                          time_stepper_pt,
                          fill_index,
                          use_attributes)
    {
     //Assign the Lagrangian coordinates
     set_lagrangian_nodal_coordinates();
    }
    
    
  };

#endif

////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////

#ifdef OOMPH_HAS_TRIANGLE_LIB  

//=========================================================================
// Unstructured refineable Triangle Mesh upgraded to solid mesh
//=========================================================================
 template<class ELEMENT>
  class RefineableSolidTriangleMesh : 
public virtual RefineableTriangleMesh<ELEMENT>,
 public virtual SolidMesh
 {
  
   public:
  
  /// \short Build mesh, based on closed curve that specifies
  /// the outer boundary of the domain and any number of internal
  /// closed curves. Specify target area for uniform element size.
  RefineableSolidTriangleMesh(
   TriangleMeshClosedCurve* &outer_boundary_pt,
   Vector<TriangleMeshInternalClosedCurve*>& internal_closed_curve_pt,
   const double &element_area,
   TimeStepper* time_stepper_pt=&Mesh::Default_TimeStepper,
   std::set<unsigned> &fill_index=TriangleMesh<ELEMENT>::Empty_fill_index,
   const bool &use_attributes=false) :
   TriangleMesh<ELEMENT>(outer_boundary_pt,
                         internal_closed_curve_pt,
                         element_area,
                         time_stepper_pt,
                         fill_index,
                         use_attributes),
   RefineableTriangleMesh<ELEMENT>(outer_boundary_pt,
                                   internal_closed_curve_pt,
                                   element_area,
                                   time_stepper_pt,
                                   fill_index,
                                   use_attributes)
    {
     //Assign the Lagrangian coordinates
     set_lagrangian_nodal_coordinates();
    }
   
   
   
   /// \short Build mesh from specified triangulation and
   /// associated target areas for elements in it.
   RefineableSolidTriangleMesh(const Vector<double> &target_area,
                               TriangulateIO& triangulate_io,
                               TimeStepper* time_stepper_pt=
                               &Mesh::Default_TimeStepper,
                               const bool &use_attributes=false)  :
    RefineableTriangleMesh<ELEMENT>(target_area,
                                    triangulate_io,
                                    time_stepper_pt,
                                    use_attributes)
    {
     //Assign the Lagrangian coordinates
     set_lagrangian_nodal_coordinates();
    }
    
    /// Empty Destructor
    virtual ~RefineableSolidTriangleMesh() {}
    
 };

#endif

}

#endif
