//LIC// ====================================================================
//LIC// This file forms part of oomph-lib, the object-oriented, 
//LIC// multi-physics finite-element library, available 
//LIC// at http://www.oomph-lib.org.
//LIC// 
//LIC//           Version 0.85. June 9, 2008.
//LIC// 
//LIC// Copyright (C) 2006-2008 Matthias Heil and Andrew Hazel
//LIC// 
//LIC// This library is free software; you can redistribute it and/or
//LIC// modify it under the terms of the GNU Lesser General Public
//LIC// License as published by the Free Software Foundation; either
//LIC// version 2.1 of the License, or (at your option) any later version.
//LIC// 
//LIC// This library is distributed in the hope that it will be useful,
//LIC// but WITHOUT ANY WARRANTY; without even the implied warranty of
//LIC// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//LIC// Lesser General Public License for more details.
//LIC// 
//LIC// You should have received a copy of the GNU Lesser General Public
//LIC// License along with this library; if not, write to the Free Software
//LIC// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
//LIC// 02110-1301  USA.
//LIC// 
//LIC// The authors may be contacted at oomph-lib@maths.man.ac.uk.
//LIC// 
//LIC//====================================================================
//Include guards
#ifndef OOMPH_PRECONDITION_HEADER
#define OOMPH_PRECONDITION_HEADER


// Config header generated by autoconfig
#ifdef HAVE_CONFIG_H
  #include <oomph-lib-config.h>
#endif

#include "matrices.h"
#include "problem.h"
#include <algorithm>

#ifdef OOMPH_HAS_MPI
#include "distributed_vector.h"
#endif

namespace oomph
{

//=============================================================================
/// \short Preconditioner base class. This is a base class for all oomph-lib
/// preconditioners and primarily contains the method definitions. All 
/// preconditioners should be derived from this class.
//=============================================================================
class Preconditioner
{

 public:

 /// Constructor (empty)
 Preconditioner(){};
 

 /// Broken copy constructor
 Preconditioner(const Preconditioner&) 
  { 
   BrokenCopy::broken_copy("Preconditioner");
  } 
 
 /// Broken assignment operator
 void operator=(const Preconditioner&) 
  {
   BrokenCopy::broken_assign("Preconditioner");
  }

  /// Destructor (empty)
  virtual ~Preconditioner(){}

#ifdef OOMPH_HAS_MPI
  /// \short Apply the preconditioner. This method should apply the 
  /// preconditioner operator to the vector r and return the vector z. This
  /// is a specialisation for distributed vectors 
  virtual void preconditioner_solve(const DistributedVector<double>&r, 
                                    DistributedVector<double> &z)
   {
    throw OomphLibError
     ("Preconditioner::preconditioner_solve() is broken virtual",
      "Preconditioner::preconditioner_solve()",
      OOMPH_EXCEPTION_LOCATION);
   }
#endif

  /// \short Apply the preconditioner. This method should apply the 
  /// preconditioner operator to the vector r and return the vector z.
  virtual void preconditioner_solve(const Vector<double>&r, Vector<double> &z)
   {
    throw OomphLibError
     ("Preconditioner::preconditioner_solve() is broken virtual",
      "Preconditioner::preconditioner_solve()",
      OOMPH_EXCEPTION_LOCATION);
   }
  
  /// \short Setup the preconditioner (emtpy). Generic interface allows 
  /// preconditioner to be assembled based on the Problem or
  /// the assembled matrix
  virtual void setup(Problem* problem_pt, DoubleMatrixBase* matrix_pt)
   {
    throw OomphLibError
     ("Preconditioner::setup() is broken virtual",
      "Preconditioner::setup()",
      OOMPH_EXCEPTION_LOCATION);
   }
  
  /// \short Clean up memory (empty). Generic interface to allows data
  /// associated with a preconditioner to be deleted
  virtual void clean_up_memory(){};

#ifdef OOMPH_HAS_MPI
  /// \short accesss function to the distribution of this preconditioner
  DistributionInfo& distribution() { return Preconditioner_distribution; }

  /// \short accesss function to the distribution of this preconditioner
  /// (const version)
  DistributionInfo distribution() const { return Preconditioner_distribution; }

  protected:

  /// \short The distribution of this preconditioner
  DistributionInfo Preconditioner_distribution;
#endif


};//Preconditioner

//=============================================================================
/// The Identity Preconditioner
//=============================================================================
class IdentityPreconditioner : public Preconditioner
 {

   public:
  
  // Constructor - nothing to construct
  IdentityPreconditioner() {}
  
  /// Broken copy constructor
  IdentityPreconditioner(const IdentityPreconditioner&) 
   { 
    BrokenCopy::broken_copy("IdentityPreconditioner");
   } 
  
  /// Broken assignment operator
  void operator=(const IdentityPreconditioner&) 
   {
    BrokenCopy::broken_assign("IdentityPreconditioner");
   }

  /// Destructor (empty)
  virtual ~IdentityPreconditioner(){}

  /// setup method - nothing to setup for this preconditioner
  virtual void setup(Problem* problem_pt, DoubleMatrixBase* matrix_pt)
   {}

#ifdef OOMPH_HAS_MPI
  /// \short Apply the preconditioner. This is a specialisation for 
  /// distributed vectors 
  virtual void preconditioner_solve(const DistributedVector<double>&r, 
                                    DistributedVector<double> &z)
   {
    z= r;
   }
#endif

  /// \short Apply the preconditioner. This method should apply the 
  /// preconditioner operator to the vector r and return the vector z.
  virtual void preconditioner_solve(const Vector<double>&r, Vector<double> &z)
   {
    unsigned nrow = r.size();
    z.resize(nrow);
    for (unsigned i = 0; i < nrow; i++)
     {
      z[i] = r[i];
     }
   }
 };  

//=====================================================================
/// Matrix-based diagonal preconditioner
//=====================================================================
class MatrixBasedDiagPreconditioner : public Preconditioner
{
 public:
 
 ///Constructor (empty)
 MatrixBasedDiagPreconditioner(){};
 
 ///Destructor (empty)
 ~MatrixBasedDiagPreconditioner(){};
 
 /// Broken copy constructor
 MatrixBasedDiagPreconditioner(const MatrixBasedDiagPreconditioner&) 
  { 
   BrokenCopy::broken_copy("MatrixBasedDiagPreconditioner");
  } 
 
 /// Broken assignment operator
 void operator=(const MatrixBasedDiagPreconditioner&) 
  {
   BrokenCopy::broken_assign("MatrixBasedDiagPreconditioner");
  }

  /// Apply preconditioner to z, i.e. z=D^-1 
  void preconditioner_solve(const Vector<double>&r, Vector<double> &z);

#ifdef OOMPH_HAS_MPI
  /// \short Apply preconditioner: Multiply r by the inverse of the diagonal.
  /// Specialisation for \c DistributedVector s
  void preconditioner_solve(const DistributedVector<double> &r,
                            DistributedVector<double>& z);
#endif

  /// \short Setup the preconditioner (store diagonal) from the fully
  /// assembled matrix. Problem pointer is ignored.
  void setup(Problem* problem_pt, DoubleMatrixBase* matrix_pt);

 private:

  /// Vector of inverse diagonal entries
  Vector<double> Inv_diag;
};





//=============================================================================
/// \short Class for a compressed-matrix coefficent (for either CC or CR
/// matrices). Contains the (row or column) index and value of a 
/// coefficient in a compressed row or column.
/// Currently only used in ILU(0) for CCDoubleMatrices to allow the 
/// coefficients in each compressed column [row] to be sorted by 
/// their row [column] index.
//=============================================================================
class CompressedMatrixCoefficient
{

  public:

 /// Constructor (no arguments)
 CompressedMatrixCoefficient(){}

 /// Constructor (takes the index and value as arguments)
 CompressedMatrixCoefficient(const unsigned& index, const double& value)
  {
   // store the index and value
   Index = index;
   Value = value;
  }

 /// Destructor (does nothing)
 ~CompressedMatrixCoefficient(){}

  /// Copy Constructor. Not Broken. Required for STL sort function. 
 CompressedMatrixCoefficient(const CompressedMatrixCoefficient& a) 
  { 
   Index = a.index();
   Value = a.value();   
  } 
 
 /// Assignment Operator. Not Broken. Required for STL sort function.
 void operator=(const CompressedMatrixCoefficient& a) 
  { 
   Index = a.index();
   Value = a.value();
  } 

 /// Less Than Operator (for the STL sort function)
 bool operator<(const CompressedMatrixCoefficient& a) const
  {
   return Index < a.index();
  }

 /// access function for the coefficient's (row or column) index
 unsigned& index() { return Index; }

 /// access function for the coefficient value
 double& value() { return Value; }

 /// \short Access function for the coefficient's (row or column_ index 
 /// (const version)
 unsigned index() const { return Index; }

 /// access function for the coefficient's value (const version)
 double value() const { return Value; }

  private:

 /// the row or column index of the compressed-matrix coefficient
 unsigned Index;

 /// the value of the compressed-matrix coefficient
 double Value;

};





//=============================================================================
/// ILU(0) Preconditioner
//=============================================================================
template <typename MATRIX> 
class ILUZeroPreconditioner : public Preconditioner
{
};


//=============================================================================
/// ILU(0) Preconditioner for matrices of CCDoubleMatrix Format
//=============================================================================
template <> 
class ILUZeroPreconditioner<CCDoubleMatrix> : public Preconditioner
{
 
 public :
  
  ///Constructor (empty)
  ILUZeroPreconditioner(){};
 
 ///Destructor (empty)
 ~ILUZeroPreconditioner(){};
 

 /// Broken copy constructor
 ILUZeroPreconditioner(const ILUZeroPreconditioner&) 
  { 
   BrokenCopy::broken_copy("ILUZeroPreconditioner");
  } 
 
 /// Broken assignment operator
 void operator=(const ILUZeroPreconditioner&) 
  {
   BrokenCopy::broken_assign("ILUZeroPreconditioner");
  }

 
 /// Apply preconditioner to r 
 void preconditioner_solve(const Vector<double>&r, Vector<double> &z);

 /// \short Setup the preconditioner (store diagonal) from the fully
 /// assembled matrix. Problem pointer is ignored.
 void setup(Problem* problem_pt, DoubleMatrixBase* matrix_pt);
 
  private:

 /// Column start for upper triangular matrix 
 Vector<unsigned> U_column_start;

 /// \short Row entry for the upper triangular matrix (each element of the 
 /// vector contains the row index and coefficient) 
 Vector<CompressedMatrixCoefficient> U_row_entry;

 /// Column start for lower triangular matrix 
 Vector<unsigned> L_column_start;

 /// \short Row entry for the lower triangular matrix (each element of the 
 /// vector contains the row index and coefficient)
 Vector<CompressedMatrixCoefficient> L_row_entry;

};


//=============================================================================
/// ILU(0) Preconditioner for matrices of CRDoubleMatrix Format
//=============================================================================
template <> 
class ILUZeroPreconditioner<CRDoubleMatrix> : public Preconditioner
{
 
 public :
  
  ///Constructor (empty)
  ILUZeroPreconditioner(){};
 

 /// Broken copy constructor
 ILUZeroPreconditioner(const ILUZeroPreconditioner&) 
  { 
   BrokenCopy::broken_copy("ILUZeroPreconditioner");
  } 
 
 /// Broken assignment operator
 void operator=(const ILUZeroPreconditioner&) 
  {
   BrokenCopy::broken_assign("ILUZeroPreconditioner");
  }
 
 ///Destructor (empty)
 ~ILUZeroPreconditioner(){};
 
 /// Apply preconditioner to r
 void preconditioner_solve(const Vector<double>&r, Vector<double> &z);
 
 /// \short Setup the preconditioner (store diagonal) from the fully
 /// assembled matrix. Problem pointer is ignored.
 void setup(Problem* problem_pt, DoubleMatrixBase* matrix_pt);
 
 
  private:


 /// Row start for upper triangular matrix 
 Vector<unsigned> U_row_start;

 /// Column index for upper triangular matrix 
 Vector<unsigned> U_column_index;

 /// Values for upper triangular matrix 
 Vector<double> U_value;
 
 /// Row start for lower triangular matrix 
 Vector<unsigned> L_row_start;

 /// Column index for lower triangular matrix 
 Vector<unsigned> L_column_index;

 /// Values for lower triangular matrix 
 Vector<double> L_value;
  
};


}

#endif
