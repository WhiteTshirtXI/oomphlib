//LIC// ====================================================================
//LIC// This file forms part of oomph-lib, the object-oriented, 
//LIC// multi-physics finite-element library, available 
//LIC// at http://www.oomph-lib.org.
//LIC// 
//LIC//           Version 0.85. June 9, 2008.
//LIC// 
//LIC// Copyright (C) 2006-2008 Matthias Heil and Andrew Hazel
//LIC// 
//LIC// This library is free software; you can redistribute it and/or
//LIC// modify it under the terms of the GNU Lesser General Public
//LIC// License as published by the Free Software Foundation; either
//LIC// version 2.1 of the License, or (at your option) any later version.
//LIC// 
//LIC// This library is distributed in the hope that it will be useful,
//LIC// but WITHOUT ANY WARRANTY; without even the implied warranty of
//LIC// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//LIC// Lesser General Public License for more details.
//LIC// 
//LIC// You should have received a copy of the GNU Lesser General Public
//LIC// License along with this library; if not, write to the Free Software
//LIC// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
//LIC// 02110-1301  USA.
//LIC// 
//LIC// The authors may be contacted at oomph-lib@maths.man.ac.uk.
//LIC// 
//LIC//====================================================================

//This header defines a class for linear solvers

//Include guards
#ifndef OOMPH_LINEAR_SOLVER_HEADER
#define OOMPH_LINEAR_SOLVER_HEADER


// Config header generated by autoconfig
#ifdef HAVE_CONFIG_H
  #include <oomph-lib-config.h>
#endif

#ifdef OOMPH_HAS_MPI
#include "mpi.h"
#endif

//oomph-lib headers
#include "Vector.h"
#include "matrices.h"

namespace oomph
{


// Forward declaration of problem class
class Problem;

//====================================================================
/// Base class for all linear solvers. This merely defines standard 
/// interfaces for linear solvers, so that different solvers can be
/// used in a clean and transparent manner. Note that LinearSolvers
/// are primarily used to solve the linear systems arising in 
/// oomph-lib's Newton iteration. Their primary solve function
/// therefore takes a pointer to the associated problem, construct its 
/// Jacobian matrix and residual vector, and return the solution
/// of the linear system formed by the Jacobian and the residual vector.
///  We also provide broken virtual interfaces
/// to a linear-algebra-type solve function in which the matrix
/// and the rhs can be specified, but this are not guaranteed to
/// implemented for all linear solvers (e.g. for frontal solvers).
//====================================================================
class LinearSolver
{
  protected:
 
 ///\short Boolean that indicates whether the matrix (or its factors, in
 ///the case of direct solver) should be stored so that the resolve function
 ///can be used.
 bool Enable_resolve;

 /// \short Boolean flag that indicates whether the time taken
 // for the solves should be documented
 bool Doc_time;
 
  public:

 /// Empty constructor, initialise the member data
 LinearSolver() : Enable_resolve(false), Doc_time(true) {}

 /// Broken copy constructor
 LinearSolver(const LinearSolver& dummy) 
  { 
   BrokenCopy::broken_copy("LinearSolver");
  } 
 
 /// Broken assignment operator
 void operator=(const LinearSolver&) 
  {
   BrokenCopy::broken_assign("LinearSolver");
  }
 
 /// Empty virtual destructor
 virtual ~LinearSolver() {}

 /// \short Access function for the Doc_times flag
 bool &doc_time() {return Doc_time;}

 /// \short Access function for the Doc_times flag (const version)
 const bool &doc_time() const {return Doc_time;}

 /// \short Boolean flag indicating if resolves are enabled
 bool resolve_is_enabled() const {return Enable_resolve;}

 /// \short Enable resolve (i.e. store matrix and/or LU decomposition, say)
 /// Virtual so it can be overloaded to perform additional tasks
 virtual void enable_resolve() {Enable_resolve=true;}

 /// \short Disable resolve (i.e. store matrix and/or LU decomposition, say)
 /// This function simply resets an internal flag. It's virtual so 
 /// it can be overloaded to perform additional tasks such as 
 /// cleaning up memory that is only required for the resolve.
 virtual void disable_resolve() {Enable_resolve=false;}

 /// \short Solver: Takes pointer to problem and returns the results vector
 /// which contains the solution of the linear system defined by
 /// the problem's fully assembled Jacobian and residual vector.
 virtual void solve(Problem* const &problem_pt, Vector<double> &result)=0;


 /// \short Linear-algebra-type solver: Takes pointer to a matrix and rhs 
 /// vector and returns the solution of the linear system. 
 virtual void solve(DoubleMatrixBase* const &matrix_pt,
                    const Vector<double> &rhs,
                    Vector<double> &result)
  {
   throw OomphLibError(
    "Linear-algebra-type solve function not implemented for this solver",
    "LinearSolver::solve()",
    OOMPH_EXCEPTION_LOCATION);
  }
 
#ifdef OOMPH_HAS_MPI
 /// \short Linear-algebra-type solver: Takes pointer to a matrix and rhs 
 /// vector and returns the solution of the linear system. 
 virtual void solve(DoubleMatrixBase* const &matrix_pt,
                    const DistributedVector<double> &rhs,
                    Vector<double> &solution)
  {
   throw OomphLibError(
    "Resolve function not implemented for this linear solver",
    "LinearSolver::solve()",
    OOMPH_EXCEPTION_LOCATION);
  }
 


 /// \short Linear-algebra-type solver: Takes pointer to a matrix and rhs 
 /// vector and returns the solution of the linear system. 
 virtual void solve(DoubleMatrixBase* const &matrix_pt,
                    const DistributedVector<double> &rhs,
                    DistributedVector<double> &solution)
  {
   throw OomphLibError(
    "Resolve function not implemented for this linear solver",
    "LinearSolver::solve()",
    OOMPH_EXCEPTION_LOCATION);
  }
#endif

 /// \short Resolve the system defined by the last assembled jacobian
 /// and the rhs vector. Solution is returned in the vector result.
 /// (broken virtual)
 virtual void resolve(const Vector<double> &rhs, Vector<double> &result)
  {
   throw OomphLibError(
    "Resolve function not implemented for this linear solver",
    "LinearSolver::resolve()",
    OOMPH_EXCEPTION_LOCATION);
  }

#ifdef OOMPH_HAS_MPI
 /// \short Resolve the system defined by the last assembled jacobian
 /// and the rhs vector. Solution is returned in the vector result.
 /// (broken virtual)
 virtual void resolve(const DistributedVector<double> &rhs,
                      Vector<double> &solution)
  {
   throw OomphLibError(
    "Resolve function not implemented for this linear solver",
    "LinearSolver::resolve()",
    OOMPH_EXCEPTION_LOCATION);
  }

 /// \short Resolve the system defined by the last assembled jacobian
 /// and the rhs vector. Solution is returned in the vector result.
 /// (broken virtual)
 virtual void resolve(const DistributedVector<double> &rhs,
                      DistributedVector<double> &solution)
  {
   throw OomphLibError(
    "Resolve function not implemented for this linear solver",
    "LinearSolver::resolve()",
    OOMPH_EXCEPTION_LOCATION);
  }
#endif

 /// \short Empty virtual function that can be overloaded in specific
 /// linear solvers to clean up any memory that may have been
 /// allocated (e.g. when preparing for a re-solve).
 virtual void clean_up_memory() {}
 
 ///  \short returns the time taken to assemble the Jacobian matrix and 
 /// residual vector (needs to be overloaded for each solver)
 virtual double jacobian_setup_time()
  {
   throw OomphLibError(
    "jacobian_setup_time has not been implemented for this linear solver",
    "LinearSolver::jacobian_setup_time()",
    OOMPH_EXCEPTION_LOCATION);
   return 0;
  }

 /// \short return the time taken to solve the linear system (needs to be 
 /// overloaded for each linear solver)
 virtual double linear_solver_solution_time()
  {
   throw OomphLibError(
    "linear_solver_solution_time has not been implemented for this linear solver",
    "LinearSolver::linear_solver_solution_time()",
    OOMPH_EXCEPTION_LOCATION);
   return 0;
  }

};

//====================================================================
/// \short Dense LU decomposition-based solve of full assembled linear system
/// VERY inefficient but useful to illustrate the principle.
//====================================================================
class DenseLU : public LinearSolver
{
 ///The DenseDoubleMatrix class is a friend
 friend class DenseDoubleMatrix;
 
  public:

 /// Constructor, initialise storage
 DenseLU() : Jacobian_setup_time(0.0),
  Solution_time(0.0), 
  Sign_of_determinant_of_matrix(0),
  Index(0), LU_factors(0), N_dof(0)
  {
   // Shut up!
   Doc_time=false;
  }

 /// Broken copy constructor
 DenseLU(const DenseLU& dummy)
  { 
   BrokenCopy::broken_copy("DenseLU");
  } 
 
 /// Broken assignment operator
 void operator=(const DenseLU&) 
  {
   BrokenCopy::broken_assign("DenseLU");
  }

 /// Destructor, clean up the stored LU factors
 ~DenseLU() {clean_up_memory();}

 /// \short Solver: Takes pointer to problem and returns the results Vector
 /// which contains the solution of the linear system defined by
 /// the problem's fully assembled Jacobian and residual Vector.
 void solve(Problem* const &problem_pt, Vector<double> &result);

 /// \short Linear-algebra-type solver: Takes pointer to a matrix and rhs 
 /// vector and returns the solution of the linear system.
 void solve(DoubleMatrixBase* const &matrix_pt,
            const Vector<double> &rhs,
            Vector<double> &result);

 ///  \short returns the time taken to assemble the jacobian matrix and 
 /// residual vector
 double jacobian_setup_time()
  {
   return Jacobian_setup_time;
  }

 /// \short return the time taken to solve the linear system (needs to be 
 /// overloaded for each linear solver)
 virtual double linear_solver_solution_time()
  {
   return Solution_time;
  }

  protected:

 /// Perform the LU decomposition of the matrix
 void factorise(DoubleMatrixBase* const &matrix_pt);

 /// Do the backsubstitution step to solve the system LU result = rhs
 void backsub(const Vector<double> &rhs,
              Vector<double> &result);

 /// Clean up the stored LU factors
 void clean_up_memory();

 /// Jacobian setup time
 double Jacobian_setup_time;
 
 /// Solution time
 double Solution_time;

 /// \short Sign of the determinant of the matrix 
 /// (obtained during the LU decomposition)
 int Sign_of_determinant_of_matrix;
 
  private:

 /// Pointer to storage for the index of permutations in the LU solve
 long* Index;
 
 /// Pointer to storage for the LU decomposition
 double* LU_factors;

 /// The number of unknowns in the linear system
 unsigned long N_dof;

};

//====================================================================
/// \short Dense LU decomposition-based solve of linear system
/// assembled via finite differencing of the residuals Vector.
/// Even more inefficient than DenseLU but excellent sanity check!
//====================================================================
class FD_LU : public DenseLU
{
  public:

 /// Constructor: empty
 FD_LU() : DenseLU() {}

 /// Broken copy constructor
 FD_LU(const FD_LU& dummy) 
  { 
   BrokenCopy::broken_copy("FD_LU");
  } 
 
 /// Broken assignment operator
 void operator=(const FD_LU&) 
  {
   BrokenCopy::broken_assign("FD_LU");
  }

 /// \short Solver: Takes pointer to problem and returns the results Vector
 /// which contains the solution of the linear system defined by
 /// the problem's residual Vector (Jacobian computed by FD approx.)
 void solve(Problem* const &problem_pt, Vector<double> &result);

 /// \short Linear-algebra-type solver: Takes pointer to a matrix and rhs 
 /// vector and returns the solution of the linear system. Problem pointer 
 /// defaults to NULL and can be omitted in linear-algebra-type solves in 
 /// which the preconditioner doesn't (mustn't!) require a pointer to an
 /// associated Problem. (broken virtual)
 void solve(DoubleMatrixBase* const &matrix_pt,
            const Vector<double> &rhs,
            Vector<double> &result)
  {DenseLU::solve(matrix_pt,rhs,result);}


};





//====================================================================
/// \short SuperLU solver: Wrapper to Demmel, Eistenstat, Gilbert,
/// Li & Liu's serial SuperLU solver.
/// See http://crd.lbl.gov/~xiaoye/SuperLU/
//====================================================================
class SuperLU : public LinearSolver
{
 //The column and row compressed double matrices are friends
 friend class CRDoubleMatrix;
 friend class CCDoubleMatrix;

  public:

 /// Constructor: Use compressed row version and no doc by default
 SuperLU() :  F_factors(0)
  {
   Compressed_row_flag=true;
   Doc_stats=false;
   Suppress_solve=false;
   Sign_of_determinant_of_matrix=0;
   N_dof=0;
  }

 /// Broken copy constructor
 SuperLU(const SuperLU& dummy) 
  { 
   BrokenCopy::broken_copy("SuperLU");
  } 
 
 /// Broken assignment operator
 void operator=(const SuperLU&) 
  {
   BrokenCopy::broken_assign("SuperLU");
  }

 ///Destructor, clean up the stored matrices
 ~SuperLU()  {clean_up_memory();}
 
 /// Access function to compressed row flag
 bool& compressed_row_flag() {return Compressed_row_flag;}
 
 /// Overload disable resolve so that it cleans up memory too
 void disable_resolve()
  {
   LinearSolver::disable_resolve();
   clean_up_memory();
  }
 
 /// \short Solver: Takes pointer to problem and returns the results Vector
 /// which contains the solution of the linear system defined by
 /// the problem's fully assembled Jacobian and residual Vector.
 void solve(Problem* const &problem_pt, Vector<double> &result);


 /// \short Linear-algebra-type solver: Takes pointer to a matrix and rhs 
 /// vector and returns the solution of the linear system. Problem pointer 
 /// defaults to NULL and can be omitted.
 void solve(DoubleMatrixBase* const &matrix_pt,
            const Vector<double> &rhs,
            Vector<double> &result);
 
 /// \short Resolve the system defined by the last assembled jacobian
 /// and the specified rhs vector. Solution is returned in the vector result
 void resolve(const Vector<double> &rhs, Vector<double> &result);

 /// Return the doc_stats flag
 bool& doc_stats() {return Doc_stats;}

 /// \short Return the flag that decides if we're actually solving the
 /// system or just assembling the Jacobian and the rhs.
 /// (Used only for timing runs, obviously)
 bool& suppress_solve() {return Suppress_solve;}

 /// \short returns the time taken to assemble the jacobian matrix and 
 /// residual vector
 double jacobian_setup_time()
  {
   return Jacobian_setup_time;
  }

 /// \short return the time taken to solve the linear system (needs to be 
 /// overloaded for each linear solver)
 virtual double linear_solver_solution_time()
  {
   return Solution_time;
  }

  protected:

 /// Do the factorisation stage
 void factorise(DoubleMatrixBase* const &matrix_pt);
  
 /// Do the backsubstitution for SuperLU solver
 void backsub(const Vector<double> &rhs,
              Vector<double> &result);
 
 /// Clean up the memory allocated by the SuperLU solver
 void clean_up_memory();

  private:

 /// Storage for the LU factors as required by SuperLU
 void *F_factors;

 /// Info flag for the SuperLU solver
 int Info;

 /// The number of unknowns in the linear system
 unsigned long N_dof;
 
 /// Sign of the determinant of the matrix
 int Sign_of_determinant_of_matrix;

 /// Jacobian setup time
 double Jacobian_setup_time;

 /// Solution time
 double Solution_time;
 
 /// Use compressed row version?
 bool Compressed_row_flag;

 /// Doc stats?
 bool Doc_stats;

 /// Suppress solve?
 bool Suppress_solve;


};

#ifdef OOMPH_HAS_MPI

//====================================================================
/// \short SuperLU_dist_global_matrix solver: 
/// Wrapper to Demmel, Eistenstat, Gilbert,
/// Li & Liu's distributed SuperLU solver, either operating on the
/// global matrix (i.e. the entire matrix is stored on each processor)
/// or on blocks of matrix rows that are held on the various processors.
/// See http://crd.lbl.gov/~xiaoye/SuperLU/
//====================================================================
class SuperLU_dist : public LinearSolver
{
  public:

 /// Constructor: By default we use the distributed memory version
 /// in which each processor only certain blocks of rows. 
 /// No doc by default
 SuperLU_dist()
  {
   Store_global_matrix=false;
   Doc_stats=false;
   Suppress_solve=false;
   Delete_matrix=false;
   Solver_data_pt=0;
   
   //First attempt at number of rows for the process grid
   int nprow=int(sqrt(double(MPI_Helpers::Nproc)));
   
   // Does this evenly divide the processor grid?
   while (nprow>1)
    {
     if (MPI_Helpers::Nproc%nprow==0) break;
     nprow-=1;
    }
   
   /// Number of rows/columns for process grid
   Nprow=nprow;
   Npcol=MPI_Helpers::Nproc/Nprow;
  }

 /// \short Solver: Takes pointer to problem and returns the results Vector
 /// which contains the solution of the linear system defined by
 /// the problem's fully assembled Jacobian and residual Vector.
 void solve(Problem* const &problem_pt, Vector<double> &result);

 /// \short Linear-algebra-type solver: Takes pointer to a matrix and rhs 
 /// vector and returns the solution of the linear system. 
 void solve(DoubleMatrixBase* const &matrix_pt,
            Vector<double> const &rhs,
            Vector<double> &result);


 /// Return the doc_stats flag
 bool& doc_stats() {return Doc_stats;}

 /// \short Return the flag that decides if each processor stores the global
 ///  matrix or only a subset of its rows
 bool& store_global_matrix() {return Store_global_matrix;}

 /// \short Return the flag that decides if we're actually solving the
 /// system or just assembling the Jacobian and the rhs.
 /// (Used only for timing runs, obviously)
 bool& suppress_solve() {return Suppress_solve;}

  private:

 /// Storage for the LU factors and other data required by SuperLU
 void *Solver_data_pt;

 /// Number of rows for the process grid 
 int Nprow;

 /// Number of columns for the process grid
 int Npcol;

 /// Doc stats?
 bool Doc_stats;

 /// Store global matrix or distributed blocks?
 bool Store_global_matrix;

 /// Suppress solve?
 bool Suppress_solve;

 /// \short SuperLU_dist needs its own copy of the input matrix, 
 /// therefore a copy must be made if any matrix passed to this
 /// solver is to be preserved. If the input matrix can be deleted
 /// this flag can be set to true to reduce the amount of memory used.
 bool Delete_matrix;

};

#endif

}

#endif
