//LIC// ====================================================================
//LIC// This file forms part of oomph-lib, the object-oriented, 
//LIC// multi-physics finite-element library, available 
//LIC// at http://www.oomph-lib.org.
//LIC// 
//LIC//           Version 0.85. June 9, 2008.
//LIC// 
//LIC// Copyright (C) 2006-2008 Matthias Heil and Andrew Hazel
//LIC// 
//LIC// This library is free software; you can redistribute it and/or
//LIC// modify it under the terms of the GNU Lesser General Public
//LIC// License as published by the Free Software Foundation; either
//LIC// version 2.1 of the License, or (at your option) any later version.
//LIC// 
//LIC// This library is distributed in the hope that it will be useful,
//LIC// but WITHOUT ANY WARRANTY; without even the implied warranty of
//LIC// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//LIC// Lesser General Public License for more details.
//LIC// 
//LIC// You should have received a copy of the GNU Lesser General Public
//LIC// License along with this library; if not, write to the Free Software
//LIC// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
//LIC// 02110-1301  USA.
//LIC// 
//LIC// The authors may be contacted at oomph-lib@maths.man.ac.uk.
//LIC// 
//LIC//====================================================================

//Include guards
#ifndef OOMPH_GENERAL_BLOCK_PRECONDITIONERS
#define OOMPH_GENERAL_BLOCK_PRECONDITIONERS


// Config header generated by autoconfig
#ifdef HAVE_CONFIG_H
  #include <oomph-lib-config.h>
#endif

// c++ include
#include<list>

// oomph-lib includes
#include "matrices.h"
#include "mesh.h"
#include "problem.h"
#include "block_preconditioner.h"
#include "SuperLU_preconditioner.h"

namespace oomph
{


//=============================================================================
/// Block diagonal preconditioner. By default SuperLU is used to solve the 
/// subsidiary systems, but other preconditioners can be used by setting then 
/// using passing a pointer to a function of type SubsidiaryPreconditionerFctPt
/// to the method subsidiary_preconditioner_function_pt().
//=============================================================================
template<typename MATRIX> 
class BlockDiagonalPreconditioner : public BlockPreconditioner<MATRIX>
{
 
 public :
  
  /// \short typefed for a function that allows other preconditioners to be
  /// emplyed to solve the subsidiary linear systems. \n
  /// The function should return a pointer to the requred subsidiary
  /// preconditioner generated using new. This preconditioner is responsible
  /// for the destruction of the subsidiary preconditioners.
  typedef Preconditioner* (*SubsidiaryPreconditionerFctPt)();
 
  /// constructor - when the preconditioner is used as a master preconditioner
  BlockDiagonalPreconditioner() : BlockPreconditioner<MATRIX>()
  {
   // null the subsidiary preconditioner function pointer
   Subsidiary_preconditioner_function_pt = 0;
  }
 
 /// Destructor - delete the preconditioner matrices
 ~BlockDiagonalPreconditioner()
  {
   this->clean_memory();
  }

 /// clean up the memory
 void clean_memory()
  {
   //number of block types
   unsigned n_block = Diagonal_block_preconditioner_pt.size();
   
   //delete diagonal blocks
   for (unsigned i = 0 ; i < n_block; i++)
    {
     delete Diagonal_block_preconditioner_pt[i];
     Diagonal_block_preconditioner_pt[i] = 0;
    }

   // clean up the block preconditioner
   this->clean_up_memory();
  }
 
 /// Broken copy constructor
 BlockDiagonalPreconditioner(const BlockDiagonalPreconditioner&) 
  { 
   BrokenCopy::broken_copy("BlockDiagonalPreconditioner");
  } 
 
 /// Broken assignment operator
 void operator=(const BlockDiagonalPreconditioner&) 
  {
   BrokenCopy::broken_assign("BlockDiagonalPreconditioner");
  }
 
 /// Apply preconditioner to r
 void preconditioner_solve(const DoubleVector &r, DoubleVector &z);
 
 /// \short Setup the preconditioner 
 void setup(Problem* problem_pt, DoubleMatrixBase* matrix_pt);
 
 /// access function to set the subsidiary preconditioner function.
 void set_subsidiary_preconditioner_function
  (SubsidiaryPreconditionerFctPt sub_prec_fn)
  {
   Subsidiary_preconditioner_function_pt = sub_prec_fn;
  };

  /// \short adds a mesh to this exact block preconditioner
  void add_mesh(Mesh* new_mesh_pt)
   {
    this->Mesh_pt.push_back(new_mesh_pt);
   }

 private :
  
  /// \short Vector of SuperLU preconditioner pointers for storing the 
  /// preconditioners for each diagonal block
  Vector<Preconditioner*> Diagonal_block_preconditioner_pt;   

 /// the SubisidaryPreconditionerFctPt 
 SubsidiaryPreconditionerFctPt Subsidiary_preconditioner_function_pt;
};



///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////



//=============================================================================
/// Exact block preconditioner - block preconditioner assembled from all blocks
/// associated with the preconditioner and solved by SuperLU.
//=============================================================================
template<typename MATRIX> 
class ExactBlockPreconditioner : public BlockPreconditioner<MATRIX>
{
 
 public :
  
  /// constructor - when the preconditioner is used as a master preconditioner
  ExactBlockPreconditioner() : BlockPreconditioner<MATRIX>()
  {}

  /// Destructor - does nothing
  ~ExactBlockPreconditioner(){}
  
  /// Broken copy constructor
  ExactBlockPreconditioner(const ExactBlockPreconditioner&) 
   { 
    BrokenCopy::broken_copy("ExactBlockPreconditioner");
   } 
  
  /// Broken assignment operator
  void operator=(const ExactBlockPreconditioner&) 
   {
    BrokenCopy::broken_assign("ExactBlockPreconditioner");
   }
  
  /// Apply preconditioner to r
  void preconditioner_solve(const DoubleVector &r, DoubleVector &z);
  
  /// \short Setup the preconditioner 
  void setup(Problem* problem_pt, DoubleMatrixBase* matrix_pt);
    
  /// \short adds a mesh to this exact block preconditioner
  void add_mesh(Mesh* new_mesh_pt)
   {
    this->Mesh_pt.push_back(new_mesh_pt);
   }
  
  
  private :
   
   /// \short Vector of SuperLU preconditioner pointers for storing the 
   /// preconditioners for each diagonal block
#ifdef OOMPH_HAS_MPI
  SuperLUDistPreconditioner Exact_block_preconditioner;
#else
  SuperLUPreconditioner Exact_block_preconditioner;   
#endif
};




//============================================================================
/// setup for the block diagonal preconditioner
//============================================================================
 template<typename MATRIX> 
 void BlockDiagonalPreconditioner<MATRIX>::setup(Problem* problem_pt, 
                                                 DoubleMatrixBase* matrix_pt)
 {
  // clean the memory
  this->clean_memory();

  //setup the blocks look up schemes
  this->block_setup(problem_pt,matrix_pt);
  
  // number of types of degree of freedom
  unsigned ndof_types = this->ndof_types();

  // Set the diagonal elements of required block to true for block diagonal
  // preconditioner
  DenseMatrix<bool> required_blocks(ndof_types,ndof_types,false); 
  for (unsigned i = 0; i < ndof_types; i++)
   {
    required_blocks(i,i) = true;
   }

  // Need to recast here -- input type is determined by specs in
  // base class.
  MATRIX* cast_matrix_pt=dynamic_cast<MATRIX*>(matrix_pt);
  
#ifdef PARANOID
  if (cast_matrix_pt==0)
   {
    throw OomphLibError("Wasn't able to cast matrix to specific type.",
                        "BlockDiagonalPreconditioner::setup()",
                        OOMPH_EXCEPTION_LOCATION);
   }
#endif

  DenseMatrix<MATRIX* > block_matrix_pt(ndof_types,ndof_types,0);

  // Get pointers to the blocks
  this->get_blocks(cast_matrix_pt, required_blocks, block_matrix_pt);

  // LU-decompose the blocks. Now we're ready to apply the preconditioner
  // by back-substitution.
  Diagonal_block_preconditioner_pt.resize(ndof_types);
  for (unsigned i=0;i<ndof_types;i++)
   {
    if (Subsidiary_preconditioner_function_pt == 0)
     {
#ifdef OOMPH_HAS_MPI
      if (Distribution_pt->communicator_pt()->nproc() > 1)
       {
        Diagonal_block_preconditioner_pt[i] = new SuperLUDistPreconditioner;
       }
      else
       {
        Diagonal_block_preconditioner_pt[i] = new SuperLUPreconditioner;
       }
#else
      Diagonal_block_preconditioner_pt[i] = new SuperLUPreconditioner;
#endif
     }
    else
     {
      Diagonal_block_preconditioner_pt[i] = 
       (*Subsidiary_preconditioner_function_pt)();
     }
    Diagonal_block_preconditioner_pt[i]
     ->setup(problem_pt,block_matrix_pt(i,i));
    delete block_matrix_pt(i,i);
    block_matrix_pt(i,i) = 0;
   }
 }
 
//=============================================================================
/// Preconditioner solve for the block diagonal preconditioner
//=============================================================================
 template<typename MATRIX> 
 void BlockDiagonalPreconditioner<MATRIX>::preconditioner_solve(
  const DoubleVector& r, DoubleVector& z)
 {
    // Cache umber of block types
  const unsigned n_block = this->nblock_types();

  // vector of vectors for each section of residual vector
  Vector<DoubleVector> block_r;
  
  // rearrange the vector r into the vector of block vectors block_r
  this->get_block_vectors(r,block_r);
  
  // if the solution vector is not setup then build it
  if (!z.distribution_setup())
   {
    z.rebuild(this->distribution_pt());
   }

  // vector of vectors for the solution block vectors
  Vector<DoubleVector> block_z(n_block);

  // solve each diagonal block
  for (unsigned i = 0; i < n_block; i++)
   {
    Diagonal_block_preconditioner_pt[i]->preconditioner_solve(block_r[i],
                                                              block_z[i]);
   }

  // copy solution in block vectors block_r back to z
  this->return_block_vectors(block_z,z);
 }
 
 

////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////



//=============================================================================
/// Setup for the block diagonal preconditioner
//=============================================================================
 template<typename MATRIX> 
 void ExactBlockPreconditioner<MATRIX>::setup(Problem* problem_pt, 
                                              DoubleMatrixBase* matrix_pt)
 {
  //setup the blocks look up schemes
  this->block_setup(problem_pt,matrix_pt);

  // get the number of DOF types
  unsigned ndof_types = this->ndof_types();

  // Set the diagonal elements of required block to true for block diagonal
  // preconditioner
  DenseMatrix<bool> required_blocks(ndof_types,
                                    ndof_types,true); 

  // Need to recast here -- input type is determined by specs in
  // base class.
  MATRIX* cast_matrix_pt=dynamic_cast<MATRIX*>(matrix_pt);
  
#ifdef PARANOID
  if (cast_matrix_pt==0)
   {
    throw OomphLibError("Wasn't able to cast matrix to specific type.",
                        "BlockDiagonalPreconditioner::setup()",
                        OOMPH_EXCEPTION_LOCATION);
   }
#endif

  DenseMatrix<MATRIX* > block_matrix_pt(ndof_types,
                                        ndof_types,0);

  // Get pointers to the blocks
  this->get_blocks(cast_matrix_pt, required_blocks, block_matrix_pt);

  // Build the preconditioner matrix
  MATRIX* exact_block_matrix_pt = 0;
  this->build_preconditioner_matrix(block_matrix_pt,exact_block_matrix_pt);

  // need to delete the matrix of block matrices
  for (unsigned i = 0; i < ndof_types; i++)
   {
    for (unsigned j = 0; j < ndof_types; j++)
     {
      delete block_matrix_pt(i,j);
      block_matrix_pt(i,j) = 0;
     }
   }

  // setup lu preconditioner for the exact block preconditioner matrix
  Exact_block_preconditioner.setup(problem_pt,exact_block_matrix_pt);

  // delete the exact block preconditioner matrix
  delete exact_block_matrix_pt;
 }
 
//=============================================================================
/// Preconditioner solve for the block diagonal preconditioner
//=============================================================================
 template<typename MATRIX> 
 void ExactBlockPreconditioner<MATRIX>::preconditioner_solve(
  const DoubleVector& r, DoubleVector& z)
 {

  // get  the block ordered components of the r vector for this preconditioner
  DoubleVector block_order_r;
  this->get_block_ordered_preconditioner_vector(r,block_order_r);

  // vector for solution
  DoubleVector block_order_z;

  // apply the preconditioner
  Exact_block_preconditioner.preconditioner_solve(block_order_r,block_order_z);

  // copy solution back to z vector
  this->return_block_ordered_preconditioner_vector(block_order_z,z);
 }
}
#endif
