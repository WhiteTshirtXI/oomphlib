//LIC// ====================================================================
//LIC// This file forms part of oomph-lib, the object-oriented, 
//LIC// multi-physics finite-element library, available 
//LIC// at http://www.oomph-lib.org.
//LIC// 
//LIC//           Version 0.85. June 9, 2008.
//LIC// 
//LIC// Copyright (C) 2006-2008 Matthias Heil and Andrew Hazel
//LIC// 
//LIC// This library is free software; you can redistribute it and/or
//LIC// modify it under the terms of the GNU Lesser General Public
//LIC// License as published by the Free Software Foundation; either
//LIC// version 2.1 of the License, or (at your option) any later version.
//LIC// 
//LIC// This library is distributed in the hope that it will be useful,
//LIC// but WITHOUT ANY WARRANTY; without even the implied warranty of
//LIC// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//LIC// Lesser General Public License for more details.
//LIC// 
//LIC// You should have received a copy of the GNU Lesser General Public
//LIC// License along with this library; if not, write to the Free Software
//LIC// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
//LIC// 02110-1301  USA.
//LIC// 
//LIC// The authors may be contacted at oomph-lib@maths.man.ac.uk.
//LIC// 
//LIC//====================================================================
//The actual solve functions for dense LU linear solvers.

// Config header generated by autoconfig
#ifdef HAVE_CONFIG_H
  #include <oomph-lib-config.h>
#endif

#ifdef OOMPH_HAS_MPI
#include "mpi.h"
#endif

//oomph-lib includes
#include "Vector.h"
#include "linear_solver.h"
#include "matrices.h"
#include "problem.h"


namespace oomph
{


//==================================================================
/// Solver: Takes pointer to problem and returns the results Vector
/// which contains the solution of the linear system defined by
/// the problem's fully assembled Jacobian and residual Vector.
//==================================================================
void DenseLU::solve(Problem* const &problem_pt, Vector<double> &result)
{
 //Initialise timer
 clock_t t_start = clock();
 
 //Find # of degrees of freedom (variables)
 const unsigned long n_dof = problem_pt->ndof();

 //Allocate storage for the residuals vector and the jacobian matrix
 Vector<double> residuals(n_dof);
 DenseDoubleMatrix jacobian(n_dof);
 
 {
  // initialise timer
  clock_t t_start = clock();
  
  //Get the full jacobian and residuals of the problem
  problem_pt->get_jacobian(residuals,jacobian);
  
  // compute jacobian setup time
  clock_t t_end = clock();
  Jacobian_setup_time = double(t_end-t_start)/CLOCKS_PER_SEC;

  //Report the time
  if(Doc_time)
   {
    oomph_info << std::endl << "CPU for setup of Dense Jacobian [sec]: " 
               << Jacobian_setup_time << std::endl;
   }
 }

 //Solve by dense LU decomposition VERY INEFFICIENT!
 solve(&jacobian,residuals,result);
 
 //Set the sign of the determinant of the jacobian
 problem_pt->sign_of_jacobian() = Sign_of_determinant_of_matrix;
 
 // Finalise/doc timings
 clock_t t_end = clock();
 double total_time=double(t_end-t_start)/CLOCKS_PER_SEC;
 if(Doc_time)
  {
   oomph_info << "CPU for DenseLU LinearSolver [sec]: " 
              << total_time << std::endl << std::endl;
  }
}


//=======================================================================
/// Delete the storage that has been allocated for the LU factors, if
/// the matrix data is not itself being overwritten.
//======================================================================
void DenseLU::clean_up_memory()
{
 //Clean up the LU factor storage, if it has been allocated
 //N.B. we don't need to check the index storage as well.
 if(LU_factors!=0)
  {
   //Delete the pointer to the LU factors
   delete[] LU_factors;
   //Null out the vector
   LU_factors = 0;
   //Delete the pointer to the Index
   delete[] Index;
   //Null out
   Index=0;
   //Reset the number of unknowns to zero
   N_dof=0;
  }
}

//=======================================================================
/// LU decompose the matrix. The algorithm is adapted from that in
/// "Numerical recipes in C" by Press et al.
//======================================================================
void DenseLU::factorise(DoubleMatrixBase* const &matrix_pt)
{
 //Set the number of unknowns
 const unsigned long n = matrix_pt->nrow();
 
#ifdef PARANOID
 unsigned long m = matrix_pt->ncol();
 // Check Matrix is square
 if (n!=m)
  {
   throw OomphLibError(
    "Cannot LU decompose a non-square matrix",
    "DenseLU::factorise()",
    OOMPH_EXCEPTION_LOCATION);
   }
#endif 

 //Small constant
 const double TINY=1.0e-20;

 //Vector vv stores the implicit scaling of each row
 Vector<double> vv(n);

 //Integer to store the sign that must multiply the determinant as
 //a consequence of the row/column interchanges
 int signature = 1;

 //Loop over rows to get implicit scaling information
 for(unsigned long i=0;i<n;i++)
  {
   double big=0.0;
   for(unsigned long j=0;j<n;j++)
    {
     double temp = std::abs((*matrix_pt)(i,j));
     if(temp > big) big = temp;
    }
   if(big==0.0) 
    {
     throw OomphLibError("Singular Matrix",
                         "DenseLU::solve()",
                         OOMPH_EXCEPTION_LOCATION);
    }
   //Save the scaling
   vv[i] = 1.0/big;
  }

 //Firsly, we shall delete any previous LU storage.
 //If the user calls this function twice without changing the matrix
 //then it is their own inefficiency, not ours (this time).
 clean_up_memory();

 //Allocate storage for the LU factors, the index and store
 //the number of unknowns
 LU_factors = new double[n*n];
 Index = new long[n];
 N_dof = n;

 //Now we know that memory has been allocated, copy over
 //the matrix values
 unsigned count=0;
 for(unsigned long i=0;i<n;i++)
  {
   for(unsigned long j=0;j<n;j++)
    {
     LU_factors[count] = (*matrix_pt)(i,j);
     ++count;
    }
  }

 //Loop over columns
 for(unsigned long j=0;j<n;j++)
  {
   //Initialise imax
   unsigned long imax=0;

   for(unsigned long i=0;i<j;i++)
    {
     double sum = LU_factors[n*i+j];
     for(unsigned long k=0;k<i;k++) 
      {
       sum -= LU_factors[n*i+k]*LU_factors[n*k+j];
      }
     LU_factors[n*i+j] = sum;
    }

   //Initialise search for largest pivot element
   double big=0.0;
   for(unsigned long i=j;i<n;i++)
    {
     double sum = LU_factors[n*i+j];
     for(unsigned long k=0;k<j;k++) 
      {
       sum -= LU_factors[n*i+k]*LU_factors[n*k+j];
      }
     LU_factors[n*i+j] = sum;
     //Set temporary
     double temp = vv[i]*std::abs(sum);
     if(temp >= big)
      {
       big = temp;
       imax = i;
      }
    }

   //Test to see if we need to interchange rows
   if(j != imax)
    {
     for(unsigned long k=0;k<n;k++)
      {
       double temp = LU_factors[n*imax+k];
       LU_factors[n*imax+k] = LU_factors[n*j+k];
       LU_factors[n*j+k] = temp;
      }
     //Change the parity of signature
     signature = -signature;
     //Interchange scale factor
     vv[imax] = vv[j];
    }
   
   //Set the index
   Index[j] = imax;
   if(LU_factors[n*j+j] == 0.0) 
    {
     LU_factors[n*j+j] = TINY;
    }
   //Divide by pivot element
   if(j != n-1)
    {
     double temp = 1.0/LU_factors[n*j+j];
     for(unsigned long i=j+1;i<n;i++) 
      {
       LU_factors[n*i+j] *= temp;
      }
    }
  
  } //End of loop over columns

 
 //Now multiply all the diagonal terms together to get the determinant
 //Note that we need to use the mantissa, exponent formulation to
 //avoid underflow errors
 double determinant_mantissa=1.0;
 int determinant_exponent = 0, iexp;
 for(unsigned i=0; i<n; i++)
  {
   //Multiply by the next diagonal entry's mantissa
   //and return the exponent
   determinant_mantissa *= frexp(LU_factors[n*i+i], &iexp);
   //Add the new exponent to the current exponent
   determinant_exponent += iexp;
   /* normalise*/
   determinant_mantissa = frexp(determinant_mantissa,&iexp);
   determinant_exponent += iexp;
  }

 //Integer to store the sign of the determinant
 int sign = 0;
 //Find the sign of the determinant
 if(determinant_mantissa > 0.0) {sign = 1;}
 if(determinant_mantissa < 0.0) {sign = -1;}
 
 //Multiply the sign by the signature
 sign *= signature;
 
 //Return the sign of the determinant
 Sign_of_determinant_of_matrix = sign;
 }

//================================================================
/// Do the backsubstitution for the DenseLU solver. Again the 
/// algorithm is based on that from "Numerical recipes in C"
/// by Press et al.
//================================================================
void DenseLU::backsub(const Vector<double> &rhs,
                      Vector<double> &result)
{
 const unsigned long n = rhs.size();
#ifdef PARANOID
 if(N_dof != n)
   {
    throw OomphLibError(
     "RHS does not have the same dimension as the linear system",
     "DenseLU::backsub()",
     OOMPH_EXCEPTION_LOCATION);
   }
#endif

  //Copy the rhs vector into the result vector
 for(unsigned long i=0;i<n;++i) {result[i] = rhs[i];}
 
 unsigned long ii=0;
 for(unsigned long i=0;i<n;i++)
  {
   unsigned long ip = Index[i];
   double sum = result[ip];
   result[ip] = result[i];
   
   if(ii != 0)
    {
     for(unsigned long j=ii-1;j<i;j++) 
      {
       sum -= LU_factors[n*i+j]*result[j];
      }
    }
   else if(sum != 0.0)
    {
     ii = i+1;
    }
   result[i] = sum;
  }

 //Now do the back substitution
 for (long i=long(n)-1;i>=0;i--)
  {
   double sum = result[i];
   for(long j=i+1;j<long(n);j++) sum -= LU_factors[n*i+j]*result[j];
   result[i] = sum/LU_factors[n*i+i];
  }
}


 /// \short Linear-algebra-type solver: Takes pointer to a matrix and rhs 
 /// vector and returns the solution of the linear system. 
 void DenseLU::solve(DoubleMatrixBase* const &matrix_pt,
                     const Vector<double> &rhs,
                     Vector<double> &result)
 {
  // Time the solver 
  clock_t t_start = clock();

  factorise(matrix_pt);
  backsub(rhs,result);

  //Doc time for solver
  clock_t t_end = clock();
  
  Solution_time = double(t_end-t_start)/CLOCKS_PER_SEC;
  if(Doc_time)
   {
    oomph_info << "CPU for solve with DenseLU   [sec]: " 
               << Solution_time << std::endl;
   }

  //If we are not resolving then delete storage
  if(!Enable_resolve) {clean_up_memory();}
 }


//==================================================================
/// Solver: Takes pointer to problem and returns the results Vector
/// which contains the solution of the linear system defined by
/// the problem's residual Vector. (Jacobian assembled by FD).
//==================================================================
void FD_LU::solve(Problem* const &problem_pt, Vector<double> &result)
{
 //Initialise timer
 clock_t t_start = clock();
 

 //Find # of degrees of freedom
 unsigned long n_dof = problem_pt->ndof();

 //Allocate storage for the residuals vector and the jacobian matrix
 Vector<double> residuals(n_dof);
 DenseDoubleMatrix jacobian(n_dof);

 {
  // initialise timer
  clock_t t_start = clock();
  
  //Get the full jacobian by finite differencing)  VERY INEFFICIENT!
  problem_pt->get_fd_jacobian(residuals,jacobian);
  
  // compute jacobian setup time
  clock_t t_end = clock();
  Jacobian_setup_time = double(t_end-t_start)/CLOCKS_PER_SEC;

  //Report the time
  if(Doc_time)
   {
    oomph_info << std::endl << "CPU for setup of Dense Jacobian [sec]: " 
               << Jacobian_setup_time << std::endl;
   }
 }

 //Solve by dense LU decomposition (not efficient)
  solve(&jacobian,residuals,result);

  //Set the sign of the determinant of the jacobian
  problem_pt->sign_of_jacobian() = Sign_of_determinant_of_matrix;
  
  // Finalise/doc timings
  clock_t t_end = clock();
  double total_time=double(t_end-t_start)/CLOCKS_PER_SEC;
  if(Doc_time)
   {
    oomph_info << "CPU for FD DenseLU LinearSolver [sec]: " 
               << total_time << std::endl << std::endl;
   }
}


//===================================================================
// Interface to SuperLU wrapper
//===================================================================
extern "C"
{
 int superlu(int *, int *, int *, int *,
             double *, int *, int *,
             double *, int *,  int *, int *,
             void*, int *);
}

//===================================================================
///\short LU decompose the matrix addressed by matrix_pt by using
/// the SuperLU solver. The resulting matrix factors are stored 
/// internally.
//===================================================================
void SuperLU::factorise(DoubleMatrixBase* const &matrix_pt)
{
 //Find # of degrees of freedom (variables)
 int n = matrix_pt->nrow();
 
 //Check that we have a square matrix
#ifdef PARANOID
 int m = matrix_pt->ncol();
 if(n != m)
  {
   std::ostringstream error_message_stream;
   error_message_stream << "Can only solve for square matrices\n" 
                        << "N, M " << n << " " << m << std::endl;
   
   throw OomphLibError(error_message_stream.str(),
                       "SuperLU::factorise()",
                       OOMPH_EXCEPTION_LOCATION);
  }
#endif
 
 //Storage for the values, rows and column indices
 //required by SuplerLU
 double *value = 0;
 int *index=0, *start=0;
 
 //Integer used to represent compressed row or column format
 //Default compressed row
 int transpose = 0;
 
 //Number of non-zero entries in the matrix
 int nnz = 0;
 
 // Doc flag (convert to int for SuperLU)
 int doc = Doc_stats;
 
 //Is it a CR matrix
 if(dynamic_cast<CRDoubleMatrix*>(matrix_pt))
  {
   //Set the appropriate row flags
   Compressed_row_flag=true;
   transpose = 1;
   //Get a cast pointer to the matrix
   CRDoubleMatrix* CR_matrix_pt = dynamic_cast<CRDoubleMatrix*>(matrix_pt);
   
   //Now set the pointers to the interanally stored values
   //and indices
   nnz = CR_matrix_pt->nnz();
   value = CR_matrix_pt->value();
   index = CR_matrix_pt->column_index();
   start = CR_matrix_pt->row_start();
  }
 //Otherwise is it the compressed column version?
 else if(dynamic_cast<CCDoubleMatrix*>(matrix_pt))
  {
   //Set the compressed row flag to false
   Compressed_row_flag=false;
   //Get a cast pointer to the matrix
   CCDoubleMatrix* CC_matrix_pt = dynamic_cast<CCDoubleMatrix*>(matrix_pt);
   
   //Now set the pointers to the interanally stored values
   //and indices
   nnz = CC_matrix_pt->nnz();
   value = CC_matrix_pt->value();
   index = CC_matrix_pt->row_index();
   start = CC_matrix_pt->column_start();
  }
 //Otherwise throw and error
 else
  {
   throw OomphLibError("SuperLU only works with CR or CC Double matrices",
                       "SuperLU::factorise()",
                       OOMPH_EXCEPTION_LOCATION);
  }
 
 // Clean up any previous storage so that if this is called twice with
 // the same matrix, we don't get a memory leak
 clean_up_memory();
 
 //Perform the lu decompose phase (i=1)
 int i=1;
 Sign_of_determinant_of_matrix =  superlu(&i, &n, &nnz,  0,
                                          value, index, start,
                                          0, &n,  &transpose, &doc,
                                          &F_factors, &Info);

 //Set the number of degrees of freedom in the linear system
 N_dof = n;
}

//=========================================================================
/// \short Linear-algebra-type solver: Takes pointer to a matrix and rhs 
/// vector and returns the solution of the linear system. Problem pointer 
/// defaults to NULL and can be omitted.
//=========================================================================
void SuperLU::solve(DoubleMatrixBase* const &matrix_pt,
                    const Vector<double> &rhs,
                    Vector<double> &result)
{
 // Time solver
 clock_t t_start = clock();

 //Factorise the matrix
 factorise(matrix_pt);

 //Now do the back solve
 backsub(rhs,result);

//  unsigned n=result.size();
//  Vector<double> product(n);
//  matrix_pt->multiply(result,product);
//  double err_max=0.0;
//  double norm=0.0;
//  for (unsigned i=0;i<n;i++)
//   {
//    norm+=rhs[i]*rhs[i];
//    double err=fabs(product[i]-rhs[i]);
//    if (err>err_max) err_max=err;
//   }
//  oomph_info << "Max. error in SuperLU solver " 
//             << err_max << " " << sqrt(norm/double(n)) 
//             << std::endl; 
 

 // Doc time for solver
 clock_t t_end = clock();
 Solution_time = double(t_end-t_start)/CLOCKS_PER_SEC;
 if(Doc_time)
  {
   oomph_info << "CPU for solve with SuperLU   [sec]: " 
              << Solution_time << std::endl;
  }

 //If we are not storing the matrix, delete
 if(!Enable_resolve) {clean_up_memory();}
}

//==================================================================
/// Solver: Takes pointer to problem and returns the results Vector
/// which contains the solution of the linear system defined by
/// the problem's fully assembled Jacobian and residual Vector.
//==================================================================
void SuperLU::solve(Problem* const &problem_pt, Vector<double> &result)
{
 // Initialise timer
 clock_t t_start = clock();
 
 //Allocate storage for the residuals vector
 Vector<double> residuals(problem_pt->ndof());

 // Use the compressed row version?
 if(Compressed_row_flag)
  {
   // Initialise timer
   clock_t t_start = clock();

   //Get the sparse jacobian and residuals of the problem
   CRDoubleMatrix CR_jacobian;
   problem_pt->get_jacobian(residuals,CR_jacobian);

   // Doc time for setup
   clock_t t_end = clock();
   Jacobian_setup_time = double(t_end-t_start)/CLOCKS_PER_SEC;
   if(Doc_time)
    {
     oomph_info << std::endl << "CPU for setup of CR Jacobian [sec]: " 
                << Jacobian_setup_time << std::endl;
    }

   //Now call the linear algebra solve, if desired
   if(!Suppress_solve) {solve(&CR_jacobian,residuals,result);}
  }
 //Otherwise its the compressed column version
 else
  {
   // Initialise timer
   clock_t t_start = clock();
   
   //Get the sparse jacobian and residuals of the problem
   CCDoubleMatrix CC_jacobian;
   problem_pt->get_jacobian(residuals,CC_jacobian);

   // Doc time for setup
   clock_t t_end = clock();
   Jacobian_setup_time=double(t_end-t_start)/CLOCKS_PER_SEC;
   if(Doc_time)
    {
     oomph_info << "\nCPU for setup of CC Jacobian [sec]: " 
                <<  Jacobian_setup_time << std::endl;
    }

   //Now call the linear algebra solve, if desired
   if(!Suppress_solve) {solve(&CC_jacobian,residuals,result);}
  }

 //Set the sign of the jacobian 
 //(this is computed in the LU decomposition phase)
 problem_pt->sign_of_jacobian() = Sign_of_determinant_of_matrix;
 
 // Finalise/doc timings
 clock_t t_end = clock();
 double total_time=double(t_end-t_start)/CLOCKS_PER_SEC;
 if(Doc_time)
  {
   oomph_info << "CPU for SuperLU LinearSolver [sec]: " 
              << total_time << std::endl << std::endl;
  }
}


//===============================================================
/// Resolve the system for a given RHS
//===============================================================
void SuperLU::resolve(const Vector<double> &rhs, Vector<double> &result)
{
 //Check that a matrix has been factorised and stored
 if(F_factors==0)
  {
   throw OomphLibError("The matrix factors have not been stored",
                       "SuperLU::resolve()",
                       OOMPH_EXCEPTION_LOCATION);
  }

 
 //Now do the back substitution phase
 backsub(rhs,result);
}

//================================================================
/// Do the backsubstitution for SuperLU
//================================================================
void SuperLU::backsub(const Vector<double> &rhs,
                      Vector<double> &result)
{
 //Find the number of unknowns
 int n = rhs.size();

#ifdef PARANOID
 if(static_cast<int>(N_dof) != n)
  {
   throw OomphLibError(
    "RHS does not have the same dimension as the linear system",
    "SuperLU::backsub()",
    OOMPH_EXCEPTION_LOCATION);
  }
#endif

 /// RHS vector
 double* b=new double[n];
 
 // Copy the values across
 for(int i=0;i<n;i++) {b[i]=rhs[i];}
 
 //Number of RHSs
 int nrhs=1;

 //Cast the boolean flags to ints for SuperLU
 int transpose = Compressed_row_flag;
 int doc = Doc_stats;

 //Do the backsubsitition phase
 int i=2;
 superlu(&i, &n, 0,  &nrhs,
         0, 0, 0,
         b, &n,  &transpose, &doc,
         &F_factors, &Info);
 
 // Copy b into rhs vector
 for(int i=0;i<n;i++) {result[i]=b[i];}
 
 // Cleanup the storage for the rhs vector
 delete[] b;
}


//===============================================================
/// Clean up the memory allocated by the SuperLU solver
//===============================================================
void SuperLU::clean_up_memory()
{
 //If we have non-zero LU factors stored
 if(F_factors!=0)
  {
   //Clean up those factors
   int i=3; 
   int transpose = Compressed_row_flag;
   superlu(&i, 0, 0,  0, 0, 0, 0,
           0, 0, &transpose, 0,
           &F_factors, &Info);

   //Set the F_factors to zero
   F_factors=0;
   N_dof=0;
  }
}

#ifdef OOMPH_HAS_MPI

//===================================================================
// Interface to SuperLU_DIST wrapper
//===================================================================
extern "C"
{
 // Interface to distributed SuperLU solver where each processor 
 // holds the entire matrix
 void superlu_dist_global_matrix(int opt_flag, int n, int nnz, 
                                 double *values, int *row_index, 
                                 int *col_start, double *b, int nprow, 
                                 int npcol, int doc, void **data, int *info);
 
 // Interface to distributed SuperLU solver where each processor 
 // holds part of the matrix
 void superlu_dist_distributed_matrix(int opt_flag, int n, int nnz_local,
                                      int nrow_local, int first_row, 
                                      double *values, int *col_index, 
                                      int *row_start, double *b,
                                      int nprow, int npcol, 
                                      int doc, void **data, int *info);
}


//===================================================================
/// LU decompose the matrix addressed by matrix_pt using
/// the SuperLU_DIST solver. The resulting matrix factors are stored 
/// internally.
/// Note: if Delete_matrix_data is true the function 
/// matrix_pt->clean_up_memory() will be used to wipe the matrix data.
//===================================================================
void SuperLU_dist::factorise(DoubleMatrixBase* const &matrix_pt)
{
 
 //Check that we have a square matrix
#ifdef PARANOID
 int m = matrix_pt->ncol();
 int n = matrix_pt->nrow();
 if(n != m)
  {
   std::ostringstream error_message_stream;
   error_message_stream << "Can only solve for square matrices\n" 
                        << "N, M " << n << " " << m << std::endl;
   
   throw OomphLibError(error_message_stream.str(),
                       "SuperLU_dist::factorise()",
                       OOMPH_EXCEPTION_LOCATION);
  }
#endif

 // Make sure any existing factors are deleted
 clean_up_memory();
  
 // Doc (0/1) = (true/false)
 int doc = !Doc_stats;
 
 // Rset Info
 Info=0;

 // Is it a DistributedCRDoubleMatrix?
 if(dynamic_cast<DistributedCRDoubleMatrix*>(matrix_pt))
  {
   // Set flag so we know the rhs vector will be distributed
   Distributed_rhs = true;
   
   // Get a cast pointer to the matrix
   DistributedCRDoubleMatrix* dist_CR_matrix_pt
    = dynamic_cast<DistributedCRDoubleMatrix*>(matrix_pt);
   
   // Find the number of non-zero entries in the matrix
   const int nnz_local = int(dist_CR_matrix_pt->nnz());

   // Find # of degrees of freedom (variables)
   Ndof = int(dist_CR_matrix_pt->nrow());
   
   // Set the number of local degrees of freedom in the linear system
   Ndof_local = int(dist_CR_matrix_pt->nrow_local());
   
   // Store the local first row index 
   First_local_dof = int(dist_CR_matrix_pt->first_row());
   
   // Set up the pointers to the matrix.
   // NOTE: these arrays (accessed via value_pt, index_pt and
   // start_pt) may be modified by the SuperLU_DIST routines, and so 
   // a copy must be taken if the matrix is to be preserved.
   
   // Copy values
   Value_pt = new double[nnz_local];
   double* matrix_value_pt = dist_CR_matrix_pt->value();
   for(int i=0;i<nnz_local;i++) 
    {
     Value_pt[i] = matrix_value_pt[i];
    }
   
   // Copy column indices
   Index_pt = new int[nnz_local];
   int* matrix_index_pt = dist_CR_matrix_pt->column_index();
   for (int i=0; i<nnz_local; i++)
    {
     Index_pt[i] = matrix_index_pt[i];
    }
   
   // Copy row starts
   Start_pt = new int[Ndof_local+1];
   int* matrix_start_pt = dist_CR_matrix_pt->row_start();
   for (int i=0; i<=Ndof_local; i++)
    {
     Start_pt[i] = matrix_start_pt[i];
    }

   // Now delete the matrix if we are allowed
   if (Delete_matrix_data==true)
    {
     dist_CR_matrix_pt->clean_up_memory();
    }
   
   // Factorize
   superlu_dist_distributed_matrix(1, Ndof, nnz_local, Ndof_local, 
                                   First_local_dof, Value_pt, Index_pt, 
                                   Start_pt, 0, Nprow, Npcol, doc,
                                   &Solver_data_pt, &Info);
   
   // Set up Ndof_remote
   Ndof_remote.resize(MPI_Helpers::Nproc);
   MPI_Allgather(&Ndof_local, 1, MPI_INT, 
                 &Ndof_remote[0], 1, MPI_INT,
                 MPI_COMM_WORLD);
   
   // Record that data is stored
   Distributed_solve_data_allocated=true;
  }

 // Or is it a CRDoubleMatrix?
 else if(dynamic_cast<CRDoubleMatrix*>(matrix_pt))
  {
   // Get a cast pointer to the matrix
   CRDoubleMatrix* serial_matrix_pt = 
    dynamic_cast<CRDoubleMatrix*>(matrix_pt);
   
   // Set flag so we know the rhs vector won't be distributed
   Distributed_rhs = false;
   
   // Store # of degrees of freedom (variables)
   Ndof = int(serial_matrix_pt->nrow());
   
   // Construct a DistributionInfo with uniform distribution
   DistributionInfo distribution(MPI_COMM_WORLD, Ndof); 
   
   // Store the number of local degrees of freedom in the linear system
   Ndof_local = int(distribution.nrow_local());
   
   // Store the local first row
   First_local_dof = int(distribution.first_row());
   
   // Set up the pointers to the matrix.
   // NOTE: these arrays (accessed via value_pt, index_pt and
   // start_pt) may be modified by the SuperLU_DIST routines, and so 
   // a copy must be taken if the matrix is to be preserved.
   double* matrix_value_pt = serial_matrix_pt->value();
   int* matrix_index_pt = serial_matrix_pt->column_index();
   int* matrix_start_pt = serial_matrix_pt->row_start();
   
   // Find the local number of non-zero entries in the matrix
   const int nnz_local = matrix_start_pt[First_local_dof + Ndof_local]
    - matrix_start_pt[First_local_dof];
   
   // Find the index of the first entry in the matrix corresponding to
   // row number First_local_dof
   const int first_local_index = matrix_start_pt[First_local_dof];
   
   // Copy values
   Value_pt = new double[nnz_local]; 
   Vector<double> value_vec(nnz_local);
   for(int i=0;i<nnz_local;i++) 
    {
     Value_pt[i] = matrix_value_pt[first_local_index+i];
    }
   
   // Copy column indices
   Index_pt = new int[nnz_local];
   for (int i=0; i<nnz_local; i++)
    {
     Index_pt[i] = matrix_index_pt[first_local_index+i];
    }
   
   // Copy row starts
   Start_pt = new int[Ndof_local+1];
   for (int i=0; i<=Ndof_local; i++)
    {
     Start_pt[i] = matrix_start_pt[First_local_dof+i]-first_local_index;
    }
   
   // Now delete the matrix data if we are allowed
   if (Delete_matrix_data==true)
    {
     serial_matrix_pt->clean_up_memory();
    }
   
   // Factorize
   superlu_dist_distributed_matrix(1, Ndof, nnz_local, Ndof_local, 
                                   First_local_dof, Value_pt, Index_pt, 
                                   Start_pt, 0, Nprow, Npcol, doc, 
                                   &Solver_data_pt, &Info);
   
   // Set up Ndof_remote
   Ndof_remote.resize(MPI_Helpers::Nproc);
   for (int p=0; p<MPI_Helpers::Nproc; p++)
    {
     Ndof_remote[p] = distribution.nrow_local(p);
    }
   
   // Record that data is stored
   Distributed_solve_data_allocated=true;
  } 
 
 // Or is it a CCDoubleMatrix?
 else if (dynamic_cast<CCDoubleMatrix*>(matrix_pt))
 {
  // Set flag so we know the rhs vector won't be distributed
  Distributed_rhs = false;
  
  // Get a cast pointer to the matrix
  CCDoubleMatrix* serial_matrix_pt = dynamic_cast<CCDoubleMatrix*>(matrix_pt);
  
  // Find the number of non-zero entries in the matrix
  const int nnz = int(serial_matrix_pt->nnz());  
  
  // Find # of degrees of freedom (variables)
  Ndof = int(serial_matrix_pt->nrow());
  
  // Find the local number of degrees of freedom in the linear system
  Ndof_local = Ndof;
  
  // Set first local index
  First_local_dof = 0;
  
  // Set up the pointers to the matrix.
  // NOTE: these arrays (accessed via value_pt, index_pt and
  // start_pt) may be modified by the SuperLU_DIST routines, and so 
  // a copy must be taken if the matrix is to be preserved.
  
  // Copy values
  Value_pt = new double[nnz];
  double* matrix_value_pt = serial_matrix_pt->value();
  for(int i=0;i<nnz;i++) 
   {
    Value_pt[i] = matrix_value_pt[i];
   }
  
  // copy row indices
  Index_pt = new int[nnz];
  int* matrix_index_pt = serial_matrix_pt->row_index();
  for (int i=0; i<nnz; i++)
   {
    Index_pt[i] = matrix_index_pt[i];
   }
  
  // copy column starts
  Start_pt = new int[Ndof_local+1];
  int* matrix_start_pt = serial_matrix_pt->column_start();
  for (int i=0; i<=Ndof_local; i++)
   {
    Start_pt[i] = matrix_start_pt[i];
   }
  
  // Delete the matrix if we are allowed
  if (Delete_matrix_data==true)
   {
    serial_matrix_pt->clean_up_memory();
   }
  
  // do the factorization
  superlu_dist_global_matrix(1, Ndof, nnz, Value_pt, Index_pt, Start_pt, 
                             0, Nprow, Npcol, doc, &Solver_data_pt, &Info);
  
  // Record that data is stored
  Global_solve_data_allocated=true;
 }
          
 // Otherwise throw an error
 else
  {
   std::ostringstream error_message_stream;
   error_message_stream << "SuperLU_dist implemented only for "
                        << " CCDoubleMatrix, CRDoubleMatrix\n"
                        << "and DistributedCRDoubleMatrix matrices\n";
   throw OomphLibError(error_message_stream.str(),
                       "SuperLU_dist::factorise()",
                       OOMPH_EXCEPTION_LOCATION);
  }
}

//================================================================
/// Do the backsubstitution for SuperLU solver
/// Note: returns the global result Vector.
//================================================================
void SuperLU_dist::backsub(const Vector<double> &rhs,
                           Vector<double> &result)
{
#ifdef PARANOID
 if(Ndof_local != rhs.size())
  {
   throw OomphLibError(
    "RHS does not have the same distribution as the linear system",
    "SuperLU_dist::backsub()",
    OOMPH_EXCEPTION_LOCATION);
  }
#endif
 
 // Doc (0/1) = (true/false)
 int doc = !Doc_stats;
 
 // Reset Info
 Info=0;

 // Do the backsubsitition phase
 if (Distributed_solve_data_allocated)
  {
   // Vector to hold local result vector
   Vector<double> result_local(Ndof_local);

   // Copy rhs values to result_local
   if (Distributed_rhs)
    {
     result_local = rhs;
    }
   else
    {
     for (int i=0; i<Ndof_local; i++)
      {
       result_local[i] = rhs[i+First_local_dof];
      }
    }

   // Call solver
   superlu_dist_distributed_matrix(2, Ndof, 0, 0, 0, 0, 0, 0, 
                                   &result_local[0], Nprow, Npcol, doc, 
                                   &Solver_data_pt, &Info);

   // generate global results Vector - first set up displacements Vector
   Vector<int> displacements(MPI_Helpers::Nproc);
   displacements[0]=0;
   for (int p=0; p<MPI_Helpers::Nproc-1; p++)
    {
     displacements[p+1]=displacements[p]+Ndof_remote[p];
    }
   
   // resize global_vector
   result.resize(Ndof); 

   // gather the local solution values
   MPI_Allgatherv(&result_local[0],
                  Ndof_local,
                  MPI_DOUBLE,
                  &result[0],
                  &Ndof_remote[0],
                  &displacements[0],
                  MPI_DOUBLE,
                  MPI_COMM_WORLD);
  }
 else if (Global_solve_data_allocated)
  {
   // Allocate storage for the result vector 
   result.resize(Ndof);
   
   // Copy the rhs values to result
   result = rhs;
   
   // Call solver
   superlu_dist_global_matrix(2, Ndof, 0, 0, 0, 0, &result[0],
                              Nprow, Npcol, doc, &Solver_data_pt, &Info);
  }
 else
  {
   throw OomphLibError("The matrix factors have not been stored",
                       "SuperLU_dist::backsub()",
                       OOMPH_EXCEPTION_LOCATION);
  }
 
}


//===============================================================
/// Clean up the memory allocated by the SuperLU_dist solver
//===============================================================
void SuperLU_dist::clean_up_memory()
{
 //If we have non-zero LU factors stored
 if(Solver_data_pt!=0)
  {
   //Clean up any stored solver data

   // Doc (0/1) = (true/false)
   int doc = !Doc_stats;
   
   // Reset Info flag
   Info=0;
   
   if (Distributed_solve_data_allocated)
    {
     superlu_dist_distributed_matrix(3, Ndof, 0, 0, 0, 0, 0, 0, 0, 
                                     Nprow, Npcol, doc, &Solver_data_pt, 
                                     &Info);
     Distributed_solve_data_allocated = false;
    }
   if (Global_solve_data_allocated)
    {
     superlu_dist_global_matrix(3, Ndof, 0, 0, 0, 0, 0,
                                Nprow, Npcol, doc, &Solver_data_pt, &Info);
     Global_solve_data_allocated = false;
    }
   
   Solver_data_pt=0;
   Ndof_local=0;
   Ndof=0;
 
   // Delete internal copy of the matrix
   delete[] Value_pt;
   delete[] Index_pt;
   delete[] Start_pt;
   Value_pt=0;
   Index_pt=0;
   Start_pt=0;
  }
}


//=========================================================================
/// Linear-algebra-type solver: Takes pointer to a matrix and rhs 
/// vector and returns the solution of the linear system. Problem pointer 
/// defaults to NULL and can be omitted. The function returns the global 
/// result Vector.
/// Note: if Delete_matrix_data is true the function 
/// matrix_pt->clean_up_memory() will be used to wipe the matrix data.
//=========================================================================
void SuperLU_dist::solve(DoubleMatrixBase* const &matrix_pt,
                         const Vector<double> &rhs,
                         Vector<double> &result)
{
 // Initialise timer
 double t_start = MPI_Wtime();

 //Factorise the matrix
 factorise(matrix_pt);
 
 //Now do the back solve
 backsub(rhs,result);

 // Doc time for solve
 double t_end = MPI_Wtime();
 Solution_time = t_end-t_start;
 
 if ((Doc_time) && (MPI_Helpers::My_rank==0))
  {
   if (Global_solve_data_allocated)
    {
     oomph_info << "Time for global SuperLU_dist solve [sec]       : "
                << t_end-t_start << std::endl;
    }
   else
    {
     oomph_info << "Time for distributed SuperLU_dist solve [sec]  : "
                << t_end-t_start << std::endl;
    }
  }
 
 // If we are not storing the solver data for resolves, delete it
 if (!Enable_resolve) 
  {
   clean_up_memory();
  }
}

//==================================================================
/// Solver: Takes pointer to problem and returns the results Vector
/// which contains the solution of the linear system defined by
/// the problem's fully assembled Jacobian and residual Vector.
//==================================================================
void SuperLU_dist::solve(Problem* const &problem_pt, Vector<double> &result)
{
 // Initialise timer
 double t_start = MPI_Wtime();
  
 // Take a copy of Delete_matrix_data
 bool copy_of_Delete_matrix_data = Delete_matrix_data;
 
 // Set Delete_matrix to true
 Delete_matrix_data = true;
 
 // Use the global version of SuperLU_DIST?
 if (Use_global_solver)
  {
   // Initialise timer
   double t_start = MPI_Wtime();
   
   // Storage for the residuals vector
   Vector<double> residuals;
   
   // Get the sparse jacobian and residuals of the problem
   CCDoubleMatrix jacobian;
   problem_pt->get_jacobian(residuals, jacobian);
   
   // Doc time for setup
   double t_end = MPI_Wtime();
   Jacobian_setup_time = t_end-t_start;
   if ((Doc_time) && (MPI_Helpers::My_rank==0))
    {
     oomph_info << "Time to set up global CC Jacobian [sec]        : "
                << Jacobian_setup_time << std::endl;
    }
   
   //Now call the linear algebra solve, if desired
   if(!Suppress_solve) 
    {
     solve(&jacobian,residuals,result);
    }
  }
 //Otherwise its the distributed solve version
 else
  {
   // Initialise timer
   double t_start = MPI_Wtime();

   // Storage for the residuals vector
   DistributedVector<double> residuals;
   
   //Get the sparse jacobian and residuals of the problem
   DistributedCRDoubleMatrix jacobian;
   problem_pt->get_jacobian(residuals, jacobian);

   // Doc time for setup
   double t_end = MPI_Wtime();
   Jacobian_setup_time = t_end-t_start;
   if ((Doc_time) && (MPI_Helpers::My_rank==0))
    {
     oomph_info << "Time to set up distributed CR Jacobian [sec]   : "
                << Jacobian_setup_time << std::endl;
    }
   
   //Now call the linear algebra solve, if desired
   if(!Suppress_solve) 
    {
     solve(&jacobian,residuals.vector(),result);
    }
  }

 // Set Delete_matrix back to original value
 Delete_matrix_data = copy_of_Delete_matrix_data;
 
 // Finalise/doc timings
 if ((Doc_time) && (MPI_Helpers::My_rank==0))
  {
   double t_end = MPI_Wtime();
   oomph_info << "Total time for SuperLU_dist " << "(np=" 
              << MPI_Helpers::Nproc << ",N=" << problem_pt->ndof()
              <<") [sec] : " << t_end-t_start << std::endl;
  }
}


//===============================================================
/// Resolve the system defined by the last assembled jacobian
/// and the specified rhs vector if resolve has been enabled.
/// Note: returns the global result Vector.
//===============================================================
void SuperLU_dist::resolve(const Vector<double> &rhs, Vector<double> &result)
{
#ifdef PARANOID
 //Check that a matrix has been factorised and stored
 if(!Global_solve_data_allocated && !Distributed_solve_data_allocated)
  {
   throw OomphLibError("The matrix factors have not been stored",
                       "SuperLU_dist::resolve()",
                       OOMPH_EXCEPTION_LOCATION);
  }
#endif
 
 // Store starting time for solve
 double t_start = MPI_Wtime();
 
 //Now do the back substitution phase
 backsub(rhs,result);

 // Doc time for solve
 double t_end = MPI_Wtime();
 Solution_time = t_end-t_start;
 
 if ((Doc_time) && (MPI_Helpers::My_rank==0))
  {
   if (Global_solve_data_allocated)
    {
     oomph_info << "Time for global SuperLU_dist solve [sec]: "
                << t_end-t_start << std::endl;
    }
   else
    {
     oomph_info << "Time for distributed SuperLU_dist solve [sec]: "
                << t_end-t_start << std::endl;
    }
  }

}

#endif

}
