//LIC// ====================================================================
//LIC// This file forms part of oomph-lib, the object-oriented, 
//LIC// multi-physics finite-element library, available 
//LIC// at http://www.oomph-lib.org.
//LIC// 
//LIC//           Version 0.85. June 9, 2008.
//LIC// 
//LIC// Copyright (C) 2006-2008 Matthias Heil and Andrew Hazel
//LIC// 
//LIC// This library is free software; you can redistribute it and/or
//LIC// modify it under the terms of the GNU Lesser General Public
//LIC// License as published by the Free Software Foundation; either
//LIC// version 2.1 of the License, or (at your option) any later version.
//LIC// 
//LIC// This library is distributed in the hope that it will be useful,
//LIC// but WITHOUT ANY WARRANTY; without even the implied warranty of
//LIC// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//LIC// Lesser General Public License for more details.
//LIC// 
//LIC// You should have received a copy of the GNU Lesser General Public
//LIC// License along with this library; if not, write to the Free Software
//LIC// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
//LIC// 02110-1301  USA.
//LIC// 
//LIC// The authors may be contacted at oomph-lib@maths.man.ac.uk.
//LIC// 
//LIC//====================================================================
//The actual solve functions for dense LU linear solvers.

// Config header generated by autoconfig
#ifdef HAVE_CONFIG_H
  #include <oomph-lib-config.h>
#endif

#ifdef OOMPH_HAS_MPI
#include "mpi.h"
#endif

//oomph-lib includes
#include "Vector.h"
#include "linear_solver.h"
#include "matrices.h"
#include "problem.h"


namespace oomph
{


//==================================================================
/// Solver: Takes pointer to problem and returns the results Vector
/// which contains the solution of the linear system defined by
/// the problem's fully assembled Jacobian and residual Vector.
//==================================================================
void DenseLU::solve(Problem* const &problem_pt, Vector<double> &result)
{
 //Initialise timer
 clock_t t_start = clock();
 
 //Find # of degrees of freedom (variables)
 const unsigned long n_dof = problem_pt->ndof();

 //Allocate storage for the residuals vector and the jacobian matrix
 Vector<double> residuals(n_dof);
 DenseDoubleMatrix jacobian(n_dof);
 
 {
  // initialise timer
  clock_t t_start = clock();
  
  //Get the full jacobian and residuals of the problem
  problem_pt->get_jacobian(residuals,jacobian);
  
  // compute jacobian setup time
  clock_t t_end = clock();
  Jacobian_setup_time = double(t_end-t_start)/CLOCKS_PER_SEC;

  //Report the time
  if(Doc_time)
   {
    oomph_info << std::endl << "CPU for setup of Dense Jacobian [sec]: " 
               << Jacobian_setup_time << std::endl;
   }
 }

 //Solve by dense LU decomposition VERY INEFFICIENT!
 solve(&jacobian,residuals,result);
 
 //Set the sign of the determinant of the jacobian
 problem_pt->sign_of_jacobian() = Sign_of_determinant_of_matrix;
 
 // Finalise/doc timings
 clock_t t_end = clock();
 double total_time=double(t_end-t_start)/CLOCKS_PER_SEC;
 if(Doc_time)
  {
   oomph_info << "CPU for DenseLU LinearSolver [sec]: " 
              << total_time << std::endl << std::endl;
  }
}


//=======================================================================
/// Delete the storage that has been allocated for the LU factors, if
/// the matrix data is not itself being overwritten.
//======================================================================
void DenseLU::clean_up_memory()
{
 //Clean up the LU factor storage, if it has been allocated
 //N.B. we don't need to check the index storage as well.
 if(LU_factors!=0)
  {
   //Delete the pointer to the LU factors
   delete[] LU_factors;
   //Null out the vector
   LU_factors = 0;
   //Delete the pointer to the Index
   delete[] Index;
   //Null out
   Index=0;
   //Reset the number of unknowns to zero
   N_dof=0;
  }
}

//=======================================================================
/// LU decompose the matrix. The algorithm is adapted from that in
/// "Numerical recipes in C" by Press et al.
//======================================================================
void DenseLU::factorise(DoubleMatrixBase* const &matrix_pt)
{
 //Set the number of unknowns
 const unsigned long n = matrix_pt->nrow();
 
#ifdef PARANOID
 unsigned long m = matrix_pt->ncol();
 // Check Matrix is square
 if (n!=m)
  {
   throw OomphLibError(
    "Cannot LU decompose a non-square matrix",
    "DenseLU::factorise()",
    OOMPH_EXCEPTION_LOCATION);
   }
#endif 

 //Small constant
 const double TINY=1.0e-20;

 //Vector vv stores the implicit scaling of each row
 Vector<double> vv(n);

 //Integer to store the sign that must multiply the determinant as
 //a consequence of the row/column interchanges
 int signature = 1;

 //Loop over rows to get implicit scaling information
 for(unsigned long i=0;i<n;i++)
  {
   double big=0.0;
   for(unsigned long j=0;j<n;j++)
    {
     double temp = std::abs((*matrix_pt)(i,j));
     if(temp > big) big = temp;
    }
   if(big==0.0) 
    {
     throw OomphLibError("Singular Matrix",
                         "DenseLU::solve()",
                         OOMPH_EXCEPTION_LOCATION);
    }
   //Save the scaling
   vv[i] = 1.0/big;
  }

 //Firsly, we shall delete any previous LU storage.
 //If the user calls this function twice without changing the matrix
 //then it is their own inefficiency, not ours (this time).
 clean_up_memory();

 //Allocate storage for the LU factors, the index and store
 //the number of unknowns
 LU_factors = new double[n*n];
 Index = new long[n];
 N_dof = n;

 //Now we know that memory has been allocated, copy over
 //the matrix values
 unsigned count=0;
 for(unsigned long i=0;i<n;i++)
  {
   for(unsigned long j=0;j<n;j++)
    {
     LU_factors[count] = (*matrix_pt)(i,j);
     ++count;
    }
  }

 //Loop over columns
 for(unsigned long j=0;j<n;j++)
  {
   //Initialise imax
   unsigned long imax=0;

   for(unsigned long i=0;i<j;i++)
    {
     double sum = LU_factors[n*i+j];
     for(unsigned long k=0;k<i;k++) 
      {
       sum -= LU_factors[n*i+k]*LU_factors[n*k+j];
      }
     LU_factors[n*i+j] = sum;
    }

   //Initialise search for largest pivot element
   double big=0.0;
   for(unsigned long i=j;i<n;i++)
    {
     double sum = LU_factors[n*i+j];
     for(unsigned long k=0;k<j;k++) 
      {
       sum -= LU_factors[n*i+k]*LU_factors[n*k+j];
      }
     LU_factors[n*i+j] = sum;
     //Set temporary
     double temp = vv[i]*std::abs(sum);
     if(temp >= big)
      {
       big = temp;
       imax = i;
      }
    }

   //Test to see if we need to interchange rows
   if(j != imax)
    {
     for(unsigned long k=0;k<n;k++)
      {
       double temp = LU_factors[n*imax+k];
       LU_factors[n*imax+k] = LU_factors[n*j+k];
       LU_factors[n*j+k] = temp;
      }
     //Change the parity of signature
     signature = -signature;
     //Interchange scale factor
     vv[imax] = vv[j];
    }
   
   //Set the index
   Index[j] = imax;
   if(LU_factors[n*j+j] == 0.0) 
    {
     LU_factors[n*j+j] = TINY;
    }
   //Divide by pivot element
   if(j != n-1)
    {
     double temp = 1.0/LU_factors[n*j+j];
     for(unsigned long i=j+1;i<n;i++) 
      {
       LU_factors[n*i+j] *= temp;
      }
    }
  
  } //End of loop over columns

 
 //Now multiply all the diagonal terms together to get the determinant
 //Note that we need to use the mantissa, exponent formulation to
 //avoid underflow errors
 double determinant_mantissa=1.0;
 int determinant_exponent = 0, iexp;
 for(unsigned i=0; i<n; i++)
  {
   //Multiply by the next diagonal entry's mantissa
   //and return the exponent
   determinant_mantissa *= frexp(LU_factors[n*i+i], &iexp);
   //Add the new exponent to the current exponent
   determinant_exponent += iexp;
   /* normalise*/
   determinant_mantissa = frexp(determinant_mantissa,&iexp);
   determinant_exponent += iexp;
  }

 //Integer to store the sign of the determinant
 int sign = 0;
 //Find the sign of the determinant
 if(determinant_mantissa > 0.0) {sign = 1;}
 if(determinant_mantissa < 0.0) {sign = -1;}
 
 //Multiply the sign by the signature
 sign *= signature;
 
 //Return the sign of the determinant
 Sign_of_determinant_of_matrix = sign;
 }

//================================================================
/// Do the backsubstitution for the DenseLU solver. Again the 
/// algorithm is based on that from "Numerical recipes in C"
/// by Press et al.
//================================================================
void DenseLU::backsub(const Vector<double> &rhs,
                      Vector<double> &result)
{
 const unsigned long n = rhs.size();
#ifdef PARANOID
 if(N_dof != n)
   {
    throw OomphLibError(
     "RHS does not have the same dimension as the linear system",
     "DenseLU::backsub()",
     OOMPH_EXCEPTION_LOCATION);
   }
#endif

  //Copy the rhs vector into the result vector
 for(unsigned long i=0;i<n;++i) {result[i] = rhs[i];}
 
 unsigned long ii=0;
 for(unsigned long i=0;i<n;i++)
  {
   unsigned long ip = Index[i];
   double sum = result[ip];
   result[ip] = result[i];
   
   if(ii != 0)
    {
     for(unsigned long j=ii-1;j<i;j++) 
      {
       sum -= LU_factors[n*i+j]*result[j];
      }
    }
   else if(sum != 0.0)
    {
     ii = i+1;
    }
   result[i] = sum;
  }

 //Now do the back substitution
 for (long i=long(n)-1;i>=0;i--)
  {
   double sum = result[i];
   for(long j=i+1;j<long(n);j++) sum -= LU_factors[n*i+j]*result[j];
   result[i] = sum/LU_factors[n*i+i];
  }
}


 /// \short Linear-algebra-type solver: Takes pointer to a matrix and rhs 
 /// vector and returns the solution of the linear system. 
 void DenseLU::solve(DoubleMatrixBase* const &matrix_pt,
                     const Vector<double> &rhs,
                     Vector<double> &result)
 {
  // Time the solver 
  clock_t t_start = clock();

  factorise(matrix_pt);
  backsub(rhs,result);

  //Doc time for solver
  clock_t t_end = clock();
  
  Solution_time = double(t_end-t_start)/CLOCKS_PER_SEC;
  if(Doc_time)
   {
    oomph_info << "CPU for solve with DenseLU   [sec]: " 
               << Solution_time << std::endl;
   }

  //If we are not resolving then delete storage
  if(!Enable_resolve) {clean_up_memory();}
 }


//==================================================================
/// Solver: Takes pointer to problem and returns the results Vector
/// which contains the solution of the linear system defined by
/// the problem's residual Vector. (Jacobian assembled by FD).
//==================================================================
void FD_LU::solve(Problem* const &problem_pt, Vector<double> &result)
{
 //Initialise timer
 clock_t t_start = clock();
 

 //Find # of degrees of freedom
 unsigned long n_dof = problem_pt->ndof();

 //Allocate storage for the residuals vector and the jacobian matrix
 Vector<double> residuals(n_dof);
 DenseDoubleMatrix jacobian(n_dof);

 {
  // initialise timer
  clock_t t_start = clock();
  
  //Get the full jacobian by finite differencing)  VERY INEFFICIENT!
  problem_pt->get_fd_jacobian(residuals,jacobian);
  
  // compute jacobian setup time
  clock_t t_end = clock();
  Jacobian_setup_time = double(t_end-t_start)/CLOCKS_PER_SEC;

  //Report the time
  if(Doc_time)
   {
    oomph_info << std::endl << "CPU for setup of Dense Jacobian [sec]: " 
               << Jacobian_setup_time << std::endl;
   }
 }

 //Solve by dense LU decomposition (not efficient)
  solve(&jacobian,residuals,result);

  //Set the sign of the determinant of the jacobian
  problem_pt->sign_of_jacobian() = Sign_of_determinant_of_matrix;
  
  // Finalise/doc timings
  clock_t t_end = clock();
  double total_time=double(t_end-t_start)/CLOCKS_PER_SEC;
  if(Doc_time)
   {
    oomph_info << "CPU for FD DenseLU LinearSolver [sec]: " 
               << total_time << std::endl << std::endl;
   }
}


//===================================================================
// Interface to SuperLU wrapper
//===================================================================
extern "C"
{
 int superlu(int *, int *, int *, int *,
             double *, int *, int *,
             double *, int *,  int *, int *,
             void*, int *);
}

//===================================================================
///\short LU decompose the matrix addressed by matrix_pt by using
/// the SuperLU solver. The resulting matrix factors are stored 
/// internally.
//===================================================================
void SuperLU::factorise(DoubleMatrixBase* const &matrix_pt)
{
 //Find # of degrees of freedom (variables)
 int n = matrix_pt->nrow();
 
 //Check that we have a square matrix
#ifdef PARANOID
 int m = matrix_pt->ncol();
 if(n != m)
  {
   std::ostringstream error_message_stream;
   error_message_stream << "Can only solve for square matrices\n" 
                        << "N, M " << n << " " << m << std::endl;
   
   throw OomphLibError(error_message_stream.str(),
                       "SuperLU::factorise()",
                       OOMPH_EXCEPTION_LOCATION);
  }
#endif
 
 //Storage for the values, rows and column indices
 //required by SuplerLU
 double *value = 0;
 int *index=0, *start=0;
 
 //Integer used to represent compressed row or column format
 //Default compressed row
 int transpose = 0;
 
 //Number of non-zero entries in the matrix
 int nnz = 0;
 
 // Doc flag (convert to int for SuperLU)
 int doc = Doc_stats;
 
 //Is it a CR matrix
 if(dynamic_cast<CRDoubleMatrix*>(matrix_pt))
  {
   //Set the appropriate row flags
   Compressed_row_flag=true;
   transpose = 1;
   //Get a cast pointer to the matrix
   CRDoubleMatrix* CR_matrix_pt = dynamic_cast<CRDoubleMatrix*>(matrix_pt);
   
   //Now set the pointers to the interanally stored values
   //and indices
   nnz = CR_matrix_pt->nnz();
   value = CR_matrix_pt->value();
   index = CR_matrix_pt->column_index();
   start = CR_matrix_pt->row_start();
  }
 //Otherwise is it the compressed column version?
 else if(dynamic_cast<CCDoubleMatrix*>(matrix_pt))
  {
   //Set the compressed row flag to false
   Compressed_row_flag=false;
   //Get a cast pointer to the matrix
   CCDoubleMatrix* CC_matrix_pt = dynamic_cast<CCDoubleMatrix*>(matrix_pt);
   
   //Now set the pointers to the interanally stored values
   //and indices
   nnz = CC_matrix_pt->nnz();
   value = CC_matrix_pt->value();
   index = CC_matrix_pt->row_index();
   start = CC_matrix_pt->column_start();
  }
 //Otherwise throw and error
 else
  {
   throw OomphLibError("SuperLU only works with CR or CC Double matrices",
                       "SuperLU::factorise()",
                       OOMPH_EXCEPTION_LOCATION);
  }
 
 // Clean up any previous storage so that if this is called twice with
 // the same matrix, we don't get a memory leak
 clean_up_memory();
 
 //Perform the lu decompose phase (i=1)
 int i=1;
 Sign_of_determinant_of_matrix =  superlu(&i, &n, &nnz,  0,
                                          value, index, start,
                                          0, &n,  &transpose, &doc,
                                          &F_factors, &Info);

 //Set the number of degrees of freedom in the linear system
 N_dof = n;
}

//=========================================================================
/// \short Linear-algebra-type solver: Takes pointer to a matrix and rhs 
/// vector and returns the solution of the linear system. Problem pointer 
/// defaults to NULL and can be omitted.
//=========================================================================
void SuperLU::solve(DoubleMatrixBase* const &matrix_pt,
                    const Vector<double> &rhs,
                    Vector<double> &result)
{
 // Time solver
 clock_t t_start = clock();

 //Factorise the matrix
 factorise(matrix_pt);

 //Now do the back solve
 backsub(rhs,result);

//  unsigned n=result.size();
//  Vector<double> product(n);
//  matrix_pt->multiply(result,product);
//  double err_max=0.0;
//  double norm=0.0;
//  for (unsigned i=0;i<n;i++)
//   {
//    norm+=rhs[i]*rhs[i];
//    double err=fabs(product[i]-rhs[i]);
//    if (err>err_max) err_max=err;
//   }
//  oomph_info << "Max. error in SuperLU solver " 
//             << err_max << " " << sqrt(norm/double(n)) 
//             << std::endl; 
 

 // Doc time for solver
 clock_t t_end = clock();
 Solution_time = double(t_end-t_start)/CLOCKS_PER_SEC;
 if(Doc_time)
  {
   oomph_info << "CPU for solve with SuperLU   [sec]: " 
              << Solution_time << std::endl;
  }

 //If we are not storing the matrix, delete
 if(!Enable_resolve) {clean_up_memory();}
}

//==================================================================
/// Solver: Takes pointer to problem and returns the results Vector
/// which contains the solution of the linear system defined by
/// the problem's fully assembled Jacobian and residual Vector.
//==================================================================
void SuperLU::solve(Problem* const &problem_pt, Vector<double> &result)
{
 // Initialise timer
 clock_t t_start = clock();
 
 //Allocate storage for the residuals vector
 Vector<double> residuals(problem_pt->ndof());

 // Use the compressed row version?
 if(Compressed_row_flag)
  {
   // Initialise timer
   clock_t t_start = clock();

   //Get the sparse jacobian and residuals of the problem
   CRDoubleMatrix CR_jacobian;
   problem_pt->get_jacobian(residuals,CR_jacobian);

   // Doc time for setup
   clock_t t_end = clock();
   Jacobian_setup_time = double(t_end-t_start)/CLOCKS_PER_SEC;
   if(Doc_time)
    {
     oomph_info << std::endl << "CPU for setup of CR Jacobian [sec]: " 
                << Jacobian_setup_time << std::endl;
    }

   //Now call the linear algebra solve, if desired
   if(!Suppress_solve) {solve(&CR_jacobian,residuals,result);}
  }
 //Otherwise its the compressed column version
 else
  {
   // Initialise timer
   clock_t t_start = clock();
   
   //Get the sparse jacobian and residuals of the problem
   CCDoubleMatrix CC_jacobian;
   problem_pt->get_jacobian(residuals,CC_jacobian);

   // Doc time for setup
   clock_t t_end = clock();
   Jacobian_setup_time=double(t_end-t_start)/CLOCKS_PER_SEC;
   if(Doc_time)
    {
     oomph_info << "\nCPU for setup of CC Jacobian [sec]: " 
                <<  Jacobian_setup_time << std::endl;
    }

   //Now call the linear algebra solve, if desired
   if(!Suppress_solve) {solve(&CC_jacobian,residuals,result);}
  }

 //Set the sign of the jacobian 
 //(this is computed in the LU decomposition phase)
 problem_pt->sign_of_jacobian() = Sign_of_determinant_of_matrix;
 
 // Finalise/doc timings
 clock_t t_end = clock();
 double total_time=double(t_end-t_start)/CLOCKS_PER_SEC;
 if(Doc_time)
  {
   oomph_info << "CPU for SuperLU LinearSolver [sec]: " 
              << total_time << std::endl << std::endl;
  }
}


//===============================================================
/// Resolve the system for a given RHS
//===============================================================
void SuperLU::resolve(const Vector<double> &rhs, Vector<double> &result)
{
 //Check that a matrix has been factorised and stored
 if(F_factors==0)
  {
   throw OomphLibError("The matrix factors have not been stored",
                       "SuperLU::resolve()",
                       OOMPH_EXCEPTION_LOCATION);
  }

 
 //Now do the back substitution phase
 backsub(rhs,result);
}

//================================================================
/// Do the backsubstitution for SuperLU
//================================================================
void SuperLU::backsub(const Vector<double> &rhs,
                      Vector<double> &result)
{
 //Find the number of unknowns
 int n = rhs.size();

#ifdef PARANOID
 if(static_cast<int>(N_dof) != n)
  {
   throw OomphLibError(
    "RHS does not have the same dimension as the linear system",
    "SuperLU::backsub()",
    OOMPH_EXCEPTION_LOCATION);
  }
#endif

 /// RHS vector
 double* b=new double[n];
 
 // Copy the values across
 for(int i=0;i<n;i++) {b[i]=rhs[i];}
 
 //Number of RHSs
 int nrhs=1;

 //Cast the boolean flags to ints for SuperLU
 int transpose = Compressed_row_flag;
 int doc = Doc_stats;

 //Do the backsubsitition phase
 int i=2;
 superlu(&i, &n, 0,  &nrhs,
         0, 0, 0,
         b, &n,  &transpose, &doc,
         &F_factors, &Info);
 
 // Copy b into rhs vector
 for(int i=0;i<n;i++) {result[i]=b[i];}
 
 // Cleanup the storage for the rhs vector
 delete[] b;
}


//===============================================================
/// Clean up the memory allocated by the SuperLU solver
//===============================================================
void SuperLU::clean_up_memory()
{
 //If we have non-zero LU factors stored
 if(F_factors!=0)
  {
   //Clean up those factors
   int i=3; 
   int transpose = Compressed_row_flag;
   superlu(&i, 0, 0,  0, 0, 0, 0,
           0, 0, &transpose, 0,
           &F_factors, &Info);

   //Set the F_factors to zero
   F_factors=0;
   N_dof=0;
  }
}

#ifdef OOMPH_HAS_MPI

// The following came from mpi_linear_solvers.cc

extern "C"
{
// Interface to distributed SuperLU solver where each processor 
// holds the entire matrix
void superlu_dist_global_matrix_bridge(int n, int nnz, 
                                       double *values, int *rowind, 
                                       int *column_start,
                                       double *b, int nprow, 
                                       int npcol, int doc);

// Interface to distributed SuperLU solver where each processor 
// holds part of the matrix
int superlu_dist_distributed_matrix_bridge(int n, int nnz, int nrow,
                                           int first_row, double *values, 
                                           int *col_index, int *row_start, 
                                           double *b, int nprow, int npcol, 
                                           int doc);


}
 
 //==================================================================
 /// Linear-algebra-type solver: Takes pointer to a matrix and rhs 
 /// vector and returns the solution of the linear system. 
 //==================================================================
 void SuperLU_dist::solve(DoubleMatrixBase* const &matrix_pt,
                          Vector<double> const &rhs,
                          Vector<double> &result)
 {
  // Initialise timer on master
  double t_start=0;
  if (MPI_Helpers::My_rank==0)
   {
    t_start = MPI_Wtime();
   }

  //Find the total number of degrees of freedom in the linear system
  //which is the total number of rows in the matrix 
  int n = matrix_pt->nrow();
  
#ifdef PARANOID
 int m = matrix_pt->ncol();
 // Check Matrix is square
 if (n!=m)
  {
   throw OomphLibError(
    "Cannot solve for a non-square matrix",
    "SuperLU_dist::solve()",
    OOMPH_EXCEPTION_LOCATION);
   }
#endif 

  //What type of matrix are we dealing with
  if(dynamic_cast<CCDoubleMatrix*>(matrix_pt))
   {
    //Set the internal flag
    Store_global_matrix = true;
    //Cast to the matrix
    CCDoubleMatrix* CC_matrix_pt = 
     dynamic_cast<CCDoubleMatrix*>(matrix_pt);

    //Find the number of non-zero entries in the matrix
    //and get pointers to the values, indices and start entries
    int nnz = CC_matrix_pt->nnz();        

    //Now copy the pointers to the values and indicies into
    //local storage. 
    //ALH: Note that this requires that the interface to SuperLU
    //does NOT delete this memory
    double *value = CC_matrix_pt->value();
    int *row_index = CC_matrix_pt->row_index();                           
    int* column_start = CC_matrix_pt->column_start();

    /// RHS vector
    double* b=new double[n];
    
    // Copy across the values
    for(int i=0;i<n;i++) {b[i]=rhs[i];}
     
    // Doc (0/1) = (true/false)
    int doc = !Doc_stats;
    
    // Distributed SuperLU 
    superlu_dist_global_matrix_bridge(n, nnz, 
                                      value, row_index, column_start,
                                      b, Nprow, Npcol, doc);
  
    // Copy b into solution vector
    for (int i=0;i<n;i++) {result[i]=b[i];}

    //We can now delete b
    delete[] b; b=0;
    
    // Doc time for solve on master
    if (MPI_Helpers::My_rank==0)
     {
      double t_end = MPI_Wtime();

      if(Doc_time)
       {
        oomph_info << "Solve time for global SuperLU_dist [sec]: "
                   << t_end-t_start << std::endl;
       }
     }
   }
  else if(dynamic_cast<DistributedCRDoubleMatrix*>(matrix_pt))
   {
    //Set the internal flag
    Store_global_matrix = false;
   
    //Cast to the matrix
    DistributedCRDoubleMatrix* dist_CR_matrix_pt
     = dynamic_cast<DistributedCRDoubleMatrix*>(matrix_pt);
    
    //Find the number of non-zero entries in the matrix
    //and get pointers to the values, indices and start entries
    int nnz = dist_CR_matrix_pt->nnz();

    // Pointers to pass the matrix values to SuperLU_DIST
    double* value_pt = 0;
    int* column_index_pt = 0;
    int* row_start_pt = 0;

    /// RHS vector
    double *b = new double[n];

    // Copy across the rhs values
    for(int i=0;i<n;i++) {b[i]=rhs[i];}
     
    // Doc (0/1) = (true/false)
    int doc = !Doc_stats;
   
    // Find the number of rows and the index of the first row
    // stored in this part of the distributed matrix
    int n_row_local = dist_CR_matrix_pt->nrow_local();
    int first_row = dist_CR_matrix_pt->first_row();

    // Distributed SuperLU
    // Note that the arrays accessed via value_pt, column index_pt and
    // row_start_pt can be modified by the routine
      
    // If we can delete the input matrix then simply
    // pass pointers to the matrix
    if (Delete_matrix==true)
     {
      // Get pointers to the matrix and pass these to 
      // the SuperLU_DIST interface
      value_pt = dist_CR_matrix_pt->value();
      column_index_pt = dist_CR_matrix_pt->column_index();
      row_start_pt = dist_CR_matrix_pt->row_start();
     }
    // Otherwise we must copy the matrix values
    else
     {
      // copy values
      value_pt = new double[nnz];
      double* matrix_value_pt = dist_CR_matrix_pt->value();
      for(int i=0;i<nnz;i++) 
       {
        value_pt[i] = matrix_value_pt[i];
       }
      
      // copy column indices
      column_index_pt = new int[nnz];
      int* matrix_column_index_pt = dist_CR_matrix_pt->column_index();
      for (int i=0; i<nnz; i++)
       {
        column_index_pt[i] = matrix_column_index_pt[i];
       }

      // copy row starts
      row_start_pt = new int[n+1];
      int* matrix_row_start_pt = dist_CR_matrix_pt->row_start();
      for (int i=0; i<=n; i++)
       {
        row_start_pt[i] = matrix_row_start_pt[i];
       }
     } // end of setting up pointers to the matrix
      
    // Distributed SuperLU
    //Note that the allocated pointers value, column index and row
    //start are killed by the routine
    superlu_dist_distributed_matrix_bridge(n, nnz, n_row_local, first_row,
                                           value_pt, column_index_pt,
                                           row_start_pt, b, Nprow, Npcol, doc);

    // Distributed SuperLU - new routine which will be operational once
    //                       Jonathan has ironed out the bugs
    //                       (in superlu_dist.c)
//      int opt=1;
//     superlu_dist_distributed_matrix(opt, n, nnz, n_row_local, first_row,
//                                     value_pt, column_index_pt, row_start_pt,
//                                     b, Nprow, Npcol, doc, &Solver_data_pt);
//     opt=2;
//     superlu_dist_distributed_matrix(opt, n, nnz, n_row_local, first_row,
//                                     value_pt, column_index_pt, row_start_pt,
//                                     b, Nprow, Npcol, doc, &Solver_data_pt);
    
//     opt=3;
//     superlu_dist_distributed_matrix(opt, n, nnz, n_row_local, first_row,
//                                     value_pt, column_index_pt, row_start_pt,
//                                     b, Nprow, Npcol, doc, &Solver_data_pt);

    // Delete matrix storage
    if (Delete_matrix==true)
     {
      dist_CR_matrix_pt->clean_up_memory();
     }
    else
     {
      delete[] column_index_pt;
      delete[] value_pt;
      delete[] row_start_pt;
     }

    // Assemble the solutions from all the partial solutions
    Vector<double> sol_loc(n_row_local);
    // Copy b into local solution vector
    for(int i=0;i<n_row_local;i++) {sol_loc[i]=b[i];}

    //We can now delete b
    delete[] b; b=0;
     
    Vector<double> sol_recv;
    int sol_ind=0;
    for(int source=0;source<MPI_Helpers::Nproc;source++)
     {
      if(source==MPI_Helpers::My_rank) sol_recv=sol_loc;
      MPI_Helpers::broadcast_vector(sol_recv,source,MPI_COMM_WORLD);
      {
       unsigned long nsol=sol_recv.size();
       for(unsigned long i=0;i<nsol;i++)
        {
         result[sol_ind]=sol_recv[i];
         sol_ind++;
        }
      }
     }


   // Doc time for solve on master
   if (MPI_Helpers::My_rank==0)
    {
     double t_end = MPI_Wtime();

     if(Doc_time)
      {
       oomph_info << "Time for distributed SuperLU_dist solve [sec]: "
                  << t_end-t_start << std::endl;
      }
    }
   }
  else
   {
    //Throw the error only on the master
    if(MPI_Helpers::My_rank==0)
     {
      throw OomphLibError("Matrix must be an MPI matrix",
                          "SuperLU_dist::solve()",
                          OOMPH_EXCEPTION_LOCATION);
     }
   }
 }


//==================================================================
/// Solver: Takes pointer to problem and returns the results Vector
/// which contains the solution of the linear system defined by
/// the problem's fully assembled Jacobian and residual Vector.
//==================================================================
void SuperLU_dist::solve(Problem* const &problem_pt,
                         Vector<double> &result)
{
 // Initialise timer on master
 double t_start=0;
 if (MPI_Helpers::My_rank==0)
  {
   t_start = MPI_Wtime();
  }

 // Upcast problem pointer to MPIProblem
 // No need to do this any more, MPIProblem incorporated into Problem
// MPIProblem* mpi_problem_pt=dynamic_cast<MPIProblem*>(problem_pt);
 
// #ifdef PARANOID
//  if (mpi_problem_pt==0)
//   {
//    std::ostringstream error_message;
//    error_message 
//     << "Can only use SuperLU_dist_global_matrix solver\n" 
//     << "for problems that are derived from MPIProblem class" 
//     << std::endl;
//    throw OomphLibError(error_message.str(),
//                        "SuperLU_dist::solve",
//                        OOMPH_EXCEPTION_LOCATION);   
//   }
// #endif

 //Find # of degrees of freedom (variables)
// unsigned long n_dof = mpi_problem_pt->ndof();
 unsigned long n_dof = problem_pt->ndof();

 // Assembly and solve with the global matrix
 //------------------------------------------
 if (Store_global_matrix)
  {   
   //Allocate storage for the residuals vector
   Vector<double> residuals(n_dof);

   // Initialise timer on master
   double t_start = 0;
   if ((Doc_time) && (MPI_Helpers::My_rank==0))
    {
     t_start = MPI_Wtime();
    }
   
   // Assemble Jacobian
   CCDoubleMatrix jacobian;
//   mpi_problem_pt->get_jacobian(residuals, jacobian);
   problem_pt->get_jacobian(residuals, jacobian);
   
   // Doc time for setup on master
   if ((Doc_time) && (MPI_Helpers::My_rank==0))
    {
     double t_end = MPI_Wtime();

     oomph_info << "Time to set up global CC Jacobian [sec] : "
                << t_end-t_start << std::endl;
    }
    
   //Solve by SuperLU_dist the system Jx = residuals
   if(!Suppress_solve) {solve(&jacobian,residuals,result);}
  }
 // Assemble and solve with distributed matrix (blocks of rows
 //-----------------------------------------------------------
 // are held on different processors
 //---------------------------------
 else
  {
   //Distributed residuals vector
   DistributedVector<double> residuals;

   // Initialise timer on master
   double t_start=0;
   if ((Doc_time) && (MPI_Helpers::My_rank==0))
    {
     t_start = MPI_Wtime();
     }

   // Setup the distributed, row compressed matrix
   DistributedCRDoubleMatrix jacobian;
//   mpi_problem_pt->get_jacobian(residuals, jacobian);
   problem_pt->get_jacobian(residuals, jacobian);

   // Doc time for setup on master
   if ((Doc_time) && (MPI_Helpers::My_rank==0))
    {
     double t_end = MPI_Wtime();
 
     oomph_info << "Time to set up distributed CR Jacobian [sec] : "
                << t_end-t_start << std::endl;
    }
   
   //Solve with SuperLU_dist
   if (!Suppress_solve) {solve(&jacobian,residuals.vector(),result);}
  }

 // Finalise/doc timings
 if (MPI_Helpers::My_rank==0)
  {
   double t_end = MPI_Wtime();

   if(Doc_time)
    {
     oomph_info << "Total time for SuperLU_dist "
                << "(np="<< MPI_Helpers::Nproc<<",N="<<n_dof<<") [sec]: "
                << t_end-t_start << std::endl;
    }
  }


}

#endif

}
