//LIC// ====================================================================
//LIC// This file forms part of oomph-lib, the object-oriented, 
//LIC// multi-physics finite-element library, available 
//LIC// at http://www.oomph-lib.org.
//LIC// 
//LIC//           Version 0.85. June 9, 2008.
//LIC// 
//LIC// Copyright (C) 2006-2008 Matthias Heil and Andrew Hazel
//LIC// 
//LIC// This library is free software; you can redistribute it and/or
//LIC// modify it under the terms of the GNU Lesser General Public
//LIC// License as published by the Free Software Foundation; either
//LIC// version 2.1 of the License, or (at your option) any later version.
//LIC// 
//LIC// This library is distributed in the hope that it will be useful,
//LIC// but WITHOUT ANY WARRANTY; without even the implied warranty of
//LIC// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//LIC// Lesser General Public License for more details.
//LIC// 
//LIC// You should have received a copy of the GNU Lesser General Public
//LIC// License along with this library; if not, write to the Free Software
//LIC// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
//LIC// 02110-1301  USA.
//LIC// 
//LIC// The authors may be contacted at oomph-lib@maths.man.ac.uk.
//LIC// 
//LIC//====================================================================
//Include guards
#ifndef OOMPH_BLOCK_PRECONDITION_HEADERQW
#define OOMPH_BLOCK_PRECONDITION_HEADERQW


// Config header generated by autoconfig
#ifdef HAVE_CONFIG_H
  #include <oomph-lib-config.h>
#endif

// c++ include
#include<list>

// oomph-lib includes
#include "matrices.h"
#include "mesh.h"
#include "problem.h"
#include "preconditioner.h"
#include "SuperLU_preconditioner.h"

namespace oomph
{


//============================================================================
/// Block Preconditioner base class. The block structure of the
/// overall problem is determined from the \c Mesh's constituent
/// elements. Each constituent element must be block-preconditionable - i.e 
/// must implement the \c GeneralisedElemens functions \c nblock_types() and 
/// get_block_numbers_for_unknowns(...). A \c Problem can have several
/// \c Meshes, but each \c Mesh can only contain a single type of element.
/// The association between global degrees of freedom and their unique global 
/// block numbers is therefore based on information provided by the elements. 
/// \n\n
/// This class can function in one of two ways. Either it acts as a
/// stand-alone block preconditioner which computes and stores 
/// the association between global degrees of freedom and their unique global 
/// block numbers itself. Alternatively, the block preconditioner can act as 
/// a subsidiary block preconditioner within a (larger) master block 
/// preconditioner (pointed to by Master_block_preconditioner_pt). 
/// The master block preconditioner 
/// must have an equal or greater number of block types. Examples
/// are the FSI precondititioner which is the 3x3 "master block preconditioner"
/// for the Navier-Stokes preconditioners which deals with the
/// 2x2 fluid-blocks within the overall structure. In this case, \b only
/// the master block preconditioner computes and stores the various
/// lookup schemes. 
/// \n\n
/// In cases where a \c Problem contains elements of different element types 
/// (e.g. fluid and solid elements in a fluid-structure interaction problem), 
/// access to the elements of the same type must be provided via pointers to 
/// (possibly auxiliary) \c Meshes that only contain elements of a single 
/// type. The block preconditioner will then create global block
/// numbers by concatenating the block types. Consider, e.g. a fluid-structure
/// interaction problem in which the first \c Mesh contains (fluid) 
/// elements whose degrees of freedom have been subdivided into 
/// types "0" (the velocity, say) and "1" (the pressure say), while 
/// the second \c Mesh contains (solid) elements whose degrees of freedom
/// are the nodal displacements, classified as its type "0". 
/// The combined block preconditioner then has three "block types": 
/// "0": Fluid velocity, "1": Fluid pressure, "2": Solid nodal positions.
//============================================================================
template<typename MATRIX>
class BlockPreconditioner : public virtual Preconditioner
{

 public :

  /// \short Constructor
  BlockPreconditioner()
  {
   // Initially set the master block preconditioner pointer to zero
   // indicating that this is stand-alone preconditioner that will
   // set up its own block lookup schemes etc.
   Master_block_preconditioner_pt = 0;

   // Initialise number of rows in this block preconditioner.
   // This information is maintained if used as subsidiary or
   // stand-alone block preconditoner (in the latter case it
   // obviously stores the number of rows within the subsidiary
   // preconditioner
   Nrow=0;
   
   // Initialise number of different block types in this preconditioner. 
   // This information is maintained if used as subsidiary or
   // stand-alone block preconditoner (in the latter case it
   // obviously stores the number of rows within the subsidiary
   // preconditioner 
   Nblock_types=0;
  }




 /// Destructor (empty)
 ~BlockPreconditioner(){}
 
 /// Broken copy constructor
 BlockPreconditioner(const BlockPreconditioner&)
  {
   BrokenCopy::broken_copy("BlockPreconditioner");
  }
 
 /// Broken assignment operator
 void operator=(const BlockPreconditioner&)
  {
   BrokenCopy::broken_assign("BlockPreconditioner");
  }

 
 /// \short Function to turn this preconditioner into a 
 /// subsidiary preconditioner that operates within a bigger
 /// "master block preconditioner (e.g. a Navier-Stokes 2x2 block
 /// preconditioner dealing with the fluid sub-blocks within a
 /// 3x3 FSI preconditioner. Once this is done the master block
 /// preconditioner deals with the block setup etc. \n
 /// The vector block_map must specify the block number in the 
 /// master preconditioner that corresponds to a block number in this 
 /// preconditioner.\n 
 /// \b NOTE 1. The length of the vector is used to determine the number of 
 /// blocks in this preconditioner therefore it must be correctly sized.
 /// \b NOTE 2. block_setup() should be called in the master preconditioner
 /// before this method is called.
 void turn_into_subsidiary_block_preconditioner
  (BlockPreconditioner<MATRIX>* master_block_prec_pt,
   Vector<unsigned>& block_map)
  {

   // Set the master block preconditioner pointer
   Master_block_preconditioner_pt = master_block_prec_pt;
   
   // Clear any data from previous use of the preconditioner as
   // non-subsidiary preconditioner
   Index_in_block.clear();
   Block_number.clear();
   Block_dimension.clear();
   Global_index.clear();
    
   // get the number of block types in this preconditioner from the length
   // of the block_map vector
   Nblock_types =  block_map.size();

   // copy the block_map vector to the Block_number_in_master_preconditioner
   // vector used to store this information
   Block_number_in_master_preconditioner.resize(Nblock_types);
   for (unsigned i = 0; i < Nblock_types; i++)
    {
     Block_number_in_master_preconditioner[i] = block_map[i];
    }

   // compute number of rows in this (sub) preconditioner
   Nrow = 0;
   for (unsigned b = 0; b < Nblock_types; b++)
    {
     Nrow += this->block_dimension(b);
    }

#ifdef PARANOID
   if (Nrow==0)
    {
     std::ostringstream error_message;
     error_message 
      << "Nrow=0 in subsidiary preconditioner. This seems fishy and\n"
      << "suggests that block_setup() was not called for the \n"
      << "master block preconditioner before turning this one into \n"
      << "a subsidiary one\n";
     throw OomphLibWarning(
      error_message.str(),
      "BlockPreconditioner:: turn_into_subsidiary_block_preconditioner",
      OOMPH_EXCEPTION_LOCATION);
    }
#endif
   
  }
 

 /// \short Access to i-th mesh (of the various meshes that
 /// contain block preconditionable elements of the same type)
 Mesh* mesh_pt(const unsigned& i) const
  {
   return Mesh_pt[i];
  }



 protected :
  
     
  /// \short Determine the size of the matrix blocks and setup the
  /// lookup schemes relating the global degrees of freedom with
  /// their "blocks" and their indices (row/column numbers) in those
  /// blocks. Does nothing if the block preconditioner acts as
  /// a subsidiary block preconditioner within a master preconditoner.
  virtual void block_setup(Problem* problem_pt);
 
 
  /// \short Gets block (i,j) from the original matrix, pointed to by
  /// matrix_pt and returns it in
  /// block_matrix_pt
  virtual void get_block(const unsigned& i, const unsigned& j, 
                         MATRIX* matrix_pt,
                         MATRIX*& block_matrix_pt);


  /// \short Get all the block matrices required by the block preconditioner.
  /// Takes the pointer to the original matrix and a matrix of bools
  /// that indicate if a specified sub-block is required
  /// for the preconditioning operation. Computes the
  /// required block matrices, and stores pointers to them
  /// in the matrix block_matrix_pt. If an entry in block_matrix_pt
  /// is equal to NULL on return, that sub-block has not been requested and is
  /// therefore not available.
  void get_blocks(MATRIX* matrix_pt,
                  DenseMatrix<bool>& required_blocks,
                  DenseMatrix<MATRIX*>& block_matrix_pt);
 
  /// \short Assemble the block preconditioner as a single matrix. This is
  /// useful because in some cases the block preconditioner cannot be applied
  /// by linear-algebra-style block elimination, operating on
  /// individual sub-blocks; this function takes the matrix
  /// of block pointers and returns a single matrix containing all the
  /// blocks of the matrix of blocks in a single matrix that can
  /// be solved directly.
  void build_preconditioner_matrix(DenseMatrix<MATRIX*>& block_matrix_pt,
                                   MATRIX*& preconditioner_matrix);
  
 
  /// \short Which block is the global unknown i_dof associated with? If this
  /// preconditioner is a subsidiary block preconditioner then the block number
  /// in the subsidiary block preconditioner is returned. If a particular 
  /// global DOF is not associated with this preconditioner then -1 is returned
  int block_number(const unsigned& i_dof)
   {
    // I'm a stand-alone block preconditioner
    if (Master_block_preconditioner_pt == 0)
     {
      return static_cast<int>(Block_number[i_dof]);
     }
    // else this preconditioner  is a subsidiary one, and its Block_number
    // lookup schemes etc haven't been set up
    else
     {
      // Block number in master prec
      unsigned blk_num = Master_block_preconditioner_pt->block_number(i_dof);

      // Search through the Block_number_in_master_preconditioner for master
      // block blk_num and return the block number in this preconditioner 
      for (unsigned i = 0; i < Nblock_types; i++)
       {
        if (Block_number_in_master_preconditioner[i] == blk_num)
         {return static_cast<int>(i);}
       }
      // if the master block preconditioner number is not found return -1
      return -1;
     }
   }
  

  /// \short What's the index (i.e. the row/column number) of global
  /// unknown i_dof within its block?
  unsigned index_in_block(const unsigned& i_dof) const
   {
    if (Master_block_preconditioner_pt == 0)
     {
      return Index_in_block[i_dof];
     }
    else
     {
      return Master_block_preconditioner_pt->index_in_block(i_dof);
     }
   }
  
  
  /// \short What is the size of "block" i, i.e. how many degrees of freedom
  /// are associated with it? Note that if this preconditioner
  /// acts as a subsidiary preconditioner, then i refers to the 
  /// block number in the subsidiary preconditioner not the 
  /// master block preconditioner
  unsigned& block_dimension(const unsigned& i)
   {
    if (Master_block_preconditioner_pt == 0)
     {
      return Block_dimension[i];
     }
    else
     {
      unsigned master_i = master_block_number(i);
      return Master_block_preconditioner_pt->block_dimension(master_i);
     }
   }

  /// \short Returns the number of DOFs (number of rows or columns) in the 
  /// overall problem. [The prefix "master_" is sort of redundant
  /// when used as a stand-alone block preconditioner but is required to avoid
  /// ambiguities when there are master and subsidiary block preconditioners.
  /// In that case it's important to distinguish between the number of
  /// unknowns (rows) in the global problem and the number of rows
  /// involved in the subsidiary block preconditioner. The latter is stored
  /// (and maintained) separately for each specific block preconditioner 
  /// regardless of its role.
  unsigned master_nrow()
   {
    if (Master_block_preconditioner_pt == 0)
     {
      return Nrow;
     }
    else
     {
      return (this->Master_block_preconditioner_pt->master_nrow());
     }
   }
  
  
  /// \short Given the block number, b, and the row within this
  /// block, i, what is the corresponding global dof number?
  unsigned global_index(const unsigned& b, const unsigned& i)
   {
    if (Master_block_preconditioner_pt == 0)           
     {                                                                         
      return Global_index[b][i];                              
     }  
    else                                                                       
     {     
      unsigned master_b = master_block_number(b);   
      return Master_block_preconditioner_pt->global_index(master_b,i);  
     }        
   }


  /// \short Takes the block number within this preconditioner and returns the
  /// corresponding block number in the master preconditioner. If this 
  /// preconditioner does not have a master block preconditioner then the block
  /// number passed is returned
  unsigned master_block_number(const unsigned& b)
   {
    if (Master_block_preconditioner_pt == 0)
     {
      return b;
     }
    else
     {
      return Block_number_in_master_preconditioner[b];
     }
   }


  /// \short Given the naturally ordered vector, v, return
  /// the vector rearranged in block order in w.
  void get_block_ordered_preconditioner_vector(const Vector<double>& v,
                                               Vector<double>& w)
   {
    // number of blocks
    unsigned n_block_types = this->Nblock_types;
    
    // determines entry of residual where a block starts
    Vector<unsigned> block_start(n_block_types,0);
    for (unsigned a = 1; a < n_block_types; a++)
     {
      block_start[a] = block_start[a-1] + this->block_dimension(a-1);
     }

    // Number of rows in the source vector
    unsigned nrow_global = this->master_nrow();
    
    //  Cleared and resized w for reordered vector
    w.clear();
    w.resize(Nrow);
    
    // reorder residual into block order
    for (unsigned int i = 0; i < nrow_global; i++)
     {
      int block_num = block_number(i);
      if (block_num >= 0)
       {
        w[block_start[block_num]+this->index_in_block(i)] = v[i];
       }
     }
   }

  /// \short Takes the naturally ordered vector, w, and reorders it in 
  /// block order. Reordered vector is returned in v. Note: If the 
  /// preconditioner is a subsidiary
  /// preconditioner then only the components of the vector associated with 
  /// the blocks of the subsidiary preconditioner will be included. Hence
  /// the length of w is master_nrow() whereas that of the v is
  void return_block_ordered_preconditioner_vector(const Vector<double>& w, 
                                                  Vector<double>& v)
   {
    // number of blocks
    unsigned n_block_types = this->Nblock_types;
    
    // determines entry of residual where a block starts
    Vector<unsigned> block_start(n_block_types,0);
    for (unsigned a = 1; a < n_block_types; a++)
     {
      block_start[a] = block_start[a-1] + this->block_dimension(a-1);
     }

    // number of rows in the source vector
    unsigned nrow_global = this->master_nrow();

    // return result to z vector in original order
    for (unsigned int i = 0; i < nrow_global; i++)
     {
      int block_num = this->block_number(i);
      if (block_num >= 0)
       {
        v[i] = w[block_start[block_num] + this->index_in_block(i)];
       }
     }
   }
  
  /// \short Takes the naturally ordered vector and rearranges it into a vector
  /// of sub vectors corresponding to the blocks, so s[b][i] contains
  /// the i-th entry in the vector associated with block b.
  /// Note: If the preconditioner is a subsidiary
  /// preconditioner then only the sub-vectors associated with 
  /// the blocks of the subsidiary preconditioner will be included. Hence
  /// the length of v is master_nrow() whereas the total length of the s
  /// s vectors is Nrow.
  void get_block_vectors(const Vector<double>& v,
                         Vector<Vector<double> >& s)
   {
    // Number of block types
    const unsigned n_block = this->nblock_types();

    // Vector of vectors for each section of residual vector
    s.resize(n_block);
  
    // set the length of each block residual vector
    for (unsigned i = 0; i < n_block; i++)
     {
      s[i].resize(this->block_dimension(i));
     }
  
    // Length of vector
    unsigned n_row = master_nrow();

    // copy the elements from the vector v to the block vectors s
    for (unsigned i = 0; i < n_row; i++)
     {
      int block_num = block_number(i);
      if (block_num >= 0)
       {
        s[block_num][this->index_in_block(i)] = v[i];
       }
     }
   }


  /// \short Takes the vector of block vectors, s, and copies its entries
  /// into the  naturally ordered vector, v. If this is a subsidiary
  /// block preconditioner only those entries in v that are 
  /// associated with its blocks are affected.
  void return_block_vectors(const Vector<Vector<double> >& s, 
                            Vector<double>& v)
   {
    // length of vector
    unsigned n_row = master_nrow();

    // copy back from the block vector s to the naturally ordered vector
    for (unsigned i = 0; i < n_row; i++)
     {
      int block_num = block_number(i);
      if (block_num >= 0)
       {
        v[i] = s[block_num][this->index_in_block(i)];
       }	
     }
   }


  /// \short Takes the naturally ordered vector, v, and extracts
  /// the n-th block vector, b. Here n is the block number in the 
  /// current preconditioner.
  void get_block_vector(const unsigned& n, const Vector<double>& v, 
                        Vector<double>& b)
   {
    // length of vector
    unsigned n_row = master_nrow();

    // get the sub block vector
    b.resize(this->block_dimension(n));
    for (unsigned i = 0; i < n_row; i++)
     {
      int block_num = block_number(i);
      if (block_num == static_cast<int>(n))
       {
        b[this->index_in_block(i)] = v[i];
       }
     }
   }


  /// \short Takes the n-th block ordered vector, b,  and copies its entries
  /// to the appropriate entries in the naturally ordered vector, v.
  /// Here n is the block number in the current block preconditioner.
  /// If the preconditioner is a subsidiary block preconditioner
  /// the other entries in v  that are not associated with it
  /// are left alone
  void return_block_vector(const unsigned& n, 
                           const Vector<double>& b,
                           Vector<double>& v)
   {
    // length of vector
    unsigned n_row = master_nrow();

    // copy back from the block vector to the naturally ordered vector
    for (unsigned i = 0; i < n_row; i++)
     {
      int block_num = block_number(i);
      if (block_num == static_cast<int>(n))
       {
        v[i] = b[this->index_in_block(i)];
       }	
     }
   }


  /// \short Vector of pointers to the meshes containing the elements used 
  /// in the block preconditioner. 
  Vector<Mesh*> Mesh_pt;

  /// \short Number of DOFs (# of rows or columns in the full matrix) in this 
  /// preconditioner. NOTE:
  /// This information is maintained if used as subsidiary or
  /// stand-alone block preconditoner (in the latter case it
  /// obviously stores the number of rows within the subsidiary
  /// preconditioner)
  unsigned Nrow; 
   
  /// \short Number of different block types in this preconditioner. NOTE:
  /// This information is maintained if used as subsidiary or
  /// stand-alone block preconditoner (in the latter case it
  /// obviously stores the number of rows within the subsidiary
  /// preconditioner) 
  unsigned Nblock_types;


  /// \short Pointer to a master block preconditioner if the block 
  /// preconditioner is acting a sub block preconditioner. 
  /// NOTE : if the preconditioner does not have a master block preconditioner
  /// then this  pointer remains null.
  BlockPreconditioner<MATRIX>* Master_block_preconditioner_pt;


  private:


  /// \short Private helper function to check that every element in the block 
  /// matrix (i,j) matches the corresponding element in the original matrix
  void block_matrix_test(const MATRIX* matrix_pt,
                         const unsigned& i,
                         const unsigned& j,
                         const MATRIX* block_matrix_pt);
  
    
  /// \short For block number i in this preconditioner this vector contains
  /// the block number in the master preconditioner. Otherwise empty
  Vector<unsigned> Block_number_in_master_preconditioner;

  /// \short Vector to store the mapping from the global dof number
  ///  to the index (row/colum number) within its block (Empty if this 
  /// preconditioner has a master preconditioner as this information is 
  /// obtained from the master preconditioner)
  Vector<unsigned> Index_in_block;
  
  /// \short Vector to store the mapping from the global dof number to
  /// its block (Empty if this preconditioner has a master preconditioner as 
  /// this information is obtained from the master preconditioner)
  Vector<unsigned> Block_number;
  
  /// \short Vector containing the size of each block, i.e. the number of
  /// global dofs associated with it. (Empty if this preconditioner has a 
  /// master preconditioner as this information is obtain from the master 
  /// preconditioner)
  Vector<unsigned> Block_dimension;

  /// \short vectors of vectors for the mapping from block number / block DOF
  /// to global row number. (Empty if this preconditioner has a 
  /// master preconditioner as this information is obtain from the master 
  /// preconditioner) 
  Vector<Vector<unsigned> > Global_index;

};



////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////



//=============================================================================
/// Block diagonal preconditioner. Acts on single mesh that contains
/// block preconditionable elements of the same type, allowing
/// the block size to be determined by the elements. SuperLU
/// is used to solve the blocks.
//=============================================================================
template<typename MATRIX> 
class BlockDiagonalPreconditioner : public BlockPreconditioner<MATRIX>
{
 
 public :
  
  /// constructor - when the preconditioner is used as a master preconditioner
  BlockDiagonalPreconditioner() : BlockPreconditioner<MATRIX>()
  {
   // Initialise -- actual value is set during setup
   this->Nblock_types=0;
  }
 
 /// Destructor - delete the preconditioner matrices
 ~BlockDiagonalPreconditioner()
  {
   //number of block types
   unsigned n_block = this->nblock_types();
   
   //delete diagonal blocks
   for (unsigned i = 0 ; i < n_block; i++)
    {
     delete Diagonal_block_preconditioner_pt[i];
     Diagonal_block_preconditioner_pt[i] = 0;
    }
  }
 
 /// Broken copy constructor
 BlockDiagonalPreconditioner(const BlockDiagonalPreconditioner&) 
  { 
   BrokenCopy::broken_copy("BlockDiagonalPreconditioner");
  } 
 
 /// Broken assignment operator
 void operator=(const BlockDiagonalPreconditioner&) 
  {
   BrokenCopy::broken_assign("BlockDiagonalPreconditioner");
  }
 
 /// Apply preconditioner to r
 void preconditioner_solve(const Vector<double>&r, Vector<double> &z);
 
 /// \short Setup the preconditioner 
 void setup(Problem* problem_pt, DoubleMatrixBase* matrix_pt);
 
 private :
  
  /// \short Vector of SuperLU preconditioner pointers for storing the 
  /// preconditioners for each diagonal block
  Vector<SuperLU_Preconditioner*> Diagonal_block_preconditioner_pt;   

};



////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////



//=============================================================================
/// Exact block preconditioner - block preconditioner assembled from all blocks
/// associated with the preconditioner and solved by SuperLU.
//=============================================================================
template<typename MATRIX> 
class ExactBlockPreconditioner : public BlockPreconditioner<MATRIX>
{
 
 public :
  
  /// constructor - when the preconditioner is used as a master preconditioner
  ExactBlockPreconditioner() : BlockPreconditioner<MATRIX>()
  {
   // Initialise -- actual value is set during setup
   this->Nblock_types=0;
  }
 
 /// constructor - for when the preconditioner is used as a sub preconditioner
 ExactBlockPreconditioner(BlockPreconditioner<MATRIX>* master_prec_pt,
                              Vector<unsigned>& block_map) :
   BlockPreconditioner<MATRIX>(master_prec_pt, block_map)
   {
    // Initialise -- actual value is set during setup
    this->Nblock_types= block_map.size();  
   }
  
  /// Destructor - does nothing
  ~ExactBlockPreconditioner(){}
  
  /// Broken copy constructor
  ExactBlockPreconditioner(const ExactBlockPreconditioner&) 
   { 
    BrokenCopy::broken_copy("ExactBlockPreconditioner");
   } 
  
  /// Broken assignment operator
  void operator=(const ExactBlockPreconditioner&) 
   {
    BrokenCopy::broken_assign("ExactBlockPreconditioner");
   }
  
  /// Apply preconditioner to r
  void preconditioner_solve(const Vector<double>&r, Vector<double> &z);
  
  /// \short Setup the preconditioner 
  void setup(Problem* problem_pt, DoubleMatrixBase* matrix_pt);
  
  
  /// \short The number of "blocks" that degrees of freedom 
  /// are sub-divided into. Note: setup(...) must have been called
  /// for this to function properly.
  unsigned nblock_types()
   {
#ifdef PARANOID
    if (Nblock_types==0)
     {
      std::ostringstream error_message;
      error_message << "nblock_types() called while Nblock_types=0. \n"
                    << "This tends to indicate that the preconditioner " 
                    << "has not been set up yet! ";
      throw OomphLibWarning(error_message.str(),
                            "BlockDiagonalPreconditioner::nblock_types()",
                            OOMPH_EXCEPTION_LOCATION);
     }
#endif
    return this->Nblock_types;
   }
  
  /// \short adds a mesh to this exact block preconditioner
  void add_mesh(Mesh* new_mesh_pt)
   {
    this->Mesh_pt.push_back(new_mesh_pt);
   }
  
  
  private :
   
   /// \short Vector of SuperLU preconditioner pointers for storing the 
   /// preconditioners for each diagonal block
   SuperLU_Preconditioner Exact_block_preconditioner;   
};




//=============================================================================
/// Determine the size of the matrix blocks and setup the
/// lookup schemes relating the global degrees of freedom with
/// their "blocks" and their indices (row/column numbers) in those
/// blocks. By default we're assuming that all elements in the 
/// \c Problem's global \c Mesh are of the same type.
/// Does nothing if the block preconditioner acts as
/// a subsidiary block preconditioner within a master preconditoner.
//=============================================================================
 template<typename MATRIX>
 void BlockPreconditioner<MATRIX>::block_setup(Problem* problem_pt)
 {

  // if the preconditioner is a subsidiary block preconditioner
  // we're done, as all the lookup schemes will be computed and
  // maintained by the master block preconditioner.
  if (Master_block_preconditioner_pt != 0) return;
  
  // How many meshes to we have?
  unsigned n_mesh=Mesh_pt.size();
  
  // How many dofs do we have in the original problem?
  Nrow=problem_pt->ndof();
  
  // Set Mesh_pt to the Problem' Mesh if nobody has made any
  // other assigment
  if (n_mesh==0) 
   {
    Mesh_pt.push_back(problem_pt->mesh_pt());
    n_mesh=1;
   }
  else if ((n_mesh == 1)&&(Mesh_pt[0]==0))
   {
    Mesh_pt[0] = problem_pt->mesh_pt();
   }
  
#ifdef PARANOID
  for (unsigned i=0;i<n_mesh;i++)
   {
    if (Mesh_pt[i]==0)
       {
        std::ostringstream error_message;
        error_message << "Error: Mesh_pt["<< i << "]=0 \n";
        throw OomphLibWarning(error_message.str(),
                              "BlockPreconditioner::block_setup",
                              OOMPH_EXCEPTION_LOCATION);
       }
     }
    // Vector to keep track of previously assigned block numbers
    // to check consistency between multple assignements. 
    Vector<int> previously_assigned_block_number(Nrow,Data::Is_unclassified);
#endif
    
    // Clear any data from previous use of the preconditioner
    Index_in_block.clear();
    Block_number.clear();
    Block_dimension.clear();
    Global_index.clear();
    
    // Create storage for indices in blocks
    Index_in_block.resize(Nrow);
    
    // set Nblock_types to zero
    Nblock_types = 0;

    // Create storage for block numbers
    Block_number.resize(Nrow);
    
    // vector to indicate when we have block data for that degree of freedom
    Vector<bool> got_data(Nrow,false);
    
    // Counter for how many entries we've filled (must be equal to Nrow
    // when we're done!)
    unsigned count = 0;
    
    // Offset for the block type in the overall system.
    // Different meshes contain different block-preconditionable
    // elements -- their blocks are added one after the other...
    unsigned block_offset=0;
    
    // Loop over all meshes
    for (unsigned m=0;m<n_mesh;m++)
     {
      // Number of elements in this mesh
      unsigned n_element = this->Mesh_pt[m]->nelement();
  
      // Find the number of block types that the elements in this mesh
      // are in charge of
      unsigned n_block_in_element=
       this->Mesh_pt[m]->element_pt(0)->nblock_types();
      Nblock_types += n_block_in_element;
   
      Block_dimension.resize(Nblock_types);
      Global_index.resize(Nblock_types);
     
      // Loop over all elements
      for (unsigned e=0;e<n_element;e++)
       {
        // List containing pairs of global equation number and
        // block number for each global dof in an element
        std::list<std::pair<unsigned long,unsigned> > block_lookup_list;

        // Get list of blocks associated with the element's global unknowns
        this->Mesh_pt[m]->element_pt(e)->
         get_block_numbers_for_unknowns(block_lookup_list);
        
        // Loop over all entries in the list
        typedef std::list<std::pair<unsigned long,unsigned> >::iterator IT;
        for (IT it=block_lookup_list.begin();it!=block_lookup_list.end();it++)
         {
          unsigned long global_dof = it->first;
          unsigned block_number = (it->second)+block_offset;
          
          // Have we not allocated this value (recall that we've initialised
          // Block_number with n_block_types, i.e. one larger than it'll ever 
          // be)
          if (!got_data[global_dof])
           {
            // got the data
            got_data[global_dof] = true;

            // Here comes another entry for this block
            Index_in_block[global_dof] = Block_dimension[block_number];
            Block_dimension[block_number]++;
            
            // Store the block number for this global unknown
            Block_number[global_dof] = block_number;

            Global_index[block_number].push_back(global_dof);


#ifdef PARANOID
            // Check consistency of block numbers if assigned multiple times
            if (previously_assigned_block_number[global_dof]<0)
             {
              previously_assigned_block_number[global_dof]=block_number;
             }
            else 
             {
              if (previously_assigned_block_number[global_dof]!=
                  int(block_number))
               {             
                std::ostringstream error_message;
                error_message << "Inconsitency in assigment of block numbers\n"
                              << "Global dof " <<  global_dof
                              << "was previously assigned to block " 
                              << previously_assigned_block_number[global_dof] 
                              << "\nNow it's been reassigned to block "
                              << block_number << "\n";
                throw OomphLibWarning(error_message.str(),
                                      "BlockPreconditioner::nblock_types()",
                                      OOMPH_EXCEPTION_LOCATION);
               }
             }
#endif
            
            // Keep counting for sanity check at the end....
            count++;
           }
         }
        
       }
      
      // About to do the next mesh which contains block preconditionable
      // elements of a different type; all the dofs that these elements are 
      // "in charge of" differ from the ones considered so far. 
      // Bump up the block counter to make sure we're not overwriting
      // anything here
      block_offset+=n_block_in_element;
      
     }
    
#ifdef PARANOID
    // Having looped over all the elements, we should now have allocated
    // a block number and an "index within its block" for each of the
    // Nrow global unknowns: Check!
    if (count!=Nrow)
     {
      std::ostringstream error_message;
      error_message << "After looping over all elements we've \n"
                    << "only assembled block info for " << count
                    << " of " << Nrow << " global degrees of freedom!";
      
      throw OomphLibError(error_message.str(),
                          "BlockPreconditioner::block_setup()",
                          OOMPH_EXCEPTION_LOCATION);
     }
#endif
    
 }


 
//=============================================================================
/// Get the block matrices required for the block preconditioner. 
/// Takes the pointer to the original matrix and a matrix of bools
/// that indicate if a specified sub-block is required
/// for the preconditioning operation. Computes the
/// required block matrices, and stores pointers to them
/// in the matrix block_matrix_pt. If an entry in block_matrix_pt
/// is equal to NULL that sub-block has not been requested and is
/// therefore not available. 
//=============================================================================
 template<typename MATRIX> 
 void BlockPreconditioner<MATRIX>::get_blocks(
  MATRIX* matrix_pt,  DenseMatrix<bool>& required_blocks,
  DenseMatrix<MATRIX*>& block_matrix_pt)
 {

  // Cache number of block types
  const unsigned n_block_types=this->Nblock_types;

#ifdef PARANOID
  // if required blocks matrix is not the correct size then abort
  if ((required_blocks.nrow() != n_block_types) || 
      (required_blocks.ncol() != n_block_types))
   {

    std::ostringstream error_message;
    error_message << "The size of the matrix of bools required_blocks" 
                  << "(which indicates which blocks are required) is not the "
                  << "right size, required_blocks is " 
                  << required_blocks.ncol()
                  << " x " << required_blocks.nrow() << ", whereas it should "
                  << "be " << n_block_types << " x " << n_block_types;
                 

    throw OomphLibError(error_message.str(),
                        "BlockPreconditioner<MATRIX>::get_blocks()",
                        OOMPH_EXCEPTION_LOCATION);
   }
#endif
  
  // resize the matrix of blocks
  block_matrix_pt.resize(n_block_types,n_block_types);
  
  // loops over the blocks
  for (unsigned i = 0; i < n_block_types; i++)
  {

    for (unsigned j = 0; j < n_block_types; j++)
     {

      // if block(i,j) is required then
      if (required_blocks(i,j))
       {
        
        get_block(i,j,matrix_pt,block_matrix_pt(i,j));

       }
      // if the block is not required then set pointer to null
      else
       {
        block_matrix_pt(i,j) = 0;	
       }
     }
   }
 }



//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////



//============================================================================
/// setup for the block diagonal preconditioner
//============================================================================
 template<typename MATRIX> 
 void BlockDiagonalPreconditioner<MATRIX>::setup(Problem* problem_pt, 
                                                 DoubleMatrixBase* matrix_pt)
 {

  //setup the blocks look up schemes
  this->block_setup(problem_pt);

  // Set the diagonal elements of required block to true for block diagonal
  // preconditioner
  DenseMatrix<bool> required_blocks(this->Nblock_types,this->Nblock_types,
                                    false); 
  for (unsigned i = 0; i < this->Nblock_types; i++)
   {
    required_blocks(i,i) = true;
   }

  // Need to recast here -- input type is determined by specs in
  // base class.
  MATRIX* cast_matrix_pt=dynamic_cast<MATRIX*>(matrix_pt);
  
#ifdef PARANOID
  if (cast_matrix_pt==0)
   {
    throw OomphLibError("Wasn't able to cast matrix to specific type.",
                        "BlockDiagonalPreconditioner::setup()",
                        OOMPH_EXCEPTION_LOCATION);
   }
#endif

  DenseMatrix<MATRIX* > block_matrix_pt(this->Nblock_types,
                                        this->Nblock_types,0);

  // Get pointers to the blocks
  this->get_blocks(cast_matrix_pt, required_blocks, block_matrix_pt);

  // LU-decompose the blocks. Now we're ready to apply the preconditioner
  // by back-substitution.
  Diagonal_block_preconditioner_pt.resize(this->Nblock_types);
  for (unsigned i=0;i<this->Nblock_types;i++)
   {
    Diagonal_block_preconditioner_pt[i] = new SuperLU_Preconditioner; 
    Diagonal_block_preconditioner_pt[i]
     ->setup(problem_pt,block_matrix_pt(i,i));
    delete block_matrix_pt(i,i);
    block_matrix_pt(i,i) = 0;
   }
 }
 
//=============================================================================
/// Preconditioner solve for the block diagonal preconditioner
//=============================================================================
 template<typename MATRIX> 
 void BlockDiagonalPreconditioner<MATRIX>::preconditioner_solve(
  const Vector<double>& r, Vector<double>& z)
 {
    // Cache umber of block types
  const unsigned n_block = this->nblock_types();

  // vector of vectors for each section of residual vector
  Vector<Vector<double> > block_r;
  
  // rearrange the vector r into the vector of block vectors block_r
  this->get_block_vectors(r,block_r);

  // solve each diagonal block
  for (unsigned i = 0; i < n_block; i++)
   {
    Diagonal_block_preconditioner_pt[i]->preconditioner_solve(block_r[i],
                                                              block_r[i]);
   }

  // copy solution in block vectors block_r back to z
  this->return_block_vectors(block_r,z);
 }
 
 

////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////



//=============================================================================
/// Setup for the block diagonal preconditioner
//=============================================================================
 template<typename MATRIX> 
 void ExactBlockPreconditioner<MATRIX>::setup(Problem* problem_pt, 
                                              DoubleMatrixBase* matrix_pt)
 {

  // Get number of block types from first element and store it
  if (this->Master_block_preconditioner_pt == 0)
   {
    this->Nblock_types = problem_pt->mesh_pt()->element_pt(0)->nblock_types();
   }

  //setup the blocks look up schemes
  this->block_setup(problem_pt);

  // Set the diagonal elements of required block to true for block diagonal
  // preconditioner
  DenseMatrix<bool> required_blocks(this->Nblock_types,this->Nblock_types,true); 

  // Need to recast here -- input type is determined by specs in
  // base class.
  MATRIX* cast_matrix_pt=dynamic_cast<MATRIX*>(matrix_pt);
  
#ifdef PARANOID
  if (cast_matrix_pt==0)
   {
    throw OomphLibError("Wasn't able to cast matrix to specific type.",
                        "BlockDiagonalPreconditioner::setup()",
                        OOMPH_EXCEPTION_LOCATION);
   }
#endif

  DenseMatrix<MATRIX* > block_matrix_pt(this->Nblock_types,
                                        this->Nblock_types,0);

  // Get pointers to the blocks
  this->get_blocks(cast_matrix_pt, required_blocks, block_matrix_pt);

  // Build the preconditioner matrix
  MATRIX* exact_block_matrix_pt = new MATRIX;
  this->build_preconditioner_matrix(block_matrix_pt,exact_block_matrix_pt);

  // need to delete the matrix of block matrices
  for (unsigned i = 0; i < this->Nblock_types; i++)
   {
    for (unsigned j = 0; j < this->Nblock_types; j++)
     {
      delete block_matrix_pt(i,j);
      block_matrix_pt(i,j) = 0;
     }
   }

  // setup lu preconditioner for the exact block preconditioner matrix
  Exact_block_preconditioner.setup(problem_pt,exact_block_matrix_pt);

  // delete the exact block preconditioner matrix
  delete exact_block_matrix_pt;

 }
 
//=============================================================================
/// Preconditioner solve for the block diagonal preconditioner
//=============================================================================
 template<typename MATRIX> 
 void ExactBlockPreconditioner<MATRIX>::preconditioner_solve(
  const Vector<double>& r, Vector<double>& z)
 {

  // get  the block ordered components of the r vector for this preconditioner
  Vector<double> block_order_r(this->Nrow);
  this->get_block_ordered_preconditioner_vector(r,block_order_r);

  // vector for solution
  Vector<double> block_order_z(this->Nrow);

  // apply the preconditioner
  Exact_block_preconditioner.preconditioner_solve(block_order_r,block_order_z);

  // copy solution back to z vector
  this->return_block_ordered_preconditioner_vector(block_order_z,z);
 }
 
}



#endif
