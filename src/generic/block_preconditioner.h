//LIC// ====================================================================
//LIC// This file forms part of oomph-lib, the object-oriented,
//LIC// multi-physics finite-element library, available
//LIC// at http://www.oomph-lib.org.
//LIC//
//LIC//           Version 0.90. August 3, 2009.
//LIC//
//LIC// Copyright (C) 2006-2009 Matthias Heil and Andrew Hazel
//LIC//
//LIC// This library is free software; you can redistribute it and/or
//LIC// modify it under the terms of the GNU Lesser General Public
//LIC// License as published by the Free Software Foundation; either
//LIC// version 2.1 of the License, or (at your option) any later version.
//LIC//
//LIC// This library is distributed in the hope that it will be useful,
//LIC// but WITHOUT ANY WARRANTY; without even the implied warranty of
//LIC// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//LIC// Lesser General Public License for more details.
//LIC//
//LIC// You should have received a copy of the GNU Lesser General Public
//LIC// License along with this library; if not, write to the Free Software
//LIC// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
//LIC// 02110-1301  USA.
//LIC//
//LIC// The authors may be contacted at oomph-lib@maths.man.ac.uk.
//LIC//
//LIC//====================================================================
//Include guards
#ifndef OOMPH_BLOCK_PRECONDITION_HEADER
#define OOMPH_BLOCK_PRECONDITION_HEADER


// Config header generated by autoconfig
#ifdef HAVE_CONFIG_H
#include <oomph-lib-config.h>
#endif

// c++ include
// #include <list>
#include <math.h>
#include <typeinfo>

// oomph-lib includes
#include "matrices.h"
#include "mesh.h"
// #include "problem.h"
#include "preconditioner.h"
#include "SuperLU_preconditioner.h"
#include "matrix_vector_product.h"

namespace oomph
{

 //============================================================================
 /// Block Preconditioner base class. The block structure of the
 /// overall problem is determined from the \c Mesh's constituent
 /// elements. Each constituent element must be block-preconditionable - i.e
 /// must implement the \c GeneralisedElemens functions \c nblock_types() and
 /// get_block_numbers_for_unknowns(...). A \c Problem can have several
 /// \c Meshes, but each \c Mesh can only contain a single type of element.
 /// The association between global degrees of freedom and their unique global
 /// dof numbers is therefore based on information provided by the elements.
 /// \n\n
 /// By default each type of DOF is assumed to be unqiue type of block,
 /// but DOF types can be grouped together in a single block when
 /// block_setup(...) is called.
 /// \n\n
 /// This class can function in one of two ways. Either it acts as a
 /// stand-alone block preconditioner which computes and stores
 /// the association between global degrees of freedom and their unique global
 /// block numbers itself. Alternatively, the block preconditioner can act as
 /// a subsidiary block preconditioner within a (larger) master block
 /// preconditioner (pointed to by Master_block_preconditioner_pt).
 /// The master block preconditioner
 /// must have an equal or greater number of block types. Examples
 /// are the FSI precondititioner which is the 3x3 "master block preconditioner"
 /// for the Navier-Stokes preconditioners which deals with the
 /// 2x2 fluid-blocks within the overall structure. In this case, \b only
 /// the master block preconditioner computes and stores the master
 /// lookup schemes. All block preconditioners compute and store their own
 /// optimised lookup schemes.
 /// \n\n
 /// In cases where a \c Problem contains elements of different element types
 /// (e.g. fluid and solid elements in a fluid-structure interaction problem),
 /// access to the elements of the same type must be provided via pointers to
 /// (possibly auxiliary) \c Meshes that only contain elements of a single
 /// type. The block preconditioner will then create global block
 /// numbers by concatenating the block types. Consider, e.g. a fluid-structure
 /// interaction problem in which the first \c Mesh contains (fluid)
 /// elements whose degrees of freedom have been subdivided into
 /// types "0" (the velocity, say) and "1" (the pressure say), while
 /// the second \c Mesh contains (solid) elements whose degrees of freedom
 /// are the nodal displacements, classified as its type "0".
 /// The combined block preconditioner then has three "block types":
 /// "0": Fluid velocity, "1": Fluid pressure, "2": Solid nodal positions.
 /// NOTE: currently this preconditioner uses the same communicator as the
 /// underlying problem. We may need to change this in the future.
 //============================================================================
 template<typename MATRIX>
 class BlockPreconditioner : public Preconditioner
 {
  public:

  /// \short Constructor
  BlockPreconditioner()
   : Block_distribution_pt(0), Ndof_types_in_mesh(0),
     Preconditioner_matrix_distribution_pt(0)
  {
   // Initially set the master block preconditioner pointer to zero
   // indicating that this is stand-alone preconditioner that will
   // set up its own block lookup schemes etc.
   Master_block_preconditioner_pt = 0;

   // Initialise number of rows in this block preconditioner.
   // This information is maintained if used as subsidiary or
   // stand-alone block preconditoner (in the latter case it
   // obviously stores the number of rows within the subsidiary
   // preconditioner
   Nrow=0;

   // Initialise number of different block types in this preconditioner.
   // This information is maintained if used as subsidiary or
   // stand-alone block preconditoner (in the latter case it
   // obviously stores the number of rows within the subsidiary
   // preconditioner
   Nblock_types=0;
   Ndof_types=0;
   
   // No preconditioner blocks has been computed yet.
   Preconditioner_blocks_have_been_precomputed = false;
   Precomputed_block_distribution_pt.resize(0);

   // Clear the Block_to_block_map
   Block_to_block_map.clear();
  }

  /// Destructor
  virtual ~BlockPreconditioner()
  {
   // Delete any existing precomputed block distributions.
   unsigned n_existing_precom_block_dist 
     = Precomputed_block_distribution_pt.size();
    for (unsigned dist_i = 0; dist_i < n_existing_precom_block_dist; dist_i++) 
    {
      delete Precomputed_block_distribution_pt[dist_i];
    }

    Precomputed_block_distribution_pt.clear();

   this->clear_block_preconditioner_base();
  }

  /// Broken copy constructor
  BlockPreconditioner(const BlockPreconditioner&)
  {
   BrokenCopy::broken_copy("BlockPreconditioner");
  }

  /// Broken assignment operator
  void operator=(const BlockPreconditioner&)
  {
   BrokenCopy::broken_assign("BlockPreconditioner");
  }

  /// \short Access function to matrix_pt. Cast the matrix pointer to
  /// MATRIX*, error check and return.
  MATRIX* matrix_pt() const
  {
   MATRIX* m_pt = dynamic_cast<MATRIX*>(Preconditioner::matrix_pt());
#ifdef PARANOID
   if(m_pt == 0)
    {
     std::ostringstream error_msg;
     error_msg << "Matrix is not correct type.";
     throw OomphLibError(error_msg.str(),
                         OOMPH_CURRENT_FUNCTION,
                         OOMPH_EXCEPTION_LOCATION);
    }
#endif
   return m_pt;
  }


  /// \short Function to turn this preconditioner into a
  /// subsidiary preconditioner that operates within a bigger
  /// "master block preconditioner (e.g. a Navier-Stokes 2x2 block
  /// preconditioner dealing with the fluid sub-blocks within a
  /// 3x3 FSI preconditioner. Once this is done the master block
  /// preconditioner deals with the block setup etc. \n
  /// The vector block_map must specify the block number in the
  /// master preconditioner that corresponds to a block number in this
  /// preconditioner.\n
  /// \b 1. The length of the vector is used to determine the number of
  /// blocks in this preconditioner therefore it must be correctly sized. \n
  /// \b 2. block_setup(...) should be called in the master preconditioner
  /// before this method is called. \n
  /// \b 3. block_setup(...) should be called in the corresponding subsidiary
  /// preconditioner after this method is called.
  void turn_into_subsidiary_block_preconditioner
  (BlockPreconditioner<MATRIX>* master_block_prec_pt,
   Vector<unsigned>& block_map);

  /// \short Specify the number of meshes required by this block
  /// preconditioner.\n
  /// Note: elements in different meshes correspond to different types
  /// of DOF.
  void set_nmesh(const unsigned& n)
  {
#ifdef PARANOID
   // Check that this preconditioner is not a subsidiary
   if(is_subsidiary_block_preconditioner())
    {
     std::string err_msg;
     err_msg = "Tried to set nmesh in subsidiary preconditioner but subsidiary";
     err_msg += "but subsidiary preconditioners do not store meshes.";
     throw OomphLibError(err_msg, OOMPH_CURRENT_FUNCTION, 
                         OOMPH_EXCEPTION_LOCATION);
    }
#endif
   Mesh_pt.resize(n,0);
   Allow_multiple_element_type_in_mesh.resize(n,0);
  }


  /// Set the i-th mesh for this block preconditioner.
  /// Note:\n
  /// The method set_nmesh(...) must be called before this method
  /// to specify the number of meshes.\n
  /// By default, it is assumed that each mesh only contains elements of the 
  /// same type. This condition may be relaxed by setting the boolean
  /// multiple_element_type_in_mesh to true, however, each mesh must only 
  /// contain elements with the same number of types of DOF.
  void set_mesh(const unsigned& i, const Mesh* const mesh_pt,
                const bool &allow_multiple_element_type_in_mesh = false)
  {
#ifdef PARANOID
   // paranoid check that mesh i can be set
   if (i >= nmesh())
    {
     std::ostringstream err_msg;
     err_msg
      << "The mesh pointer has space for " << nmesh()
      << " meshes.\n" << "Cannot store a mesh at entry " << i << "\n"
      << "Has set_nmesh(...) been called?";
     throw OomphLibError(err_msg.str(),
                         OOMPH_CURRENT_FUNCTION,
                         OOMPH_EXCEPTION_LOCATION);
    }

   // Check that the mesh pointer is not null.
   if(mesh_pt == 0)
    {
     std::ostringstream err_msg;
     err_msg
      << "The mesh pointer is null.";
     throw OomphLibError(err_msg.str(),
                         OOMPH_CURRENT_FUNCTION,
                         OOMPH_EXCEPTION_LOCATION);
    }

   // Check that this preconditioner is not a subsidiary
   if(is_subsidiary_block_preconditioner())
    {
     std::string err_msg;
     err_msg = "Tried to set a mesh in subsidiary preconditioner but subsidiary";
     err_msg += "but subsidiary preconditioners do not store meshes.";
     throw OomphLibError(err_msg, OOMPH_CURRENT_FUNCTION, 
                         OOMPH_EXCEPTION_LOCATION);
    }
#endif

   // store the mesh pt and n dof types
   Mesh_pt[i]=mesh_pt;

   // Does this mesh contain multiple element types?
   Allow_multiple_element_type_in_mesh[i] 
     = unsigned(allow_multiple_element_type_in_mesh);
  }

  /// \short Determine the size of the matrix blocks and setup the
  /// lookup schemes relating the global degrees of freedom with
  /// their "blocks" and their indices (row/column numbers) in those
  /// blocks.\n
  /// The distributions of the preconditioner and the blocks are
  /// automatically specified (and assumed to be uniform) at this
  /// stage.\n
  /// This method should be used if each DOF type corresponds to a
  /// unique block type.
  virtual void block_setup();

  /// \short Determine the size of the matrix blocks and setup the
  /// lookup schemes relating the global degrees of freedom with
  /// their "blocks" and their indices (row/column numbers) in those
  /// blocks.\n
  /// The distributions of the preconditioner and the blocks are
  /// automatically specified (and assumed to be uniform) at this
  /// stage.\n
  /// This method should be used if each any block contains more than one
  /// type of DOF. The argument vector dof_to_block_map should be of length
  /// ndof. Each element should contain an integer indicating the block number
  /// corresponding to that type of DOF.
  void block_setup(Vector<unsigned>& dof_to_block_map);

  /// \short Put block (i,j) into output_matrix.
  ///
  /// If the preconditioner blocks for this preconditioner has
  /// been precomputed (Preconditioner_blocks_have_been_precomputed is
  /// true), then this function calls get_precomputed_block(...), otherwise
  /// get_block_from_original_matrix(...) is called.
  void get_block(const unsigned& i, const unsigned& j,
                 MATRIX& output_matrix) const
  {
   // Assume that if the preconditioner blocks have been precomputed, we
   // would want to use them.
   if(Preconditioner_blocks_have_been_precomputed)
    { get_precomputed_block(i, j, output_matrix); }
   else
    { get_block_from_original_matrix(i, j, output_matrix); }
  }

  /// \short Return block (i,j).
  ///
  /// If the preconditioner blocks for this preconditioner has
  /// been precomputed (Preconditioner_blocks_have_been_precomputed is
  /// true), then this function calls get_precomputed_block(...), otherwise
  /// get_block_from_original_matrix(...) is called.
  MATRIX get_block(const unsigned& i, const unsigned& j) const
   {
    MATRIX output_matrix;
    get_block(i, j, output_matrix);
    return output_matrix;
   }


  /// \short Get a block from a different matrix using the blocking scheme
  /// that has already been set up.
  void get_block_other_matrix(const unsigned& i, const unsigned& j,
                              MATRIX* in_matrix_pt,
                              MATRIX& output_matrix)
  {
   MATRIX* backup_matrix_pt = matrix_pt();
   set_matrix_pt(in_matrix_pt);

   get_block(i, j, output_matrix);

   set_matrix_pt(backup_matrix_pt);
  }

  /// \short Get all the block matrices required by the block
  /// preconditioner.  Takes a pointer to a matrix of bools that indicate
  /// if a specified sub-block is required for the preconditioning
  /// operation. Computes the required block matrices, and stores pointers
  /// to them in the matrix block_matrix_pt. If an entry in block_matrix_pt
  /// is equal to NULL on return, that sub-block has not been requested and
  /// is therefore not available.
  ///
  /// WARNING: the matrix pointers are created using new so you must delete
  /// them all manually!
  ///
  /// WARNING 2: the matrix pointers in block_matrix_pt MUST be null
  /// because Richard in all his wisdom decided to call delete on any
  /// non-null pointers. Presumably to avoid fixing his memory leaks
  /// properly...
  void get_blocks(DenseMatrix<bool>& required_blocks,
                  DenseMatrix<MATRIX*>& block_matrix_pt) const;
 
  /// \short Takes the naturally ordered vector and rearranges it into a
  /// vector of sub vectors corresponding to the blocks, so s[b][i] contains
  /// the i-th entry in the vector associated with block b.
  /// Note: If the preconditioner is a subsidiary preconditioner then only the
  /// sub-vectors associated with the blocks of the subsidiary preconditioner
  /// will be included. Hence the length of v is master_nrow() whereas the
  /// total length of the s s vectors is Nrow.
  /// NOTE: If the preconditioner blocks are precomputed, then this function
  /// calls get_block_vectors_with_precomputed_block_ordering(...),
  /// otherwise get_block_vector_with_original_matrix_ordering(...) is called.
  void get_block_vectors(const DoubleVector& v,
                         Vector<DoubleVector >& s) const;

  /// \short Takes the vector of block vectors, s, and copies its entries into
  /// the naturally ordered vector, v. If this is a subsidiary block
  /// preconditioner only those entries in v that are associated with its
  /// blocks are affected.
  /// NOTE: If the preconditioner blocks are precomputed, then this function
  /// calls return_block_vectors_with_precomputed_block_ordering(...),
  /// otherwise return_block_vector_with_original_matrix_ordering(...) 
  /// is called.
  void return_block_vectors(const Vector<DoubleVector >& s,
                            DoubleVector& v) const;
  
  /// \short Takes the naturally ordered vector, v and returns the n-th
  /// block vector, b. Here n is the block number in the current
  /// preconditioner. If blocks for this preconditioner has been precomputed
  /// then this function calls the function get_precomputed_block_vector(...).
  /// Otherwise it calls get_block_vector_from_original_matrix(...).
  void get_block_vector(const unsigned& n, const DoubleVector& v,
                        DoubleVector& b) const;

  /// \short Takes the n-th block vector, b, and copies its entries
  /// to the appropriate entries in the naturally ordered vector, v, either
  /// by calling return_block_vector_with_precomputed_block_ordering(...)
  /// if the preconditioner blocks have been precomputed or
  /// return_block_vector_with_original_matrix_ordering(...) otherwise.
  /// Here n is the block number in the current block preconditioner.
  /// If the preconditioner is a subsidiary block preconditioner
  /// the other entries in v  that are not associated with it
  /// are left alone.
  void return_block_vector(const unsigned& n,
                           const DoubleVector& b,
                           DoubleVector& v) const;

  /// \short Given the naturally ordered vector, v, return
  /// the vector rearranged in block order in w.
  void get_block_ordered_preconditioner_vector(const DoubleVector& v,
                                               DoubleVector& w) const;

  /// \short Takes the naturally ordered vector, w, and reorders it in block
  /// order. Reordered vector is returned in v. Note: If the preconditioner is
  /// a subsidiary preconditioner then only the components of the vector
  /// associated with the blocks of the subsidiary preconditioner will be
  /// included. Hence the length of w is master_nrow() whereas that of the v
  /// is
  void return_block_ordered_preconditioner_vector(const DoubleVector& w,
                                                  DoubleVector& v) const;

  /// \short Return the number of block types.
  unsigned nblock_types(const bool &real_nblock_types = false) const
  {
   if(real_nblock_types)
    {  
     return Nblock_types;
    }
   else
    {
     if(Preconditioner_blocks_have_been_precomputed)
      {
       return nblock_types_precomputed();
      }
     else
      {
       return Nblock_types;
      }
    }
  }
  /// RAYRAY
  unsigned ndof_types_in_coarse_dof_type(const unsigned& coarse_doftype) const
   {
    if(Preconditioner_blocks_have_been_precomputed)
     {
      return Doftype_to_doftype_map[coarse_doftype].size();
     }
    else
     {
      return 1;
     }
   }

  /// \short Return the total number of DOF types.
  unsigned ndof_types(const bool &real_ndof_types = false) const
  {
    if (is_subsidiary_block_preconditioner())
     {
      if(real_ndof_types || !Preconditioner_blocks_have_been_precomputed)
       {
        return Ndof_types;
       }
      else
       {
        return ndof_types_precomputed();
       }
     }
    else
     {
      unsigned ndof = 0;
      for (unsigned i = 0; i < nmesh(); i++)
       {ndof += ndof_types_in_mesh(i);}
      return ndof;
     }
 
//   if(real_ndof_types)
//    {
//     if (is_subsidiary_block_preconditioner())
//      {
//       return Ndof_types;
//      }
//     else
//      {
//       unsigned ndof = 0;
//       for (unsigned i = 0; i < nmesh(); i++)
//        {ndof += ndof_types_in_mesh(i);}
//       return ndof;
//      }
//    }
//   else
//    {
//     if(Preconditioner_blocks_have_been_precomputed)
//      {
//       return ndof_types_precomputed();
//      }
//     else
//      {
//       if (is_subsidiary_block_preconditioner())
//        {
//         return Ndof_types;
//        }
//       else
//        {
//         unsigned ndof = 0;
//         for (unsigned i = 0; i < nmesh(); i++)
//          {ndof += ndof_types_in_mesh(i);}
//         return ndof;
//        }
//      }
//    }
  }

  /// \short Access to i-th mesh (of the various meshes that contain block
  /// preconditionable elements of the same type). If this is a subsidiary
  /// preconditioner then the master Mesh_pt is used.
  const Mesh* mesh_pt(const unsigned& i) const
  {
   // Get the mesh pointer either from here or from the master
   const Mesh* temp;
   if(is_subsidiary_block_preconditioner())
    {
     temp = master_block_preconditioner_pt()->mesh_pt(i);
    }
   else
    {
     temp = Mesh_pt[i];
    }

#ifdef PARANOID
   if(temp == 0)
    {
     std::ostringstream error_msg;
     error_msg << "Mesh pointer " << i << " is null.";
     throw OomphLibError(error_msg.str(),
                         OOMPH_CURRENT_FUNCTION,
                         OOMPH_EXCEPTION_LOCATION);
    }

   // Warn if any meshes have been set in subsidiary block preconditioners
   // (because they are ignored and could have been set before it became a
   // subsidiary block preconditioner).
   if(is_subsidiary_block_preconditioner() && ! Mesh_pt.empty())
    {
     std::string error_msg = "Meshes have been set in a subsidiary preconditioner!";
     throw OomphLibError(error_msg, OOMPH_CURRENT_FUNCTION,
                         OOMPH_EXCEPTION_LOCATION);
    }
#endif

   return temp;
  }

  /// \short Return the number of meshes in Mesh_pt. If this is a
  /// subsidiary preconditioner then the master Mesh_pt is used.
  unsigned nmesh() const 
  {
#ifdef PARANOID
   if(is_subsidiary_block_preconditioner() && ! Mesh_pt.empty())
    {
     std::string error_msg = "Meshes have been set in a subsidiary preconditioner!";
     throw OomphLibError(error_msg, OOMPH_CURRENT_FUNCTION,
                         OOMPH_EXCEPTION_LOCATION);
    }
#endif

   if(is_subsidiary_block_preconditioner())
    {
     return master_block_preconditioner_pt()->nmesh();
    }
   else
    {
     return Mesh_pt.size();
    }
  }

  /// \short Return the block number corresponding to a global index i_dof.
  int block_number(const unsigned& i_dof) const
  {
   int dn = dof_number(i_dof);
   if (dn == -1)
    {
     return dn;
    }
   else
    {
     return Dof_number_to_block_number_lookup[dn];
    }
  }

  /// \short Return the index in the block corresponding to a global block
  /// number i_dof.
  int index_in_block(const unsigned& i_dof) const
  {

   // the index in the dof block
   unsigned index = index_in_dof(i_dof);

   // the dof block number
   int dof_block_number = dof_number(i_dof);
   if (dof_block_number >= 0)
    {

     // the 'actual' block number
     unsigned blk_number = block_number(i_dof);

     // compute the index in the block
     unsigned j = 0;
     while (int(Block_number_to_dof_number_lookup[blk_number][j]) !=
            dof_block_number)
      {
       index +=
        dof_block_dimension
        (Block_number_to_dof_number_lookup[blk_number][j]);
       j++;
      }

     // and return
     return index;
    }
   return -1;
  }

  /// \short Access function to the block distributions.
  const LinearAlgebraDistribution*
  block_distribution_pt(const unsigned b) const
  {
   return Block_distribution_pt[b];
  }

  /// \short Access function to the distribution of the master
  /// preconditioner. If this preconditioner does not have a master
  /// preconditioner then the distribution of this preconditioner is returned.
  const LinearAlgebraDistribution* master_distribution_pt() const
  {
   if (is_master_block_preconditioner())
    {
     return this->distribution_pt();
    }
   else
    {
     return Master_block_preconditioner_pt->master_distribution_pt();
    }
  }

  /// \short Return the number of DOF types in mesh i.
  unsigned ndof_types_in_mesh(const unsigned& i) const
  {
   // If we have a master preconditioner then ask it for the
   // result. Otherwise if we have calculated the value then return
   // it, if not then get the mesh to calculate it.
   if(is_subsidiary_block_preconditioner())
    {
     return master_block_preconditioner_pt()->ndof_types_in_mesh(i);
    }
   else if(Ndof_types_in_mesh.size() > 0)
    {
     return Ndof_types_in_mesh[i];
    }
   else
    {
     return mesh_pt(i)->ndof_types();
    }
  }

  /// \short Return true if this preconditioner is a subsidiary
  /// preconditioner.
  bool is_subsidiary_block_preconditioner() const
  {return (this->Master_block_preconditioner_pt != 0);}

  /// \short Return true if this preconditioner is the master block
  /// preconditioner.
  bool is_master_block_preconditioner() const
  {return (this->Master_block_preconditioner_pt == 0);}

  /// \short Set the base part of the filename to output blocks to. If it is
  /// set then all blocks will be output at the end of block_setup. If it is
  /// left empty nothing will be output.
  void set_block_output_to_files(const std::string& basefilename)
  {Output_base_filename = basefilename;}

  /// \short Turn off output of blocks (by clearing the basefilename string).
  void disable_block_output_to_files()
  {Output_base_filename.clear();}

  /// \short Test if output of blocks is on or not.
  bool block_output_on() const
  {return Output_base_filename.size() > 0;}

  /// Output all blocks to numbered files. Called at the end of get blocks if
  /// an output filename has been set.
  void output_blocks_to_files(const std::string& basefilename,
                              const unsigned& precision = 8) const
  {
   unsigned nblocks = nblock_types(true);

   for(unsigned i=0; i<nblocks; i++)
    {
     for(unsigned j=0; j<nblocks; j++)
      {
       // Construct the filename.
       std::string filename(basefilename + "_block_"
                            + StringConversion::to_string(i)
                            + "_" + StringConversion::to_string(j));

       // Write out the block.
       get_block(i,j).sparse_indexed_output(filename, precision, true);
      }
    }
  }

  /// \short A helper method to reduce the memory requirements of block
  /// preconditioners. Once the methods get_block(...), get_blocks(...)
  /// and build_preconditioner_matrix(...) have been called in this and
  /// all subsidiary block preconditioners this method can be called to
  /// clean up.
  void post_block_matrix_assembly_partial_clear()
  {
   if (is_master_block_preconditioner())
    {
     Index_in_dof_block_dense.clear();
     Dof_number_dense.clear();
#ifdef OOMPH_HAS_MPI
     Index_in_dof_block_sparse.clear();
     Dof_number_sparse.clear();
     Global_index_sparse.clear();
     Index_in_dof_block_sparse.clear();
     Dof_number_sparse.clear();
#endif
     Dof_dimension.clear();
    }
   Ndof_in_block.clear();
   Dof_number_to_block_number_lookup.clear();
   Block_number_to_dof_number_lookup.clear();
  }

  /// \short Access function to the master block preconditioner pt.
  BlockPreconditioner<MATRIX>* master_block_preconditioner_pt() const
  {
#ifdef PARANOID
   if (is_master_block_preconditioner())
    {
     std::ostringstream error_message;
     error_message << "This block preconditioner does not have "
                   << "a master preconditioner.";
     throw OomphLibError(error_message.str(), OOMPH_CURRENT_FUNCTION,
                         OOMPH_EXCEPTION_LOCATION);
    }
#endif
   return Master_block_preconditioner_pt;
  }

  /// \short Clears all BlockPreconditioner data. Called by the destructor
  /// and the block_setup(...) methods
  void clear_block_preconditioner_base()
  {

   // clear the Distributions
   this->clear_distribution();
   unsigned nblock = Block_distribution_pt.size();
   for (unsigned b = 0; b < nblock; b++)
    {
     delete Block_distribution_pt[b];
    }
   Block_distribution_pt.resize(0);

   // clear the global index
   Global_index.clear();

   // call the post block matrix assembly clear
   this->post_block_matrix_assembly_partial_clear();

#ifdef OOMPH_HAS_MPI
   // storage if the matrix is distributed
   unsigned nr = Rows_to_send_for_get_block.nrow();
   unsigned nc = Rows_to_send_for_get_block.ncol();
   for (unsigned p = 0; p < nc; p++)
    {
     delete[] Rows_to_send_for_get_ordered[p];
     delete[] Rows_to_recv_for_get_ordered[p];
     for (unsigned b = 0; b < nr; b++)
      {
       delete[] Rows_to_recv_for_get_block(b,p);
       delete[] Rows_to_send_for_get_block(b,p);
      }
    }
   Rows_to_recv_for_get_block.resize(0,0);
   Nrows_to_recv_for_get_block.resize(0,0);
   Rows_to_send_for_get_block.resize(0,0);
   Nrows_to_send_for_get_block.resize(0,0);
   Rows_to_recv_for_get_ordered.clear();
   Nrows_to_recv_for_get_ordered.clear();
   Rows_to_send_for_get_ordered.clear();
   Nrows_to_send_for_get_ordered.clear();

#endif

   // zero
   if (is_master_block_preconditioner())
    {
     Nrow = 0;
     Ndof_types = 0;
     Nblock_types = 0;
    }

   // delete the prec matrix dist pt
   delete Preconditioner_matrix_distribution_pt;
   Preconditioner_matrix_distribution_pt = 0;
  }

  /// \short debugging method to document the setup.\n
  /// Should only be called after block_setup(...).
  void document()
  {
   oomph_info << std::endl;
   oomph_info << "===========================================" << std::endl;
   oomph_info << "Block Preconditioner Documentation" << std::endl
              << std::endl;
   oomph_info << "Number of DOF types: " << ndof_types(true) << std::endl;
   oomph_info << "Number of block types: " << nblock_types(true) << std::endl;
   oomph_info << std::endl;
   if (is_subsidiary_block_preconditioner())
    {
     for (unsigned d = 0; d < Ndof_types; d++)
      {
       oomph_info << "Master DOF number " << d << " : "
                  << this->master_dof_number(d) << std::endl;
      }
    }
   oomph_info << std::endl;
   for (unsigned b = 0; b < nblock_types(true); b++)
    {
     oomph_info << "Block " << b << " DOF types:";
     for (unsigned i = 0; i < Block_number_to_dof_number_lookup[b].size();
          i++)
      {
       oomph_info << " " << Block_number_to_dof_number_lookup[b][i];
      }
     oomph_info << std::endl;
    }
   oomph_info << std::endl;
   oomph_info << "Master block preconditioner distribution:" << std::endl;
   oomph_info << *master_distribution_pt() << std::endl;
   oomph_info << "Preconditioner matrix distribution:" << std::endl;
   oomph_info << *preconditioner_matrix_distribution_pt() << std::endl;
   for (unsigned b = 0; b < Nblock_types; b++)
    {
     oomph_info << "Block " << b << " distribution:" << std::endl;
     oomph_info << *Block_distribution_pt[b] << std::endl;
    }

   // DS: the functions called here no longer exist and this function is
   // never used as far as I can tell, so it should be fine to comment this
   // bit out:
   // if (is_master_block_preconditioner())
   //  {
   //   oomph_info << "First look-up row: " << this->first_lookup_row()
   //              << std::endl;
   //   oomph_info << "Number of look-up rows: "
   //              << this->nlookup_rows() << std::endl;
   //  }
   oomph_info << "===========================================" << std::endl;
   oomph_info << std::endl;
  }

  /// \short Set the precomputed (and possibly modified) preconditioner blocks.
  /// The precomputed_block_pt is a Dense matrix of pointers of precomputed 
  /// blocks for this preconditioner to use in preconditioning.
  /// The doftype_to_doftype_map is a mapping of the doftypes in the master
  /// preconditioner to the doftypes required by THIS preconditioner.
  /// 
  /// \n
  /// 
  /// For example, the Lagrangian preconditioner (in 3D with one constraint) 
  /// has doftypes:
  /// 0  1  2  3  4  5  6 7
  /// ub vb wb uc vc wc p Lc
  /// 
  /// The LSC preconditioner requires u, v, p, then the doftype_to_doftype_map 
  /// will be:
  /// [0 3]
  /// [1 4]
  /// [2 5]
  /// [6]
  /// 
  /// \n
  /// 
  /// This function is called from outside of this preconditioner to set
  /// block matrices to use instead of the block matrices extracted from the
  /// jacobian. A typical use would be if this is a subsidiary preconditioner
  /// and a master preconditioner has to pass down modified blocks for the 
  /// subidiary preconditioner to use.
  void set_precomputed_blocks(
      DenseMatrix<CRDoubleMatrix*>&precomputed_block_pt,
      Vector<Vector<unsigned> > & doftype_to_doftype_map)
  {
#ifdef PARANOID
   // How many block rows are there?
   unsigned precomputed_block_nrow = precomputed_block_pt.nrow();

   // Ensure that a square block matrix is given.
   if(precomputed_block_nrow != precomputed_block_pt.ncol())
    {
     std::ostringstream error_message;
     error_message << "The number of block rows and block columns are "
                   << "not the same." << std::endl;
     throw OomphLibError(error_message.str(),
                         OOMPH_CURRENT_FUNCTION,
                         OOMPH_EXCEPTION_LOCATION);
    }

   // Check that this is the most fine grain .
   if(precomputed_block_nrow != this->ndof_types(true))
    {
     std::ostringstream error_message;
     error_message << "This must be the most fine grain block matrix.\n"
                   << "It must have ndof_types number of rows / columns.\n"
                   << "You have given me a " << precomputed_block_nrow
                   << " by " << precomputed_block_nrow << " matrix.\n"
                   << "I want a " << ndof_types(true) << " by "
                   << ndof_types(true)
                   << " matrix." << std::endl;
     throw OomphLibError(error_message.str(),
                         OOMPH_CURRENT_FUNCTION,
                         OOMPH_EXCEPTION_LOCATION);
    }

   // Check that all matrices have been set and have been built.
   for (unsigned block_row_i = 0; block_row_i < precomputed_block_nrow;
        block_row_i++)
    {
     for (unsigned block_col_i = 0; block_col_i < precomputed_block_nrow;
          block_col_i++)
      {
       // Check that the block matrix has been set.
       if(precomputed_block_pt(block_row_i,block_col_i) == 0)
        {
         std::ostringstream error_message;
         error_message << "Block (" << block_row_i
                       << "," << block_col_i << ")"
                       << " is NULL." << std::endl;
         throw OomphLibError(error_message.str(),
                             OOMPH_CURRENT_FUNCTION,
                             OOMPH_EXCEPTION_LOCATION);
        }

       // Check that the block matrix has been built.
       if(!precomputed_block_pt(block_row_i,block_col_i)->built())
        {
         std::ostringstream error_message;
         error_message << "Block (" << block_row_i
                       << "," << block_col_i << ")"
                       << " is not built." << std::endl;
         throw OomphLibError(error_message.str(),
                             OOMPH_CURRENT_FUNCTION,
                             OOMPH_EXCEPTION_LOCATION);
        }
      }
    }

   // Check that the size of all matrices "make sense".
   // First do the rows.
   for (unsigned block_row_i = 0; block_row_i < precomputed_block_nrow;
        block_row_i++)
    {

     // Note that we are checking this against the dof block dimensions in
     // this preconditioner. Thus at the same time we check if this is the
     // dimension this preconditioner expects.
     unsigned current_block_row_nrow
      = this->dof_block_dimension(block_row_i);

     // Loop through the columns
     for(unsigned block_col_i = 0; block_col_i < precomputed_block_nrow;
         block_col_i++)
      {
       // Get the global row of this block.
       unsigned current_block_nrow = precomputed_block_pt(block_row_i,
                                                    block_col_i)->nrow();
       if(current_block_row_nrow != current_block_nrow)
        {
         std::ostringstream error_message;
         error_message << "Block (" << block_row_i
                       << "," << block_col_i << ")"
                       << " does not have the correct number of rows."
                       << std::endl;
         throw OomphLibError(error_message.str(),
                             OOMPH_CURRENT_FUNCTION,
                             OOMPH_EXCEPTION_LOCATION);
        }
      }
    }

   // Now check the columns
   for(unsigned block_col_i = 0; block_col_i < precomputed_block_nrow;
       block_col_i++)
    {
     // Get the number of columns for this block column
     unsigned current_block_col_ncol
      = precomputed_block_pt(0,block_col_i)->ncol();

     // Loop through the rows
     for(unsigned block_row_i = 0; block_row_i < precomputed_block_nrow;
         block_row_i++)
      {
       // Get the number of columns for this block.
       unsigned current_block_ncol = precomputed_block_pt(block_row_i,
                                                    block_col_i)->ncol();
       if(current_block_col_ncol != current_block_ncol)
        {
         std::ostringstream error_message;
         error_message << "Block (" << block_row_i
                       << "," << block_col_i << ")"
                       << " does not have the correct number of columns."
                       << std::endl;
         throw OomphLibError(error_message.str(),
                             OOMPH_CURRENT_FUNCTION,
                             OOMPH_EXCEPTION_LOCATION);
        }
      }
    }

   // This function should be used only by master preconditioners to pass
   // blocks to this subsidiary preconditioner. If this is a master, then we
   // warn the using.
   if(is_master_block_preconditioner())
    {
     std::ostringstream warning_message;
     warning_message << "Warning: This is a master preconditioner\n"
                     << "This function should not be called." << std::endl;
     throw OomphLibWarning(warning_message.str(),
                           OOMPH_CURRENT_FUNCTION,
                           OOMPH_EXCEPTION_LOCATION);
    }


   // Checks for doftype_to_doftype_map
   // No more than ndof types described, 
   // and check that all entries are unique.
   std::set<unsigned> doftype_map_set;

   unsigned doftype_to_doftype_map_size = doftype_to_doftype_map.size();
   for (unsigned i = 0; i < doftype_to_doftype_map_size; i++)
    {
     unsigned doftype_to_doftype_map_i_size = doftype_to_doftype_map[i].size();
     for (unsigned j = 0; j < doftype_to_doftype_map_i_size; j++)
      {
       std::set<unsigned>::iterator doftype_map_it;
       std::pair<std::set<unsigned>::iterator,bool> doftype_map_ret;

       doftype_map_ret = doftype_map_set.insert(doftype_to_doftype_map[i][j]);
         
       if(!doftype_map_ret.second)
        {
         std::ostringstream error_message;
         error_message << "Error: the doftype number "
                       << doftype_to_doftype_map[i][j]
                       << " is already inserted."
                       << std::endl;
         throw OomphLibError(error_message.str(),
                             OOMPH_CURRENT_FUNCTION,
                             OOMPH_EXCEPTION_LOCATION);
        }
      }
    }
     
   // All doftype described in doftype_to_doftype_map must be unique.
   if(precomputed_block_nrow != doftype_map_set.size())
    {
     std::ostringstream error_message;
     error_message << "Error: all doftypes must be assigned. \n"
                   << "Only " << doftype_map_set.size()
                   << " doftypes have been assigned."
                   << std::endl;
     throw OomphLibError(error_message.str(),
                         OOMPH_CURRENT_FUNCTION,
                         OOMPH_EXCEPTION_LOCATION);
    }

#endif
    
   // Set the precomputed blocks.
   Precomputed_block_pt = precomputed_block_pt;

   // Set the Doftype_to_doftype_map.
   Doftype_to_doftype_map = doftype_to_doftype_map;

   // Flag indicating that the preconditioner blocks has been precomputed.
   Preconditioner_blocks_have_been_precomputed = true;
  }
/// RAYRAY
 bool preconditioner_blocks_have_been_precomputed() const
  {
   return Preconditioner_blocks_have_been_precomputed;
  }
/// RAYRAY
  DenseMatrix<CRDoubleMatrix*> precomputed_block_pt() const
  {
   return Precomputed_block_pt;
  } 
 // Calls set_precomputed_block(...) with the "identity" doftype_to_doftype_map.
 // See the other set_precomputed_block(...) function for more details.
 void set_precomputed_blocks(DenseMatrix<CRDoubleMatrix*>&precomputed_block_pt)
  {
   unsigned precomputed_block_nrow = precomputed_block_pt.nrow();

   Vector<Vector<unsigned> > doftype_to_doftype_map(precomputed_block_nrow,
                                                Vector<unsigned>(1,0));

   for (unsigned i = 0; i < precomputed_block_nrow; i++) 
    {
     doftype_to_doftype_map[i][0] = i;
    }

   set_precomputed_blocks(precomputed_block_pt,doftype_to_doftype_map);
  }

  /// \short the number of blocks precomputed. If the preconditioner blocks are
  /// precomputed then it should be the same as the nblock_types 
  /// REQUIRED by this preconditioner.
  unsigned nblock_types_precomputed() const
  {
   return Block_to_block_map.size();
  }

  /// \short the number of dof types precomputed. 
  /// If the preconditioner blocks are precomputed then it should be the same 
  /// as the ndof_types REQUIRED by this preconditioner.
  unsigned ndof_types_precomputed() const
  {
   return Doftype_to_doftype_map.size();
  }

  /// \short Setup a matrix vector product.
  /// The distribution of the block column must be the same as the 
  /// RHS vector being solved. By default, OOMPH-LIB's uniform row distribution
  /// is employed. When blocks are precomputed, this is no longer true, the RHS
  /// vector is now a concatenation of the corresponding block distributions.
  /// To solve this problem, we have stored the precomputed block distributions
  /// which are available for such instances!
  void setup_matrix_vector_product(MatrixVectorProduct* matvec_prod_pt,
                                   CRDoubleMatrix* block_pt,
                                   unsigned block_col_index)
  {
    if(this->Preconditioner_blocks_have_been_precomputed)
     {
      matvec_prod_pt->setup(block_pt,
                            Precomputed_block_distribution_pt[block_col_index]);
     }
    else
     {
      matvec_prod_pt->setup(block_pt);
     }
  }




 private:

  /// \short Private helper function to check that every element in the block
  /// matrix (i,j) matches the corresponding element in the original matrix
  void block_matrix_test(const unsigned& i,
                         const unsigned& j,
                         const MATRIX* block_matrix_pt) const;


  /// **No comment was on this function** I think it is some kind of binary
  /// search in the vector vec for value el, it looks like it returns -1 for a
  /// failure - David.
  int get_index_of_element(const Vector<unsigned>& vec, const unsigned el) const
  {
   int lo = 0;
   int hi = vec.size();
   int mid = (hi+lo)/2;
   while (vec[mid] != el)
    {
     if (vec[mid] < el)
      {
       if (hi==mid) return -1;
       lo = mid;
      }
     else
      {
       if (lo==mid) return -1;
       hi = mid;
      }
     mid = (hi+lo)/2;
    }
   return mid;
  }

 protected:

  /// \short A helper function to return a block vector if the preconditioner
  /// blocks have been precomputed.
  /// Takes the n-th block ordered vector, b, and copies its entries
  /// to the appropriate entries in the naturally ordered vector, v.
  /// Here n is the block number in the current block preconditioner.
  /// If the preconditioner is a subsidiary block preconditioner
  /// the other entries in v  that are not associated with it
  /// are left alone.
  void return_block_vector_with_precomputed_block_ordering(const unsigned& n,
                           const DoubleVector& b,
                           DoubleVector& v) const;

  /// \short A helper function to return a block if no preconditioner blocks
  /// were precomputed.
  /// Takes the n-th block ordered vector, b,  and copies its entries
  /// to the appropriate entries in the naturally ordered vector, v.
  /// Here n is the block number in the current block preconditioner.
  /// If the preconditioner is a subsidiary block preconditioner
  /// the other entries in v  that are not associated with it
  /// are left alone.
  void return_block_vector_with_original_matrix_ordering(const unsigned& n,
                           const DoubleVector& b,
                           DoubleVector& v) const;

  /// \short A helper function, takes the naturally ordered vector, v, 
  /// and extracts the n-th block vector, b. 
  /// Here n is the block number in the current preconditioner. 
  /// NOTE: The ordering of the vector b is the same as the 
  /// ordering of the block matrix from get_precomputed_block(...).
  void get_block_vector_with_precomputed_block_ordering(
    const unsigned& n, const DoubleVector& v, DoubleVector& b) const;

  /// \short A helper function, takes the naturally ordered vector, v, 
  /// and extracts the n-th block vector, b. 
  /// Here n is the block number in the current preconditioner. 
  /// NOTE: The ordering of the vector b is the same as the 
  /// ordering of the block matrix from get_block_from_original_matrix(...).
  void get_block_vector_with_original_matrix_ordering(
    const unsigned& n, const DoubleVector& v, DoubleVector& b) const;

  /// \short A helper function, takes the naturally ordered vector and 
  /// rearranges it into a vector of sub vectors corresponding to the 
  /// PRECOMPUTED blocks, so s[b][i] contains the i-th entry in the vector 
  /// associated with the precomputed block b.
  /// Note: If the preconditioner is a subsidiary preconditioner then only the
  /// sub-vectors associated with the blocks of the subsidiary preconditioner
  /// will be included. Hence the length of v is master_nrow() whereas the
  /// total length of the s vectors is Nrow.
  void get_block_vectors_with_precomputed_block_ordering(
      const DoubleVector& v, Vector<DoubleVector >& s) const;

  /// \short A helper function, takes the naturally ordered vector and 
  /// rearranges it into a vector of sub vectors corresponding to the blocks, 
  /// so s[b][i] contains the i-th entry in the vector associated with block b. 
  /// These blocks and vectors are those corresponding to the original block 
  /// matrix ordering, i.e. there are no precomputed blocks.
  /// Note: If the preconditioner is a subsidiary preconditioner then only the
  /// sub-vectors associated with the blocks of the subsidiary preconditioner
  /// will be included. Hence the length of v is master_nrow() whereas the
  /// total length of the s s vectors is Nrow.
  void get_block_vectors_with_original_matrix_ordering(
      const DoubleVector& v, Vector<DoubleVector >& s) const;

  /// \short A helper function, takes the vector of block vectors, s, 
  /// and copies its entries into the naturally ordered vector, v. 
  /// This function assume that there are nblocks_precomputed block vectors 
  /// and they have the precomputed block ordering. If this is a subsidiary 
  /// block preconditioner only those entries in v that are associated with 
  /// its blocks are affected.
  void return_block_vectors_with_precomputed_block_ordering(
      const Vector<DoubleVector >& s, DoubleVector& v) const;

  /// \short A helper function, takes the vector of block vectors, s, and 
  /// copies its entries into the naturally ordered vector, v. 
  /// The block vectors are assumed to have the ordering of the original 
  /// block matrices. I.e. there are no precomputed blocks. 
  /// If this is a subsidiary block preconditioner only those entries in v 
  /// that are associated with its blocks are affected.
  void return_block_vectors_with_original_matrix_ordering(
      const Vector<DoubleVector >& s, DoubleVector& v) const;

  /// \short Gets block (i,j) from the original matrix, pointed to by
  /// Matrix_pt and returns it in output_block.
  void get_block_from_original_matrix(const unsigned& i, const unsigned& j,
                                      MATRIX& output_block) const;

  /// \short Gets block (i,j) from the Precomputed_block_pt, which is a
  /// DenseMatrix of pointers to precomputed (and possibly modified)
  /// blocks. Necessary concatenation handled by this function and the
  /// result is returned in output_block.
  void get_precomputed_block(const unsigned& i, const unsigned& j,
                             MATRIX& output_block) const;
  
  /// \short Check if any of the meshes are distributed. This is equivalent
  /// to problem.distributed() and is used as a replacement.
  bool any_mesh_distributed() const
  {
#ifdef OOMPH_HAS_MPI
   // is_mesh_distributed() is only available with MPI
   for(unsigned i=0, n=nmesh(); i<n; i++)
    {
     if(mesh_pt(i)->is_mesh_distributed()) { return true; }
    }
#endif
   return false;
  }

  /// \short Return the number of the block associated with global unknown
  /// i_dof. If this preconditioner is a subsidiary block preconditioner then
  /// the block number in the subsidiary block preconditioner is returned. If
  /// a particular global DOF is not associated with this preconditioner then
  /// -1 is returned
  int dof_number(const unsigned& i_dof) const
  {

   if (is_master_block_preconditioner())
    {
#ifdef OOMPH_HAS_MPI
     unsigned first_row = this->distribution_pt()->first_row();
     unsigned nrow_local = this->distribution_pt()->nrow_local();
     unsigned last_row = first_row+nrow_local-1;
     if (i_dof >= first_row && i_dof <= last_row)
      {
       return static_cast<int>(Dof_number_dense[i_dof-first_row]);
      }
     else
      {
       int index = this->get_index_of_element(Global_index_sparse,i_dof);
       if (index >= 0)
        {
         return Dof_number_sparse[index];
        }
      }
     // if we here we couldn't find the i_dof
#ifdef PARANOID
     std::ostringstream error_message;
     error_message
      << "Requested dof_number(...) for global DOF " << i_dof << "\n"
      << "cannot be found.\n";
     throw OomphLibError(
                         error_message.str(),
                         OOMPH_CURRENT_FUNCTION,
                         OOMPH_EXCEPTION_LOCATION);
#endif
#else
     return static_cast<int>(Dof_number_dense[i_dof]);
#endif
    }
   // else this preconditioner  is a subsidiary one, and its Block_number
   // lookup schemes etc haven't been set up
   else
    {
     // Block number in master prec
     unsigned blk_num = Master_block_preconditioner_pt->dof_number(i_dof);

     // Search through the Block_number_in_master_preconditioner for master
     // block blk_num and return the block number in this preconditioner
     for (unsigned i = 0; i < this->ndof_types(true); i++)
      {
       if (Dof_number_in_master_preconditioner[i] == blk_num)
        {return static_cast<int>(i);}
      }
     // if the master block preconditioner number is not found return -1
     return -1;
    }

   // Shouldn't get here
   throw OomphLibError("Never get here\n",
                       OOMPH_CURRENT_FUNCTION,
                       OOMPH_EXCEPTION_LOCATION);
   // Dummy return
   return -1;
  }

  /// \short Return the row/column number of global unknown i_dof within it's
  /// block.
  unsigned index_in_dof(const unsigned& i_dof) const
  {
   if (is_master_block_preconditioner())
    {
#ifdef OOMPH_HAS_MPI
     unsigned first_row = this->distribution_pt()->first_row();
     unsigned nrow_local = this->distribution_pt()->nrow_local();
     unsigned last_row = first_row+nrow_local-1;
     if (i_dof >= first_row && i_dof <= last_row)
      {
       return static_cast<int>(Index_in_dof_block_dense[i_dof-first_row]);
      }
     else
      {
       int index = this->get_index_of_element(Global_index_sparse,i_dof);
       if (index >= 0)
        {
         return Index_in_dof_block_sparse[index];
        }
      }
     // if we here we couldn't find the i_dof
#ifdef PARANOID
     std::ostringstream error_message;
     error_message
      << "Requested index_in_dof(...) for global DOF " << i_dof << "\n"
      << "cannot be found.\n";
     throw OomphLibError(
                         error_message.str(),
                         OOMPH_CURRENT_FUNCTION,
                         OOMPH_EXCEPTION_LOCATION);
#endif
#else
     return Index_in_dof_block_dense[i_dof];
#endif
    }
   else
    {
     return Master_block_preconditioner_pt->index_in_dof(i_dof);
    }

   // Shouldn't get here
   throw OomphLibError("Never get here\n",
                       OOMPH_CURRENT_FUNCTION,
                       OOMPH_EXCEPTION_LOCATION);
   // Dummy return
   return -1;
  }

  /// \short Return the number of degrees of freedom in block b. Note that if
  /// this preconditioner acts as a subsidiary preconditioner then b refers
  /// to the block number in the subsidiary preconditioner not the master
  /// block preconditioner.
  unsigned block_dimension(const unsigned& b) const
  {
   return Block_distribution_pt[b]->nrow();
  }

  /// \short Return the size of the dof "block" i, i.e. how many degrees of
  /// freedom are associated with it. Note that if this preconditioner acts as
  /// a subsidiary preconditioner, then i refers to the block number in the
  /// subsidiary preconditioner not the master block preconditioner
  unsigned dof_block_dimension(const unsigned& i) const
  {

   // I don't understand the difference between this function and
   // block_dimension(...) but I'm not going to mess with it... David

   if(is_master_block_preconditioner())
    {
     return Dof_dimension[i];
    }
   else
    {
     unsigned master_i = master_dof_number(i);
     return Master_block_preconditioner_pt->dof_block_dimension(master_i);
    }
  }

  /// \short Return the number of dofs (number of rows or columns) in the
  /// overall problem. The prefix "master_" is sort of redundant when used as
  /// a stand-alone block preconditioner but is required to avoid ambiguities.
  /// The latter is stored (and maintained) separately for each specific block
  /// preconditioner regardless of its role.
  unsigned master_nrow() const
  {
   if (is_master_block_preconditioner())
    {
     return Nrow;
    }
   else
    {
     return (this->Master_block_preconditioner_pt->master_nrow());
    }
  }

  /// \short Takes the block number within this preconditioner and returns the
  /// corresponding block number in the master preconditioner. If this
  /// preconditioner does not have a master block preconditioner then the
  /// block number passed is returned
  unsigned master_dof_number(const unsigned& b) const
  {
   if (is_master_block_preconditioner())
    return b;
   else
    return Dof_number_in_master_preconditioner[b];
  }

  /// \short access function to the preconditioner matrix distribution pt
  const LinearAlgebraDistribution*
  preconditioner_matrix_distribution_pt() const
  {
   if (is_master_block_preconditioner())
    return Preconditioner_matrix_distribution_pt;
   else
    return this->distribution_pt();
  }

  /// \short Precomputed (and possibly modified) blocks.
  DenseMatrix<CRDoubleMatrix*> Precomputed_block_pt;
  
  /// \short The distribution for precomputed blocks.
  Vector<LinearAlgebraDistribution*> Precomputed_block_distribution_pt;

  /// \short Mapping for blocks passed down from the above preconditioner.
  Vector<Vector<unsigned> > Block_to_block_map;

  /// \short Mapping for doftypes passed down from the above preconditioner.
  Vector<Vector<unsigned> > Doftype_to_doftype_map;

  /// \short Flag indicating if blocks have been precomputed 
  /// (and possibly modified).
  bool Preconditioner_blocks_have_been_precomputed;

  /// \short Storage for the default distribution for each block.
  Vector<LinearAlgebraDistribution*> Block_distribution_pt;

  /// \short Vector of unsigned to indicate which meshes contain multiple
  /// element types.
  Vector<unsigned> Allow_multiple_element_type_in_mesh;

  /// \short Vector of pointers to the meshes containing the elements used in
  /// the block preconditioner. Const pointers to prevent modification of the
  /// mesh by the preconditioner (this could be relaxed if needed).
  Vector<const Mesh*> Mesh_pt;
  
  /// \short Storage for number of types of degree of freedom of the elements
  /// in each mesh.
  Vector<unsigned> Ndof_types_in_mesh;

  /// \short Number of different block types in this preconditioner. Note that
  /// this information is maintained if used as a subsidiary or stand-alone
  /// block preconditoner, in the latter case it stores the number of blocks
  /// within the subsidiary preconditioner.
  unsigned Nblock_types;

  ///\short Number of different dof types in this preconditioner. Note that
  /// this information is maintained if used as a subsidiary or stand-alone
  /// block preconditoner, in the latter case it stores the number of blocks
  /// within the subsidiary preconditioner.
  unsigned Ndof_types;
 
 private:

  /// \short Number of dofs (# of rows or columns in the matrix) in this
  /// preconditioner. Note that this information is maintained if used as a
  /// subsidiary or stand-alone block preconditoner, in the latter case it
  /// stores the number of rows within the subsidiary preconditioner.
  unsigned Nrow;

  /// \short If the block preconditioner is acting a subsidiary block
  /// preconditioner then a pointer to the master preconditioner is stored
  /// here. If the preconditioner does not have a master block preconditioner
  /// then this  pointer remains null.
  BlockPreconditioner<MATRIX>* Master_block_preconditioner_pt;

  /// \short The map between the blocks in the preconditioner and the master
  /// preconditioner. If there is no master preconditioner it remains empty.
  Vector<unsigned> Dof_number_in_master_preconditioner;

  /// \short **This was uncommented** Presumably a non-distributed analogue of
  /// Index_in_dof_block_sparse.
  Vector<unsigned> Index_in_dof_block_dense;

  /// \short Vector to store the mapping from the global dof number to its
  /// block. Empty if this preconditioner has a master preconditioner, in this
  /// case the information is obtained from the master preconditioner.
  Vector<unsigned> Dof_number_dense;

#ifdef OOMPH_HAS_MPI

  // The following three vectors store data on the matrix rows/matrix
  // columns/dofs (the three are equivalent) that are not on this processor.

  /// \short For global indices outside of the range this->first_row()
  /// to this->first_row()+this->nrow_local(), the Index_in_dof_block
  /// and Dof_number are stored sparsely in the vectors:
  /// + Index_in_dof_block_sparse;
  /// + Dof_number_sparse;
  /// The corresponding global indices are stored in this vector.
  Vector<unsigned> Global_index_sparse;

  /// \short Vector to store the mapping from the global dof number to the
  /// index (row/colum number) within its block (empty if this preconditioner
  /// has a master preconditioner as this information is obtained from the
  /// master preconditioner). Sparse version: for global indices outside of the
  /// range this->first_row() to this->first_row()+this->nrow_local(). The
  /// global index of an element in this vector is defined in
  /// Global_index_sparse.
  Vector<unsigned> Index_in_dof_block_sparse;

  /// \short Vector to store the mapping from the global dof number to its
  /// block (empty if this preconditioner has a master preconditioner as this
  /// information is obtained from the master preconditioner). Sparse
  /// version: for global indices outside of the range this->first_row() to
  /// this->first_row()+this->nrow_local(). The global index of an element in
  /// this vector is defined in Global_index_sparse.
  Vector<unsigned> Dof_number_sparse;
#endif

  /// \short Vector containing the size of each block, i.e. the number of
  /// global dofs associated with it. (Empty if this preconditioner has a
  /// master preconditioner as this information is obtain from the master
  /// preconditioner.)
  Vector<unsigned> Dof_dimension;

  /// \short Vectors of vectors for the mapping from block number and block
  /// row to global row number. Empty if this preconditioner has a master
  /// preconditioner as this information is obtain from the master
  /// preconditioner.
  Vector<Vector<unsigned> > Global_index;

  /// \short Vector of vectors to store the mapping from block number to the
  /// dof number (each element could be a vector because we allow multiple
  /// dofs types in a single block).
  Vector<Vector<unsigned> > Block_number_to_dof_number_lookup;

  /// \short Vector to the mapping from dof number to block number.
  Vector<unsigned> Dof_number_to_block_number_lookup;

  /// \short Number of types of degree of freedom associated with each block.
  Vector<unsigned> Ndof_in_block;



#ifdef OOMPH_HAS_MPI
  /// \short The global rows to be sent of block b to processor p (matrix
  /// indexed [b][p]).
  DenseMatrix<int*> Rows_to_send_for_get_block;

  /// \short The number of global rows to be sent of block b to processor p
  /// (matrix indexed [b][p]).
  DenseMatrix<unsigned> Nrows_to_send_for_get_block;

  /// \short The block rows to be received from processor p for block b
  /// (matrix indexed [b][p]).
  DenseMatrix<int*> Rows_to_recv_for_get_block;

  /// \short The number of block rows to be received from processor p for
  /// block b (matrix indexed [b][p]).
  DenseMatrix<unsigned> Nrows_to_recv_for_get_block;

  /// \short The global rows to be sent to processor p for
  /// get_block_ordered_... type methods.
  Vector<int*> Rows_to_send_for_get_ordered;

  /// \short The number global rows to be sent to processor p for
  /// get_block_ordered_... type methods.
  Vector<unsigned> Nrows_to_send_for_get_ordered;

  /// \short The preconditioner rows to be received from processor p for
  /// get_block_ordered_... type methods.
  Vector<int*> Rows_to_recv_for_get_ordered;

  /// \short The number of preconditioner rows to be received from processor
  /// p for get_block_ordered_... type methods.
  Vector<unsigned> Nrows_to_recv_for_get_ordered;
#endif

  /// \short The distribution of the preconditioner matrix - only used if
  /// this preconditioner is a master preconditioner. Warning: always use
  /// the access function preconditioner_matrix_distribution_pt().
  LinearAlgebraDistribution* Preconditioner_matrix_distribution_pt;

  /// \short Static boolean to allow block_matrix_test(...) to be run.
  /// Defaults to false.
  static bool Run_block_matrix_test;

  /// \short String giving the base of the files to write block data into. If
  /// empty then do not output blocks. Default is empty.
  std::string Output_base_filename;
 };


}
#endif
