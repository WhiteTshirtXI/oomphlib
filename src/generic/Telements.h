//LIC// ====================================================================
//LIC// This file forms part of oomph-lib, the object-oriented, 
//LIC// multi-physics finite-element library, available 
//LIC// at http://www.oomph-lib.org.
//LIC// 
//LIC//           Version 0.85. June 9, 2008.
//LIC// 
//LIC// Copyright (C) 2006-2008 Matthias Heil and Andrew Hazel
//LIC// 
//LIC// This library is free software; you can redistribute it and/or
//LIC// modify it under the terms of the GNU Lesser General Public
//LIC// License as published by the Free Software Foundation; either
//LIC// version 2.1 of the License, or (at your option) any later version.
//LIC// 
//LIC// This library is distributed in the hope that it will be useful,
//LIC// but WITHOUT ANY WARRANTY; without even the implied warranty of
//LIC// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//LIC// Lesser General Public License for more details.
//LIC// 
//LIC// You should have received a copy of the GNU Lesser General Public
//LIC// License along with this library; if not, write to the Free Software
//LIC// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
//LIC// 02110-1301  USA.
//LIC// 
//LIC// The authors may be contacted at oomph-lib@maths.man.ac.uk.
//LIC// 
//LIC//====================================================================
//Header functions for classes that define Telements
#ifndef OOMPH_TELEMENT_HEADER
#define OOMPH_TELEMENT_HEADER

// Config header generated by autoconfig
#ifdef HAVE_CONFIG_H
  #include <oomph-lib-config.h>
#endif

//oomph-lib headers
#include "Vector.h"
#include "shape.h"
#include "integral.h"
#include "elements.h"

namespace oomph
{
//========================================================================
/// A class for those member functions that must be fully specialised
/// for the Telements. The fact that member functions of partially
/// specialised classes cannot necessarily be fully specialised 
/// means that we must either fully specialise every class, or use this
/// base class to fully specialize only those functions that are required.
//========================================================================
template<unsigned DIM, unsigned NNODE_1D>
 class TElementShape { };

/////////////////////////////////////////////////////////////////////////
/// TElementShape inline functions:
/////////////////////////////////////////////////////////////////////////
template<>
 class TElementShape<1,2>
 {
   public:

//=======================================================================
/// Return local coordinates of node j
//=======================================================================
  void local_coordinate_of_node(const unsigned& j,
                                Vector<double>& s)
   {
    s.resize(1);
    switch (j)
     {
     case 0:
      s[0]=0.0;
      break;
      
     case 1:
      s[0]=1.0;
      break;
      
     default:
      std::ostringstream error_message;
      error_message << "Element only has two nodes; called with node number " 
                    << j << std::endl;
      
      throw OomphLibError(error_message.str(),
                          "TElement::local_coordinate_of_node()",
                          OOMPH_EXCEPTION_LOCATION);
     }
   }


//=======================================================================
/// Shape function for specific TElement<1,2>
//=======================================================================
  void shape(const Vector<double> &s, Shape &psi) const
   {
    psi[0] = 1.0 - s[0];
    psi[1] = s[0];
   }
  

//=======================================================================
/// Derivatives of shape functions for specific TElement<2,2>
//=======================================================================
  void dshape_local(const Vector<double> &s,
                    Shape &psi, DShape &dpsids) const
   {
    this->shape(s, psi);
    
    // Derivatives
    dpsids(0,0) = -1.0;
    dpsids(1,0) = 1.0;
   }
  
  
//=======================================================================
/// Second derivatives of shape functions for specific TElement<1,2>:
/// d2psids(i,0) = \f$ \partial^2 \psi_j / \partial s_0^2 \f$ \n
//=======================================================================
  void d2shape_local(const Vector<double> &s, 
                     Shape &psi, 
                     DShape &dpsids, 
                     DShape &d2psids) const
   {
    this->dshape_local(s, psi,dpsids);

    d2psids(0,0) = 0.0;
    d2psids(1,0) = 0.0;
   }
 };


template<>
 class TElementShape<1,3>
 {
   public:
//=======================================================================
/// Return local coordinates of node j
//=======================================================================
  void local_coordinate_of_node(const unsigned& j,
                                Vector<double>& s)
   {
    s.resize(1);
    switch (j)
     {
     case 0:
      s[0]=0.0;
      break;
      
     case 1:
      s[0]=0.5;
      break;
      
     case 2:
      s[0]=1.0;
      break;
      
     default:
      std::ostringstream error_message;
      error_message 
       << "Element only has three nodes; called with node number " 
       << j << std::endl;
      
      throw OomphLibError(error_message.str(),
                          "TElement::local_coordinate_of_node()",
                          OOMPH_EXCEPTION_LOCATION);
     }
   }


//=======================================================================
/// Shape function for specific TElement<1,3>
//=======================================================================
  void shape(const Vector<double> &s, Shape &psi) const
{
 psi[0] = 2.0*(s[0] - 1.0)*(s[0]-0.5);
 psi[1] = 4.0*(1.0-s[0])*s[0];
 psi[2] = 2.0*(s[0] -  0.5)*s[0];
}


//=======================================================================
/// Derivatives of shape functions for specific TElement<1,3>
//=======================================================================
  void dshape_local(const Vector<double> &s,
                    Shape &psi, DShape &dpsids) const
   {
 //ALH: Don't know why object qualifier is needed
 this->shape(s, psi);

 dpsids(0,0) = 4.0*s[0] - 3.0;
 dpsids(1,0) = 4.0 - 8.0*s[0];
 dpsids(2,0) = 4.0*s[0] - 1.0;
}


//=======================================================================
/// Second derivatives of shape functions for specific TElement<2,3>:
/// d2psids(i,0) = \f$ \partial^2 \psi_j / \partial s_0^2 \f$ \n
//=======================================================================
  void d2shape_local(const Vector<double> &s, 
                     Shape &psi, 
                     DShape &dpsids, 
                     DShape &d2psids) const
   {
    //ALH: Don't know why object qualifier is needed
    this->dshape_local(s, psi,dpsids);
    
    d2psids(0,0) = 4.0;
    d2psids(1,0) = -8.0;
    d2psids(2,0) = 4.0;
   }

 };

template<>
 class TElementShape<1,4>
 {
   public:
//=======================================================================
/// Return local coordinates of node j
//=======================================================================
  void local_coordinate_of_node(const unsigned& j,
                                Vector<double>& s)
   {
    s.resize(1);
    switch (j)
  {
  case 0:
   s[0]=0.0;
   break;

  case 1:
   s[0]=(1.0/3.0);
   break;

  case 2:
   s[0]=(2.0/3.0);
   break;

  case 3:
   s[0]=1.0;
   break;

  default:
   std::ostringstream error_message;
   error_message << "Element only has four nodes; called with node number " 
                 << j << std::endl;
   
   throw OomphLibError(error_message.str(),
                       "TElement::local_coordinate_of_node()",
                       OOMPH_EXCEPTION_LOCATION);
  }
}


//=======================================================================
/// Shape function for specific TElement<1,4>
//=======================================================================
void shape(const Vector<double> &s, Shape &psi) const
{
 psi[0] = 0.5*(1.0 - s[0])*(3.0*s[0] -2.0)*(3.0*s[0] - 1.0);
 psi[1] = -4.5*s[0]*(1.0-s[0])*(3.0*s[0] - 2.0);
 psi[2] =  4.5*s[0]*(1.0-s[0])*(3.0*s[0] - 1.0);
 psi[3] = 0.5*s[0]*(3.0*s[0] -2.0)*(3.0*s[0] - 1.0);
}

//=======================================================================
/// Derivatives of shape functions for specific TElement<1,4>
//=======================================================================
 void dshape_local(const Vector<double> &s,
                   Shape &psi, DShape &dpsids) const
{
 //ALH: Don't know why object qualifier is needed
 this->shape(s, psi);
 
 dpsids(0,0) = -13.5*s[0]*s[0] + 18.0*s[0] - 5.5;
 dpsids(1,0) = 40.5*s[0]*s[0] - 45.0*s[0] + 9.0;
 dpsids(2,0) = -40.5*s[0]*s[0] + 36.0*s[0] - 4.5;
 dpsids(3,0) = 13.5*s[0]*s[0] - 9.0*s[0] + 1.0;
}

//=======================================================================
/// Second derivatives of shape functions for specific TElement<2,4>:
/// d2psids(i,0) = \f$ \partial^2 \psi_j / \partial s_0^2 \f$ \n
//=======================================================================
void d2shape_local(const Vector<double> &s,
                   Shape &psi,
                   DShape &dpsids,
                   DShape &d2psids) const
{
 throw OomphLibError("Not checked yet",
                     "TElement::d2shape_local()",
                     OOMPH_EXCEPTION_LOCATION);

 //ALH: Don't know why object qualifier is needed
 this->dshape_local(s, psi,dpsids);
 
 d2psids(0,0) = 0.0;
 d2psids(1,0) = 0.0;
 d2psids(2,0) = 0.0;
 d2psids(3,0) = 0.0;
}
};




template<>
 class TElementShape<2,2>
 {
   public:
//=======================================================================
/// Return local coordinates of node j
//=======================================================================
  void local_coordinate_of_node(const unsigned& j,
                                Vector<double>& s)
   {
    switch (j)
     {
     case 0:
      s[0]=1.0;
      s[1]=0.0;
      break;
      
     case 1:
      s[0]=0.0;
      s[1]=1.0;
      break;
      
     case 2:
      s[0]=0.0;
      s[1]=0.0;
      break;
      
     default:
      std::ostringstream error_message;
      error_message << "Element only has three nodes; called with node number " 
                    << j << std::endl;
      
      throw OomphLibError(error_message.str(),
                          "TElement::local_coordinate_of_node()",
                          OOMPH_EXCEPTION_LOCATION);
     }
   }


//=======================================================================
/// Shape function for specific TElement<2,2>
//=======================================================================
  void shape(const Vector<double> &s, Shape &psi) const
   {
    psi[0] = s[0];
    psi[1] = s[1];
    psi[2] = 1.0-s[0]-s[1];
   }
  

//=======================================================================
/// Derivatives of shape functions for specific TElement<2,2>
//=======================================================================
  void dshape_local(const Vector<double> &s,
                    Shape &psi, DShape &dpsids) const
   {
    this->shape(s, psi);
    
    // Derivatives
    dpsids(0,0) = 1.0;
    dpsids(0,1) = 0.0;
    dpsids(1,0) = 0.0;
    dpsids(1,1) = 1.0;
    dpsids(2,0) = -1.0;
    dpsids(2,1) = -1.0;
   }
  
  
//=======================================================================
/// Second derivatives of shape functions for specific TElement<2,2>:
 /// d2psids(i,0) = \f$ \partial^2 \psi_j / \partial s_0^2 \f$ \n
 /// d2psids(i,1) = \f$ \partial^2 \psi_j / \partial s_1^2 \f$ \n
 /// d2psids(i,2) = \f$ \partial^2 \psi_j / \partial s_0 \partial s_1 \f$ \n
//=======================================================================
  void d2shape_local(const Vector<double> &s, 
                     Shape &psi, 
                     DShape &dpsids, 
                     DShape &d2psids) const
   {
    this->dshape_local(s, psi,dpsids);
    
    for(unsigned i=0;i<3;i++)
     {
      d2psids(i,0) = 0.0;
      d2psids(i,1) = 0.0;
      d2psids(i,2) = 0.0;
     }
   }
 };

template<>
 class TElementShape<2,3>
 {
   public:
//=======================================================================
/// Return local coordinates of node j
//=======================================================================
  void local_coordinate_of_node(const unsigned& j,
                                Vector<double>& s)
   {
    switch (j)
     {
     case 0:
      s[0]=1.0;
      s[1]=0.0;
      break;
      
     case 1:
      s[0]=0.0;
      s[1]=1.0;
      break;
      
     case 2:
      s[0]=0.0;
      s[1]=0.0;
      break;
      
     case 3:
      s[0]=0.5;
      s[1]=0.5;
      break;
      
     case 4:
      s[0]=0.0;
      s[1]=0.5;
      break;
      
     case 5:
      s[0]=0.5;
      s[1]=0.0;
      break;
      
     default:
      std::ostringstream error_message;
      error_message << "Element only has six nodes; called with node number " 
                    << j << std::endl;
      
      throw OomphLibError(error_message.str(),
                          "TElement::local_coordinate_of_node()",
                          OOMPH_EXCEPTION_LOCATION);
     }
   }


//=======================================================================
/// Shape function for specific TElement<2,3>
//=======================================================================
  void shape(const Vector<double> &s, Shape &psi) const
{
 // Reconstruct the third area coordinate
 double s_2=1.0-s[0]-s[1];

 // note that s[2] needs replacing by s_2 everywhere since only 
 // two independent variables s[0],s[1] and s_2 is expressed in terms of those
 // later.
 psi[0] = 2.0*s[0]*(s[0]-0.5);
 psi[1] = 2.0*s[1]*(s[1]-0.5);
 psi[2] = 2.0*s_2 *(s_2 -0.5);
 psi[3] = 4.0*s[0]*s[1];
 psi[4] = 4.0*s[1]*s_2;
 psi[5] = 4.0*s_2*s[0];
}


//=======================================================================
/// Derivatives of shape functions for specific TElement<2,3>
//=======================================================================
  void dshape_local(const Vector<double> &s,
                    Shape &psi, DShape &dpsids) const
   {
 //ALH: Don't know why object qualifier is needed
 this->shape(s, psi);

 dpsids(0,0) = 4.0*s[0]-1.0;
 dpsids(0,1) = 0.0;
 dpsids(1,0) = 0.0;
 dpsids(1,1) = 4.0*s[1]-1.0;
 dpsids(2,0) = 2.0*(2.0*s[0]-1.5+2.0*s[1]);
 dpsids(2,1) = 2.0*(2.0*s[0]-1.5+2.0*s[1]);
 dpsids(3,0) = 4.0*s[1];
 dpsids(3,1) = 4.0*s[0];
 dpsids(4,0) = -4.0*s[1];
 dpsids(4,1) = 4.0*(1.0-s[0]-2.0*s[1]);
 dpsids(5,0) = 4.0*(1.0-2.0*s[0]-s[1]);
 dpsids(5,1) = -4.0*s[0];
}


//=======================================================================
/// Second derivatives of shape functions for specific TElement<2,3>:
/// d2psids(i,0) = \f$ \partial^2 \psi_j / \partial s_0^2 \f$ \n
/// d2psids(i,1) = \f$ \partial^2 \psi_j / \partial s_1^2 \f$ \n
/// d2psids(i,2) = \f$ \partial^2 \psi_j / \partial s_0 \partial s_1 \f$ \n
//=======================================================================
  void d2shape_local(const Vector<double> &s, 
                     Shape &psi, 
                     DShape &dpsids, 
                     DShape &d2psids) const
   {
    //ALH: Don't know why object qualifier is needed
    this->dshape_local(s, psi,dpsids);
    
    d2psids(0,0) = 4.0;
    d2psids(0,1) = 0.0;
    d2psids(0,2) = 0.0;
    
    d2psids(1,0) = 0.0;
    d2psids(1,1) = 4.0;
    d2psids(1,2) = 0.0;
    
    d2psids(2,0) = 4.0;
    d2psids(2,1) = 4.0;
    d2psids(2,2) = 4.0;

    d2psids(3,0) = 0.0;
    d2psids(3,1) = 0.0;
    d2psids(3,2) = 4.0;
    
    d2psids(4,0) = 0.0;
    d2psids(4,1) = -8.0;
    d2psids(4,2) = -4.0;
    
    d2psids(5,0) = -8.0;
    d2psids(5,1) = 0.0;
    d2psids(5,2) = -4.0;
   }
  
 };

template<>
 class TElementShape<2,4>
 {
   public:
//=======================================================================
/// Return local coordinates of node j
//=======================================================================
  void local_coordinate_of_node(const unsigned& j,
                                Vector<double>& s)
   {
    switch (j)
  {
  case 0:
   s[0]=1.0;
   s[1]=0.0;
   break;

  case 1:
   s[0]=0.0;
   s[1]=1.0;
   break;

  case 2:
   s[0]=0.0;
   s[1]=0.0;
   break;

  case 3:
   s[0]=2.0/3.0;
   s[1]=1.0/3.0;
   break;

  case 4:
   s[0]=1.0/3.0;
   s[1]=2.0/3.0;
   break;

  case 5:
   s[0]=0.0;
   s[1]=2.0/3.0;
   break;

  case 6:
   s[0]=0.0;
   s[1]=1.0/3.0;
   break;

  case 8:
   s[0]=2.0/3.0;
   s[1]=0.0;
   break;

  case 7:
   s[0]=1.0/3.0;
   s[1]=0.0;
   break;

  case 9:
   s[0]=1.0/3.0;
   s[1]=1.0/3.0;
   break;

  default:
   std::ostringstream error_message;
   error_message << "Element only has ten nodes; called with node number " 
                 << j << std::endl;
   
   throw OomphLibError(error_message.str(),
                       "TElement::local_coordinate_of_node()",
                       OOMPH_EXCEPTION_LOCATION);
  }
}


//=======================================================================
/// Shape function for specific TElement<2,4>
//=======================================================================
void shape(const Vector<double> &s, Shape &psi) const
{
 psi[0] = 0.5*s[0]*(3.0*s[0]-2.0)*(3.0*s[0]-1.0);
 psi[1] = 0.5*s[1]*(3.0*s[1]-2.0)*(3.0*s[1]-1.0);
 psi[2] = 0.5*(1.0-s[0]-s[1])*(1.0-3.0*s[0]-3.0*s[1])*(2.0-3.0*s[0]-3.0*s[1]);
 psi[3] = 4.5*s[0]*s[1]*(3.0*s[0]-1.0);
 psi[4] = 4.5*s[0]*s[1]*(3.0*s[1]-1.0);
 psi[5] = 4.5*s[1]*(1.0-s[0]-s[1])*(3.0*s[1]-1.0);
 psi[6] = 4.5*s[1]*(1.0-s[0]-s[1])*(3.0*(1.0-s[0]-s[1])-1.0);
 psi[7] = 4.5*s[0]*(1.0-s[0]-s[1])*(2.0-3*s[0]-3*s[1]);
 psi[8] = 4.5*s[0]*(1.0-s[0]-s[1])*(3.0*s[0]-1.0);
 psi[9] = 27.0*s[0]*s[1]*(1.0-s[0]-s[1]);
}

//=======================================================================
/// Derivatives of shape functions for specific TElement<2,4>
//=======================================================================
 void dshape_local(const Vector<double> &s,
                   Shape &psi, DShape &dpsids) const
{
  
 //ALH: Don't know why object qualifier is needed
 this->shape(s, psi);
 
 dpsids(0,0) = 13.5*s[0]*s[0]-9.0*s[0]+1.0;
 dpsids(0,1) = 0.0;
 dpsids(1,0) = 0.0;
 dpsids(1,1) = 13.5*s[1]*s[1]-9.0*s[1]+1.0;
 dpsids(2,0) = 0.5*(36.0*s[0]+36.0*s[1]-27.0*s[0]*s[0]-
                    27.0*s[1]*s[1]-54.0*s[0]*s[1]-11.0);
 dpsids(2,1) = 0.5*(36.0*s[0]+36.0*s[1]-27.0*s[0]*s[0]-
                    27.0*s[1]*s[1]-54.0*s[0]*s[1]-11.0);
 dpsids(3,0) = 27.0*s[0]*s[1]-4.5*s[1];
 dpsids(3,1) = 4.5*s[0]*(3.0*s[0]-1.0);
 dpsids(4,0) = 4.5*s[1]*(3.0*s[1]-1.0);
 dpsids(4,1) = 27.0*s[0]*s[1]-4.5*s[0];
 dpsids(5,0) = 4.5*(s[1]-3.0*s[1]*s[1]);
 dpsids(5,1) = 4.5*(s[0]-6.0*s[0]*s[1]-9.0*s[1]*s[1]+8*s[1]-1.0);
 dpsids(6,0) = 4.5*(6.0*s[0]*s[1]-5.0*s[1]+6.0*s[1]*s[1]);
 dpsids(6,1) = 4.5*(2.0-5.0*s[0]+3.0*s[0]*s[0]+12.0*s[0]*s[1]-
                    10.0*s[1]+9.0*s[1]*s[1]);
 dpsids(7,0) = 4.5*(2.0-10.0*s[0]+9.0*s[0]*s[0]+12.0*s[0]*s[1]-
                    5.0*s[1]+3.0*s[1]*s[1]);
 dpsids(7,1) = 4.5*(6.0*s[0]*s[0]-5.0*s[0]+6.0*s[0]*s[1]);
 dpsids(8,0) = 4.5*(s[1]-6.0*s[0]*s[1]-9.0*s[0]*s[0]+8*s[0]-1.0);
 dpsids(8,1) = 4.5*(s[0]-3.0*s[0]*s[0]);
 dpsids(9,0) = 27.0*s[1]-54.0*s[0]*s[1]-27.0*s[1]*s[1];
 dpsids(9,1) = 27.0*s[0]-54.0*s[0]*s[1]-27.0*s[0]*s[0];
 
}

//=======================================================================
/// Second derivatives of shape functions for specific TElement<2,4>:
/// d2psids(i,0) = \f$ \partial^2 \psi_j / \partial s_0^2 \f$ \n
/// d2psids(i,1) = \f$ \partial^2 \psi_j / \partial s_1^2 \f$ \n
/// d2psids(i,2) = \f$ \partial^2 \psi_j / \partial s_0 \partial s_1 \f$ \n
//=======================================================================
void d2shape_local(const Vector<double> &s,
                   Shape &psi,
                   DShape &dpsids,
                   DShape &d2psids) const
{
 throw OomphLibError("Not checked yet",
                     "TElement::d2shape_local()",
                     OOMPH_EXCEPTION_LOCATION);

 //ALH: Don't know why object qualifier is needed
 this->dshape_local(s, psi,dpsids);
 
 d2psids(0,0) = 9.0*(3.0*s[0]-1.0);
 d2psids(0,1) = 0.0;
 d2psids(0,2) = 0.0;
 d2psids(1,0) = 0.0;
 d2psids(1,1) = 0.0;
 d2psids(1,2) = 9.0*(3.0*s[1]-1.0);
 d2psids(2,0) = 9.0*(2.0-3.0*s[0]-3.0*s[1]);
 d2psids(2,1) = 9.0*(2.0-3.0*s[0]-3.0*s[1]);
 d2psids(2,2) = 9.0*(2.0-3.0*s[0]-3.0*s[1]);
 d2psids(3,0) = 27.0*s[1];
 d2psids(3,1) = 0.0;
 d2psids(3,2) = 27.0*s[0]-4.5;
 d2psids(4,0) = 0.0;
 d2psids(4,1) = 27.0*s[0];
 d2psids(4,2) = 27.0*s[1]-4.5;
 d2psids(5,0) = 0.0;
 d2psids(5,1) = 9.0*(4.0-3.0*s[0]-9.0*s[1]);
 d2psids(5,2) = 4.5*(1.0-6.0*s[1]);
 d2psids(6,0) = 27.0*s[1];
 d2psids(6,1) = 9.0*(6.0*s[0]+9.0*s[1]-5.0);
 d2psids(6,2) = 4.5*(6.0*s[0]+12.0*s[1]-5.0);
 d2psids(8,0) = 9.0*(4.0-9.0*s[0]-3.0*s[1]);
 d2psids(8,1) = 0.0;
 d2psids(8,2) = 4.5*(1.0-6.0*s[0]);
 d2psids(7,0) = 9.0*(9.0*s[0]+6.0*s[1]-5.0);
 d2psids(7,1) = 27.0*s[0];
 d2psids(7,2) = 4.5*(12.0*s[0]+6.0*s[1]-5.0);
 d2psids(9,0) = -54.0*s[1];
 d2psids(9,1) = -54.0*s[0];
 d2psids(9,2) = 27.0-54.0*s[0]-54.0*s[1];
}
};



//========================================================================
/// Empty base class for Telements (created so that 
/// we can use dynamic_cast<>() to figure out if a an element
/// is a Telement).
//========================================================================
 class TElementBase : public virtual FiniteElement
{

  public:

 /// Empty default constructor
 TElementBase(){} 

 /// Broken copy constructor
 TElementBase(const TElementBase&) 
  { 
   BrokenCopy::broken_copy("TElementBase");
  } 
 
 /// Broken assignment operator
 void operator=(const TElementBase&) 
  {
   BrokenCopy::broken_assign("TElementBase");
  }



 ///Check whether the local coordinates are valid or not
 bool local_coord_is_valid(const Vector<double> &s) 
  {

   // Check coordinates
   unsigned ncoord=dim();
   double sum=0.0;   
   for (unsigned i=0;i<ncoord;i++)
    {
     //Each local coordinate must be positive
     if (s[i]<0.0)
      {
       return false;
      }
     sum+=s[i];
    }
   
   //Sum must be less than 1
   if (sum<=1.0)
    {
     return true;
    }
   
   // We're outside...
   return false;

  }
 
 /// \short Check whether the local coordinates are valid or not and
 /// allow for rounding tolerance. If the local coordinate specifed
 /// by s is "slightly" outside the element (as specified by
 /// rounding_tolerance) we move the point back into the element. 
 bool local_coord_is_valid(Vector<double> &s, 
                           const double &rounding_tolerance)
  {

   // Check coordinates
   unsigned ncoord=dim();
   double sum=0.0;
   for (unsigned i=0;i<ncoord;i++)
    {
     //We allow a slight rounding tolerance
     //Each coordinate must be positive
     if (s[i]<0.0)
      {
       if (fabs(s[i])<rounding_tolerance)
        {
         s[i]=0.0;
        }
       else
        {
         return false;
        }
      }
     sum+=s[i];
    }
   
   
   //Sum must be less than 1
   double excess=sum-1.0;
   if (sum<=1.0)
    {
     return true;
    }
   else if ( (excess >= 0.0) && ( excess < rounding_tolerance) )
    {
     //In this case, we subtract 10% more than excess to refit
     double sub = (1.1*excess)/3.0 ;
     for (unsigned i=0;i<ncoord;i++)
      {
       s[i]-=sub;
      }
     return true;
    }
   
   // We're genuinely outside the element -- bail out.
   return false;

  }
 
};

//=======================================================================
///General TElement class
///
/// Empty, just establishes the template parameters
//=======================================================================
template<unsigned DIM, unsigned NNODE_1D>
class TElement
{
};			 


//=======================================================================
/// General TElement class specialised to one spatial dimensions
/// Ordering of nodes is 0 at local coordinate s[0] = 0, 1 at local 
/// coordinate s[0] = 1 and then filling in the intermediate values
/// from s[0]=0 to 1. 
//=======================================================================
template<unsigned NNODE_1D>
class TElement<1,NNODE_1D> : public virtual TElementBase, 
 public TElementShape<1,NNODE_1D>
{
  private:
 
 /// Spatial dimension of nodes in this element
 static const unsigned Every_node_ndim;
 
 /// \short Default integration rule: Gaussian integration of same 'order' as 
 /// the element
 //This is sort of optimal, because it means that the integration is exact
 //for the shape functions. Can overwrite this in specific element defintion.
 static TGauss<1,NNODE_1D> Default_integration_scheme;
 
 /// Min value of local coordinate
 static const double S_min;

 /// Max. value of local coordinate
 static const double S_max;

 
public:
 
 /// Constructor
 TElement()
  {
   // Number of nodes
   switch (NNODE_1D)
    {
    case 2:
    case 3:
    case 4:
     break;

    default:
     std::string error_message =
      "One-dimensional TElements are currently only implemented for\n";
     error_message +=
      "three and six nodes, i.e. NNODE_1D=2 , 3 , 4\n";
     
     throw OomphLibError(error_message,
                         "TElement::TElement()",
                         OOMPH_EXCEPTION_LOCATION);
    }

   // Set the number of nodes
   unsigned n_node = NNODE_1D;
   this->set_n_node(n_node);

   // Set the elemental and nodal dimension
   set_dimension(1);

   //Assign default (full) spatial integration scheme
   set_integration_scheme(&Default_integration_scheme);
  }
 

 /// Broken copy constructor
 TElement(const TElement&) 
  { 
   BrokenCopy::broken_copy("TElement");
  } 
 
 /// Broken assignment operator
 void operator=(const TElement&) 
  {
   BrokenCopy::broken_assign("TElement");
  }


 /// Destructor
 ~TElement() {}
 
 /// Number of nodes along each element edge
 unsigned nnode_1d() const {return NNODE_1D;} 

 /// Calculate the geometric shape functions at local coordinate s
 inline void shape(const Vector<double> &s, Shape &psi) const
  {TElementShape<1,NNODE_1D>::shape(s,psi);}
 
 /// \short Compute the  geometric shape functions and 
 /// derivatives w.r.t. local coordinates at local coordinate s
 inline void dshape_local(const Vector<double> &s, Shape &psi, 
                          DShape &dpsids) const
  {TElementShape<1,NNODE_1D>::dshape_local(s,psi,dpsids);}

 /// \short Computer the geometric shape functions, derivatives and
 /// second derivatives w.r.t local coordinates at local coordinate s \n
 /// d2psids(i,0) = \f$ \partial^2 \psi_j / \partial s_0^2 \f$ \n
 /// d2psids(i,1) = \f$ \partial^2 \psi_j / \partial s_1^2 \f$ \n
 /// d2psids(i,2) = \f$ \partial^2 \psi_j / \partial s_0 \partial s_1 \f$ \n
 inline void d2shape_local(const Vector<double> &s, Shape &psi, 
                           DShape &dpsids, DShape &d2psids) const
  {TElementShape<1,NNODE_1D>::d2shape_local(s,psi,dpsids,d2psids);}

 /// \short Overload the template-free interface for the calculation of
 /// inverse jacobian matrix. This is a one dimensional element, so use
 /// the 1D version.
 double invert_jacobian_mapping(const DenseMatrix<double> &jacobian,
                                DenseMatrix<double>&inverse_jacobian) const
  {return FiniteElement::invert_jacobian<1>(jacobian,inverse_jacobian);}
  
 /// Min. value of local coordinate
 double s_min() const {return S_min;}

 /// Max. value of local coordinate
 double s_max() const {return S_max;}

 /// Return local coordinates of node j
 inline void local_coordinate_of_node(const unsigned& j,Vector<double>& s)
  {TElementShape<1,NNODE_1D>::local_coordinate_of_node(j,s);}

  /// Output
  void output(std::ostream &output);

  /// Output at specified number of plot points
  void output(std::ostream &outfile, const unsigned &nplot);

 /// C-style output 
 void output(FILE* file_pt);

 /// C_style output at n_plot points
 void output(FILE* file_pt, const unsigned &n_plot);

 /// \short  Get vector of local coordinates of plot point i (when plotting 
 /// nplot points in each "coordinate direction").
 void get_s_plot(const unsigned& i, const unsigned& nplot,
                 Vector<double>& s)
  {
   if (nplot>1)
    {
     s[0] = double(i)/double(nplot-1);
    }
   else
    {
     s[0]=0.5;
    }
  }
 
 /// \short Return string for tecplot zone header (when plotting 
 /// nplot points in each "coordinate direction)
 std::string tecplot_zone_string(const unsigned& nplot)
 {
  char header[100];
  sprintf(header,"ZONE I=%i\n",nplot);
  return header;
 }
 
 /// Return total number of plot points (when plotting 
 /// nplot points in each "coordinate direction)
 unsigned nplot_points(const unsigned& nplot) 
  {return nplot;}

 /// \short Build the lower-dimensional FaceElement (an element of type
 /// PointElement).  The face index takes two values
 /// corresponding to the two possible faces:
 /// -1 (Left)  s[0] = -1.0
 /// +1 (Right) s[0] =  1.0
 void build_face_element(const int &face_index,
                         FaceElement* face_element_pt);

};


//=======================================================================
/// General TElement class specialised to two spatial dimensions
/// Ordering of nodes as in Zienkiwizc sketches: vertex nodes
/// 0 - 1 - 2 anticlockwise. Midside nodes filled in progressing
/// along the consecutive edges. Central node(s) come(s) last.
//=======================================================================
template<unsigned NNODE_1D>
class TElement<2,NNODE_1D> : public virtual TElementBase, 
 public TElementShape<2,NNODE_1D>
{
  private:
 
 /// Spatial dimension of nodes in this element
 static const unsigned Every_node_ndim;

 /// Nodal translation scheme for use when generating face elements
 static const unsigned NodeOnFace[3][NNODE_1D];
 
 /// \short Default integration rule: Gaussian integration of same 'order' as 
 /// the element
 //This is sort of optimal, because it means that the integration is exact
 //for the shape functions. Can overwrite this in specific element defintion.
 static TGauss<2,NNODE_1D> Default_integration_scheme;
 
 /// Min value of local coordinate
 static const double S_min;

 /// Max. value of local coordinate
 static const double S_max;

 
public:
 
 /// Constructor
 TElement()
  {
   // Number of nodes
   switch (NNODE_1D)
    {
    case 2:
    case 3:
    case 4:
     break;

    default:
     std::string error_message =
      "Triangles are currently only implemented for\n";
     error_message +=
      "three and six nodes, i.e. NNODE_1D=2 , 3 , 4\n";
     
     throw OomphLibError(error_message,
                         "TElement::TElement()",
                         OOMPH_EXCEPTION_LOCATION);
    }

   // Set the number of nodes
   unsigned n_node = (NNODE_1D*(NNODE_1D+1))/2;
   this->set_n_node(n_node);

   // Set the elemental and nodal dimension
   set_dimension(2);

   //Assign default (full) spatial integration scheme
   set_integration_scheme(&Default_integration_scheme);
  }
 

 /// Broken copy constructor
 TElement(const TElement&) 
  { 
   BrokenCopy::broken_copy("TElement");
  } 
 
 /// Broken assignment operator
 void operator=(const TElement&) 
  {
   BrokenCopy::broken_assign("TElement");
  }


 /// Destructor
 ~TElement() {}
 
 /// Number of nodes along each element edge
 unsigned nnode_1d() const {return NNODE_1D;} 

 /// Calculate the geometric shape functions at local coordinate s
 inline void shape(const Vector<double> &s, Shape &psi) const
  {TElementShape<2,NNODE_1D>::shape(s,psi);}
 
 /// \short Compute the  geometric shape functions and 
 /// derivatives w.r.t. local coordinates at local coordinate s
 inline void dshape_local(const Vector<double> &s, Shape &psi, 
                          DShape &dpsids) const
  {TElementShape<2,NNODE_1D>::dshape_local(s,psi,dpsids);}

 /// \short Computer the geometric shape functions, derivatives and
 /// second derivatives w.r.t local coordinates at local coordinate s \n
 /// d2psids(i,0) = \f$ \partial^2 \psi_j / \partial s_0^2 \f$ \n
 /// d2psids(i,1) = \f$ \partial^2 \psi_j / \partial s_1^2 \f$ \n
 /// d2psids(i,2) = \f$ \partial^2 \psi_j / \partial s_0 \partial s_1 \f$ \n
 inline void d2shape_local(const Vector<double> &s, Shape &psi, 
                           DShape &dpsids, DShape &d2psids) const
  {TElementShape<2,NNODE_1D>::d2shape_local(s,psi,dpsids,d2psids);}

 /// \short Overload the template-free interface for the calculation of
 /// inverse jacobian matrix. This is a two dimensional element, so use
 /// the 2D version.
 double invert_jacobian_mapping(const DenseMatrix<double> &jacobian,
                                DenseMatrix<double>&inverse_jacobian) const
  {return FiniteElement::invert_jacobian<2>(jacobian,inverse_jacobian);}
  
 /// Min. value of local coordinate
 double s_min() const {return S_min;}

 /// Max. value of local coordinate
 double s_max() const {return S_max;}

 /// Return local coordinates of node j
 inline void local_coordinate_of_node(const unsigned& j,Vector<double>& s)
  {TElementShape<2,NNODE_1D>::local_coordinate_of_node(j,s);}

  /// Output
  void output(std::ostream &output);

  /// Output at specified number of plot points
  void output(std::ostream &outfile, const unsigned &nplot);

 /// C-style output 
 void output(FILE* file_pt);

 /// C_style output at n_plot points
 void output(FILE* file_pt, const unsigned &n_plot);

 /// \short  Get vector of local coordinates of plot point i (when plotting 
 /// nplot points in each "coordinate direction").
 void get_s_plot(const unsigned& iplot, const unsigned& nplot,
                 Vector<double>& s)
  {
   if (nplot>1)
    {
     unsigned np=0,i,j;
     for(i=0;i<nplot;++i)
      {
       for(j=0;j<nplot-i;++j)
        {
         if(np==iplot)
          {
           s[0] = double(j)/double(nplot-1);
           s[1] = double(i)/double(nplot-1);
           return;
          }
         ++np;
        }
      }
    }
   else
    {
     s[0] = 1.0/3.0;
     s[1] = 1.0/3.0;
    }
  }
 
 /// \short Return string for tecplot zone header (when plotting 
 /// nplot points in each "coordinate direction)
 std::string tecplot_zone_string(const unsigned& nplot)
 {
  char header[100];
  unsigned nel=0;
  for (unsigned i=1;i<nplot;i++) {nel+=2*i-1;}  
  sprintf(header,"ZONE N=%i, E=%i, F=FEPOINT, ET=TRIANGLE\n",
          nplot_points(nplot),nel);
  return header;
 }

 /// \short Add tecplot zone "footer" to output stream (when plotting 
 /// nplot points in each "coordinate direction).
 /// Empty by default -- can be used, e.g., to add FE connectivity
 /// lists to elements that need it.
 void write_tecplot_zone_footer(std::ostream& outfile, 
                                const unsigned& nplot)
  {
   //Output node lists for sub elements for Tecplot (node index 
   //must start at 1)
   unsigned nod_count=1;
   for(unsigned i=0;i<nplot;i++)
    {
     for(unsigned j=0;j<nplot-i;j++)
      {
       if(j<nplot-i-1)
        {
         outfile << nod_count << " " << nod_count+1 
                 << " " << nod_count+nplot-i << std::endl;
         if(j<nplot-i-2)
          {
           outfile << nod_count+1 << " " 
                   << nod_count+nplot-i+1 << " " 
                   << nod_count+nplot-i << std::endl;
          }
        }
       ++nod_count;
      }
    }
  }
 
 /// \short Add tecplot zone "footer" to C-style output. (when plotting 
 /// nplot points in each "coordinate direction).
 /// Empty by default -- can be used, e.g., to add FE connectivity
 /// lists to elements that need it.
 void write_tecplot_zone_footer(FILE* file_pt,
                                const unsigned& nplot)
  {
   //Output node lists for sub elements for Tecplot (node index 
   //must start at 1)
   unsigned nod_count=1;
   for(unsigned i=0;i<nplot;i++)
    {
     for(unsigned j=0;j<nplot-i;j++)
      {
       if(j<nplot-i-1)
        {
         fprintf(file_pt,"%i %i %i \n",nod_count,nod_count+1,
                 nod_count+nplot-i);
         if(j<nplot-i-2)
          {
           fprintf(file_pt,"%i %i %i \n",nod_count+1,nod_count+nplot-i+1,
                   nod_count+nplot-i);
          }
        }
       ++nod_count;
      }
    }
  }
 
 /// Return total number of plot points (when plotting 
 /// nplot points in each "coordinate direction)
 unsigned nplot_points(const unsigned& nplot) 
  {
   unsigned np=0;
   for (unsigned i=1;i<=nplot;i++) {np+=i;}
   return np;
  }


 /// \short Build the lower-dimensional FaceElement (an element of type
 /// TElement<1,NNODE_1D>). The face index takes three possible values:
 /// 0 (Left)         s[0] = 0.0
 /// 1 (Bottom)       s[1] = 0.0
 /// 2 (Sloping face) s[0] = 1.0 - s[1]
 void build_face_element(const int &face_index,
                         FaceElement* face_element_pt);


};


///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////


//=======================================================================
/// Return local coordinates of node j
//=======================================================================
template<>
class TElementShape<3,2>
{
  public:
 void local_coordinate_of_node(const unsigned& j,
                               Vector<double>& s)
  {
   switch (j)
    {
    case 0:
     s[0]=1.0;
     s[1]=0.0;
     s[2]=0.0;
     break;
     
    case 1:
     s[0]=0.0;
     s[1]=1.0;
     s[2]=0.0;
     break;
     
    case 2:
     s[0]=0.0;
     s[1]=0.0;
     s[2]=1.0;
     break;
     
    case 3:
     s[0]=0.0;
     s[1]=0.0;
     s[2]=0.0;
     break;
     
    default:
     std::ostringstream error_message;
     error_message << "Element only has four nodes; called with node number " 
                   << j << std::endl;
     
     throw OomphLibError(error_message.str(),
                         "TElement::local_coordinate_of_node()",
                         OOMPH_EXCEPTION_LOCATION);
    }
  }



//=======================================================================
/// Shape function for specific TElement<3,2>
//=======================================================================
 void shape(const Vector<double> &s, Shape &psi) const
  {
   psi[0] = s[0];
   psi[1] = s[1];
   psi[2] = s[2];
   psi[3] = 1.0-s[0]-s[1]-s[2];
  }


//=======================================================================
/// Derivatives of shape functions for specific TElement<3,2>
//=======================================================================
 void dshape_local(const Vector<double> &s,
                   Shape &psi, DShape &dpsids) const
  {
   //ALH: Don't know why object qualifier is needed
   this->shape(s, psi);
   
   // Derivatives
   dpsids(0,0) = 1.0;
 dpsids(0,1) = 0.0;
 dpsids(0,2) = 0.0;

 dpsids(1,0) = 0.0;
 dpsids(1,1) = 1.0;
 dpsids(1,2) = 0.0;

 dpsids(2,0) = 0.0;
 dpsids(2,1) = 0.0;
 dpsids(2,2) = 1.0;

 dpsids(3,0) = -1.0;
 dpsids(3,1) = -1.0;
 dpsids(3,2) = -1.0;
}



//=======================================================================
/// Second derivatives of shape functions for specific TElement<3,2>: \n
/// d2psids(i,0) = \f$ \partial^2 \psi_j / \partial s_0^2 \f$ \n
/// d2psids(i,1) = \f$ \partial^2 \psi_j / \partial s_1^2 \f$ \n
/// d2psids(i,2) = \f$ \partial^2 \psi_j / \partial s_2^2 \f$ \n
/// d2psids(i,3) = \f$ \partial^2 \psi_j / \partial s_0 \partial s_1 \f$ \n
/// d2psids(i,4) = \f$ \partial^2 \psi_j / \partial s_0 \partial s_2 \f$ \n
/// d2psids(i,5) = \f$ \partial^2 \psi_j / \partial s_1 \partial s_2 \f$ \n
//=======================================================================
 void d2shape_local(const Vector<double> &s,
                    Shape &psi,
                                         DShape &dpsids,
                                         DShape &d2psids) const
{
 //ALH: Don't know why object qualifier is needed
 this->dshape_local(s, psi,dpsids);

 for(unsigned i=0;i<4;i++)
  {
   d2psids(i,0) = 0.0;
   d2psids(i,1) = 0.0;
   d2psids(i,2) = 0.0;
   d2psids(i,3) = 0.0;
   d2psids(i,4) = 0.0;
   d2psids(i,5) = 0.0;
  }
}

};



//=======================================================================
/// Return local coordinates of node j
//=======================================================================
template<>
 class TElementShape<3,3>
 {
   public:
  void local_coordinate_of_node(const unsigned& j,
                                Vector<double>& s)
{
 switch (j)
  {
  case 0:
   s[0]=1.0;
   s[1]=0.0;
   s[2]=0.0;
   break;

  case 1:
   s[0]=0.0;
   s[1]=1.0;
   s[2]=0.0;
   break;

  case 2:
   s[0]=0.0;
   s[1]=0.0;
   s[2]=1.0;
   break;

  case 3:
   s[0]=0.0;
   s[1]=0.0;
   s[2]=0.0;
   break;

  case 4:
   s[0]=0.5;
   s[1]=0.5;
   s[2]=0.0;
   break;

  case 5:
   s[0]=0.5;
   s[1]=0.0;
   s[2]=0.5;
   break;

  case 6:
   s[0]=0.5;
   s[1]=0.0;
   s[2]=0.0;
   break;

  case 7:
   s[0]=0.0;
   s[1]=0.5;
   s[2]=0.5;
   break;

  case 8:
   s[0]=0.0;
   s[1]=0.0;
   s[2]=0.5;
   break;

  case 9:
   s[0]=0.0;
   s[1]=0.5;
   s[2]=0.0;
   break;

  default:
   std::ostringstream error_message;
   error_message << "Element only has ten nodes; called with node number " 
                 << j << std::endl;
   
   throw OomphLibError(error_message.str(),
                       "TElement::local_coordinate_of_node()",
                       OOMPH_EXCEPTION_LOCATION);
  }
}



//=======================================================================
/// Shape function for specific TElement<3,3>
//=======================================================================
void shape(const Vector<double> &s, Shape &psi) const
{
 double s3=1.0-s[0]-s[1]-s[2];
 psi[0] = (2.0*s[0]-1.0)*s[0];
 psi[1] = (2.0*s[1]-1.0)*s[1];
 psi[2] = (2.0*s[2]-1.0)*s[2];
 psi[3] = (2.0*s3-1.0)*s3;
 psi[4] = 4.0*s[0]*s[1];
 psi[5] = 4.0*s[0]*s[2];
 psi[6] = 4.0*s[0]*s3;
 psi[7] = 4.0*s[1]*s[2];
 psi[8] = 4.0*s[2]*s3;
 psi[9] = 4.0*s[1]*s3;
}


//=======================================================================
/// Derivatives of shape functions for specific TElement<3,3>
//=======================================================================
void dshape_local(const Vector<double> &s,
                  Shape &psi, DShape &dpsids) const
{
 //ALH: Don't know why object qualifier is needed
 this->shape(s, psi);
 
 // Derivatives
 double s3=1.0-s[0]-s[1]-s[2];

 dpsids(0,0) = 4.0*s[0]-1.0;
 dpsids(0,1) = 0.0;
 dpsids(0,2) = 0.0;

 dpsids(1,0) = 0.0;
 dpsids(1,1) = 4.0*s[1]-1.0;
 dpsids(1,2) = 0.0;

 dpsids(2,0) = 0.0;
 dpsids(2,1) = 0.0;
 dpsids(2,2) = 4.0*s[2]-1.0;

 dpsids(3,0) = -4.0*s3+1.0;
 dpsids(3,1) = -4.0*s3+1.0;
 dpsids(3,2) = -4.0*s3+1.0;

 dpsids(4,0) = 4.0*s[1];
 dpsids(4,1) = 4.0*s[0];
 dpsids(4,2) = 0.0;

 dpsids(5,0) = 4.0*s[2];
 dpsids(5,1) = 0.0;
 dpsids(5,2) = 4.0*s[0];

 dpsids(6,0) = 4.0*(s3-s[0]);
 dpsids(6,1) = -4.0*s[0];
 dpsids(6,2) = -4.0*s[0];

 dpsids(7,0) = 0.0;
 dpsids(7,1) = 4.0*s[2];
 dpsids(7,2) = 4.0*s[1];

 dpsids(8,0) = -4.0*s[2];
 dpsids(8,1) = -4.0*s[2];
 dpsids(8,2) = 4.0*(s3-s[2]);

 dpsids(9,0) = -4.0*s[1];
 dpsids(9,1) = 4.0*(s3-s[1]);
 dpsids(9,2) = -4.0*s[1];


}


//=======================================================================
/// Second derivatives of shape functions for specific TElement<3,3>:\n
/// d2psids(i,0) = \f$ \partial^2 \psi_j / \partial s_0^2 \f$ \n
/// d2psids(i,1) = \f$ \partial^2 \psi_j / \partial s_1^2 \f$ \n
/// d2psids(i,2) = \f$ \partial^2 \psi_j / \partial s_2^2 \f$ \n
/// d2psids(i,3) = \f$ \partial^2 \psi_j / \partial s_0 \partial s_1 \f$ \n
/// d2psids(i,4) = \f$ \partial^2 \psi_j / \partial s_0 \partial s_2 \f$ \n
/// d2psids(i,5) = \f$ \partial^2 \psi_j / \partial s_1 \partial s_2 \f$ \n
//=======================================================================
void d2shape_local(const Vector<double> &s,
                                         Shape &psi,
                                         DShape &dpsids,
                                         DShape &d2psids) const
{
 //ALH: Don't know why object qualifier is needed
 this->dshape_local(s, psi,dpsids);

 //(.,3) for mixed derivative s[0]-s[1]
 //(.,4) for mixed derivative s[0]-s[2]
 //(.,5) for mixed derivative s[1]-s[2]

 d2psids(0,0) = 4.0;
 d2psids(0,1) = 0.0;
 d2psids(0,2) = 0.0;
 d2psids(0,3) = 0.0;
 d2psids(0,4) = 0.0;
 d2psids(0,5) = 0.0;


 d2psids(1,0) = 0.0;
 d2psids(1,1) = 4.0;
 d2psids(1,2) = 0.0;
 d2psids(1,3) = 0.0;
 d2psids(1,4) = 0.0;
 d2psids(1,5) = 0.0;

 d2psids(2,0) = 0.0;
 d2psids(2,1) = 0.0;
 d2psids(2,2) = 4.0;
 d2psids(2,3) = 0.0;
 d2psids(2,4) = 0.0;
 d2psids(2,5) = 0.0;

 d2psids(3,0) = 4.0;
 d2psids(3,1) = 4.0;
 d2psids(3,2) = 4.0;
 d2psids(3,3) = 4.0;
 d2psids(3,4) = 4.0;
 d2psids(3,5) = 4.0;

 d2psids(4,0) = 0.0;
 d2psids(4,1) = 0.0;
 d2psids(4,2) = 0.0;
 d2psids(4,3) = 4.0;
 d2psids(4,4) = 0.0;
 d2psids(4,5) = 0.0;

 d2psids(5,0) = 0.0;
 d2psids(5,1) = 0.0;
 d2psids(5,2) = 0.0;
 d2psids(5,3) = 0.0;
 d2psids(5,4) = 4.0;
 d2psids(5,5) = 0.0;

 d2psids(6,0) =-8.0;
 d2psids(6,1) = 0.0;
 d2psids(6,2) = 0.0;
 d2psids(6,3) = -4.0;
 d2psids(6,4) = -4.0;
 d2psids(6,5) = 0.0;

 d2psids(7,0) = 0.0;
 d2psids(7,1) = 0.0;
 d2psids(7,2) = 0.0;
 d2psids(7,3) = 0.0;
 d2psids(7,4) = 0.0;
 d2psids(7,5) = 4.0;

 d2psids(8,0) = 0.0;
 d2psids(8,1) = 0.0;
 d2psids(8,2) = -8.0;
 d2psids(8,3) = 0.0;
 d2psids(8,4) = -4.0;
 d2psids(8,5) = -4.0;

 d2psids(9,0) = 0.0;
 d2psids(9,1) = -8.0;
 d2psids(9,2) = 0.0;
 d2psids(9,3) = -4.0;
 d2psids(9,4) = 0.0;
 d2psids(9,5) = -4.0;

}


};

//=======================================================================
/// General TElement class specialised to three spatial dimensions (tet)
/// Ordering of nodes inverted from Zienkiewizc sketches: When looking into the
/// tet from vertex node 0. The vertex nodes on the opposite face are
/// 1 - 2 - 3 in anticlockwise direction. Other nodes filled in edge by 
/// edge, then the face ones, then the internal ones.
//=======================================================================
template<unsigned NNODE_1D>
class TElement<3,NNODE_1D> : public virtual TElementBase,
                  public TElementShape<3,NNODE_1D>
{
  private:
 
 /// Spatial dimension of nodes in this element
 static const unsigned Every_node_ndim;
 
 /// Nodal translation scheme for use when generating face elements
 static const unsigned NodeOnFace[4][(NNODE_1D*(NNODE_1D+1))/2];
 
 /// \short Default integration rule: Gaussian integration of same 'order' as
 /// the element
 //This is sort of optimal, because it means that the integration is exact
 //for the shape functions. Can overwrite this in specific element defintion.
 static TGauss<3,NNODE_1D> Default_integration_scheme;
 
 /// Min value of local coordinate
 static const double S_min;

 /// Max. value of local coordinate
 static const double S_max;

 
public:
 
 /// Constructor
 TElement()
  {
   switch (NNODE_1D)
    {
    case 2:
    case 3:
     break;

/*     case 4: */
/*      n_node = 20; */
/*      break; */

    default:
     std::string error_message =
      "Tets are currently only implemented for\n";
     error_message +=
      "four and ten nodes, i.e. NNODE_1D=2 , 3 \n";
     
     throw OomphLibError(error_message,
                         "TElement::TElement()",
                         OOMPH_EXCEPTION_LOCATION);
    }


   // Set the number of nodes
   unsigned n_node = (NNODE_1D*(NNODE_1D+1))/2 + 1 + 3*(NNODE_1D-2);
   this->set_n_node(n_node);

   // Set the elemental and nodal dimensions
   set_dimension(3);

   //Assign default (full) spatial integration scheme
   set_integration_scheme(&Default_integration_scheme);
  }



 /// Broken copy constructor
 TElement(const TElement&) 
  { 
   BrokenCopy::broken_copy("TElement");
  } 
 
 /// Broken assignment operator
 void operator=(const TElement&) 
  {
   BrokenCopy::broken_assign("TElement");
  }

  
  /// Destructor
  ~TElement() {}
  
  /// Number of nodes along each element edge
  unsigned nnode_1d() const {return NNODE_1D;}
  
  /// Calculate the geometric shape functions at local coordinate s
  inline void shape(const Vector<double> &s, Shape &psi) const
   {TElementShape<3,NNODE_1D>::shape(s,psi);}
  
  /// \short Compute the  geometric shape functions and
  /// derivatives w.r.t. local coordinates at local coordinate s
  inline void dshape_local(const Vector<double> &s, Shape &psi,
                           DShape &dpsids) const
   {TElementShape<3,NNODE_1D>::dshape_local(s,psi,dpsids);}

  /// \short Computer the geometric shape functions, derivatives and
  /// second derivatives w.r.t local coordinates at local coordinate s. \n
  /// d2psids(i,0) = \f$ \partial^2 \psi_j / \partial s_0^2 \f$ \n
  /// d2psids(i,1) = \f$ \partial^2 \psi_j / \partial s_1^2 \f$ \n
  /// d2psids(i,2) = \f$ \partial^2 \psi_j / \partial s_2^2 \f$ \n
  /// d2psids(i,3) = \f$ \partial^2 \psi_j / \partial s_0 \partial s_1 \f$ \n
  /// d2psids(i,4) = \f$ \partial^2 \psi_j / \partial s_0 \partial s_2 \f$ \n
  /// d2psids(i,5) = \f$ \partial^2 \psi_j / \partial s_1 \partial s_2 \f$ \n
  inline void d2shape_local(const Vector<double> &s, Shape &psi,
                            DShape &dpsids, DShape &d2psids) const
   {TElementShape<3,NNODE_1D>::d2shape_local(s,psi,dpsids,d2psids);}
  
  /// \short Overload the template-free interface for the calculation of
  /// inverse jacobian matrix. This is a three dimensional element, so use
  /// the 3D version.
  double invert_jacobian_mapping(const DenseMatrix<double>&jacobian,
                                 DenseMatrix<double>&inverse_jacobian) const
  {return FiniteElement::invert_jacobian<3>(jacobian,inverse_jacobian);}
    
  /// Min. value of local coordinate
  double s_min() const {return S_min;}
  
  /// Max. value of local coordinate
  double s_max() const {return S_max;}
  
  /// Return local coordinates of node j
  inline void local_coordinate_of_node(const unsigned& j,Vector<double>& s)
   {TElementShape<3,NNODE_1D>::local_coordinate_of_node(j,s);}

  /// Output
  void output(std::ostream &output);
  
  /// Output at specified number of plot points
  void output(std::ostream &outfile, const unsigned &nplot);
  
  /// C-style output
  void output(FILE* file_pt);
  
  /// C_style output at n_plot points
  void output(FILE* file_pt, const unsigned &n_plot);
  
  /// \short  Get vector of local coordinates of plot point i (when plotting
  /// nplot points in each "coordinate direction).
  void get_s_plot(const unsigned& iplot, const unsigned& nplot,
                  Vector<double>& s)
  {
   if (nplot>1)
    {
     unsigned np=0;
     for(unsigned i=0;i<nplot;++i)
      {
       for(unsigned j=0;j<nplot-i;++j)
        {
         for(unsigned k=0;k<nplot-i-j;++k)
          {
           if(np==iplot)
            {
             {
              s[0] = double(j)/double(nplot-1);
              s[1] = double(i)/double(nplot-1);
              s[2] = double(k)/double(nplot-1);
              return;
             }
            }
           np++;
          }
        }
      }
    }
   else
    {
     s[0] = 1.0/4.0;
     s[1] = 1.0/4.0;
     s[2] = 1.0/4.0;
    }
  }

  /// \short Return string for tecplot zone header (when plotting
  /// nplot points in each "coordinate direction)
  std::string tecplot_zone_string(const unsigned& nplot)
  {
   char header[100];
   unsigned nel=0;
   nel=(nplot-1)*(nplot-1)*(nplot-1);
   sprintf(header,"ZONE N=%i, E=%i, F=FEPOINT, ET=TETRAHEDRON\n",
           nplot_points(nplot),nel);
   return header;
  }
  
  /// \short Add tecplot zone "footer" to output stream (when plotting
  /// nplot points in each "coordinate direction).
  /// Empty by default -- can be used, e.g., to add FE connectivity
  /// lists to elements that need it.
  void write_tecplot_zone_footer(std::ostream& outfile,
                                 const unsigned& nplot)
   {
    
    //Output node lists for sub elements for Tecplot (node index
    //must start at 1)
    unsigned nod_count=1;
    for(unsigned i=0;i<nplot;i++)
     {
      for(unsigned j=0;j<nplot-i;j++)
       {
        for(unsigned k=0;k<nplot-i-j;k++)
         {
          if(k<nplot-i-j-1)
           {
            outfile<< nod_count << " " 
                   << nod_count+1 << " " 
                   << nod_count+nplot-i-j <<" "
                   <<nod_count+nplot-i-j+((nplot-1-i)*(nplot-i)/2)
                   << std::endl;
            if(k<nplot-i-j-2)
             {
              outfile << nod_count+1<< " " 
                      << nod_count+nplot-i-j << " " 
                      << nod_count+nplot-i-j+((nplot-1-i)*(nplot-i)/2) << " "
                      << nod_count+2*(nplot-i-j)-1+((nplot-1-i)*(nplot-i)/2)
                      << std::endl;
              outfile << nod_count+1 << " "
                      << nod_count+nplot-i-j << " " 
                      << nod_count+nplot-i-j+1<< " " 
                      << nod_count+2*(nplot-i-j)-1+((nplot-1-i)*(nplot-i)/2)
                      << std::endl;
              outfile << nod_count+1<< " " 
                      << nod_count+nplot-i-j+((nplot-1-i)*(nplot-i)/2)<< " "
                      << nod_count+nplot-i-j+((nplot-1-i)*(nplot-i)/2)+1<< " "
                      << nod_count+2*(nplot-i-j)-1+((nplot-1-i)*(nplot-i)/2)
                      << std::endl;
              outfile << nod_count+1<< " "
                      << nod_count+nplot-i-j+1<< " " 
                      << nod_count+nplot-i-j+((nplot-1-i)*(nplot-i)/2)+1
                      << " " 
                      << nod_count+2*(nplot-i-j)-1+((nplot-1-i)*(nplot-i)/2)
                      << std::endl;
             }
            if(k>1)
             {
              outfile << nod_count+nplot-i-j-1<< " " 
                      << nod_count+nplot-i-j+((nplot-1-i)*(nplot-i)/2)-1 
                      << " "
                      << nod_count+2*(nplot-i-j-1)+((nplot-1-i)*(nplot-i)/2)-1
                      <<" "
                      << nod_count+2*(nplot-i-j-1)+((nplot-1-i)*(nplot-i)/2)
                      << std::endl;
             }
           }//end if(k<nplot-i-j-1)
          ++nod_count;
         }
       }
     }
   } //end of write tecplot...
  

 /// \short Add tecplot zone "footer" to C-style output. (when plotting
 /// nplot points in each "coordinate direction).
 /// Empty by default -- can be used, e.g., to add FE connectivity
 /// lists to elements that need it.
  void write_tecplot_zone_footer(FILE* file_pt,
                                 const unsigned& nplot)
   {
    //Output node lists for sub elements for Tecplot (node index
    //must start at 1)
    unsigned nod_count=1;
    for(unsigned i=0;i<nplot;i++)
     {
      for(unsigned j=0;j<nplot-i;j++)
       {
        for(unsigned k=0;k<nplot-i-j;k++)
         {
          if(j<nplot-i-1)
           {
            fprintf(file_pt,"%i %i %i \n",nod_count,
                    nod_count+1,nod_count+nplot-i);
            if(j<nplot-i-2)
             {
              fprintf(file_pt,"%i %i %i \n",nod_count+1,nod_count+nplot-i+1,
                      nod_count+nplot-i);
             }
           }
          ++nod_count;
         }
       }
     }
   }
      
 /// \short Return total number of plot points (when plotting
 /// nplot points in each "coordinate direction)
 unsigned nplot_points(const unsigned& nplot)
  { 
   unsigned res=0;
   if(nplot>1)
    {
     res=4;
     for(unsigned i=3;i<=nplot;i++)
      {
       res+=(i*(i+1)/2);
      }
     return res;
    }
   //Otherwise we return 1(?)
   return 1;
  }

 /// \short Build the lower-dimensional FaceElement (an element of type
 /// TElement<2,NNODE_1D>). The face index can take one of four values
 /// corresponding to the four possible faces:
 /// 0: (left)           s[0] = 0.0
 /// 1: (bottom)         s[1] = 0.0
 /// 2: (back)           s[2] = 0.0
 /// 3: (sloping face)   s[0] + s[1] + s[2] = 1
 void build_face_element(const int &face_index,
                         FaceElement* face_element_pt);
 
};


///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////


//========================================================================
/// Base class for Solid Telements 
//========================================================================
class TSolidElementBase : public virtual TElementBase,
                          public virtual SolidFiniteElement
{


  public:

 /// Constructor: Empty
 TSolidElementBase(){};

 /// Broken copy constructor
 TSolidElementBase(const TSolidElementBase&) 
  { 
   BrokenCopy::broken_copy("TSolidElementBase");
  } 
 
 /// Broken assignment operator
 void operator=(const TSolidElementBase&) 
  {
   BrokenCopy::broken_assign("TSolidElementBase");
  }

};




//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////


//=======================================================================
/// SolidTElement elements are triangular/tet elements whose 
/// derivatives also include those based upon the lagrangian 
/// positions of the nodes.
/// They are the basis for solid mechanics elements.
//=======================================================================
template <unsigned DIM, unsigned NNODE_1D> 
class SolidTElement
{};


//=======================================================================
///SolidTElement elements, specialised to one spatial dimension
//=======================================================================
template <unsigned NNODE_1D>
class SolidTElement<1,NNODE_1D> : public virtual TElement<1,NNODE_1D>, 
 public virtual TSolidElementBase
{
  public:

 /// Constructor
 SolidTElement() : TElement<1,NNODE_1D>(), SolidFiniteElement() 
  {
   //Set the Lagrangian dimension of the element
   set_lagrangian_dimension(1);
  }
 
 /// Broken copy constructor
 SolidTElement(const SolidTElement&) 
  { 
   BrokenCopy::broken_copy("SolidTElement");
  } 
 
 /// Broken assignment operator
 void operator=(const SolidTElement&) 
  {
   BrokenCopy::broken_assign("SolidTElement");
  }

 /// \short Build the lower-dimensional FaceElement (an element of type
 /// SolidPointElement).  The face index takes two values
 /// corresponding to the two possible faces:
 /// -1 (Left)  s[0] = -1.0
 /// +1 (Right) s[0] =  1.0
 inline void build_face_element(const int &face_index, 
                                FaceElement* face_element_pt);
 

};


///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////
// SolidTElements
///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////////
// 1D SolidTElements
///////////////////////////////////////////////////////////////////////////


//===========================================================
/// Function to setup geometrical information for lower-dimensional 
/// FaceElements (which are of type SolidTElement<0,1>).
//===========================================================
template<unsigned NNODE_1D>
void SolidTElement<1,NNODE_1D>::
build_face_element(const int &face_index,
                   FaceElement *face_element_pt)
{
 //Build the standard non-solid FaceElement
 TElement<1,NNODE_1D>::build_face_element(face_index,face_element_pt);

 //Set the Lagrangian dimension from the first node of the present element
 dynamic_cast<SolidFiniteElement*>(face_element_pt)->
  set_lagrangian_dimension(static_cast<SolidNode*>(node_pt(0))->nlagrangian());
}
 


//=======================================================================
/// SolidTElement elements, specialised to two spatial dimensions
//=======================================================================
template <unsigned NNODE_1D>
class SolidTElement<2,NNODE_1D> : public virtual TElement<2,NNODE_1D>, 
 public virtual TSolidElementBase
{
  private:

 /// Lagrangian dimension of every node in this element
 static const unsigned Every_node_nlagrangian;

  public:

 /// Constructor
 SolidTElement() : TElementBase(), TElement<2,NNODE_1D>(),
  SolidFiniteElement(), TSolidElementBase()
  {
   //Set the Lagrangian dimension of the element
   set_lagrangian_dimension(2);
  }

 /// Broken copy constructor
 SolidTElement(const SolidTElement&) 
  { 
   BrokenCopy::broken_copy("SolidTElement");
  } 
 
 /// Broken assignment operator
 void operator=(const SolidTElement&) 
  {
   BrokenCopy::broken_assign("SolidTElement");
  }

 /// \short Build the lower-dimensional FaceElement (an element of type
 /// SolidTElement<1,NNODE_1D>). The face index takes three possible values:
 /// 0 (Left)         s[0] = 0.0
 /// 1 (Bottom)       s[1] = 0.0
 /// 2 (Sloping face) s[0] = 1.0 - s[1]
 inline void build_face_element(const int &face_index,
                                FaceElement* face_element_pt);
 
};


///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////
// 2D SolidTElements
///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////


//===========================================================
/// Function to setup geometrical information for lower-dimensional 
/// FaceElements (which are of type SolidTElement<1,NNODE_1D>).
//===========================================================
template<unsigned NNODE_1D>
void SolidTElement<2,NNODE_1D>::
build_face_element(const int &face_index, FaceElement *face_element_pt)
{
 //Build the standard non-solid FaceElement
 TElement<2,NNODE_1D>::build_face_element(face_index,face_element_pt);
 
 //Set the Lagrangian dimension from the first node of the present element
 dynamic_cast<SolidFiniteElement*>(face_element_pt)->
  set_lagrangian_dimension(static_cast<SolidNode*>(node_pt(0))->nlagrangian());
}



//=======================================================================
/// SolidTElement elements, specialised to three spatial dimensions
//=======================================================================
template <unsigned NNODE_1D>
class SolidTElement<3,NNODE_1D> : public virtual TElement<3,NNODE_1D>, 
 public virtual TSolidElementBase
{
  private:

 /// Lagrangian dimension of every node in this element
 static const unsigned Every_node_nlagrangian;

  public:

 /// Constructor
 SolidTElement() : TElementBase(), TElement<3,NNODE_1D>(),
  SolidFiniteElement(), TSolidElementBase()
  {
   //Set the Lagrangian dimension of the element
   set_lagrangian_dimension(3);
  }

 /// Broken copy constructor
 SolidTElement(const SolidTElement&) 
  { 
   BrokenCopy::broken_copy("SolidTElement");
  } 
 
 /// Broken assignment operator
 void operator=(const SolidTElement&) 
  {
   BrokenCopy::broken_assign("SolidTElement");
  }


 /// \short Build the lower-dimensional FaceElement (an element of type
 /// SolidTElement<2,NNODE_1D>). The face index can take one of four values
 /// corresponding to the four possible faces:
 /// 0: (left)           s[0] = 0.0
 /// 1: (bottom)         s[1] = 0.0
 /// 2: (back)           s[2] = 0.0
 /// 3: (sloping face)   s[0] + s[1] + s[2] = 1
 inline void build_face_element(const int &face_index,
                                FaceElement* face_element_pt);

};



///////////////////////////////////////////////////////////////////////////
// 3D SolidTElements
///////////////////////////////////////////////////////////////////////////


//===========================================================
/// Function to setup geometrical information for lower-dimensional 
/// FaceElements (which are of type SolidTElement<1,NNODE_1D>).
//===========================================================
template<unsigned NNODE_1D>
void SolidTElement<3,NNODE_1D>::
 build_face_element(const int &face_index,
                    FaceElement *face_element_pt)
{
 //Build the standard non-solid FaceElement
 TElement<3,NNODE_1D>::build_face_element(face_index,face_element_pt);
 
 //Set the Lagrangian dimension from the first node of the present element
 dynamic_cast<SolidFiniteElement*>(face_element_pt)->
  set_lagrangian_dimension(static_cast<SolidNode*>(node_pt(0))->nlagrangian());
}



}

#endif
