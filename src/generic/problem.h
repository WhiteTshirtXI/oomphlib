#//LIC// ====================================================================
//LIC// This file forms part of oomph-lib, the object-oriented, 
//LIC// multi-physics finite-element library, available 
//LIC// at http://www.oomph-lib.org.
//LIC// 
//LIC//           Version 0.85. June 9, 2008.
//LIC// 
//LIC// Copyright (C) 2006-2008 Matthias Heil and Andrew Hazel
//LIC// 
//LIC// This library is free software; you can redistribute it and/or
//LIC// modify it under the terms of the GNU Lesser General Public
//LIC// License as published by the Free Software Foundation; either
//LIC// version 2.1 of the License, or (at your option) any later version.
//LIC// 
//LIC// This library is distributed in the hope that it will be useful,
//LIC// but WITHOUT ANY WARRANTY; without even the implied warranty of
//LIC// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//LIC// Lesser General Public License for more details.
//LIC// 
//LIC// You should have received a copy of the GNU Lesser General Public
//LIC// License along with this library; if not, write to the Free Software
//LIC// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
//LIC// 02110-1301  USA.
//LIC// 
//LIC// The authors may be contacted at oomph-lib@maths.man.ac.uk.
//LIC// 
//LIC//====================================================================
//A generic problem class to keep MH happy

//Include guards to prevent multiple inclusion of this header
#ifndef OOMPH_PROBLEM_CLASS_HEADER
#define OOMPH_PROBLEM_CLASS_HEADER


// Config header generated by autoconfig
#ifdef HAVE_CONFIG_H
  #include <oomph-lib-config.h>
#endif

//OOMPH-LIB headers
#include "Vector.h"
#include "matrices.h"
#include "explicit_timesteppers.h"
#include <complex>



namespace oomph
{
 //Forward definition for Data class
 class Data;

 //Forward definition for Time class
 class Time;

 //Forward definition for TimeStepper class
 class TimeStepper;

 //Forward definition for Mesh class
 class Mesh;

 //Forward definition for RefineableElement class
 class RefineableElement;

 //Forward definition for the GeneralisedElement class
 class GeneralisedElement;

 //Forward definition for the Linearsolver class
 class LinearSolver;

 //Forward definition for the Eigensolver class
 class EigenSolver;

 //Forward definition for the assembly handler
 class AssemblyHandler;


//=======================================================================
/// \short The Problem class
///
/// The main components of a Problem are:
/// - a pointer to the (global) Mesh (which provides ordered
///   access to the nodes, elements, etc of all submeshes in the problem --
///   if there are any)
/// - pointers to the submeshes (if there are any)
/// - pointers to any global Data
/// - a pointer to the global Time
/// - pointers to the Timestepper used in the problem
/// - a pointer to the linear solver that will be used in Newton's method
/// - pointers to all DOFs in the problem.
///
/// Obviously, at this level in the code hierarchy, many things become
/// very problem-dependent but when setting up a specific problem 
/// (as a class that inherits from Problem), the problem constructor
/// will/should typically have a structure similar to this:
/// \code 
/// // Set up a timestepper
///  TimeStepper* time_stepper_pt=new Steady;
///
/// // Add timestepper to problem
///  add_time_stepper_pt(time_stepper_pt);
///
/// // Build and assign mesh
///  Problem::mesh_pt() = new SomeMesh<ELEMENT_TYPE>(Nelement,time_stepper_pt);
///
/// // Set the boundary conditions for this problem: All nodes are
/// // free by default -- just pin the ones that have Dirichlet conditions
/// // here (boundary 0 in this example)
/// unsigned i_bound = 0
/// unsigned num_nod= mesh_pt()->nboundary_node(ibound);
///   for (unsigned inod=0;inod<num_nod;inod++)
///    {
///      mesh_pt()->boundary_node_pt(ibound,inod)->pin(0);
///    }
/// 
/// // Complete the build of all elements so they are fully functional
///
///  // Setup equation numbering scheme
///  oomph_info <<"Number of equations: " << assign_eqn_numbers() << std::endl;
/// \endcode
/// For time-dependent problems, we can then use
/// \code assign_initial_values_impulsive (); \endcode
/// to generate an initial guess (for an impulsive start) and
/// the problem can then be solved, e.g. using the steady
/// or unsteady Newton solvers
/// \code newton_solve() \endcode
/// or
/// \code unsteady_newton_solve(...) \endcode
///
//=======================================================================
 class Problem : public ExplicitTimeSteppableObject
{
 //The handler classes need to be friend
 friend class FoldHandler;
 friend class PitchForkHandler;
 friend class HopfHandler;
 friend class BlockFoldLinearSolver;
 friend class BlockPitchForkLinearSolver;
 friend class BlockHopfLinearSolver;

  private: 

 /// The mesh pointer 
 Mesh* Mesh_pt;

 /// Vector of pointers to submeshes
 Vector<Mesh*> Sub_mesh_pt;
 
 /// Pointer to the linear solver for the problem
 LinearSolver* Linear_solver_pt;

 /// Pointer to the eigen solver for the problem
 EigenSolver* Eigen_solver_pt;

 //Pointer to handler
 AssemblyHandler *Assembly_handler_pt;

 /// Pointer to the default linear solver
 LinearSolver* Default_linear_solver_pt;

 /// Pointer to the default eigensolver
 EigenSolver* Default_eigen_solver_pt;
  
 /// Pointer to the default assembly handler
 AssemblyHandler* Default_assembly_handler_pt;

 /// Pointer to global time for the problem
 Time* Time_pt;

 /// \short The Vector of time steppers (there could be many 
 /// different ones in multiphysics problems)
 Vector<TimeStepper*> Time_stepper_pt;

 /// \short Pointer to a single explicit timestepper
 ExplicitTimeStepper *Explicit_time_stepper_pt;

 /// Pointer to vector for backup of dofs
 Vector<double>* Saved_dof_pt;

 /// \short Private helper function that is used to assemble the Jacobian 
 /// matrix in the case when the storage is row or column compressed.
 /// The boolean Flag indicates
 /// if we want compressed row format (true) or compressed column.
 /// This version uses vectors of pairs.
 virtual void sparse_assemble_row_or_column_compressed_with_vectors_of_pairs(
  Vector<Vector<int> > &column_or_row_index,
  Vector<Vector<int> > &row_or_column_start,
  Vector<Vector<double> > &value, 
  Vector<Vector<double>*> &residual,
  bool compressed_row_flag);

 /// \short Private helper function that is used to assemble the Jacobian 
 /// matrix in the case when the storage is row or column compressed.
 /// The boolean Flag indicates
 /// if we want compressed row format (true) or compressed column.
 /// This version uses two vectors.
 virtual void sparse_assemble_row_or_column_compressed_with_two_vectors(
  Vector<Vector<int> > &column_or_row_index,
  Vector<Vector<int> > &row_or_column_start,
  Vector<Vector<double> > &value, 
  Vector<Vector<double>*> &residual,
  bool compressed_row_flag);

 /// \short Private helper function that is used to assemble the Jacobian 
 /// matrix in the case when the storage is row or column compressed.
 /// The boolean Flag indicates
 /// if we want compressed row format (true) or compressed column.
 /// This version uses maps
 virtual void sparse_assemble_row_or_column_compressed_with_maps(
  Vector<Vector<int> > &column_or_row_index,
  Vector<Vector<int> > &row_or_column_start,
  Vector<Vector<double> > &value, 
  Vector<Vector<double>*> &residual,
  bool compressed_row_flag);

 /// \short Private helper function that is used to assemble the Jacobian 
 /// matrix in the case when the storage is row or column compressed.
 /// The boolean Flag indicates
 /// if we want compressed row format (true) or compressed column.
 /// This version uses lists
 virtual void sparse_assemble_row_or_column_compressed_with_lists(
  Vector<Vector<int> > &column_or_row_index,
  Vector<Vector<int> > &row_or_column_start,
  Vector<Vector<double> > &value, 
  Vector<Vector<double>*> &residual,
  bool compressed_row_flag);


 /// \short Vector of global data: "Nobody" (i.e. none of the elements etc.)
 /// is "in charge" of this Data so it would be overlooked when it
 /// comes to equation-numbering, timestepping etc. Including
 /// (pointers) to such Data in here, puts the Problem itself 
 /// "in charge" of these tasks.
 Vector<Data*> Global_data_pt;

 /// \short A function that performs the guts of the continuation
 /// derivative calculation in arc length continuation problems.
 void calculate_continuation_derivatives_helper(const DoubleVector &z);

#ifdef OOMPH_HAS_MPI

 /// \short Assemble entire Jacobian matrix in compressed row [or column]
 /// format in parallel. Each processor first assembles a block of rows
 /// of the complete Jacobian and residual, and then assembles the whole
 /// Jacobian and residual.
 /// column_or_row_index : Column [or row] index of given entry
 /// row_or_column_start : Index of first entry for given row [or column]
 /// value               : Vector of nonzero entries
 /// residuals           : Residual vector
 /// compressed_row_flag : compressed row storage? Otherwise
 ///                       compressed column -- defaults to false as 
 ///                       this is the format required by the global memory
 ///                       version of SuperLU_dist
 void global_matrix_sparse_assemble
 (Vector<Vector<int> > &column_or_row_index,
  Vector<Vector<int> > &row_or_column_start,
  Vector<Vector<double> > &value,
  Vector<Vector<double>*> &residuals,
  bool compressed_row_flag=false);


 /// \short Assembles a block of successive rows [or columns] of the
 /// Jacobian matrix in distributed compressed row format (as required by
 /// the distributed storage version of SuperLU_dist) or in compressed
 /// column storage, plus the associated distributed residuals.
 /// This function assembles the rows [or columns] for each processor
 /// by first calling partial_sparse_assemble and then communicates
 /// between processors to assemble distributed sets of rows [or columns].
 /// Arguments are the obvious ones, but note the following:
 /// - Matrix is stored in CR [or CC] format, however only the
 ///   entries for a subset of rows are included, with
 ///   \c first_row_or_column being the first row [or column] stored here.
 /// - The i-th entry in \c row_or_column_start corresponds
 ///   to the (i+first_row_or_column) -th row [or column] in the global matrix.
 /// - The residual vector contains the subset of entries corresponding
 ///   to the same set of rows [or columns] of the matrix, so the
 ///   i-th entry in the residual vector returned corresponds
 ///   to the (i+first_row_or_column) -th entry in the global residual vector.
 ///   (This is the format that is required by SuperLU_dist).
 /// - \c n_row_or_column is number of consecutive rows [columns] held locally.
 /// - \c n_tot is total number of rows [columns] in the overall matrix.
 /// - \c compressed_row_flag defaults to true.
 void distributed_matrix_sparse_assemble(
  Vector<Vector<int> > &column_or_row_index,
  Vector<Vector<int> > &row_or_column_start,
  Vector<Vector<double> > &value,
  Vector<Vector<double>*> &residuals,
  unsigned long& first_row_or_column,
  unsigned long& n_row_or_column,
  unsigned long& n_tot,
  bool compressed_row_flag);
#endif

protected:

 /// Vector of pointers to dofs
 Vector<double*> Dof_pt;

 //--------------------- Newton solver parameters

 /// \short The Tolerance below which the Newton Method is deemed to have 
 /// converged
 double Newton_solver_tolerance;

 /// Maximum number of Newton Iterations
 unsigned Max_newton_iterations;

 /// \short Maximum desired residual:
 /// if the maximum residual exceeds this value, the program will exit
 double Max_residuals;
 
 /// Is re-use of Jacobian in Newton iteration enabled? Default: false
 bool Jacobian_reuse_is_enabled;

 /// \short Has a Jacobian been computed (and can therefore be re-used 
 /// if required)? Default: false
 bool Jacobian_has_been_computed;


 /// \short Boolean flag indicating if we're dealing with a linear or nonlinear
 /// Problem -- if set to false the Newton solver will not check
 /// the residual before or after the linear solve. Set to true by default;
 /// can be over-written in specific Problem class.
 bool Problem_is_nonlinear;

 /// \short Flag to determine which sparse assembly method to use
 /// By default we use assembly by vectors of pairs.
 unsigned Sparse_assembly_method;

 /// \short Protected boolean flag to halt program execution
 /// during sparse assemble process to assess peak memory 
 /// usage. Initialised to false (obviously!)
 bool Pause_at_end_of_sparse_assembly;

 /// Enumerated flags to determine which sparse assembly method is used
 enum Assembly_method {Perform_assembly_using_vectors_of_pairs,
                       Perform_assembly_using_two_vectors,
                       Perform_assembly_using_maps,
                       Perform_assembly_using_lists};
 
 /// \short A tolerance used to determine whether the entry in a sparse
 /// matrix is zero. If it is then storage need not be allocated.
 double Numerical_zero_for_sparse_assembly;


 /// \short Protected helper function that is used to assemble the Jacobian 
 /// matrix in the case when the storage is row or column compressed.
 /// The boolean Flag indicates
 /// if we want compressed row format (true) or compressed column.
 virtual void sparse_assemble_row_or_column_compressed(
  Vector<Vector<int> > &column_or_row_index,
  Vector<Vector<int> > &row_or_column_start,
  Vector<Vector<double> > &value, 
  Vector<Vector<double>*> &residual,
  bool compressed_row_flag);

 //---------------------Explicit time-stepping parameters

 ///Is re-use of the mass matrix in explicit timestepping enabled Default:false
 bool Mass_matrix_reuse_is_enabled;
 
 ///\short Has the mass matrix been computed (and can therefore be reused) 
 ///Default: false
 bool Mass_matrix_has_been_computed;
 
 //---------------------Discontinuous control flags
 ///\short Is the problem a discontinuous one, i.e. can the
 ///elemental contributions be treated independently. Default: false
 bool Discontinuous_element_formulation;


 //--------------------- Adaptive time-stepping parameters

 /// Minimum desired dt: if dt falls below this value, exit
 double Minimum_dt;

 /// Maximum desired dt
 double Maximum_dt;

 /// \short Maximum possible increase of dt between time-steps in adaptive
 /// schemes
 double DTSF_max_increase;

 //---------------------  Arc-length continuation paramaters

 /// Boolean to control whether arc-length should be scaled
 bool Scale_arc_length;

 /// Proportion of the arc-length to taken by the parameter
 double Desired_proportion_of_arc_length;

 /// \short Value of the scaling parameter required so that the parameter 
 /// occupies the desired proportion of the arc length
 double Theta_squared;

 /// Storage for the sign of the global Jacobian 
 int Sign_of_jacobian;

 /// \short The direction of the change in parameter that will ensure that
 /// a branch is followed in one direction only
 double Continuation_direction;

 /// Storage for the derivative of the global parameter wrt arc-length
 double Parameter_derivative;

 /// Storage for the present value of the global parameter
 double Parameter_current;

 /// Storage for the derivatives of the problem variables wrt arc-length
 Vector<double> Dof_derivatives;

 /// Storage for the present values of the variables
 Vector<double> Dofs_current;

 /// Storage for the current step value
 double Ds_current;

 /// \short The desired number of Newton Steps to reach convergence at each
 /// step along the arc
 unsigned Desired_newton_iterations_ds;

 /// Minimum desired value of arc-length
 double Minimum_ds;

 /// Boolean to control bifurcation detection
 bool Bifurcation_detection;

 /// Boolean to indicate whether a sign change has occured in the Jacobian
 bool First_jacobian_sign_change;

 /// Boolean to indicate whether an arc-length step has been taken
 bool Arc_length_step_taken;

#ifdef OOMPH_HAS_MPI
 /// Has the problem been distributed amongst multiple processors?
 bool Problem_has_been_distributed;

  public:

 /// access function to the problem has been distributed flag
 const bool distributed() const { return Problem_has_been_distributed; }

  protected:
#endif

 /// \short Any actions that are to be performed before a complete 
 /// Newton solve (e.g. adjust boundary conditions). CAREFUL: This
 /// step should (and if the FD-based LinearSolver FD_LU is used, must) 
 /// only update values that are pinned!
 virtual void actions_before_newton_solve() { }

 /// \short Any actions that are to be performed after a complete Newton solve,
 /// e.g. post processing.  CAREFUL: This
 /// step should (and if the FD-based LinearSolver FD_LU is used, must) 
 /// only update values that are pinned!
 virtual void actions_after_newton_solve() { }

 /// \short Any actions that are to be performed before 
 /// the residual is checked in the Newton method, e.g. update 
 /// any boundary conditions that depend upon
 /// variables of the problem; update any `slave' variables; or
 /// perform an update of the nodal positions in SpineMeshes etc.
 /// CAREFUL: This
 /// step should (and if the FD-based LinearSolver FD_LU is used, must) 
 /// only update values that are pinned!
 virtual void actions_before_newton_convergence_check(){}

 /// \short Any actions that are to be performed before each individual
 /// Newton step. Most likely to be used for diagnostic purposes 
 /// to doc the solution during a non-converging iteration, say.
 virtual void actions_before_newton_step() {}

 /// \short Any actions that are to be performed after each individual
 /// Newton step. Most likely to be used for diagnostic purposes 
 /// to doc the solution during a non-converging iteration, say.
 virtual void actions_after_newton_step(){}

 /// \short Actions that should be performed before each implicit time step. 
 /// This is needed when one wants
 /// to solve a steady problem before timestepping and needs to distinguish
 /// between the two cases
 virtual void actions_before_implicit_timestep() {}

 /// \short Actions that should be performed after each implicit time step. 
 /// This is needed when one wants
 /// to solve a steady problem before timestepping and needs to distinguish
 /// between the two cases
 virtual void actions_after_implicit_timestep() {}

 /// \short Actions that should be performed before each explicit time step. 
 virtual void actions_before_explicit_timestep() {}

 /// \short Actions that should be performed after each explicit time step. 
 virtual void actions_after_explicit_timestep() {}

 /// \short Actions that are to be performed before a mesh adaptation. 
 /// These might include removing any additional elements, such as traction
 /// boundary elements before the adaptation.
 virtual void actions_before_adapt() {}
 
 /// Actions that are to be performed after a mesh adaptation.
 virtual void actions_after_adapt() {}
 
 /// \short Actions that are to be performed when the global parameter
 /// has been changed in the function get_derivative_wrt_global_parameter()
 /// The default is to call actions_before_newton_solve(), 
 /// actions_before_newton_convergence_check() and 
 /// actions_after_newton_solve().
 /// This could be amazingly inefficient in certain problems and should 
 /// be overloaded in such cases. An example would be when a remesh is
 /// required in general, but the global parameter does not affect the mesh
 /// directly.
 virtual void actions_after_change_in_global_parameter()
  {
   //Default action should cover all possibilities
   actions_before_newton_solve();
   actions_before_newton_convergence_check();
   actions_after_newton_solve();
  }

 /// \short Actions that are to be performed after a change in the parameter
 /// that is being varied as part of the solution of a bifurcation detection
 /// problem. The default is to call actions_before_newton_solve(), 
 /// actions_before_newton_convergence_check() and 
 /// actions_after_newton_solve().
 /// This could be amazingly inefficient in certain problems and should 
 /// be overloaded in such cases. An example would be when a remesh is
 /// required in general, but the global parameter does not affect the mesh
 /// directly.
 virtual void actions_after_change_in_bifurcation_parameter()
  {
   //Default action should cover all possibilities
   actions_before_newton_solve();
   actions_before_newton_convergence_check();
   actions_after_newton_solve();
  }


 /// \short Set initial condition (incl previous timesteps). 
 /// We need to establish this interface
 /// because I.C. needs to be reset when problem is adapted during
 /// the first timestep.
 virtual void set_initial_condition()
  {
   std::ostringstream warn_message;
   warn_message
    << "Warning: We're using the default (empty) set_initial_condition().\n"
    << "If the initial conditions isn't re-assigned after a mesh adaption \n" 
    << "the initial conditions will represent the interpolation of the \n"
    << "initial conditions that were assigned on the original coarse mesh.\n";
   OomphLibWarning(warn_message.str(),
                   "Problem::set_initial_condition()",
                   OOMPH_EXCEPTION_LOCATION);
   
  }

 /// \short Function to calculate a global error norm, used in adaptive
 /// timestepping to control the change in timestep. Individual errors for
 /// each data object can be obtained via the data timestepper's 
 /// temporal_error_in_value or temporal_error_in_position functions and should
 /// be combined to construct a global norm. For example, in fluids problems
 /// a suitable norm is usually the weighted sum of the errors in the 
 /// velocities; for moving mesh problems is it usually better to use
 /// the weighted sum of the errors in position.
 virtual double global_temporal_error_norm()
  {
   std::string error_message =
    "The global_temporal_error_norm function will be problem-specific:\n";
   error_message +=
    "Please write your own in your Problem class";
   
   throw OomphLibError(error_message,
                       "Problem::global_temporal_error_norm()",
                       OOMPH_EXCEPTION_LOCATION);
   return 0.0;
  }

 /// The communicator for this problem - by default the underlying MPI_Comm
 /// object is MPI_COMM_WORLD
 OomphCommunicator* Communicator_pt;

  public:

 /// access function to the oomph-lib communicator
 const OomphCommunicator* communicator_pt() const
  {
   return Communicator_pt;
  }

 /// Function pointer for spatial error estimator
 typedef void(*SpatialErrorEstimatorFctPt)(Mesh*& mesh_pt, 
                                           Vector<double>& elemental_error);
 
 /// Function pointer for spatial error estimator with doc
 typedef void(*SpatialErrorEstimatorWithDocFctPt)(Mesh*& mesh_pt, 
                                                  Vector<double>& 
                                                  elemental_error,
                                                  DocInfo& doc_info);
 
 /// \short Constructor: Allocate space for one time stepper
 /// and set all pointers to NULL and set defaults for all
 /// parameters.
 Problem();

 /// Broken copy constructor
 Problem(const Problem& dummy) 
  { 
   BrokenCopy::broken_copy("Problem");
  } 
 
 /// Broken assignment operator
 void operator=(const Problem&) 
  {
   BrokenCopy::broken_assign("Problem");
  }


 /// Virtual destructor to clean up memory
 virtual ~Problem();

 /// Return a pointer to the global mesh
 Mesh*& mesh_pt() {return Mesh_pt;}

 /// Return a pointer to the global mesh (const version)
 Mesh* const &mesh_pt() const {return Mesh_pt;}
 
 /// \short Return a pointer to the i-th submesh. If there are
 /// no submeshes, the 0-th submesh is the global mesh itself.
 Mesh* &mesh_pt(const unsigned &imesh)
  {
   // If there are no submeshes then the zero-th submesh is the 
   // mesh itself 
   if((Sub_mesh_pt.size()==0)&&(imesh==0)) {return Mesh_pt;}
   else {return Sub_mesh_pt[imesh];}
  }

 /// Return a pointer to the i-th submesh (const version)
 Mesh* const &mesh_pt(const unsigned &imesh) const
  {
   // If there are no submeshes then the zero-th submesh is the 
   // mesh itself 
   if((Sub_mesh_pt.size()==0)&&(imesh==0)) {return Mesh_pt;}
   else {return Sub_mesh_pt[imesh];}
  }

 /// Return number of submeshes
 unsigned nsub_mesh() const {return Sub_mesh_pt.size();}

 /// \short Add a submesh to the problem and return its number, i, by which it
 /// can be accessed via mesh_pt(i).
 unsigned add_sub_mesh(Mesh* const &mesh_pt) 
  {
   Sub_mesh_pt.push_back(mesh_pt);
   return Sub_mesh_pt.size()-1;
  }


 /// \short Flush the problem's collection of sub-meshes. Must be followed
 /// by call to rebuild_global_mesh().
 void flush_sub_meshes() {Sub_mesh_pt.clear();}

 /// \short Build the global mesh by combining the all the submeshes.
 /// \b Note: The nodes boundary information refers to the boundary numbers
 /// within the submesh!
 void build_global_mesh();

 /// \short If one of the submeshes has changed (e.g. by
 /// mesh adaptation) we need to update the global mesh.
 /// \b Note: The nodes boundary information refers to the
 /// boundary numbers within the submesh!
 void rebuild_global_mesh();

 /// Return a pointer to the linear solver object
 LinearSolver* &linear_solver_pt() {return Linear_solver_pt;}

 /// Return a pointer to the linear solver object (const version)
 LinearSolver* const &linear_solver_pt() const {return Linear_solver_pt;}

 /// Return a pointer to the eigen solver object
 EigenSolver* &eigen_solver_pt() {return Eigen_solver_pt;}

 /// Return a pointer to the eigen solver object (const version)
 EigenSolver* const &eigen_solver_pt() const {return Eigen_solver_pt;}

 /// Return a pointer to the global time object
 Time* &time_pt() {return Time_pt;}

 /// Return the current value of continuous time
 double& time(); 

 /// \short Access function for the pointer to the first (presumably only) 
 /// timestepper
 TimeStepper* &time_stepper_pt()
  {
   if (Time_stepper_pt.size()==0)
    {
     throw OomphLibError("No timestepper allocated yet\n",
                         "Problem::time_stepper_pt()",
                         OOMPH_EXCEPTION_LOCATION);
    }
   return Time_stepper_pt[0];
  }

 /// Return a pointer to the i-th timestepper
 TimeStepper* &time_stepper_pt(const unsigned &i)
  {return Time_stepper_pt[i];}

 /// Return a pointer to the explicit timestepper
 ExplicitTimeStepper* &explicit_time_stepper_pt()
  {return Explicit_time_stepper_pt;}

 /// \short Shift all values along to prepare for next timestep
 void shift_time_values();

 /// Return a pointer to the assembly handler object
 AssemblyHandler* &assembly_handler_pt() {return Assembly_handler_pt;}
 
 /// Return a pointer to the assembly handler object (const version)
 AssemblyHandler* const &assembly_handler_pt() const 
  {return Assembly_handler_pt;}
  
 /// \short Access function to min timestep in adaptive timestepping
 double& minimum_dt() {return Minimum_dt;}
 
 /// \short Access function to max timestep in adaptive timestepping
 double& maximum_dt() {return Maximum_dt;}

 /// \short Add a timestepper to the problem. The function will automatically
 /// create or resize the Time object so that it contains the appropriate
 /// number of levels of storage.
 void add_time_stepper_pt(TimeStepper* const &time_stepper_pt);

 /// \short Set the explicit timestepper for the problem. The function
 /// will automatically create or resize the Time object so that it contains
 /// the appropriate number of levels of storage
 void set_explicit_time_stepper_pt(ExplicitTimeStepper* 
                                   const &explicit_time_stepper_pt);


 /// \short Set all timesteps to the same value, dt, and assign 
 /// weights for all timesteppers in the problem
 void initialise_dt(const double& dt);

 /// \short Set the value of the timesteps to be equal to the values passed in 
 /// a vector and assign weights for all timesteppers in the problem
 void initialise_dt(const Vector<double>& dt);

 /// Return a pointer to the the i-th global data object
 Data* &global_data_pt(const unsigned &i) {return Global_data_pt[i];}

 /// \short Add Data to the Problem's global data -- the Problem will
 /// perform equation numbering etc. for such Data
 void add_global_data(Data* const &global_data_pt)
  {Global_data_pt.push_back(global_data_pt);}


 /// \short Flush the Problem's global data  -- resizes container to zero.
 /// Data objects are not deleted!
 void flush_global_data() {Global_data_pt.resize(0);}


 /// Return the number of dofs
 unsigned long ndof() const 
  {return Dof_pt.size();}

 /// Return the number of time steppers
 unsigned ntime_stepper() const {return Time_stepper_pt.size();}

 ///Return the number of global data values
 unsigned nglobal_data() const {return Global_data_pt.size();}

 /// \short Self-test: Check meshes and global data. Return 0 for OK
 unsigned self_test();

 /// \short Assign all equation numbers for problem: Deals with global
 /// data (= data that isn't attached to any elements) and then
 /// does the equation numbering for the elements. Virtual so it 
 /// can be overloaded in MPI problems.
 virtual unsigned long assign_eqn_numbers();

 /// \short Indicate that the problem involves discontinuous elements
 /// This allows for a more efficiently assembly and inversion of the
 /// mass matrix
 void enable_discontinuous_formulation() 
  {Discontinuous_element_formulation = true;}

 /// \short Disable the use of a discontinuous-element formulation.
 /// Note that the methods will all still work even if the elements are
 /// discontinuous, we will just be assembling a larger system matrix than
 /// necessary.
 void disable_discontinuous_formulation()
  {Discontinuous_element_formulation = false;}



 /// \short Return the vector of dofs, i.e. a vector containing the current
 /// values of all unknowns.
 void get_dofs(DoubleVector& dofs);

 /// \short Set the values of the dofs
 void set_dofs(const DoubleVector &dofs);

 /// \short Add lambda x incremenet_dofs[l] to the l-th dof
 void add_to_dofs(const double &lambda, const DoubleVector &increment_dofs);

 /// \short i-th dof in the problem
 double& dof(const unsigned& i)
  {
   return *(Dof_pt[i]);
  }

 /// \short i-th dof in the problem (const version)
 double dof(const unsigned& i) const
  {
   return *(Dof_pt[i]);
  }

 ///\short Return the residual vector multiplied by the inverse mass matrix
 ///Virtual so that it can be overloaded for mpi problems
 virtual void get_inverse_mass_matrix_times_residuals(DoubleVector &Mres);

 /// \short Return the fully-assembled residuals Vector for the problem: 
 /// Virtual so it can be overloaded in for mpi problems
 virtual void get_residuals(DoubleVector &residuals);

 /// \short Return the fully-assembled Jacobian and residuals for the problem
 /// Interface for the case when the Jacobian matrix is dense.
 /// This is virtual so, if we feel like it (e.g. for testing iterative
 /// solvers with specific test matrices, we can bypass the default
 /// assembly procedure for the Jacobian and the residual vector.
 virtual void get_jacobian(DoubleVector &residuals, 
                           DenseDoubleMatrix& jacobian);

 /// \short Return the fully-assembled Jacobian and residuals for the problem.
 /// Interface for the case when the Jacobian is in row-compressed storage
 /// format. This is virtual so, if we feel like it (e.g. for testing iterative
 /// solvers with specific test matrices), we can bypass the default
 /// assembly procedure for the Jacobian and the residual vector.
 virtual void get_jacobian(DoubleVector &residuals,
                           CRDoubleMatrix &jacobian);

 /// \short Return the fully-assembled Jacobian and residuals for the problem.
 /// Interface for the case when the Jacobian is in column-compressed storage
 /// format. This is virtual so, if we feel like it (e.g. for testing iterative
 /// solvers with specific test matrices), we can bypass the default
 /// assembly procedure for the Jacobian and the residual vector.
 virtual void get_jacobian(DoubleVector &residuals, 
                           CCDoubleMatrix &jacobian);

 /// \short Return the fully-assembled Jacobian and residuals, generated by
 /// finite differences
 void get_fd_jacobian(DoubleVector &residuals, 
                      DenseMatrix<double> &jacobian);

 /// \short Get the derivative of the entire residuals vector wrt a 
 /// global parameter, used in continuation problems
 void get_derivative_wrt_global_parameter(double* const &parameter_pt,
                                          DoubleVector &result);

 /// \short Get derivative of an element in the problem wrt a global parameter,
 /// used in continuation problems
 void get_derivative_wrt_global_parameter(double* const &parameter_pt,
                                          GeneralisedElement* const &elem_pt,
                                          Vector<double> &result);

 /// \short Solve an eigenproblem as assembled by EigenElements
 /// calculate n_eval eigenvalues and return the corresponding
 /// eigenvectors
 void solve_eigenproblem(const unsigned &n_eval, 
                         Vector<std::complex<double> > &eigenvalue,
                         Vector<DoubleVector> &eigenvector);

 /// \short Solve an eigenproblem as assembled by EigenElements, 
 /// but only return the eigenvalues, not the eigenvectors
 void solve_eigenproblem(const unsigned &n_eval,
                         Vector<std::complex<double> > &eigenvalue)
  {
   //Create temporary storage for the eigenvectors (potentially wasteful)
   Vector<DoubleVector> eigenvector;
   solve_eigenproblem(n_eval,eigenvalue,eigenvector);
  }

 /// \short Get the matrices required by a eigensolver. If the
 ///shift parameter is non-zero the second matrix will be shifted
 void get_eigenproblem_matrices(CRDoubleMatrix &mass_matrix,
                                CRDoubleMatrix &main_matrix,
                                const double &shift=0.0);
 
 /// \short Assign the eigenvector passed to the function
 /// to the dofs in the problem so that it can be output by
 /// the usual routines.
 void assign_eigenvector_to_dofs(DoubleVector &eigenvector);
 
 /// \short Add the eigenvector passed to the function scaled by
 /// the constat epsilon to the dofs in the problem so that 
 /// it can be output by the usual routines
 void add_eigenvector_to_dofs(const double &epsilon,
                              DoubleVector &eigenvector);

 /// \short Store the current values of the degrees of freedom
 void store_current_dof_values();

 /// \short Restore the stored values of the degrees of freedom
 void restore_dof_values();

 /// \short Enable recycling of Jacobian in Newton iteration 
 /// (if the linear solver allows it).
 /// Useful for linear problems with constant Jacobians or nonlinear
 /// problems where you're willing to risk the trade-off between
 /// faster solve times and degraded Newton convergence rate
 void enable_jacobian_reuse()
  {
   Jacobian_reuse_is_enabled=true;
   Jacobian_has_been_computed=false;
  }

 /// \short Disable recycling of Jacobian in Newton iteration
 void disable_jacobian_reuse()
  {
   Jacobian_reuse_is_enabled=false;
   Jacobian_has_been_computed=false;
  }

 /// \short Is recycling of Jacobian in Newton iteration enabled?
 bool jacobian_reuse_is_enabled()
  {
   return Jacobian_reuse_is_enabled;
  }

 /// \short Use Newton method to solve the problem
 void newton_solve();

 /// \short Adaptive Newton solve: up to max_adapt adaptations of all
 /// refineable submeshes are performed to achieve the 
 /// the error targets specified in the refineable submeshes.
 void newton_solve(unsigned const &max_adapt);

 /// \short Solve a steady problem using adaptive Newton's method, 
 /// but in the context of an overall unstady problem, perhaps to 
 /// determine an initial condition. 
 /// This is achieved by setting the weights in the timesteppers to be zero
 /// which has the effect of rendering them steady timesteppers.
 /// The optional argument max_adapt specifies the max. number of 
 /// adaptations of all refineable submeshes are performed to 
 /// achieve the the error targets specified in the refineable submeshes.
 void steady_newton_solve(unsigned const &max_adapt=0);

/// \short Copy Data values, nodal positions etc from specified problem.
/// Note: This is not a copy constructor. We assume that the current
/// and the "original" problem have both been created by calling
/// the same problem constructor so that all Data objects,
/// time steppers etc. in the two problems are completely independent.
/// This function copies the nodal, internal and global values,
/// and the time parameters from the original problem into
/// "this" one. This functionality is required, e.g. for
/// multigrid computations.
 void copy(Problem* orig_problem_pt);

 /// \short Read refinement pattern of all refineable meshes and refine them
 /// accordingly, then read all Data and nodal position info from 
 /// file for restart. Return flag to indicate if the restart was from 
 /// steady or unsteady solution
 virtual void read(std::ifstream& restart_file, bool& unsteady_restart);

 /// \short Read refinement pattern of all refineable meshes and refine them
 /// accordingly, then read all Data and nodal position info from 
 /// file for restart. 
 virtual void read(std::ifstream& restart_file)
  {
   bool unsteady_restart;
   read(restart_file,unsteady_restart);
  }

 /// \short Dump refinement pattern of all refineable meshes and all generic
 /// Problem data to file for restart. 
 virtual void dump(std::ofstream& dump_file);

#ifdef OOMPH_HAS_MPI

 /// \short Classify any non-classified nodes into halo/haloed and
 /// synchronise equation numbers. Return the total
 /// number of degrees of freedom in the overall problem
 long synchronise_eqn_numbers();

 /// \short Synchronise the degrees of freedom by overwriting
 /// the haloed values with their non-halo counterparts held
 /// on other processors
 void synchronise_dofs();

 /// Check the halo/haloed node/element schemes
 void check_halo_schemes(DocInfo& doc_info);

 /// Check the halo/haloed node/element schemes
 void check_halo_schemes()
  {
   DocInfo tmp_doc_info;
   tmp_doc_info.doc_flag()=false;
   check_halo_schemes(tmp_doc_info);
  }

 /// Distribute the problem and doc
 void distribute(DocInfo& doc_info, 
                 const bool& report_stats);
 
 /// Distribute the problem
 void distribute(const bool& report_stats=false)
  {
   DocInfo doc_info;
   doc_info.doc_flag()=false;
   distribute(doc_info,report_stats);
  }

 /// \short (Irreversibly) redistribute elements and nodes, usually
 /// after another round of refinement, to get rid of
 /// excessively wide halo layers. Note that the current
 /// mesh will be now regarded as the base mesh and no unrefinement
 /// relative to it will be possible once this function 
 /// has been called.
 void redistribute(DocInfo& doc_info, 
                   const bool& report_stats);


 /// \short (Irreversibly) redistribute elements and nodes, usually
 /// after another round of refinement, to get rid of
 /// excessively wide halo layers. Note that the current
 /// mesh will be now regarded as the base mesh and no unrefinement
 /// relative to it will be possible once this function 
 /// has been called.
  void redistribute(const bool& report_stats=false)
  {
   DocInfo doc_info;
   doc_info.doc_flag()=false;
   redistribute(doc_info,report_stats);
  }
  
  /// Threshold for error throwing in Problem::check_halo_schemes()
  double Max_permitted_error_for_halo_check;

#endif

  /// \short Boolean to indicate if all output is suppressed in 
  /// Problem::newton_solve(). Defaults to false.
  bool Shut_up_in_newton_solve;

  protected:

 /// \short Perform a basic arc-length continuation step using Newton's
 /// method. Returns number of Newton steps taken.
 unsigned newton_solve_continuation(double* const &parameter_pt);

 /// \short This function performs a basic continuation step using the Newton 
 /// method. The number of Newton steps taken is returned, to be used in any 
 /// external step-size control routines. 
 /// The governing parameter of the problem is passed as a pointer to the
 /// routine, as is a vector in which 
 /// to store the derivatives wrt the parameter, if required.
 unsigned newton_solve_continuation(double* const &parameter_pt, 
                                    DoubleVector &z);

 ///\short A function to calculate the derivatives wrt the arc-length. This 
 /// version of the function actually does a linear solve so that the 
 /// derivatives
 /// are calculated "exactly" rather than using the values at the Newton
 /// step just before convergence. This is necessary in spatially adaptive
 /// problems, in which the number of degrees of freedom changes and so
 /// the appropriate derivatives must be calculated for the new variables.
 /// This function is called if no Newton steps were taken in the
 /// continuation routine ... i.e. the initial residuals were sufficiently
 /// small.
 void calculate_continuation_derivatives(double* const &parameter_pt);
 
 /// \short A function to calculate the derivatives with respect to the 
 /// arc-length required for continuation. The arguments is the solution 
 /// of the  linear system,
 /// Jz = dR/dparameter, that gives du/dparameter and the direction 
 /// output from the newton_solve_continuation function. The derivatives
 /// are stored in the ContinuationParameters namespace.
 void calculate_continuation_derivatives(const DoubleVector &z);

  public:

 /// \short Turn on fold tracking using the augmented system specified
 /// in the FoldHandler class. After a call to this function subsequent calls
 /// of the standard solution methods will converge to a fold (limit) point
 /// at a particular value of the variable addressed by parameter_pt.
 /// The system may not converge if the initial guess is sufficiently poor
 /// or, alternatively, if finite differencing is used to calculate the 
 /// jacobian matrix in the elements.  If the boolean flag block_solver is
 /// true (the default) then a block factorisation is used to solve the
 /// augmented system which is both faster and uses less memory.
 void activate_fold_tracking(double* const &parameter_pt,
                             const bool &block_solve=true);

 /// \short Turn on pitchfork tracking using the augmented system specified
 /// in the PitchForkHandler class. 
 /// After a call to this function subsequent calls
 /// of the standard solution methods will converge to a pitchfork 
 /// bifurcation
 /// at a particular value of the variable addressed by parameter_pt.
 /// The symmetry that is to be broken must be specified by supplying
 /// a symmetry_vector(ndof). The easiest way to determine such a vector
 /// is to solve the associated eigenproblem \f$ Jx = \lambda M x\f$ 
 /// and pass in the eigenvector. This is not always necessary however,
 /// if the symmetry is easy to construct.
 /// The system may not converge if the initial guess is sufficiently poor
 /// or, alternatively, if finite differencing is used to calculate the 
 /// jacobian matrix in the elements. If the boolean flag block_solver is
 /// true (the default) then a block factorisation is used to solve the
 /// augmented system which is both faster and requires less memory.
 void activate_pitchfork_tracking(double* const &parameter_pt,
                                  const DoubleVector &symmetry_vector,
                                  const bool &block_solve=true);

 /// \short Turn on Hopf bifurcation
 /// tracking using the augmented system specified
 /// in the HopfHandler class. After a call to this function subsequent calls
 /// of the standard solution methods will converge to a Hopf bifuraction
 /// at a particular value of the variable addressed by parameter_pt.
 /// The system may not converge if the initial guess is sufficiently poor
 /// or, alternatively, if finite differencing is used to calculate the 
 /// jacobian matrix in the elements. 
 void activate_hopf_tracking(double* const &parameter_pt,
                             const bool &block_solve=true);

  /// \short Turn on Hopf bifurcation
 /// tracking using the augmented system specified
 /// in the HopfHandler class. After a call to this function subsequent calls
 /// of the standard solution methods will converge to a Hopf bifuraction
 /// at a particular value of the variable addressed by parameter_pt.
 /// The system may not converge if the initial guess is sufficiently poor
 /// or, alternatively, if finite differencing is used to calculate the 
 /// jacobian matrix in the elements. This interface allows specification
 /// of an inital guess for the frequency and real and imaginary parts
 /// of the null vector, such as might be obtained from an eigensolve
 void activate_hopf_tracking(double* const &parameter_pt,
                             const double &omega,
                             const DoubleVector &null_real,
                             const DoubleVector &null_imag,
                             const bool &block_solve=true);

 /// \short Deactivate all bifuraction tracking, by reseting
 /// the assembly handler to the default
 void deactivate_bifurcation_tracking()
  {reset_assembly_handler_to_default();}

 /// \short Reset the system to the standard non-augemented state
 void reset_assembly_handler_to_default();

 /// \short Solve a steady problem using arc-length continuation, where
 /// parameter is the parameter of the problem and ds is the arc_length
 double arc_length_step_solve(double* const &parameter_pt,
                              const double &ds);

 /// \short Reset the "internal" arc-length continuation parameters, so as
 /// to allow continuation in another parameter. N.B. The parameters that
 /// are reset are the "minimum" that are required, others should perhaps
 /// be reset, depending upon the application.
 void reset_arc_length_parameters()
  {
   Theta_squared = 1.0;
   Sign_of_jacobian = 0;
   Continuation_direction = 1.0;
   Parameter_derivative = 1.0;
   First_jacobian_sign_change=false; 
   Arc_length_step_taken=false;
   Dof_derivatives.resize(0);
  }

 /// \short Access function for the sign of the global jacobian matrix.
 /// This will be set by the linear solver, if possible (direct solver).
 /// If not alternative methods must be used to detect bifurcations 
 /// (solving the associated eigenproblem).
 int &sign_of_jacobian() {return Sign_of_jacobian;}

 /// \short Take an explicit timestep of size dt and optionally shift
 /// any stored values of the time history
 void explicit_timestep(const double &dt, const bool &shift_values=true);

 /// \short Advance time by dt and solve by Newton's method.
 /// This version always shifts time values
 void unsteady_newton_solve(const double &dt);

 /// \short Advance time by dt and solve the system,
 /// using Newton's method. The boolean flag is used to control 
 /// whether the time
 /// values should be shifted. If it is true the current data values will 
 /// be shifted (copied to the locations where there are stored as 
 /// previous timesteps) before solution.
 void unsteady_newton_solve(const double &dt, const bool &shift_values);

 /// \short Unsteady adaptive Newton solve: up to max_adapt adaptations of all
 /// refineable submeshes are performed to achieve the 
 /// the error targets specified in the refineable submeshes.
 /// If first==true, the initial conditions
 /// are re-assigned after the mesh adaptations.
 /// Shifting of time can be suppressed by overwriting the
 /// default value of shift (true). [Shifting must be done
 /// if first_timestep==true because we're constantly re-assigning
 /// the initial conditions; if first_timestep==true and shift==false
 /// shifting is performed anyway and a warning is issued.
 void unsteady_newton_solve(const double &dt, 
                            const unsigned &max_adapt,
                            const bool &first,
                            const bool& shift=true);


 /// \short Unsteady "doubly" adaptive Newton solve: Does temporal
 /// adaptation first, i.e. we try to do a timestep with an increment
 /// of dt, and adjusting dt until the solution on the given mesh satisfies
 /// the temporal error measure with tolerance epsilon. Following
 /// this, we do up to max_adapt spatial adaptions (without 
 /// re-examining the temporal error). If first==true, the initial conditions
 /// are re-assigned after the mesh adaptations.
 /// Shifting of time can be suppressed by overwriting the
 /// default value of shift (true). [Shifting must be done
 /// if first_timestep==true because we're constantly re-assigning
 /// the initial conditions; if first_timestep==true and shift==false
 /// shifting is performed anyway and a warning is issued.
 double doubly_adaptive_unsteady_newton_solve(const double &dt, 
                                              const double &epsilon,
                                              const unsigned &max_adapt,
                                              const bool &first,
                                              const bool& shift=true);

 
 /// \short Attempt to advance timestep by dt_desired. If the solution fails
 /// the timestep will be halved until convergence is achieved, or the timestep
 /// falls below NewtonSolverParameters::Minimum_time_step. The error control
 /// parameter epsilon represents the (approximate) desired magnitude of the 
 /// global error at each timestep. The routine returns
 /// a double that is the suggested next timestep and should be passed as
 /// dt_desired the next time the routine is called. This version always
 /// shifts the time values.
 double adaptive_unsteady_newton_solve(const double &dt_desired, 
                                       const double &epsilon);

 /// \short Attempt to advance timestep by dt_desired. If the solution fails
 /// the timestep will be halved until convergence is achieved, or the timestep
 /// falls below NewtonSolverParameters::Minimum_time_step. The error control
 /// parameter epsilon represents the (approximate) desired magnitude of the 
 /// global error at each timestep. The routine returns
 /// a double that is the suggested next timestep and should be passed as
 /// dt_desired the next time the routine is called.
 /// Once again the boolean flag, shift_values, is used to control whether
 /// the time values are shifted.
 double adaptive_unsteady_newton_solve(const double &dt_desired, 
                                       const double &epsilon,
                                       const bool &shift_values);
 
 /// \short Initialise data and nodal positions to simulate impulsive 
 /// start from initial configuration/solution
 void assign_initial_values_impulsive();

 /// \short Initialise data and nodal positions to simulate an impulsive
 /// start and also set the initial and previous values of dt
 void assign_initial_values_impulsive(const double &dt);

 /// \short Calculate predictions
 void calculate_predictions();

 ///\short Enable recycling of the mass matrix in explicit timestepping
 ///schemes. Useful for timestepping on fixed meshes when you want
 ///to avoid the linear solve phase.
 void enable_mass_matrix_reuse();

 ///\short Turn off recyling of the mass matrix in explicit timestepping 
 ///schemes
 void disable_mass_matrix_reuse();

 ///\short Return whether the mass matrix is being reused
 bool mass_matrix_reuse_is_enabled() {return Mass_matrix_reuse_is_enabled;}

 /// \short  Refine (all) refineable (sub)mesh(es) uniformly and 
 /// rebuild problem; doc refinement process.
 void refine_uniformly(DocInfo& doc_info);

 /// \short  Refine (all) refineable (sub)mesh(es) uniformly and 
 /// rebuild problem
 void refine_uniformly()
  {
   DocInfo doc_info;
   doc_info.doc_flag()=false;
   refine_uniformly(doc_info);
  }

 /// Do uniform refinement for submesh i_mesh with documentation
 void refine_uniformly(const unsigned& i_mesh, DocInfo& doc_info);

 /// Do uniform refinement for submesh i_mesh without documentation
 void refine_uniformly(const unsigned& i_mesh)
  {  
   DocInfo doc_info;
   doc_info.doc_flag()=false;
   refine_uniformly(i_mesh,doc_info);
  }

 /// \short Refine (one and only!) mesh by splitting the elements identified
 /// by their numbers relative to the problems' only mesh, then rebuild 
 /// the problem. [Can't see how/why one would want to do this for multiple
 /// meshes -- if you need this functionality implement it yourself;
 /// you'll probably need to pass a Vector of refinement Vectors...].
 void refine_selected_elements(const Vector<unsigned>& 
                               elements_to_be_refined);


 /// \short Refine (one and only!) mesh by splitting the elements identified
 /// by their pointers, then rebuild 
 /// the problem. [Can't see how/why one would want to do this for multiple
 /// meshes -- if you need this functionality implement it yourself;
 /// you'll probably need to pass a Vector of refinement Vectors...].
 void refine_selected_elements(const Vector<RefineableElement*>& 
                               elements_to_be_refined_pt);

 /// \short Refine specified submesh by splitting the elements identified
 /// by their pointers, then rebuild the problem.
 void refine_selected_elements(const unsigned& i_mesh,
                               const Vector<RefineableElement*>& 
                               elements_to_be_refined_pt);


 /// \short  Refine (all) refineable (sub)mesh(es) uniformly and 
 /// rebuild problem. Return 0 for success,
 /// 1 for failure (if unrefinement has reached the coarsest permitted
 /// level)
 unsigned unrefine_uniformly();

 /// Do uniform refinement for submesh i_mesh without documentation.
 /// Return 0 for success, 1 for failure (if unrefinement has reached 
 /// the coarsest permitted level)
 unsigned unrefine_uniformly(const unsigned& i_mesh);

 /// \short Adapt problem:
 /// Perform mesh adaptation for (all) refineable (sub)mesh(es),
 /// based on their own error estimates and the target errors specified
 /// in the mesh(es). Following mesh adaptation,
 /// update global mesh, and re-assign equation numbers. 
 /// Return # of refined/unrefined elements. On return from this
 /// function, Problem can immediately be solved again.
 void adapt(unsigned& n_refined, unsigned& n_unrefined);

 /// \short Adapt problem:
 /// Perform mesh adaptation for (all) refineable (sub)mesh(es),
 /// based on their own error estimates and the target errors specified
 /// in the mesh(es). Following mesh adaptation,
 /// update global mesh, and re-assign equation numbers. 
 /// On return from this function, Problem can immediately be solved again.
 /// [Argument-free wrapper]
 void adapt()
  {
   unsigned n_refined, n_unrefined;
   adapt(n_refined,n_unrefined);
  }

 /// \short Get max and min error for all elements in submeshes
 void doc_errors(DocInfo& doc_info);

 /// \short Get max and min error for all elements in submeshes
 void doc_errors()
  {
   DocInfo tmp_doc_info;
   tmp_doc_info.doc_flag()=false;
   doc_errors(tmp_doc_info);
  }

 /// \short Access fct to bool that controls if all output is suppressed
 /// in Problem::newton_solve(). (Default setting is false).
 bool& shut_up_in_newton_solve() {return Shut_up_in_newton_solve;}


};


//=======================================================================
/// A class to handle errors in the Newton solver
//=======================================================================
class NewtonSolverError
{
  public:

 /// Error in the linear solver
 bool linear_solver_error;

 /// Max. # of iterations performed when the Newton solver died
 unsigned iterations;

 /// Max. residual when Newton solver died
 double maxres;
 
 /// Default constructor, does nothing
 NewtonSolverError() : 
  linear_solver_error(false), iterations(0), maxres(0.0) {}

 ///Constructor that passes a failure of the linear solver
 NewtonSolverError(bool Passed_linear_failure) :
  linear_solver_error(Passed_linear_failure), iterations(0), maxres(0.0) {}

 /// Constructor that passes number of iterations and residuals
 NewtonSolverError(unsigned Passed_iterations, double Passed_maxres) : 
  linear_solver_error(false), iterations(Passed_iterations), 
  maxres(Passed_maxres) {}

/*  /// Broken copy constructor */
/*  NewtonSolverError(const NewtonSolverError& dummy)  */
/*   {  */
/*    BrokenCopy::broken_copy("NewtonSolverError"); */
/*   }  */
 
/*  /// Broken assignment operator */
/*  void operator=(const NewtonSolverError&)  */
/*   { */
/*    BrokenCopy::broken_assign("NewtonSolverError"); */
/*   } */

};

}

#endif
