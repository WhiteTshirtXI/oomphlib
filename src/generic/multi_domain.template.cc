//LIC// ====================================================================
//LIC// This file forms part of oomph-lib, the object-oriented, 
//LIC// multi-physics finite-element library, available 
//LIC// at http://www.oomph-lib.org.
//LIC// 
//LIC//           Version 0.85. June 9, 2008.
//LIC// 
//LIC// Copyright (C) 2006-2008 Matthias Heil and Andrew Hazel
//LIC// 
//LIC// This library is free software; you can redistribute it and/or
//LIC// modify it under the terms of the GNU Lesser General Public
//LIC// License as published by the Free Software Foundation; either
//LIC// version 2.1 of the License, or (at your option) any later version.
//LIC// 
//LIC// This library is distributed in the hope that it will be useful,
//LIC// but WITHOUT ANY WARRANTY; without even the implied warranty of
//LIC// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//LIC// Lesser General Public License for more details.
//LIC// 
//LIC// You should have received a copy of the GNU Lesser General Public
//LIC// License along with thi library; if not, write to the Free Software
//LIC// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
//LIC// 02110-1301  USA.
//LIC// 
//LIC// The authors may be contacted at oomph-lib@maths.man.ac.uk.
//LIC// 
//LIC//====================================================================
//Templated multi-domain functions

//Include guards to prevent multiple inclusion of the header
#ifndef OOMPH_MULTI_DOMAIN_CC
#define OOMPH_MULTI_DOMAIN_CC

// Config header generated by autoconfig
#ifdef HAVE_CONFIG_H
#include <oomph-lib-config.h>
#endif

//Oomph-lib headers
#include "geom_objects.h"
#include "problem.h"
#include "shape.h"

#include "mesh.h"
#include "mesh_as_geometric_object.h"
#include "mesh_as_geometric_object.template.cc"
#include "algebraic_elements.h"
#include "macro_element_node_update_element.h"
#include "Qelements.h"
#include "element_with_external_element.h"
#include "multi_domain.h"

namespace oomph
{

//// Templated helper functions for multi-domain methods using locate_zeta

//========================================================================
/// Set the source element(s) for each element in each mesh
/// Each time this routine is called it needs to start from scratch
/// with new external halo(ed) elements and nodes, and add their data
/// as external data.
/// This is an example for a single two-domain problem where the 
/// meshes occupy the same physical space.
//========================================================================
 template<class ELEMENT_0,class ELEMENT_1>
  void Multi_domain_functions::setup_multi_domain_interactions
  (Problem* problem_pt,Mesh* const &first_mesh_pt, Mesh* const &second_mesh_pt,
   const unsigned& first_interaction, const unsigned& second_interaction)
  {
   // Storage for number of processors, current process and communicator
   OomphCommunicator* comm_pt=problem_pt->communicator_pt();
   int n_proc=comm_pt->nproc();

   // Flush all the current external halo(ed) element and node storage
   first_mesh_pt->flush_all_external_storage();
   second_mesh_pt->flush_all_external_storage();

   // Extract the element dimensions from the first element of each mesh
   unsigned el_dim_first=0;
   if (first_mesh_pt->nelement() > 0)
    {
     el_dim_first=
      dynamic_cast<ELEMENT_0*>(first_mesh_pt->element_pt(0))->dim();
    }
   unsigned el_dim_second=0;
   if (second_mesh_pt->nelement() > 0)
    {
     el_dim_second=
      dynamic_cast<ELEMENT_1*>(second_mesh_pt->element_pt(0))->dim();
    }

   // Need to do an Allreduce
#ifdef OOMPH_HAS_MPI
   if (n_proc > 1)
    {
     unsigned el_dim_first_reduce;
     MPI_Allreduce(&el_dim_first,&el_dim_first_reduce,1,MPI_INT,MPI_MAX,
                   comm_pt->mpi_comm());
     el_dim_first=el_dim_first_reduce;

     unsigned el_dim_second_reduce;
     MPI_Allreduce(&el_dim_second,&el_dim_second_reduce,1,MPI_INT,MPI_MAX,
                   comm_pt->mpi_comm());
     el_dim_second=el_dim_second_reduce;
    }
#endif

   // Check the dimensions are the same!
   if (el_dim_first!=el_dim_second)
    {
     std::ostringstream error_stream;
     error_stream << "The elements within the two meshes do not\n"
                  << "have the same dimension, so the multi-domain\n"
                  << "method will not work.\n"
                  << "first mesh: " << el_dim_first 
                  << ", second mesh: " << el_dim_second << "\n";
     throw OomphLibError
      (error_stream.str(),
       "Multi_domain_functions::setup_multi_domain_interactions(...)",
       OOMPH_EXCEPTION_LOCATION);
    }

   // Call setup_multi_domain_interaction in both directions
   // Don't check for duplicates after setting the first interaction
   // Wrapper for element dimension
   if (el_dim_first==1)
    {
     Check_for_duplicates=false;
     setup_multi_domain_interaction<ELEMENT_1,1>
      (problem_pt,first_mesh_pt,second_mesh_pt,first_interaction);

     Check_for_duplicates=true;
     setup_multi_domain_interaction<ELEMENT_0,1>
      (problem_pt,second_mesh_pt,first_mesh_pt,second_interaction);
    }
   else if (el_dim_first==2)
    {
     oomph_info << "first_interaction=" << first_interaction << std::endl;
     Check_for_duplicates=false;
     setup_multi_domain_interaction<ELEMENT_1,2>
      (problem_pt,first_mesh_pt,second_mesh_pt,first_interaction);

     Check_for_duplicates=true;
     setup_multi_domain_interaction<ELEMENT_0,2>
      (problem_pt,second_mesh_pt,first_mesh_pt,second_interaction);
    }
   else if (el_dim_first==3)
    {
     Check_for_duplicates=false;
     setup_multi_domain_interaction<ELEMENT_1,3>
      (problem_pt,first_mesh_pt,second_mesh_pt,first_interaction);

     Check_for_duplicates=true;
     setup_multi_domain_interaction<ELEMENT_0,3>
      (problem_pt,second_mesh_pt,first_mesh_pt,second_interaction);
    }
   else
    {
     std::ostringstream error_stream;
     error_stream << "The elements within the two meshes have a\n"
                  << "dimension not equal to 1, 2 or 3.\n"
                  << "The multi-domain method will not work in this case.\n"
                  << "The dimension is: " << el_dim_second << "\n";
     throw OomphLibError
      (error_stream.str(),
       "Multi_domain_functions::setup_multi_domain_interactions(...)",
       OOMPH_EXCEPTION_LOCATION);
    }

  }


//========================================================================
/// Setup multi-domain interactions for two meshes occupying
/// the same physical space; 
/// - \c mesh_pt points to the mesh of ElementWithExternalElements
/// - \c external_mesh_pt contains the "sources" for these
///      ElementWithExternalElements
//========================================================================
 template<class EXT_ELEMENT,unsigned EL_DIM>
  void Multi_domain_functions::setup_multi_domain_interaction
  (Problem* problem_pt, Mesh* const &mesh_pt, Mesh* const &external_mesh_pt,
   const unsigned& interaction_index)
  {
   // Call the auxiliary function with GEOM_OBJECT=EXT_ELEMENT
   // and EL_DIM_EUL=EL_DIM_LAG=EL_DIM
   aux_setup_multi_domain_interaction<EXT_ELEMENT,EXT_ELEMENT,EL_DIM,EL_DIM>
    (problem_pt,mesh_pt,external_mesh_pt,interaction_index);
  }


//========================================================================
/// Setup multi-domain interactions for two meshes where one is of
/// a higher dimension and has an associated mesh for the face where it
/// interacts with the other mesh
/// - \c mesh_pt points to the mesh of ElementWithExternalElements
/// - \c external_mesh_pt points to the mesh that contains the elements
///   of type EXT_ELEMENT that provide the "source" for the
///   \c ElementWithExternalElements.
/// - \c external_face_mesh_pt points to the face mesh created from
///   the \c external_mesh_pt which is of the same dimension as \c mesh_pt.
///   The elements contained in \c external_face_mesh_pt are of type 
///   FACE_ELEMENT_GEOM_OBJECT 
//========================================================================
 template<class EXT_ELEMENT,class FACE_ELEMENT_GEOM_OBJECT,unsigned EL_DIM>
  void Multi_domain_functions::setup_multi_domain_interaction
  (Problem* problem_pt, Mesh* const &mesh_pt, Mesh* const &external_mesh_pt,
   Mesh* const &external_face_mesh_pt, const unsigned& interaction_index)
  {
   // Bulk elements must be external elements in this case
   Use_bulk_element_as_external=true;

   // Call the auxiliary routine with GEOM_OBJECT=FACE_ELEMENT_GEOM_OBJECT
   // and EL_DIM_LAG=EL_DIM-1, EL_DIM_EUL=EL_DIM
   aux_setup_multi_domain_interaction
    <EXT_ELEMENT,FACE_ELEMENT_GEOM_OBJECT,EL_DIM-1,EL_DIM>
    (problem_pt,mesh_pt,external_mesh_pt,
     interaction_index,external_face_mesh_pt);
  }


//========================================================================
/// This routine calls the locate_zeta routine (simultaneously on each 
/// processor for each individual processor's element set if necessary)
/// and sets up the external (halo) element and node storage as
/// necessary.  The locate_zeta procedure here works for all multi-domain
/// problems where either two meshes occupy the same physical space but have
/// differing element types (e.g. a Boussinesq convection problem where
/// AdvectionDiffusion elements interact with Navier-Stokes type elements)
/// or two meshes interact along some boundary of the external mesh,
/// represented by a "face mesh", such as an FSI problem.
//========================================================================
 template<class EXT_ELEMENT,class GEOM_OBJECT,
  unsigned EL_DIM_LAG,unsigned EL_DIM_EUL>
  void Multi_domain_functions::aux_setup_multi_domain_interaction
  (Problem* problem_pt, Mesh* const &mesh_pt, Mesh* const &external_mesh_pt,
   const unsigned& interaction_index, Mesh* const &external_face_mesh_pt)
  {
#ifdef OOMPH_HAS_MPI
   // Storage for number of processors
   int n_proc=problem_pt->communicator_pt()->nproc();
#endif

   // Timing
   double t_start=0.0; double t_end=0.0; double t_local=0.0;
   double t_set=0.0; double t_locate=0.0; double t_spiral_start=0.0;
#ifdef OOMPH_HAS_MPI
   double t_loop_start=0.0; double t_sendrecv=0.0; double t_missing=0.0;
   double t_send_info=0.0; double t_create_halo=0.0;
#endif

   if (Doc_timings) 
    {
     t_start=TimingHelpers::timer();
    }

#ifdef OOMPH_HAS_MPI
   // Print a warning for the case where the external mesh is solid and 
   // the problem has been distributed - this has not yet been tested
   if (problem_pt->problem_has_been_distributed())
    {
     SolidMesh* solid_mesh_pt=dynamic_cast<SolidMesh*>(external_mesh_pt);
     if (solid_mesh_pt!=0)
      {
       std::ostringstream warning_stream;
       warning_stream << "Multi-domain method has not been comprehensively "
                      << "tested for \n distributed problems where the "
                      << "external mesh is a SolidMesh." << std::endl;
       OomphLibWarning(
        warning_stream.str(),
        "Multi_domain_functions::aux_setup_multi_domain_interaction(...)",
        OOMPH_EXCEPTION_LOCATION);
      }
    }
#endif

   // Geometric object used to represent the external (face) mesh
   MeshAsGeomObject<EL_DIM_LAG,EL_DIM_EUL,GEOM_OBJECT >* mesh_geom_obj_pt;

   // Are bulk elements used as external elements?
   if (!Use_bulk_element_as_external)
    {
     // Set the geometric object from the external mesh
     mesh_geom_obj_pt=new MeshAsGeomObject<EL_DIM_LAG,EL_DIM_EUL,GEOM_OBJECT >
      (external_mesh_pt,problem_pt->communicator_pt(),
       Compute_extreme_bin_coordinates);
    }
   else
    {
     // Set the geometric object from the external face mesh argument
     mesh_geom_obj_pt=new MeshAsGeomObject<EL_DIM_LAG,EL_DIM_EUL,GEOM_OBJECT >
      (external_face_mesh_pt,problem_pt->communicator_pt(),
       Compute_extreme_bin_coordinates);
    }

   if (!Compute_extreme_bin_coordinates)
    {
     // New values for number of bins in each direction - not needed
//     mesh_geom_obj_pt->nx_bin()=Nx_bin;

     // New maxima and minima to be used in each direction
     mesh_geom_obj_pt->x_min()=X_min-Percentage_offset*(X_max-X_min);
     mesh_geom_obj_pt->x_max()=X_max+Percentage_offset*(X_max-X_min);
     if (EL_DIM_LAG>=2)
      {
//       mesh_geom_obj_pt->ny_bin()=Ny_bin;
       mesh_geom_obj_pt->y_min()=Y_min-Percentage_offset*(Y_max-Y_min);
       mesh_geom_obj_pt->y_max()=Y_max+Percentage_offset*(Y_max-Y_min);
      }
     if (EL_DIM_LAG==3)
      {
//       mesh_geom_obj_pt->nz_bin()=Nz_bin;
       mesh_geom_obj_pt->z_min()=Z_min-Percentage_offset*(Z_max-Z_min);;
       mesh_geom_obj_pt->z_max()=Z_max+Percentage_offset*(Z_max-Z_min);;
      }

     // Create the bin structure
     mesh_geom_obj_pt->create_bins_of_objects();
    }

   if (Doc_timings) 
    {
     t_set=TimingHelpers::timer();
     oomph_info << "CPU for bin creation: "
                << t_set-t_start << std::endl;
    }

   // Total number of integration points
   unsigned tot_int=0;

   // Loop over (this processor's) elements and set lookup array
   unsigned n_element=mesh_pt->nelement();
   External_element_located.resize(n_element);
   for (unsigned e=0;e<n_element;e++)
    {
     ElementWithExternalElement *el_pt=
      dynamic_cast<ElementWithExternalElement*>(mesh_pt->element_pt(e));
     External_element_located[e].resize(0);
#ifdef OOMPH_HAS_MPI
     if (!el_pt->is_halo())
#endif
      {
       //We need to allocate storage for the external elements
       //within the element. Memory will actually only be 
       //allocated the first time this function is called for 
       //each element, or if the number of interactions or integration
       //points within the element has changed.
       el_pt->initialise_external_element_storage();

       unsigned n_intpt=el_pt->integral_pt()->nweight();
       for (unsigned ipt=0;ipt<n_intpt;ipt++)
        {
         External_element_located[e].push_back(0);
         tot_int++;
        }
      }
    }

   /// Loop over "spirals" from here instead; increment the "level"
   /// and pass it in to the relevant locate_* functions
   unsigned n_max_level=Nx_bin;
   if (EL_DIM_LAG>=2)
    {
     if (Ny_bin > n_max_level) 
      {
       n_max_level=Ny_bin;
      }
    }
   if (EL_DIM_LAG==3)
    {
     if (Nz_bin > n_max_level) 
      {
       n_max_level=Nz_bin;
      }
    }


   // Loop over "spirals/levels" away from the current position
   for (unsigned i_level=0;i_level<n_max_level;i_level++)
    {
     // Record time at start of spiral loop
     if (Doc_timings) 
      {
       t_spiral_start=TimingHelpers::timer();
      }

     // Tell MeshAsGeomObject the current spiral level
     mesh_geom_obj_pt->current_spiral_level()=i_level;

     // Perform locate_zeta locally first!
     locate_zeta_for_local_coordinates(mesh_pt,external_mesh_pt,
                                       mesh_geom_obj_pt,interaction_index);

     if (Doc_stats)
      {
       oomph_info << "At level " << i_level << " percent discovered so far = " 
                  << 100.0*double(tot_int-Count_local_zeta_dim)/double(tot_int)
                  << " (on local processor) " << std::endl;
      }

     if (Doc_timings) 
      {
       t_local=TimingHelpers::timer();
       oomph_info << "CPU for local location of zeta coordinate: "
                  << t_local-t_spiral_start << std::endl;
      }

     // Now test whether anything needs to be broadcast elsewhere
     // (i.e. were there any failures in the locate method above?)
     // If there are, then the zetas for these failures need to be
     // broadcast...

     // local size of Zetas array
     unsigned all_count_zetas=Count_local_zetas;
#ifdef OOMPH_HAS_MPI
     // Only perform the reduction operation if there's more than one process
     if (problem_pt->communicator_pt()->nproc() > 1)
      {
       MPI_Allreduce(&Count_local_zetas,&all_count_zetas,1,MPI_INT,MPI_SUM,
                     problem_pt->communicator_pt()->mpi_comm());
      }

     // If the zetas array is not empty on any process 
     // and the problem is distributed, we need to locate elsewhere
     if ((all_count_zetas!=0) && (problem_pt->problem_has_been_distributed()))
      {
       // Loop over (number of processes - 1) starting from 1
       // - this number is the "distance" from the current process to the
       // process for which it is attempting to locate an element for the
       // current set of zeta coordinates
       for (int iproc=1;iproc<n_proc;iproc++)
        {
         // Record time at start of loop
         if (Doc_timings) 
          {
           t_loop_start=TimingHelpers::timer();
          }

         // Send the zeta values you haven't found to the
         // next process, receive from the previous process
         send_and_receive_missing_zetas(problem_pt);

         if (Doc_timings) 
          {
           t_sendrecv=TimingHelpers::timer();
           oomph_info << "CPU for send/recv of remaining zeta coordinates: "
                      << t_sendrecv-t_loop_start << std::endl;
          }

         // Perform the locate_zeta for the new set of zetas on this process
         locate_zeta_for_missing_coordinates<GEOM_OBJECT,EL_DIM_LAG,EL_DIM_EUL>
          (iproc,external_mesh_pt,problem_pt,mesh_geom_obj_pt);

         if (Doc_timings) 
          {
           t_missing=TimingHelpers::timer();
           oomph_info << "CPU for location of missing zeta coordinates: "
                      << t_missing-t_sendrecv << std::endl;
          }

         // Send any located coordinates back to the correct process, and 
         // prepare to send on to the next process if necessary
         send_and_receive_located_info(iproc,external_mesh_pt,problem_pt);

         if (Doc_timings) 
          {
           t_send_info=TimingHelpers::timer();
           oomph_info << "CPU for send/recv of new element info: "
                      << t_send_info-t_missing << std::endl;
          }

         // Create any located external halo elements on the current process
         create_external_halo_elements<EXT_ELEMENT,EL_DIM_LAG,EL_DIM_EUL>
          (iproc,mesh_pt,external_mesh_pt,problem_pt,interaction_index);

         if (Doc_timings) 
          {
           t_create_halo=TimingHelpers::timer();
           oomph_info << "CPU for local creation of external halo objects: "
                      << t_create_halo-t_send_info << std::endl;
          }
        }
      } // end if (all_count_zetas!=0)
#endif

     // Output information about location of elements for integration points
     if (Doc_stats)
      {
       oomph_info << "At level " << i_level << " percent discovered so far = " 
                  << 100.0*double(tot_int-Count_local_zeta_dim)/double(tot_int)
                  << " (on the other processors) " << std::endl;
      }

     // Do we have any further locating to do?
     // Only perform the reduction operation if there's more than one process
     all_count_zetas=Count_local_zetas;
#ifdef OOMPH_HAS_MPI
     if (problem_pt->communicator_pt()->nproc() > 1)
      {
       MPI_Allreduce(&Count_local_zetas,&all_count_zetas,1,MPI_INT,MPI_SUM,
                     problem_pt->communicator_pt()->mpi_comm());
      }
#endif

     /// If all_count_zetas is now zero then break out of the spirals loop
     if (all_count_zetas==0) { break; }

    } // end of "spirals" loop

   // Doc timings if required
   if (Doc_timings)
    {
     t_locate=TimingHelpers::timer();
     oomph_info << "CPU for location and creation of all external elements: "
                << t_locate-t_start << std::endl;
    }

   // Delete the geometric object representing the mesh
   delete mesh_geom_obj_pt;

   // Clean up all the (extern) Vectors associated with creating the
   // external storage information
   clean_up();

   // Check for and remove duplicate equation numbers between external halo
   // storage across different processors
   // NB this only needs to be called in parallel
#ifdef OOMPH_HAS_MPI
   if (Check_for_duplicates)
    {
     // Only necessary to do this on a multi-processor job
     if (n_proc!=1)
      {
       if (Doc_stats)
        {
         oomph_info << "Duplicate removal, number of global equation numbers:"
                    << problem_pt->assign_eqn_numbers(false) << std::endl;
        }
       else
        {
         problem_pt->assign_eqn_numbers(false);
        }

       // Must remove duplicates from both meshes in a two-way interaction
       remove_duplicate_data(problem_pt,external_mesh_pt);
       remove_duplicate_data(problem_pt,mesh_pt);
      }
     else
      {
       if (Doc_stats)
        {
         oomph_info << "INFO: No need to remove duplicate equation numbers"
                    << " on a single-process run, continuing" << std::endl;
        }
      }
    }
#endif

   // Doc timings if required
   if (Doc_timings)
    {
     t_end=TimingHelpers::timer();
     oomph_info << "CPU for setup_multi_domain_interaction: "
                << t_end-t_start << std::endl;
    }

#ifdef OOMPH_HAS_MPI
   // Output information about external storage if required
   if (Doc_stats)
    {
     // How many external elements does the external mesh have now?
     oomph_info << "------------------------------------------" << std::endl;
     oomph_info << "External mesh: I have " << external_mesh_pt->nelement()
                << " elements, of which "
                << external_mesh_pt->nroot_halo_element()
                << " are root halo elements, and "
                << external_mesh_pt->nroot_haloed_element() 
                << " are root haloed elements, and there are " 
                << external_mesh_pt->nexternal_halo_element()
                << " external halo elements, "
                << external_mesh_pt->nexternal_haloed_element()
                << " external haloed elements, and "
                << external_mesh_pt->nexternal_element()
                << " external elements (on this process)." << std::endl;

     // How many external nodes does each submesh have now?
     oomph_info << "------------------------------------------" << std::endl;
     oomph_info << "External mesh: I have " << external_mesh_pt->nnode()
                << " nodes, of which " << external_mesh_pt->nhalo_node()
                << " are halo nodes, and "
                << external_mesh_pt->nhaloed_node() << " are haloed "
                << "nodes" << std::endl
                << "and there are " << external_mesh_pt->nexternal_halo_node()
                << " external halo nodes, "
                << external_mesh_pt->nexternal_haloed_node()
                << " external haloed nodes, and "
                << external_mesh_pt->nexternal_node()
                << " external nodes (already on this process)." << std::endl;

     // How many elements does this submesh have for each of the processors?
     for (int iproc=0;iproc<n_proc;iproc++)
      {
       oomph_info << "----------------------------------------" << std::endl;
       oomph_info << "With process " << iproc << " there are "
                  << external_mesh_pt->nroot_halo_element(iproc)
                  << " root halo elements, and "
                  << external_mesh_pt->nroot_haloed_element(iproc)
                  << " root haloed elements" << std::endl
                  << "and there are "
                  << external_mesh_pt->nexternal_halo_element(iproc)
                  << " external halo elements, and "
                  << external_mesh_pt->nexternal_haloed_element(iproc)
                  << " external haloed elements." << std::endl;

       oomph_info << "----------------------------------------" << std::endl;
       oomph_info << "With process " << iproc << " there are "
                  << external_mesh_pt->nhalo_node(iproc)
                  << " halo nodes, and "
                  << external_mesh_pt->nhaloed_node(iproc)
                  << " haloed nodes" << std::endl
                  << "and there are "
                  << external_mesh_pt->nexternal_halo_node(iproc)
                  << " external halo nodes, and "
                  << external_mesh_pt->nexternal_haloed_node(iproc)
                  << " external haloed nodes." << std::endl;
      }
     oomph_info << "-----------------------------------------" << std::endl
                << std::endl;
    }
#endif

  } // end of aux_setup_multi_domain_interaction

 //=====================================================================
 /// locate zeta for current set of "local" coordinates
 //=====================================================================
 template<class GEOM_OBJECT,unsigned EL_DIM_LAG,unsigned EL_DIM_EUL>
  void Multi_domain_functions::locate_zeta_for_local_coordinates
  (Mesh* const &mesh_pt, Mesh* const &external_mesh_pt,
   MeshAsGeomObject<EL_DIM_LAG,EL_DIM_EUL,GEOM_OBJECT >* &mesh_geom_obj_pt,
   const unsigned& interaction_index)
  {
   // Number of local elements
   unsigned n_element=mesh_pt->nelement();

   // Initialise counters and arrays
   Local_zetas.resize(0);
   Local_zeta_dim.resize(0);
   Count_local_zetas=0;
   Count_zetas=0;
   Count_local_zeta_dim=0;
   Count_zeta_dim=0;

   // Loop over this processor's elements
   for (unsigned e=0;e<n_element;e++)
    {
     ElementWithExternalElement *el_pt=
      dynamic_cast<ElementWithExternalElement*>(mesh_pt->element_pt(e));
#ifdef OOMPH_HAS_MPI
     // Only visit non-halo elements
     if (!el_pt->is_halo())
#endif
      {
       // Find number of Gauss points and element dimension
       unsigned n_intpt=el_pt->integral_pt()->nweight();
       unsigned el_dim=el_pt->dim();
       // Set storage for local and global coordinates
       Vector<double> s_local(el_dim);
       Vector<double> x_global(el_dim);

       // Loop over integration points
       for (unsigned ipt=0;ipt<n_intpt;ipt++)
        {         
         // Has this integration point been done yet?
         if (External_element_located[e][ipt]==0)
          {
           // Get local coordinates
           for (unsigned i=0;i<el_dim;i++)
            {
             s_local[i]=el_pt->integral_pt()->knot(ipt,i);
            }
           // Interpolate to global coordinates
           el_pt->interpolated_zeta(s_local,x_global);

           // Storage for geometric object and its local coordinates
           GeomObject* sub_geom_obj_pt=0;
           Vector<double> s_ext(el_dim);

           // Perform locate_zeta locally for this coordinate
           bool called_from_multi_domain=true;
           mesh_geom_obj_pt->locate_zeta(x_global,sub_geom_obj_pt,s_ext,
                                         called_from_multi_domain);

           // Has the required element been located?
           if (sub_geom_obj_pt!=0)
            {
             // The required element has been located
             // The located coordinates have the same dimension as the bulk
             FiniteElement* source_el_pt;
             Vector<double> s_source(EL_DIM_EUL);

             // Is the bulk element the actual external element?
             if (!Use_bulk_element_as_external)
              {
               // Use the object directly
               source_el_pt=dynamic_cast<FiniteElement*>(sub_geom_obj_pt);
               s_source=s_ext;
              }
             else
              {
               // Cast to a FaceElement and use the bulk element
               FaceElement* face_el_pt=
                dynamic_cast<FaceElement*>(sub_geom_obj_pt);
               source_el_pt=dynamic_cast<FiniteElement*>(face_el_pt->
                                                         bulk_element_pt());
               // Translate the returned local coords into the bulk element
               face_el_pt->get_local_coordinate_in_bulk(s_ext,s_source);
              }

             // Check if it's a halo; if it is then the non-halo equivalent
             // needs to be located from another processor
#ifdef OOMPH_HAS_MPI
             if (!source_el_pt->is_halo())
#endif
              {
               // Set the external element pointer and local coordinates
               el_pt->external_element_pt(interaction_index,ipt)=source_el_pt;
               el_pt->external_element_local_coord(interaction_index,ipt)
                =s_source;

               // Set the lookup array to 1/true 
               External_element_located[e][ipt]=1;

               // Has this been used as a source for this element already?
               bool source_already_used=false;
               if (!source_already_used)
                {
                 // Add to the external mesh's external element storage
                 bool added_external_element;
                 added_external_element=
                  external_mesh_pt->add_external_element_pt(source_el_pt);

                 // If it was added then also try to add its nodes
                 if (added_external_element)
                  {
                   // Loop over the nodes of this external element
                   // and add (uniquely) as external nodes
                   unsigned n_node=source_el_pt->nnode();
                   for (unsigned j=0; j<n_node; j++)
                    {
                     Node* nod_pt=source_el_pt->node_pt(j);

                     bool added_external_node;
                     added_external_node=
                      external_mesh_pt->add_external_node_pt(nod_pt);

                     // If the node was added then try to add any masters too
                     if (added_external_node)
                      {
                       // Now do the same for any master nodes
                       if (dynamic_cast<RefineableElement*>(source_el_pt)!=0)
                        {
                         int n_cont=dynamic_cast<RefineableElement*>
                          (source_el_pt)->ncont_interpolated_values();
                         for (int i_cont=-1;i_cont<n_cont;i_cont++)
                          {
                           // Is this a hanging node in this variable?
                           if (nod_pt->is_hanging(i_cont))
                            {
                             HangInfo* hang_pt=nod_pt->
                              hanging_pt(i_cont);
                             // Loop over the master nodes
                             unsigned n_master=hang_pt->nmaster();
                             for (unsigned m=0; m<n_master; m++)
                              {
                               Node* master_nod_pt=
                                hang_pt->master_node_pt(m);

                               // Again this will only add if the node
                               // is not in the storage already
                               external_mesh_pt->
                                add_external_node_pt(master_nod_pt);
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
#ifdef OOMPH_HAS_MPI
             else // elements can only be halo if MPI is turned on
              {
               // Add required information to arrays
               for (unsigned i=0;i<el_dim;i++)
                {
                 Local_zetas.push_back(x_global[i]);
                 Count_local_zetas++;
                }
               Local_zeta_dim.push_back(el_dim);
               Count_local_zeta_dim++;
              }
#endif
            }
           else
            {
             // If it has failed then add the required information to the
             // arrays which need to be sent to the other processors so that
             // they can perform the locate_zeta

             // Add this global coordinate to the LOCAL zeta array
             for (unsigned i=0;i<el_dim;i++)
              {
               Local_zetas.push_back(x_global[i]);
               Count_local_zetas++;
              }
             // Add the element dimension to the LOCAL Zeta_dim array
             Local_zeta_dim.push_back(el_dim);
             Count_local_zeta_dim++;
             // Need another array indicating the current element number
             // for which the locate_zeta method did not work locally?
            }
          }
        } // end loop over integration points
      }
    } // end loop over local elements

  }

#ifdef OOMPH_HAS_MPI
 
 //=====================================================================
 /// locate zeta for current set of missing coordinates
 //=====================================================================
 template<class GEOM_OBJECT,unsigned EL_DIM_LAG,unsigned EL_DIM_EUL>
  void Multi_domain_functions::locate_zeta_for_missing_coordinates
  (int& iproc, Mesh* const &external_mesh_pt, Problem* problem_pt,
   MeshAsGeomObject<EL_DIM_LAG,EL_DIM_EUL,GEOM_OBJECT >* &mesh_geom_obj_pt)
  {
   // Storage for number of processors, current process and communicator
   OomphCommunicator* comm_pt=problem_pt->communicator_pt();
   int n_proc=comm_pt->nproc();
   int my_rank=comm_pt->my_rank();

   // Reset counters and resize vectors to be sent
   Count_double_values=0;
   Count_unsigned_values=0;
   Count_located_coord=0;
   Double_values.resize(0);
   Unsigned_values.resize(0);
   Located_coord.resize(0);

   Count_zetas=0;
   Count_local_zeta_dim=0;
   Count_local_zetas=0;
   Local_zeta_dim.resize(0);
   Local_zetas.resize(0);

   Found_zeta.resize(Count_zeta_dim);
   Located_element.resize(Count_zeta_dim);

   // Loop over the Zeta_dim array...
   for (unsigned i=0;i<Count_zeta_dim;i++)
    {
     unsigned el_dim=Zeta_dim[i];
     if (el_dim==0)
      {
       // The coordinate was already located 
       Found_zeta[i]=0; 
       Located_element[i]=0;
      }
     else // It was not found yet, so try to find it on the current process
      {
       // Storage for global coordinates to be located
       Vector<double> x_global(el_dim);
       // Loop to fill in coordinates
       for (unsigned ii=0;ii<el_dim;ii++)
        {
         x_global[ii]=Zetas[Count_zetas];
         Count_zetas++;
        }

       // Perform locate_zeta for these coordinates
       GeomObject *sub_geom_obj_pt;
       Vector<double> ss(el_dim);
       bool called_from_multi_domain=true;
       mesh_geom_obj_pt->locate_zeta(x_global,sub_geom_obj_pt,ss,
                                     called_from_multi_domain);

       // Did the locate method work?
       if (sub_geom_obj_pt!=0)
        {
         // Get the source element - bulk or not?
         FiniteElement *source_el_pt;
         if (!Use_bulk_element_as_external)
          {
           source_el_pt=dynamic_cast<FiniteElement*>(sub_geom_obj_pt);
          }
         else
          {
           FaceElement *face_el_pt=dynamic_cast<FaceElement*>(sub_geom_obj_pt);
           source_el_pt=dynamic_cast<FiniteElement*>(face_el_pt->
                                                     bulk_element_pt());
          }

         // Check if the returned element is halo
         if (!source_el_pt->is_halo())
          {
           // The correct non-halo element has been located; this will become
           // an external haloed element on the current process, and an
           // external halo copy needs to be created on the current process
           // minus wherever we are in the "ring-loop"
           int halo_copy_proc=my_rank-iproc;
           // If iproc is bigger than my_rank then we've "gone through" nproc-1
           if (my_rank<iproc) { halo_copy_proc=n_proc+halo_copy_proc; }

           // So, we found zeta on the current processor
           Found_zeta[i]=my_rank+1;
           // This source element is an external halo on process halo_copy_proc
           // but it should only be added to the storage if it hasn't
           // been added already, and this information also needs to be
           // communicated over to the other process

           unsigned n_extern_haloed=external_mesh_pt->
            nexternal_haloed_element(halo_copy_proc);
           unsigned external_haloed_el_index;
           external_haloed_el_index=
            external_mesh_pt->add_external_haloed_element_pt(halo_copy_proc,
                                                             source_el_pt);

           // If it was added to the storage then the returned index
           // will be the same as the (old) size of the storage
           if (external_haloed_el_index==n_extern_haloed)
            {
             // Set index in Located_element to say it should be newly created
             Located_element[i]=New;

             // How many continuously interpolated values are there?
             int n_cont_inter_values;
             if (dynamic_cast<RefineableElement*>(source_el_pt)!=0)
              {
               n_cont_inter_values=dynamic_cast<RefineableElement*>
                (source_el_pt)->ncont_interpolated_values();
              }
             else
              {
               n_cont_inter_values=-1;
              }

             // Since it is (externally) haloed from the current process,
             // the info required to create a new element in the equivalent
             // external halo layer on process halo_copy_proc needs to be 
             // sent there

             // If we're using macro elements to update...
             MacroElementNodeUpdateMesh* macro_mesh_pt=
              dynamic_cast<MacroElementNodeUpdateMesh*>(external_mesh_pt);
             if (macro_mesh_pt!=0)
              {
               Unsigned_values.push_back(1);
               Count_unsigned_values++;

               MacroElement* macro_el_pt=source_el_pt->macro_elem_pt();
               // Send the macro element number across
               unsigned macro_el_num=macro_el_pt->macro_element_number();
               Unsigned_values.push_back(macro_el_num);
               Count_unsigned_values++;

               // we need to send
               // the lower left and upper right coordinates of the macro
               QElementBase* q_el_pt=dynamic_cast<QElementBase*>(source_el_pt);
               if (q_el_pt!=0)
                {
                 // The macro element needs to be set first before
                 // its lower left and upper right coordinates can be accessed
                 // Now send the lower left and upper right coordinates
                 unsigned el_dim=q_el_pt->dim();
                 for (unsigned i_dim=0;i_dim<el_dim;i_dim++)
                  {
                   Double_values.push_back(q_el_pt->s_macro_ll(i_dim));
                   Count_double_values++;
                   Double_values.push_back(q_el_pt->s_macro_ur(i_dim));
                   Count_double_values++;
                  }
                }
               else // Throw an error
                {
                 std::ostringstream error_stream;
                 error_stream << "You are using a MacroElement node update\n"
                              << "in a case with non-QElements. This has not\n"
                              << "yet been implemented.\n";
                 throw OomphLibError
                  (error_stream.str(),
                   "Multi_domain_functions::simultaneous_locate_zeta()",
                   OOMPH_EXCEPTION_LOCATION);
                }

              }
             else // Not using macro elements to update
              {
               Unsigned_values.push_back(0);
               Count_unsigned_values++;
              }

             // Loop over the nodes of the new source element
             unsigned n_node=source_el_pt->nnode();
             for (unsigned j=0;j<n_node;j++)
              {
               Node* nod_pt=source_el_pt->node_pt(j);

               // Add the node to the storage; this routine
               // also takes care of any master nodes if the
               // node is hanging
               add_external_haloed_node_to_storage(halo_copy_proc,nod_pt,
                                                   problem_pt,
                                                   external_mesh_pt,
                                                   n_cont_inter_values,
                                                   source_el_pt);
              }
            
            }
           else // it has already been added, so tell the other process
            {
             // Set index to indicate an element has already been added
             Located_element[i]=Exists;
             Unsigned_values.push_back(external_haloed_el_index);
             Count_unsigned_values++;
            }

           // The coordinates returned by locate_zeta are also needed
           // in the setup of the source elements on the other process
           if (!Use_bulk_element_as_external)
            {
             for (unsigned ii=0;ii<el_dim;ii++)
              {
               Located_coord.push_back(ss[ii]);
               Count_located_coord++;
              }
            }
           else // translate the coordinates to the bulk element
            {
             // The translation is from Lagrangian to Eulerian
             Vector<double> s_trans(EL_DIM_EUL);
             FaceElement *face_el_pt=
              dynamic_cast<FaceElement*>(sub_geom_obj_pt);
             face_el_pt->get_local_coordinate_in_bulk(ss,s_trans);
             for (unsigned ii=0;ii<EL_DIM_EUL;ii++)
              {
               Located_coord.push_back(s_trans[ii]);
               Count_located_coord++;
              }
            }
          }
         else // halo, so search again until non-halo equivalent is located
          {
           // Add required information to arrays (as below)
           for (unsigned ii=0;ii<el_dim;ii++)
            {
             Local_zetas.push_back(x_global[ii]);
             Count_local_zetas++;
            }
           Local_zeta_dim.push_back(el_dim);
           Count_local_zeta_dim++;
           // It wasn't found here
           Found_zeta[i]=0;
           // Set index to indicate not found
           Located_element[i]=Not_found;
          }
        }
       else // not successful this time, so prepare for next process to try
        {
         // Add this global coordinate to the LOCAL zeta array
         for (unsigned ii=0;ii<el_dim;ii++)
          {
           Local_zetas.push_back(x_global[ii]);
           Count_local_zetas++;
          }
         // Add the element dimension to the LOCAL Zeta_dim array
         Local_zeta_dim.push_back(el_dim);
         Count_local_zeta_dim++;
         // It wasn't found here
         Found_zeta[i]=0;
         // Set index to indicate not found
         Located_element[i]=Not_found;
        }
      }

    }

  }


//=====================================================================
/// Creates external (halo) elements on the loop process based on the
/// information received from each locate_zeta call on other processes
//=====================================================================
 template<class EXT_ELEMENT,unsigned EL_DIM_LAG,unsigned EL_DIM_EUL>
  void Multi_domain_functions::create_external_halo_elements
  (int& iproc, Mesh* const &mesh_pt, Mesh* const &external_mesh_pt, 
   Problem* problem_pt, const unsigned& interaction_index)
  {
   OomphCommunicator* comm_pt=problem_pt->communicator_pt();
   int my_rank=comm_pt->my_rank();

   // Reset counters
   Count_zeta_dim=0;
   Count_double_values=0;
   Count_located_coord=0;
   Count_unsigned_values=0;

   // The creation all happens on the current processor
   // Loop over this processors elements
   unsigned n_element=mesh_pt->nelement();
   for (unsigned e=0;e<n_element;e++)
    {
     // Cast to ElementWithExternalElement to set external element (if located)
     ElementWithExternalElement *el_pt=
      dynamic_cast<ElementWithExternalElement*>(mesh_pt->element_pt(e));
     if (!el_pt->is_halo())
      {
       // Loop over integration points
       unsigned n_intpt=el_pt->integral_pt()->nweight();
       for (unsigned ipt=0;ipt<n_intpt;ipt++)
        {
         // Has an external element been assigned to this integration point?
         if (External_element_located[e][ipt]==0)
          {

           // Was a (non-halo) element located for this integration point
           if (((Found_zeta[Count_zeta_dim]-1)==my_rank) || 
               (Found_zeta[Count_zeta_dim]==0))
            {
             // Either it was already found, or not found on the current set
             // In either case, we don't need to do anything for this
             // integration point
            }
           else
            {
             // Get the process number on which the element was located
             unsigned loc_p=Found_zeta[Count_zeta_dim]-1;

             // Is it a new external halo element or not?
             // If so, then create it, populate it, and add it as a
             // source; if not, then find the right one which
             // has already been created and use it as the source
             // element. 

             // FiniteElement stored at this integration point
             FiniteElement* f_el_pt=0;

             // Is it a new element?
             if (Located_zetas[Count_zeta_dim]==New)
              {
               // Create a new element from the communicated values
               // and coords from the process that located zeta
               EXT_ELEMENT *new_el_pt= new EXT_ELEMENT;

               // Add it to the external halo element storage
               f_el_pt=dynamic_cast<FiniteElement*>(new_el_pt);

               // Add external halo element to this mesh
               external_mesh_pt->
                add_external_halo_element_pt(loc_p,f_el_pt);

               // We need the number of interpolated values if Refineable
               int n_cont_inter_values;
               if (dynamic_cast<RefineableElement*>(new_el_pt)!=0)
                {
                 n_cont_inter_values=dynamic_cast<RefineableElement*>
                  (new_el_pt)->ncont_interpolated_values();
                }
               else
                {
                 n_cont_inter_values=-1;
                }

               // If we're using macro elements to update
               if (Unsigned_values[Count_unsigned_values]==1)
                {
                 Count_unsigned_values++;

                 // Set the macro element
                 MacroElementNodeUpdateMesh* macro_mesh_pt=
                  dynamic_cast<MacroElementNodeUpdateMesh*>
                  (external_mesh_pt);
                 unsigned macro_el_num=Unsigned_values[Count_unsigned_values];
                 new_el_pt->set_macro_elem_pt
                  (macro_mesh_pt->macro_domain_pt()->
                   macro_element_pt(macro_el_num));
                 Count_unsigned_values++;

                 // We need to receive the lower left
                 // and upper right coordinates of the macro element
                 QElementBase* q_el_pt=
                  dynamic_cast<QElementBase*>(new_el_pt);
                 if (q_el_pt!=0)
                  {
                   unsigned el_dim=q_el_pt->dim();
                   for (unsigned i_dim=0;i_dim<el_dim;i_dim++)
                    {
                     q_el_pt->s_macro_ll(i_dim)=
                      Double_values[Count_double_values];
                     Count_double_values++;
                     q_el_pt->s_macro_ur(i_dim)=
                      Double_values[Count_double_values];
                     Count_double_values++;
                    }
                  }
                 else // Throw an error, since this is only implemented for Q
                  {
                   std::ostringstream error_stream;
                   error_stream << "Using MacroElement node update\n"
                                << "in a case with non-QElements\n"
                                << "has not yet been implemented.\n";
                   throw OomphLibError
                    (error_stream.str(),
                     "Multi_domain_functions::create_external_elements()",
                     OOMPH_EXCEPTION_LOCATION);

                  }
                }
               else // Not using macro elements
                {
                 Count_unsigned_values++;
                }

               // Now we add nodes to the new element
               unsigned n_node=new_el_pt->nnode();
               for (unsigned j=0;j<n_node;j++)
                {
                 Node* new_nod_pt=0;

                 // Call the add external halo node helper function
                 add_external_halo_node_to_storage<EXT_ELEMENT>
                  (new_nod_pt,external_mesh_pt,loc_p,j,new_el_pt,
                   n_cont_inter_values,problem_pt);
                }
              }
             else // the element already exists as an external_halo
              {
               // The index itself is in Unsigned_values[...]
               unsigned external_halo_el_index=
                Unsigned_values[Count_unsigned_values];
               Count_unsigned_values++;

               // Use this index to get the element
               f_el_pt=external_mesh_pt->
                external_halo_element_pt
                (loc_p,external_halo_el_index);
              }
             // The source element storage was initialised but
             // not filled earlier, so do it now
             // The located coordinates are required
             // (which could be a different dimension to zeta, e.g. in FSI)
             unsigned el_dim=f_el_pt->dim();
             Vector<double> s_located(el_dim);
             for (unsigned i=0;i<el_dim;i++)
              {
               s_located[i]=Located_coord[Count_located_coord];
               Count_located_coord++;
              }

             // Set the element for this integration point
             el_pt->external_element_pt(interaction_index,ipt)=f_el_pt;
             el_pt->
              external_element_local_coord(interaction_index,ipt)=s_located;

             // Set the lookup array to true
             External_element_located[e][ipt]=1;
            }
           // Increment the integration point counter
           Count_zeta_dim++;

          }

        } // end loop over integration points

      }
    } // end loop over local processor's elements

  }


//============start of add_external_halo_node_to_storage===============
/// Helper function to add external halo nodes, including any masters,
/// based on information received from the haloed process
//=========================================================================
 template<class EXT_ELEMENT>
  void Multi_domain_functions::add_external_halo_node_to_storage
  (Node* &new_nod_pt, Mesh* const &external_mesh_pt, unsigned& loc_p,
   unsigned& node_index, EXT_ELEMENT* new_el_pt, int& n_cont_inter_values,
   Problem* problem_pt)
  {
   // Add the external halo node if required
   add_external_halo_node_helper<EXT_ELEMENT>
    (new_nod_pt,external_mesh_pt,loc_p,node_index,new_el_pt,
     n_cont_inter_values,problem_pt);

   for (int i_cont=-1;i_cont<n_cont_inter_values;i_cont++)
    {
     if (Unsigned_values[Count_unsigned_values]==1)
      {
       Count_unsigned_values++;
       unsigned n_master=Unsigned_values
        [Count_unsigned_values];
       Count_unsigned_values++;
       // Setup new HangInfo
       HangInfo* hang_pt=new HangInfo(n_master);
       for (unsigned m=0;m<n_master;m++)
        {
         Node* master_nod_pt=0;
         // Get the master node (creating and adding it if required)
         add_external_halo_master_node_helper<EXT_ELEMENT>
          (master_nod_pt,new_nod_pt,external_mesh_pt,loc_p,new_el_pt,
           n_cont_inter_values,problem_pt);

         // Get the weight and set the HangInfo
         double master_weight=Double_values
          [Count_double_values];
         Count_double_values++;
         hang_pt->set_master_node_pt(m,master_nod_pt,master_weight);
        }
       new_nod_pt->set_hanging_pt(hang_pt,i_cont);
      }
     else // Not a hanging node
      {
       Count_unsigned_values++;
      }
    } // end loop over continous interpolated values

  }

//=======start of add_external_halo_node_helper===========================
/// Helper functiono to add external halo node that is not a master
//========================================================================
template<class EXT_ELEMENT>
 void Multi_domain_functions::add_external_halo_node_helper
  (Node* &new_nod_pt, Mesh* const &external_mesh_pt, unsigned& loc_p,
   unsigned& node_index, EXT_ELEMENT* new_el_pt, int& n_cont_inter_values,
   Problem* problem_pt)
 {
  // Given the node and the external mesh, and received information
  // about them from process loc_p, construct them on the current process
  if (Unsigned_values[Count_unsigned_values]==1)
   {
    // Increment counter
    Count_unsigned_values++;
    // Construct a new node based upon sent information
    construct_new_external_halo_node_helper<EXT_ELEMENT>
     (new_nod_pt,loc_p,node_index,new_el_pt,external_mesh_pt,problem_pt);
   }
  else
   {
    // Increment counter (node already exists)
    Count_unsigned_values++;
    // Copy node from received location
    new_nod_pt=external_mesh_pt->external_halo_node_pt
     (loc_p,Unsigned_values[Count_unsigned_values]);
    new_el_pt->node_pt(node_index)=new_nod_pt;
    // Increment counter
    Count_unsigned_values++;
   }
 }

//========================================================================
/// Helper function to add external halo node that is a master
//========================================================================
template<class EXT_ELEMENT>
 void Multi_domain_functions::add_external_halo_master_node_helper
  (Node* &new_master_nod_pt, Node* &new_nod_pt, Mesh* const &external_mesh_pt,
   unsigned& loc_p, EXT_ELEMENT* new_el_pt, int& ncont_inter_values,
   Problem* problem_pt)
 {
  // Given the node and the external mesh, and received information
  // about them from process loc_p, construct them on the current process
  if (Unsigned_values[Count_unsigned_values]==1)
   {
    // Increment counter
    Count_unsigned_values++;
    // Construct a new node based upon sent information
    construct_new_external_halo_master_node_helper<EXT_ELEMENT>
     (new_master_nod_pt,new_nod_pt,loc_p,new_el_pt,
      external_mesh_pt,problem_pt);
   }
  else
   {
    // Increment counter (node already exists)
    Count_unsigned_values++;
    // Copy node from received location
    new_master_nod_pt=external_mesh_pt->external_halo_node_pt
     (loc_p,Unsigned_values[Count_unsigned_values]);
    // Increment counter
    Count_unsigned_values++;
   }
 }


//========start of construct_new_external_halo_node_helper=================
/// Helper function which constructs a new external halo node (on new element)
/// with the required information sent from the haloed process
//========================================================================
template<class EXT_ELEMENT>
 void Multi_domain_functions::construct_new_external_halo_node_helper
 (Node* &new_nod_pt, unsigned& loc_p, unsigned& node_index,
  EXT_ELEMENT* new_el_pt, Mesh* const &external_mesh_pt, Problem* problem_pt)
 {
  // Null TimeStepper for now
  TimeStepper* time_stepper_pt=0;
  // Default number of previous values to 1
  unsigned n_prev=1;

  // The first entry in nodal_info indicates
  // if a timestepper is required for this halo node
  if (Unsigned_values
      [Count_unsigned_values]==1)
   {
    Count_unsigned_values++;
    // Index
    time_stepper_pt=problem_pt->time_stepper_pt
     (Unsigned_values[Count_unsigned_values]);
    Count_unsigned_values++;
    // Check whether number of prev values is "sent" across
    n_prev+=time_stepper_pt->nprev_values();
   }
  else
   {
    // No timestepper, increment counter
    Count_unsigned_values++;
   }

  // If this node was on a boundary then it needs to
  // be on the same boundary here
  if (Unsigned_values[Count_unsigned_values]==1)
   {
    Count_unsigned_values++;

    // Construct a new boundary node
    if (time_stepper_pt!=0)
     {
      new_nod_pt=new_el_pt->construct_boundary_node
       (node_index,time_stepper_pt);
     }
    else
     {
      new_nod_pt=new_el_pt->construct_boundary_node(node_index);
     }

    // How many boundaries on the external mesh?
    unsigned n_bnd=external_mesh_pt->nboundary();
    for (unsigned i_bnd=0;i_bnd<n_bnd;i_bnd++)
     {
      if (Unsigned_values
          [Count_unsigned_values]==1)
       {
        // Add to current boundary; increment counter
        external_mesh_pt->add_boundary_node(i_bnd,
                                            new_nod_pt);
        Count_unsigned_values++;
       }
      else
       {
        // Not on this boundary; increment counter
        Count_unsigned_values++;
       }
     }
   }
  else
   {
    // Not on boundary, increment counter
    Count_unsigned_values++;

    // Construct an ordinary (non-boundary) node
    if (time_stepper_pt!=0)
     {
      new_nod_pt=new_el_pt->construct_node
       (node_index,time_stepper_pt);
     }
    else
     {
      new_nod_pt=new_el_pt->construct_node(node_index);
     }
   }

  // Node constructed: add to external halo nodes
  external_mesh_pt->add_external_halo_node_pt(loc_p,new_nod_pt);

  // Is the new constructed node Algebraic?
  AlgebraicNode* new_alg_nod_pt=dynamic_cast<AlgebraicNode*>
   (new_nod_pt);

  // If it is algebraic, its node update functions will
  // not yet have been set up properly
  if (new_alg_nod_pt!=0)
   {
    // The AlgebraicMesh is the external mesh
    AlgebraicMesh* alg_mesh_pt=dynamic_cast<AlgebraicMesh*>
     (external_mesh_pt);

    /// The first entry of All_alg_nodal_info contains
    /// the default node update id
    /// e.g. for the quarter circle there are 
    /// "Upper_left_box", "Lower right box" etc...
    unsigned update_id=Unsigned_values
     [Count_unsigned_values];
    Count_unsigned_values++;

    Vector<double> ref_value;

    // The size of this vector is in the next entry
    // of All_alg_nodal_info
    unsigned n_ref_val=Unsigned_values
     [Count_unsigned_values];
    Count_unsigned_values++;

    // The reference values themselves are in
    // All_alg_ref_value
    ref_value.resize(n_ref_val);
    for (unsigned i_ref=0;i_ref<n_ref_val;i_ref++)
     {
      ref_value[i_ref]=Double_values
       [Count_double_values];
      Count_double_values++;
     }

    Vector<GeomObject*> geom_object_pt;
    /// again we need the size of this vector as it varies
    /// between meshes; we also need some indication
    /// as to which geometric object should be used...

    // The size of this vector is in the next entry
    // of All_alg_nodal_info
    unsigned n_geom_obj=Unsigned_values
     [Count_unsigned_values];
    Count_unsigned_values++;

    // The remaining indices are in the rest of 
    // All_alg_nodal_info
    geom_object_pt.resize(n_geom_obj);
    for (unsigned i_geom=0;i_geom<n_geom_obj;i_geom++)
     {
      unsigned geom_index=Unsigned_values
       [Count_unsigned_values];
      Count_unsigned_values++;
      // This index indicates which of the AlgebraicMesh's
      // stored geometric objects should be used
      // (0 is a null pointer; everything else should have
      //  been filled in by the specific Mesh).  If it
      // hasn't been filled in then the update_node_update
      // call should fix it
      geom_object_pt[i_geom]=alg_mesh_pt->
       geom_object_list_pt(geom_index);
     }

    /// For the received update_id, ref_value, geom_object
    /// call add_node_update_info
    new_alg_nod_pt->add_node_update_info
     (update_id,alg_mesh_pt,geom_object_pt,ref_value);

    /// Now call update_node_update
    alg_mesh_pt->update_node_update(new_alg_nod_pt);
   }

  // Is the node a MacroElementNodeUpdateNode?
  MacroElementNodeUpdateNode* macro_nod_pt=
   dynamic_cast<MacroElementNodeUpdateNode*>(new_nod_pt);

  if (macro_nod_pt!=0)
   {
    // Need to call set_node_update_info; this requires
    // a Vector<GeomObject*> (taken from the mesh)
    Vector<GeomObject*> geom_object_vector_pt;

    // Access the required geom objects from the
    // MacroElementNodeUpdateMesh
    MacroElementNodeUpdateMesh* macro_mesh_pt=
     dynamic_cast<MacroElementNodeUpdateMesh*>
     (external_mesh_pt);
    geom_object_vector_pt=
     macro_mesh_pt->geom_object_vector_pt();

    // Get local coordinate of node in new element
    Vector<double> s_in_macro_node_update_element;
    new_el_pt->local_coordinate_of_node
     (node_index,s_in_macro_node_update_element);

    // Set node update info for this node
    macro_nod_pt->set_node_update_info
     (new_el_pt,s_in_macro_node_update_element,
      geom_object_vector_pt);
   }

  // Is the new node a SolidNode?
  SolidNode* solid_nod_pt=dynamic_cast<SolidNode*>(new_nod_pt);
  if (solid_nod_pt!=0)
   {
    unsigned n_val=solid_nod_pt->variable_position_pt()->nvalue();
    for (unsigned i_val=0;i_val<n_val;i_val++)
     {
      for (unsigned t=0;t<n_prev;t++)
       {
        solid_nod_pt->variable_position_pt()->
         set_value(t,i_val,
                   Double_values[Count_double_values]);
        Count_double_values++;
       }
     }
   }

  // Get copied history values
  unsigned n_val=new_nod_pt->nvalue();
  for (unsigned i_val=0;i_val<n_val;i_val++)
   {
    for (unsigned t=0;t<n_prev;t++)
     {
      new_nod_pt->set_value(t,i_val,Double_values
                            [Count_double_values]);
      Count_double_values++;
     }
   }

  // Get copied history values for positions
  unsigned n_dim=new_nod_pt->ndim();
  for (unsigned idim=0;idim<n_dim;idim++)
   {
    for (unsigned t=0;t<n_prev;t++)
     {
      // Copy to coordinate
      new_nod_pt->x(t,idim)=Double_values
       [Count_double_values];
      Count_double_values++;
     }
   }

 }

//======start of construct_new_external_halo_master_node_helper===========
/// Helper function which constructs a new external halo master node
/// with the required information sent from the haloed process
//========================================================================
template<class EXT_ELEMENT>
 void Multi_domain_functions::construct_new_external_halo_master_node_helper
 (Node* &new_master_nod_pt, Node* &nod_pt, unsigned& loc_p,
  EXT_ELEMENT* new_el_pt, Mesh* const &external_mesh_pt, Problem* problem_pt)
 {
  // First three sent numbers are dimension, position type and nvalue
  // (to be used in Node constructors)
  unsigned n_dim=Unsigned_values[Count_unsigned_values];
  Count_unsigned_values++;
  unsigned n_position_type=Unsigned_values
   [Count_unsigned_values];
  Count_unsigned_values++;
  unsigned n_value=Unsigned_values
   [Count_unsigned_values];
  Count_unsigned_values++;
  

  // If it's a solid node also receive the lagrangian dimension and pos type
  SolidNode* solid_nod_pt=dynamic_cast<SolidNode*>(nod_pt);
  unsigned n_lag_dim;
  unsigned n_lag_type;
  if (solid_nod_pt!=0)
   {
    n_lag_dim=Unsigned_values[Count_unsigned_values];
    Count_unsigned_values++;
    n_lag_type=Unsigned_values[Count_unsigned_values];
    Count_unsigned_values++;
   }

  // Null TimeStepper for now
  TimeStepper* time_stepper_pt=0;
  // Default number of previous values to 1
  unsigned n_prev=1;

  // The first entry in nodal_info indicates
  // the timestepper required for this halo node
  if (Unsigned_values
      [Count_unsigned_values]==1)
   {
    Count_unsigned_values++;
    // Index minus one!
    time_stepper_pt=problem_pt->time_stepper_pt
     (Unsigned_values[Count_unsigned_values]);
    Count_unsigned_values++;
    // Check whether number of prev values is "sent" across
    n_prev+=time_stepper_pt->nprev_values();
   }
  else
   {
    Count_unsigned_values++;
   }

  // Is the node for which the master is required Algebraic, Macro or Solid?
  AlgebraicNode* alg_nod_pt=dynamic_cast<AlgebraicNode*>(nod_pt);
  MacroElementNodeUpdateNode* macro_nod_pt=
   dynamic_cast<MacroElementNodeUpdateNode*>(nod_pt);

  // What type of node was the node for which we are constructing a master?
  if (alg_nod_pt!=0)
   {
    // The master node should also be algebraic

    // If this master node's haloed copy is on a boundary then 
    // it needs to be on the same boundary here
    if (Unsigned_values[Count_unsigned_values]==1)
     {
      Count_unsigned_values++;
      // Create a new BoundaryNode (not attached to an element)
      if (time_stepper_pt!=0)
       {
        new_master_nod_pt = new BoundaryNode<AlgebraicNode>
         (time_stepper_pt,n_dim,n_position_type,n_value);
       }
      else
       {
        new_master_nod_pt = new BoundaryNode<AlgebraicNode>
         (n_dim,n_position_type,n_value);
       }
      // How many boundaries on the external mesh?
      unsigned n_bnd=external_mesh_pt->nboundary();
      for (unsigned i_bnd=0;i_bnd<n_bnd;i_bnd++)
       {
        if (Unsigned_values[Count_unsigned_values]==1)
         {
          // Add to current boundary; increment counter
          external_mesh_pt->add_boundary_node(i_bnd,new_master_nod_pt);
          Count_unsigned_values++;
         }
        else
         {
          // Not on this boundary; incremenet counter
          Count_unsigned_values++;
         }
       }
     }
    else
     {
      // Not on any boundary, incremenet counter
      Count_unsigned_values++;

      // Create node (not attached to any element)
      if (time_stepper_pt!=0)
       {
        new_master_nod_pt = new AlgebraicNode
         (time_stepper_pt,n_dim,n_position_type,n_value);
       }
      else
       {
        new_master_nod_pt = new AlgebraicNode
         (n_dim,n_position_type,n_value);
       }
     }

    // Add this as an external halo node BEFORE considering node update!
    external_mesh_pt->add_external_halo_node_pt(loc_p,new_master_nod_pt);

    // The external mesh is itself Algebraic...
    AlgebraicMesh* alg_mesh_pt=dynamic_cast<AlgebraicMesh*>
     (external_mesh_pt);

    /// The first entry of All_unsigned_values is the default node update id
    unsigned update_id=Unsigned_values
     [Count_unsigned_values];
    Count_unsigned_values++;

    // Setup algebraic node update info for this new node
    Vector<double> ref_value;

    // The size of this vector is in the next entry
    unsigned n_ref_val=Unsigned_values
     [Count_unsigned_values];
    Count_unsigned_values++;

    // The reference values are in the subsequent entries of All_double_values
    ref_value.resize(n_ref_val);
    for (unsigned i_ref=0;i_ref<n_ref_val;i_ref++)
     {
      ref_value[i_ref]=Double_values
       [Count_double_values];
      Count_double_values++;
     }

    // Also require a Vector of geometric objects
    Vector<GeomObject*> geom_object_pt;

    // The size of this vector is in the next entry of All_unsigned_values
    unsigned n_geom_obj=Unsigned_values
     [Count_unsigned_values];
    Count_unsigned_values++;

    // The remaining indices are in the rest of 
    // All_alg_nodal_info
    geom_object_pt.resize(n_geom_obj);
    for (unsigned i_geom=0;i_geom<n_geom_obj;i_geom++)
     {
      unsigned geom_index=Unsigned_values
       [Count_unsigned_values];
      Count_unsigned_values++;
      // This index indicates which (if any) of the AlgebraicMesh's
      // stored geometric objects should be used
      geom_object_pt[i_geom]=alg_mesh_pt->geom_object_list_pt(geom_index);
     }

    AlgebraicNode* alg_master_nod_pt=
     dynamic_cast<AlgebraicNode*>(new_master_nod_pt);

    /// ... so for the specified update_id, call
    /// add_node_update_info
    alg_master_nod_pt->add_node_update_info
     (update_id,alg_mesh_pt,geom_object_pt,ref_value);

    /// Now call update_node_update
    alg_mesh_pt->update_node_update(alg_master_nod_pt);
   }
  else if (macro_nod_pt!=0)
   {
    // The master node should also be a macro node
    // If this master node's haloed copy is on a boundary then 
    // it needs to be on the same boundary here
    if (Unsigned_values[Count_unsigned_values]==1)
     {
      Count_unsigned_values++;
      // Create a new BoundaryNode (not attached to an element)
      if (time_stepper_pt!=0)
       {
        new_master_nod_pt = new BoundaryNode<MacroElementNodeUpdateNode>
         (time_stepper_pt,n_dim,n_position_type,n_value);
       }
      else
       {
        new_master_nod_pt = new BoundaryNode<MacroElementNodeUpdateNode>
         (n_dim,n_position_type,n_value);
       }
      // How many boundaries on the external mesh?
      unsigned n_bnd=external_mesh_pt->nboundary();
      for (unsigned i_bnd=0;i_bnd<n_bnd;i_bnd++)
       {
        if (Unsigned_values[Count_unsigned_values]==1)
         {
          // Add to current boundary; increment counter
          external_mesh_pt->add_boundary_node(i_bnd,new_master_nod_pt);
          Count_unsigned_values++;
         }
        else
         {
          // Not on this boundary; incremenet counter
          Count_unsigned_values++;
         }
       }
     }
    else
     {
      // Not on boundary, incremenet counter
      Count_unsigned_values++;

      // Create node (not attached to any element)
      if (time_stepper_pt!=0)
       {
        new_master_nod_pt = new MacroElementNodeUpdateNode
         (time_stepper_pt,n_dim,n_position_type,n_value);
       }
      else
       {
        new_master_nod_pt = new MacroElementNodeUpdateNode
         (n_dim,n_position_type,n_value);
       }
     }

    // Add this as an external halo node
    external_mesh_pt->add_external_halo_node_pt(loc_p,new_master_nod_pt);

    // Create a new node update element for this master node if required
    EXT_ELEMENT *new_node_update_el_pt;
    if (Unsigned_values[Count_unsigned_values]==1)
     {
      Count_unsigned_values++;
      new_node_update_el_pt=new EXT_ELEMENT;

      FiniteElement *f_el_pt=
       dynamic_cast<FiniteElement*>(new_node_update_el_pt);
      external_mesh_pt->add_external_halo_element_pt(loc_p,f_el_pt);

      // Need number of interpolated values if Refineable
      int n_cont_inter_values;
      if (dynamic_cast<RefineableElement*>(new_node_update_el_pt)!=0)
       {
        n_cont_inter_values=dynamic_cast<RefineableElement*>
         (new_node_update_el_pt)->ncont_interpolated_values();
       }
      else
       {
        n_cont_inter_values=-1;
       }

      // If we're using macro elements to update,
      if (Unsigned_values[Count_unsigned_values]==1)
       {
        Count_unsigned_values++;

        // Set the macro element
        MacroElementNodeUpdateMesh* macro_mesh_pt=
         dynamic_cast<MacroElementNodeUpdateMesh*>
         (external_mesh_pt);
        unsigned macro_el_num=
         Unsigned_values[Count_unsigned_values];
        new_node_update_el_pt->set_macro_elem_pt
         (macro_mesh_pt->macro_domain_pt()->macro_element_pt(macro_el_num));
        Count_unsigned_values++;

        // we need to receive
        // the lower left and upper right coordinates of the macro
        QElementBase* q_el_pt=
         dynamic_cast<QElementBase*>(new_node_update_el_pt);
        if (q_el_pt!=0)
         {
          unsigned el_dim=q_el_pt->dim();
          for (unsigned i_dim=0;i_dim<el_dim;i_dim++)
           {
            q_el_pt->s_macro_ll(i_dim)=Double_values
             [Count_double_values];
            Count_double_values++;
            q_el_pt->s_macro_ur(i_dim)=Double_values
             [Count_double_values];
            Count_double_values++;
           }
         }
        else // Throw an error
         {
          std::ostringstream error_stream;
          error_stream << "You are using a MacroElement node update\n"
                       << "in a case with non-QElements. This has not\n"
                       << "yet been implemented.\n";
          throw OomphLibError
           (error_stream.str(),
            "Multi_domain_functions::construct_new_external_halo_master_...()",
            OOMPH_EXCEPTION_LOCATION);
         }
       }
      else // No macro element
       {
        Count_unsigned_values++;
       }


      unsigned n_node=new_node_update_el_pt->nnode();
      for (unsigned j=0;j<n_node;j++)
       {
        Node* new_nod_pt=0;
        add_external_halo_node_to_storage<EXT_ELEMENT>
         (new_nod_pt,external_mesh_pt,loc_p,j,new_node_update_el_pt,
          n_cont_inter_values,problem_pt);
       }

     }
    else // The node update element exists already
     {
      Count_unsigned_values++;
      new_node_update_el_pt=dynamic_cast<EXT_ELEMENT*>
       (external_mesh_pt->external_halo_element_pt
        (loc_p,Unsigned_values[Count_unsigned_values]));
      Count_unsigned_values++;
     }

    // Remaining required information to create functioning
    // MacroElementNodeUpdateNode...

    // Get the required geom objects for the node update
    // from the mesh
    Vector<GeomObject*> geom_object_vector_pt;
    MacroElementNodeUpdateMesh* macro_mesh_pt=
     dynamic_cast<MacroElementNodeUpdateMesh*>
     (external_mesh_pt);
    geom_object_vector_pt=macro_mesh_pt->geom_object_vector_pt();

    // Cast to MacroElementNodeUpdateNode
    MacroElementNodeUpdateNode* macro_master_nod_pt=
     dynamic_cast<MacroElementNodeUpdateNode*>(new_master_nod_pt);

    // Set all required information - node update element,
    // local coordinate in this element, and then set node update info
    macro_master_nod_pt->node_update_element_pt()=
     new_node_update_el_pt;

    // Need to get the local node index of the macro_master_nod_pt
    unsigned local_node_index;
    unsigned n_node=new_node_update_el_pt->nnode();
    for (unsigned j=0;j<n_node;j++)
     {
      if (macro_master_nod_pt==new_node_update_el_pt->node_pt(j))
       {
        local_node_index=j;
        break;
       }
     }

    Vector<double> s_in_macro_node_update_element;
    new_node_update_el_pt->local_coordinate_of_node
     (local_node_index,s_in_macro_node_update_element);

    macro_master_nod_pt->set_node_update_info
     (new_node_update_el_pt,s_in_macro_node_update_element,
      geom_object_vector_pt);
   }
  else if (solid_nod_pt!=0)
   {
    // The master node should also be a SolidNode
    // If this node was on a boundary then it needs to
    // be on the same boundary here
    if (Unsigned_values[Count_unsigned_values]==1)
     {
      Count_unsigned_values++;
      // Construct a new boundary node
      if (time_stepper_pt!=0)
       {
        new_master_nod_pt=new BoundaryNode<SolidNode>
         (time_stepper_pt,n_lag_dim,n_lag_type,n_dim,n_position_type,n_value);
       }
      else
       {
        new_master_nod_pt=new BoundaryNode<SolidNode>
         (n_lag_dim,n_lag_type,n_dim,n_position_type,n_value);
       }
      // How many boundaries on the external mesh?
      unsigned n_bnd=external_mesh_pt->nboundary();
      for (unsigned i_bnd=0;i_bnd<n_bnd;i_bnd++)
       {
        if (Unsigned_values[Count_unsigned_values]==1)
         {
          // Add to current boundary; increment counter
          external_mesh_pt->add_boundary_node(i_bnd,
                                              new_master_nod_pt);
          Count_unsigned_values++;
         }
        else
         {
          // Not on this boundary; increment counter
          Count_unsigned_values++;
         }
       }
     }
    else
     {
      // Not on boundary, increment counter
      Count_unsigned_values++;
      // Construct an ordinary (non-boundary) node
      if (time_stepper_pt!=0)
       {
        new_master_nod_pt=new SolidNode
         (time_stepper_pt,n_lag_dim,n_lag_type,n_dim,n_position_type,n_value);
       }
      else
       {
        new_master_nod_pt=new SolidNode
         (n_lag_dim,n_lag_type,n_dim,n_position_type,n_value);
       }
     }

    // Add this as an external halo node
    external_mesh_pt->add_external_halo_node_pt(loc_p,new_master_nod_pt);

    // Copy across particular info required for SolidNode
    SolidNode* solid_master_nod_pt=dynamic_cast<SolidNode*>(new_master_nod_pt);
    unsigned n_val=solid_master_nod_pt->variable_position_pt()->nvalue();
    for (unsigned i_val=0;i_val<n_val;i_val++)
     {
      for (unsigned t=0;t<n_prev;t++)
       {
        solid_master_nod_pt->variable_position_pt()->
         set_value(t,i_val,
                   Double_values[Count_double_values]);
       }
     }

   }
  else // Just an ordinary node!
   {
    // If this node was on a boundary then it needs to
    // be on the same boundary here
    if (Unsigned_values[Count_unsigned_values]==1)
     {
      Count_unsigned_values++;
      // Construct a new boundary node
      if (time_stepper_pt!=0)
       {
        new_master_nod_pt=new BoundaryNode<Node>
         (time_stepper_pt,n_dim,n_position_type,n_value);
       }
      else
       {
        new_master_nod_pt=new BoundaryNode<Node>
         (n_dim,n_position_type,n_value);
       }
      // How many boundaries on the external mesh?
      unsigned n_bnd=external_mesh_pt->nboundary();
      for (unsigned i_bnd=0;i_bnd<n_bnd;i_bnd++)
       {
        if (Unsigned_values[Count_unsigned_values]==1)
         {
          // Add to current boundary; increment counter
          external_mesh_pt->add_boundary_node(i_bnd,
                                              new_master_nod_pt);
          Count_unsigned_values++;
         }
        else
         {
          // Not on this boundary; increment counter
          Count_unsigned_values++;
         }
       }
     }
    else
     {
      // Not on boundary, increment counter
      Count_unsigned_values++;
      // Construct an ordinary (non-boundary) node
      if (time_stepper_pt!=0)
       {
        new_master_nod_pt=new Node
         (time_stepper_pt,n_dim,n_position_type,n_value);
       }
      else
       {
        new_master_nod_pt=new Node(n_dim,n_position_type,n_value);
       }
     }

    // Add this as an external halo node
    external_mesh_pt->add_external_halo_node_pt(loc_p,new_master_nod_pt);

   }

  // Remaining info received for all node types
  // Get copied history values
  unsigned n_val=new_master_nod_pt->nvalue();
  for (unsigned i_val=0;i_val<n_val;i_val++)
   {
    for (unsigned t=0;t<n_prev;t++)
     {
      new_master_nod_pt->set_value(t,i_val,Double_values
                                   [Count_double_values]);
      Count_double_values++;
     }
   }

  // Get copied history values for positions
  unsigned n_nod_dim=new_master_nod_pt->ndim();
  for (unsigned idim=0;idim<n_nod_dim;idim++)
   {
    for (unsigned t=0;t<n_prev;t++)
     {
      // Copy to coordinate
      new_master_nod_pt->x(t,idim)=Double_values
       [Count_double_values];
      Count_double_values++;
     }
   }

 }


#endif


}

#endif




 
