//LIC// ====================================================================
//LIC// This file forms part of oomph-lib, the object-oriented, 
//LIC// multi-physics finite-element library, available 
//LIC// at http://www.oomph-lib.org.
//LIC// 
//LIC//           Version 0.90. August 3, 2009.
//LIC// 
//LIC// Copyright (C) 2006-2009 Matthias Heil and Andrew Hazel
//LIC// 
//LIC// This library is free software; you can redistribute it and/or
//LIC// modify it under the terms of the GNU Lesser General Public
//LIC// License as published by the Free Software Foundation; either
//LIC// version 2.1 of the License, or (at your option) any later version.
//LIC// 
//LIC// This library is distributed in the hope that it will be useful,
//LIC// but WITHOUT ANY WARRANTY; without even the implied warranty of
//LIC// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//LIC// Lesser General Public License for more details.
//LIC// 
//LIC// You should have received a copy of the GNU Lesser General Public
//LIC// License along with this library; if not, write to the Free Software
//LIC// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
//LIC// 02110-1301  USA.
//LIC// 
//LIC// The authors may be contacted at oomph-lib@maths.man.ac.uk.
//LIC// 
//LIC//====================================================================
//Templated multi-domain functions

//Include guards to prevent multiple inclusion of the header
#ifndef OOMPH_MULTI_DOMAIN_CC
#define OOMPH_MULTI_DOMAIN_CC

// Config header generated by autoconfig
#ifdef HAVE_CONFIG_H
#include <oomph-lib-config.h>
#endif

//Oomph-lib headers
#include "geom_objects.h"
#include "problem.h"
#include "shape.h"

#include "mesh.h"
#include "mesh_as_geometric_object.h"
#include "algebraic_elements.h"
#include "macro_element_node_update_element.h"
#include "Qelements.h"
#include "element_with_external_element.h"
#include "multi_domain.h"

namespace oomph
{

//// Templated helper functions for multi-domain methods using locate_zeta

//========================================================================
/// Set up the two-way multi-domain interactions for the 
/// problem pointed to by \c problem_pt.
/// Use this for cases where first_mesh_pt and second_mesh_pt
/// occupy the same physical space and are populated by
/// ELEMENT_0 and ELEMENT_1 respectively, and are combined to solve
/// a single problem. The elements in two meshes interact both ways
/// the elements in each mesh act as "external elements" for the 
/// elements in the "other" mesh. The interaction indices allow the 
/// specification of which interaction we're setting up in the two 
/// meshes. They default to zero, which is appropriate if there's 
/// only a single interaction.
//========================================================================
 template<class ELEMENT_0,class ELEMENT_1>
  void Multi_domain_functions::setup_multi_domain_interactions
  (Problem* problem_pt,Mesh* const &first_mesh_pt, Mesh* const &second_mesh_pt,
   const unsigned& first_interaction, const unsigned& second_interaction)
  {
   // Flush all the current external halo(ed) element and node storage
   first_mesh_pt->flush_all_external_storage();
   second_mesh_pt->flush_all_external_storage();

   // Call setup_multi_domain_interaction in both directions
   // Don't check for duplicates after setting the first interaction
#ifdef OOMPH_HAS_MPI
   Check_for_duplicates=false;
#endif
   setup_multi_domain_interaction<ELEMENT_1>
    (problem_pt,first_mesh_pt,second_mesh_pt,first_interaction);

#ifdef OOMPH_HAS_MPI
   Check_for_duplicates=true;
#endif
   setup_multi_domain_interaction<ELEMENT_0>
    (problem_pt,second_mesh_pt,first_mesh_pt,second_interaction);

  }


//========================================================================
 ///  Function to set up the one-way multi-domain interaction for 
 /// problems where the meshes pointed to by \c mesh_pt and \c external_mesh_pt
 /// occupy the same physical space, and the elements in \c external_mesh_pt
 /// act as "external elements" for the \c ElementWithExternalElements
 /// in \c mesh_pt (but not vice versa):
 /// - \c mesh_pt points to the mesh of ElemenWithExternalElements for which
 ///   the interaction is set up. 
 /// - \c external_mesh_pt points to the mesh that contains the elements
 ///   of type EXT_ELEMENT that act as "external elements" for the
 ///   \c ElementWithExternalElements in \ mesh_pt.
 /// - The interaction_index parameter defaults to zero and must be otherwise
 ///   set by the user if there is more than one mesh that provides sources
 ///   for the Mesh pointed to by mesh_pt.
//========================================================================
 template<class EXT_ELEMENT>
  void Multi_domain_functions::setup_multi_domain_interaction
  (Problem* problem_pt, Mesh* const &mesh_pt, Mesh* const &external_mesh_pt,
   const unsigned& interaction_index)
  {
   // Call the auxiliary function with GEOM_OBJECT=EXT_ELEMENT
   // and EL_DIM_EUL=EL_DIM_LAG=dimension returned from helper function
   unsigned dim=0;
   get_dim_helper(problem_pt,mesh_pt,external_mesh_pt,dim);

   if(dim > 3)
    {
     std::ostringstream error_stream;
     error_stream << "The elements within the two interacting meshes have a\n"
                  << "dimension not equal to 1, 2 or 3.\n"
                  << "The multi-domain method will not work in this case.\n"
                  << "The dimension is: " << dim << "\n";
     throw OomphLibError
      (error_stream.str(),
       "Multi_domain_functions::setup_multi_domain_interaction(...)",
       OOMPH_EXCEPTION_LOCATION);
    }

   // Wrapper for each dimension (template parameter)
   aux_setup_multi_domain_interaction<EXT_ELEMENT,EXT_ELEMENT>
    (problem_pt,mesh_pt,external_mesh_pt,interaction_index);

  }


//========================================================================
 /// Function to set up the one-way multi-domain interaction for 
 /// FSI-like problems. 
 /// - \c mesh_pt points to the mesh of \c ElemenWithExternalElements for which
 ///   the interaction is set up. In an FSI example, this mesh would contain
 ///   the \c FSIWallElements (either beam/shell elements or the
 ///   \c FSISolidTractionElements that apply the traction to 
 ///   a "bulk" solid mesh that is loaded by the fluid.)
 /// - \c external_mesh_pt points to the mesh that contains the elements
 ///   of type EXT_ELEMENT that provide the "source" for the
 ///   \c ElementWithExternalElements. In an FSI example, this 
 ///   mesh would contain the "bulk" fluid elements.
 /// - \c external_face_mesh_pt points to the mesh of \c FaceElements
 ///   attached to the \c external_mesh_pt. The mesh pointed to by
 ///   \c external_face_mesh_pt has the same dimension as \c mesh_pt.
 ///   The elements contained in \c external_face_mesh_pt are of type 
 ///   FACE_ELEMENT_GEOM_OBJECT. In an FSI example, these elements
 ///   are usually the \c FaceElementAsGeomObjects (templated by the
 ///   type of the "bulk" fluid elements to which they are attached)
 ///   that define the FSI boundary of the fluid domain.
 /// - The interaction_index parameter defaults to zero and must otherwise be
 ///   set by the user if there is more than one mesh that provides "external
 ///   elements" for the Mesh pointed to by mesh_pt (e.g. in the case
 ///   when a beam or shell structure is loaded by fluid from both sides.)
//========================================================================
 template<class EXT_ELEMENT,class FACE_ELEMENT_GEOM_OBJECT>
  void Multi_domain_functions::setup_multi_domain_interaction
  (Problem* problem_pt, Mesh* const &mesh_pt, Mesh* const &external_mesh_pt,
   Mesh* const &external_face_mesh_pt, const unsigned& interaction_index)
  {
   // Bulk elements must be external elements in this case
   Use_bulk_element_as_external=true;

   // Call the auxiliary routine with GEOM_OBJECT=FACE_ELEMENT_GEOM_OBJECT
   // and EL_DIM_LAG=dim, EL_DIM_EUL=dim+1
   unsigned dim=0;
   get_dim_helper(problem_pt,mesh_pt,external_face_mesh_pt,dim);

   if(dim > 2)
    {
     std::ostringstream error_stream;
     error_stream << "The elements within the two interacting meshes have a\n"
                  << "dimension not equal to 1 or 2.\n"
                  << "The multi-domain method will not work in this case.\n"
                  << "The dimension is: " << dim << "\n";
     throw OomphLibError
      (error_stream.str(),
       "Multi_domain_functions::setup_multi_domain_interaction(...)",
       OOMPH_EXCEPTION_LOCATION);
    }


   aux_setup_multi_domain_interaction
    <EXT_ELEMENT,FACE_ELEMENT_GEOM_OBJECT>
    (problem_pt,mesh_pt,external_mesh_pt,
     interaction_index,external_face_mesh_pt);
  }


//========================================================================
/// This routine calls the locate_zeta routine (simultaneously on each 
/// processor for each individual processor's element set if necessary)
/// and sets up the external (halo) element and node storage as
/// necessary.  The locate_zeta procedure here works for all multi-domain
/// problems where either two meshes occupy the same physical space but have
/// differing element types (e.g. a Boussinesq convection problem where
/// AdvectionDiffusion elements interact with Navier-Stokes type elements)
/// or two meshes interact along some boundary of the external mesh,
/// represented by a "face mesh", such as an FSI problem.
//========================================================================
 template<class EXT_ELEMENT,class GEOM_OBJECT>
  void Multi_domain_functions::aux_setup_multi_domain_interaction
  (Problem* problem_pt, Mesh* const &mesh_pt, Mesh* const &external_mesh_pt,
   const unsigned& interaction_index, Mesh* const &external_face_mesh_pt)
  {
#ifdef OOMPH_HAS_MPI
   // Storage for number of processors
   int n_proc=problem_pt->communicator_pt()->nproc();
#endif

   unsigned all_count_zetas=0;

   // Timing
   double t_start=0.0; double t_end=0.0; double t_local=0.0;
   double t_set=0.0; double t_locate=0.0; double t_spiral_start=0.0;
#ifdef OOMPH_HAS_MPI
   double t_loop_start=0.0; double t_sendrecv=0.0; double t_missing=0.0;
   double t_send_info=0.0; double t_create_halo=0.0;
#endif

   if (Doc_timings) 
    {
     t_start=TimingHelpers::timer();
    }

// #ifdef OOMPH_HAS_MPI
//    // Print a warning for the case where the external mesh is solid and 
//    // the problem has been distributed - this has not yet been tested
//    if (problem_pt->problem_has_been_distributed())
//     {
//      SolidMesh* solid_mesh_pt=dynamic_cast<SolidMesh*>(external_mesh_pt);
//      if (solid_mesh_pt!=0)
//       {
//        std::ostringstream warning_stream;
//        warning_stream << "Multi-domain method has not been comprehensively "
//                       << "tested for \n distributed problems where the "
//                       << "external mesh is a SolidMesh." << std::endl;
//        OomphLibWarning(
//         warning_stream.str(),
//         "Multi_domain_functions::aux_setup_multi_domain_interaction(...)",
//         OOMPH_EXCEPTION_LOCATION);
//       }
//     }
// #endif

   // Geometric object used to represent the external (face) mesh
   MeshAsGeomObject* mesh_geom_obj_pt=0;

   // Are bulk elements used as external elements?
   if (!Use_bulk_element_as_external)
    {
     // Set the geometric object from the external mesh
     mesh_geom_obj_pt=new MeshAsGeomObject
      (external_mesh_pt,problem_pt->communicator_pt(),
       Compute_extreme_bin_coordinates);
    }
   else
    {
     // Set the geometric object from the external face mesh argument
     mesh_geom_obj_pt=new MeshAsGeomObject
      (external_face_mesh_pt,problem_pt->communicator_pt(),
       Compute_extreme_bin_coordinates);
    }

   unsigned EL_DIM_LAG = mesh_geom_obj_pt->nlagrangian();

   if (!Compute_extreme_bin_coordinates)
    {
     // Check X_min is less than X_max
     if (X_min >= X_max)
      {
       std::ostringstream error_stream;
       error_stream << "Minimum coordinate in the X direction of the bin\n"
                    << "to be used in the multi-domain method is greater\n"
                    << "than or equal to the maximum coordinate.\n"
                    << "  X_min=" << X_min << ", X_max=" << X_max << "\n";
       throw OomphLibError
        (error_stream.str(),
         "Multi_domain_functions::aux_setup_multi_domain_interactions(...)",
         OOMPH_EXCEPTION_LOCATION);
      }

     // New maxima and minima to be used in each direction
     mesh_geom_obj_pt->x_min()=X_min-Percentage_offset*(X_max-X_min);
     mesh_geom_obj_pt->x_max()=X_max+Percentage_offset*(X_max-X_min);
     if (EL_DIM_LAG>=2)
      {
       // Check Y_min is less than Y_max
       if (Y_min >= Y_max)
        {
         std::ostringstream error_stream;
         error_stream << "Minimum coordinate in the Y direction of the bin\n"
                      << "to be used in the multi-domain method is greater\n"
                      << "than or equal to the maximum coordinate.\n"
                      << "  Y_min=" << Y_min << ", Y_max=" << Y_max << "\n";
         throw OomphLibError
          (error_stream.str(),
           "Multi_domain_functions::aux_setup_multi_domain_interactions(...)",
           OOMPH_EXCEPTION_LOCATION);
        }

       mesh_geom_obj_pt->y_min()=Y_min-Percentage_offset*(Y_max-Y_min);
       mesh_geom_obj_pt->y_max()=Y_max+Percentage_offset*(Y_max-Y_min);
      }
     if (EL_DIM_LAG==3)
      {
       // Check Z_min is less than Z_max
       if (Z_min >= Z_max)
        {
         std::ostringstream error_stream;
         error_stream << "Minimum coordinate in the Z direction of the bin\n"
                      << "to be used in the multi-domain method is greater\n"
                      << "than or equal to the maximum coordinate.\n"
                      << "  Z_min=" << Z_min << ", Z_max=" << Z_max << "\n";
         throw OomphLibError
          (error_stream.str(),
           "Multi_domain_functions::aux_setup_multi_domain_interactions(...)",
           OOMPH_EXCEPTION_LOCATION);
        }

       mesh_geom_obj_pt->z_min()=Z_min-Percentage_offset*(Z_max-Z_min);;
       mesh_geom_obj_pt->z_max()=Z_max+Percentage_offset*(Z_max-Z_min);;
      }

     // Create the bin structure
     mesh_geom_obj_pt->create_bins_of_objects();
    }

   if (Doc_timings) 
    {
     t_set=TimingHelpers::timer();
     oomph_info << "CPU for bin creation: "
                << t_set-t_start << std::endl;
    }

   // Total number of integration points
   unsigned tot_int=0;

   // Loop over (this processor's) elements and set lookup array
   unsigned n_element=mesh_pt->nelement();
   External_element_located.resize(n_element);
   for (unsigned e=0;e<n_element;e++)
    {
     ElementWithExternalElement *el_pt=
      dynamic_cast<ElementWithExternalElement*>(mesh_pt->element_pt(e));
     External_element_located[e].resize(0);
#ifdef OOMPH_HAS_MPI
     if (!el_pt->is_halo())
#endif
      {
       //We need to allocate storage for the external elements
       //within the element. Memory will actually only be 
       //allocated the first time this function is called for 
       //each element, or if the number of interactions or integration
       //points within the element has changed.
       el_pt->initialise_external_element_storage();

       unsigned n_intpt=el_pt->integral_pt()->nweight();
       for (unsigned ipt=0;ipt<n_intpt;ipt++)
        {
         External_element_located[e].push_back(0);
         tot_int++;
        }
      }
    }

   /// Loop over "spirals" from here instead; increment the "level"
   /// and pass it in to the relevant locate_* functions
   unsigned n_max_level=Nx_bin;
   if (EL_DIM_LAG>=2)
    {
     if (Ny_bin > n_max_level) 
      {
       n_max_level=Ny_bin;
      }
    }
   if (EL_DIM_LAG==3)
    {
     if (Nz_bin > n_max_level) 
      {
       n_max_level=Nz_bin;
      }
    }

   // Storage for info about coordinate location
   Vector<double> coords_located_locally(n_max_level,0.0);
   Vector<double> coords_located_elsewhere(n_max_level,0.0);
   unsigned max_level_reached=1;

   // Loop over "spirals/levels" away from the current position
   for (unsigned i_level=0;i_level<n_max_level;i_level++)
    {
     // Record time at start of spiral loop
     if (Doc_timings) 
      {
       t_spiral_start=TimingHelpers::timer();
      }

     // Tell MeshAsGeomObject the current spiral level
     mesh_geom_obj_pt->current_spiral_level()=i_level;

     // Perform locate_zeta locally first!
     locate_zeta_for_local_coordinates(mesh_pt,external_mesh_pt,
                                       mesh_geom_obj_pt,interaction_index);

     // Store stats about successful locates for reporting later
     if (Doc_stats)
      {
       unsigned count_locates=0;
       for (unsigned e=0;e<n_element;e++)
        {
         ElementWithExternalElement *el_pt=
          dynamic_cast<ElementWithExternalElement*>(mesh_pt->element_pt(e));
#ifdef OOMPH_HAS_MPI
         if (!el_pt->is_halo())
#endif
          {
           unsigned n_intpt=el_pt->integral_pt()->nweight();
           for (unsigned ipt=0;ipt<n_intpt;ipt++)
            {
             count_locates+=External_element_located[e][ipt];
            }
          }
        }
       // Store percentage of integration points successfully located
       coords_located_locally[i_level]=
        100.0*double(count_locates)/double(tot_int);
      }

     if (Doc_timings) 
      {
       t_local=TimingHelpers::timer();
       oomph_info << "CPU for local location of zeta coordinate: "
                  << t_local-t_spiral_start << std::endl;
      }

     // Now test whether anything needs to be broadcast elsewhere
     // (i.e. were there any failures in the locate method above?)
     // If there are, then the zetas for these failures need to be
     // broadcast...

     // local size of Zetas array
     all_count_zetas=Count_local_zetas;
#ifdef OOMPH_HAS_MPI
     // Only perform the reduction operation if there's more than one process
     if (problem_pt->communicator_pt()->nproc() > 1)
      {
       MPI_Allreduce(&Count_local_zetas,&all_count_zetas,1,MPI_INT,MPI_SUM,
                     problem_pt->communicator_pt()->mpi_comm());
      }

     // If the zetas array is not empty on any process 
     // and the problem is distributed, we need to locate elsewhere
     if ((all_count_zetas!=0) && (problem_pt->problem_has_been_distributed()))
      {
       // Loop over (number of processes - 1) starting from 1
       // - this number is the "distance" from the current process to the
       // process for which it is attempting to locate an element for the
       // current set of zeta coordinates
       for (int iproc=1;iproc<n_proc;iproc++)
        {
         // Record time at start of loop
         if (Doc_timings) 
          {
           t_loop_start=TimingHelpers::timer();
          }

         // Send the zeta values you haven't found to the
         // next process, receive from the previous process
         send_and_receive_missing_zetas(problem_pt);

         if (Doc_timings) 
          {
           t_sendrecv=TimingHelpers::timer();
           oomph_info << "CPU for send/recv of remaining zeta coordinates: "
                      << t_sendrecv-t_loop_start << std::endl;
          }

         // Perform the locate_zeta for the new set of zetas on this process
         locate_zeta_for_missing_coordinates
          (iproc,external_mesh_pt,problem_pt,mesh_geom_obj_pt);

         if (Doc_timings) 
          {
           t_missing=TimingHelpers::timer();
           oomph_info << "CPU for location of missing zeta coordinates: "
                      << t_missing-t_sendrecv << std::endl;
          }

         // Send any located coordinates back to the correct process, and 
         // prepare to send on to the next process if necessary
         send_and_receive_located_info(iproc,external_mesh_pt,problem_pt);

         if (Doc_timings) 
          {
           t_send_info=TimingHelpers::timer();
           oomph_info << "CPU for send/recv of new element info: "
                      << t_send_info-t_missing << std::endl;
          }

         // Create any located external halo elements on the current process
         create_external_halo_elements<EXT_ELEMENT>
          (iproc,mesh_pt,external_mesh_pt,problem_pt,interaction_index);

         if (Doc_timings) 
          {
           t_create_halo=TimingHelpers::timer();
           oomph_info << "CPU for local creation of external halo objects: "
                      << t_create_halo-t_send_info << std::endl;
          }
        }
      } // end if (all_count_zetas!=0)
#endif

     // Store information about location of elements for integration points
     if (Doc_stats)
      {
       unsigned count_locates=0;
       for (unsigned e=0;e<n_element;e++)
        {
         ElementWithExternalElement *el_pt=
          dynamic_cast<ElementWithExternalElement*>(mesh_pt->element_pt(e));
#ifdef OOMPH_HAS_MPI
         if (!el_pt->is_halo())
#endif
          {
           unsigned n_intpt=el_pt->integral_pt()->nweight();
           for (unsigned ipt=0;ipt<n_intpt;ipt++)
            {
             count_locates+=External_element_located[e][ipt];
            }
          }
        }
       // Store total percentage of locates so far
       coords_located_elsewhere[i_level]=
        100.0*double(count_locates)/double(tot_int);
      }

     // Do we have any further locating to do?
     // Only perform the reduction operation if there's more than one process
     all_count_zetas=Count_local_zetas;

#ifdef OOMPH_HAS_MPI
     if (problem_pt->communicator_pt()->nproc() > 1)
      {
       MPI_Allreduce(&Count_local_zetas,&all_count_zetas,1,MPI_INT,MPI_SUM,
                     problem_pt->communicator_pt()->mpi_comm());
      }
#endif

     // Specify max level reached for later loop
     max_level_reached=i_level+1;
     /// If all_count_zetas is now zero then break out of the spirals loop
     if (all_count_zetas==0) { break; }

    } // end of "spirals" loop


   // If we haven't found all zetas we're dead now...
   if (all_count_zetas!=0)
    {
     std::ostringstream error_stream;
     error_stream 
      << "Multi_domain_functions::locate_zeta_for_local_coordinates()"
      << "\nhas failed\n";
     error_stream 
      << "\n\nThis is most likely to arise because the two meshes\n"
      << "that are to be matched don't overlap perfectly or\n"
      << "because the elements are distorted and too small a \n"
      << "number of sampling points has been used when setting\n"
      << "up the bin structure.\n\n"
      << "You should try to increase the value of \n"
      << "Multi_domain_functions::Nsample_points from \n"
      << "its current value of " 
      << Multi_domain_functions::Nsample_points << "\n";

     std::ofstream outfile;
     outfile.open("missing_coords_mesh.dat");
     mesh_pt->output(outfile);
     outfile.close();
     outfile.open("missing_coords_ext_mesh.dat");
     external_mesh_pt->output(outfile);
     outfile.close();
     outfile.open("missing_coords_bin.dat");
     mesh_geom_obj_pt->output_bins(outfile);
     outfile.close();

     outfile.open("missing_coords.dat");     
     error_stream << "Failure at element/intpt:\n";
     unsigned n=External_element_located.size();
     for (unsigned e=0;e<n;e++)
      {
       unsigned n_intpt=External_element_located[e].size();
       for (unsigned ipt=0;ipt<n_intpt;ipt++)
        {
         if (External_element_located[e][ipt]==0)
          {

           // Cast
           ElementWithExternalElement *el_pt=
            dynamic_cast<ElementWithExternalElement*>(mesh_pt->element_pt(e));

           unsigned n_dim_el=el_pt->dim();
           Vector<double> s(n_dim_el);
           for (unsigned i=0;i<n_dim_el;i++)
            {
             s[i]=el_pt->integral_pt()->knot(ipt,i);
            }
           unsigned n_dim=el_pt->node_pt(0)->ndim();
           Vector<double> x(n_dim);
           el_pt->interpolated_x(s,x);
           for (unsigned i=0;i<n_dim;i++)
            {
             error_stream << x[i] << " ";
             outfile<< x[i] << " ";
            }            
           error_stream << std::endl;
           outfile << std::endl;
          }
        }
      }
     outfile.close();

     error_stream 
      << "Mesh and external mesh documented in missing_coords_mesh.dat\n"
      << "and missing_coords_ext_mesh.dat, respectively. Missing \n"
      << "coordinates in missing_coords.dat\n";
    throw OomphLibError
     (error_stream.str(),
      "Multi_domain_functions::locate_zeta_for_local_coordinates()",
      OOMPH_EXCEPTION_LOCATION);
    }               
   

   // Doc timings if required
   if (Doc_timings)
    {
     t_locate=TimingHelpers::timer();
     oomph_info << "CPU for location and creation of all external elements: "
                << t_locate-t_start << std::endl;
    }

   // Delete the geometric object representing the mesh
   delete mesh_geom_obj_pt;

   // Clean up all the (extern) Vectors associated with creating the
   // external storage information
   clean_up();

#ifdef OOMPH_HAS_MPI
   // Output information about external storage if required
   if (Doc_stats)
    {
     // Report stats regarding location method
     oomph_info << "-------------------------------------------" << std::endl;
     oomph_info << "- Cumulative percentage of locate success -" << std::endl; 
     oomph_info << "--- Spiral -- Found local -- Found else ---" << std::endl;
     for (unsigned level=0; level<max_level_reached; level++)
      {
       oomph_info << "---   " << level << "   -- " 
                  << coords_located_locally[level] << " -- "
                  << coords_located_elsewhere[level] << " ---" << std::endl;
      }
     oomph_info << "-------------------------------------------" << std::endl;


     // How many external elements does the external mesh have now?
     oomph_info << "------------------------------------------" << std::endl;
     oomph_info << "External mesh: I have " << external_mesh_pt->nelement()
                << " elements, and " << std::endl
                << external_mesh_pt->nexternal_halo_element()
                << " external halo elements, "
                << external_mesh_pt->nexternal_haloed_element()
                << " external haloed elements," << std::endl << "and "
                << external_mesh_pt->nexternal_element()
                << " external elements (on this processor)." << std::endl;

     // How many external nodes does each submesh have now?
     oomph_info << "------------------------------------------" << std::endl;
     oomph_info << "External mesh: I have " << external_mesh_pt->nnode()
                << " nodes, and " << std::endl
                << external_mesh_pt->nexternal_halo_node()
                << " external halo nodes, "
                << external_mesh_pt->nexternal_haloed_node()
                << " external haloed nodes," << std::endl << "and "
                << external_mesh_pt->nexternal_node()
                << " external nodes (already on this processor)." << std::endl;
     oomph_info << "------------------------------------------" << std::endl;
    }

   // Output further information about (external) halo(ed)
   // elements and nodes if required
   if (Doc_full_stats)
    {
     // How many elements does this submesh have for each of the processors?
     for (int iproc=0;iproc<n_proc;iproc++)
      {
       oomph_info << "----------------------------------------" << std::endl;
       oomph_info << "With process " << iproc << " there are "
                  << external_mesh_pt->nroot_halo_element(iproc)
                  << " root halo elements, and "
                  << external_mesh_pt->nroot_haloed_element(iproc)
                  << " root haloed elements" << std::endl
                  << "and there are "
                  << external_mesh_pt->nexternal_halo_element(iproc)
                  << " external halo elements, and "
                  << external_mesh_pt->nexternal_haloed_element(iproc)
                  << " external haloed elements." << std::endl;

       oomph_info << "----------------------------------------" << std::endl;
       oomph_info << "With process " << iproc << " there are "
                  << external_mesh_pt->nhalo_node(iproc)
                  << " halo nodes, and "
                  << external_mesh_pt->nhaloed_node(iproc)
                  << " haloed nodes" << std::endl
                  << "and there are "
                  << external_mesh_pt->nexternal_halo_node(iproc)
                  << " external halo nodes, and "
                  << external_mesh_pt->nexternal_haloed_node(iproc)
                  << " external haloed nodes." << std::endl;
      }
     oomph_info << "-----------------------------------------" << std::endl
                << std::endl;
    }

   // Check for and remove duplicate equation numbers between external halo
   // storage across different processors
   // NB this only needs to be called in parallel
   if (Check_for_duplicates)
    {
     // Only necessary to do this on a multi-processor job
     if (n_proc!=1)
      {
       if (Doc_stats)
        {
         oomph_info << "Duplicate removal, number of global equation numbers:"
                    << problem_pt->assign_eqn_numbers(false) << std::endl;
        }
       else
        {
         problem_pt->assign_eqn_numbers(false);
        }

       // Must remove duplicates from both meshes in a two-way interaction
       remove_duplicate_data(problem_pt,external_mesh_pt);
       remove_duplicate_data(problem_pt,mesh_pt);
      }
    }
#endif

   // Doc timings if required
   if (Doc_timings)
    {
     t_end=TimingHelpers::timer();
     oomph_info << "CPU for setup_multi_domain_interaction: "
                << t_end-t_start << std::endl;
    }

  } // end of aux_setup_multi_domain_interaction

#ifdef OOMPH_HAS_MPI


//=====================================================================
/// Creates external (halo) elements on the loop process based on the
/// information received from each locate_zeta call on other processes
//=====================================================================
 template<class EXT_ELEMENT>
  void Multi_domain_functions::create_external_halo_elements
  (int& iproc, Mesh* const &mesh_pt, Mesh* const &external_mesh_pt, 
   Problem* problem_pt, const unsigned& interaction_index)
  {
   OomphCommunicator* comm_pt=problem_pt->communicator_pt();
   int my_rank=comm_pt->my_rank();

   // Reset counters
   Count_zeta_dim=0;
   Count_double_values=0;
   Count_located_coord=0;
   Count_unsigned_values=0;

   // The creation all happens on the current processor
   // Loop over this processors elements
   unsigned n_element=mesh_pt->nelement();
   for (unsigned e=0;e<n_element;e++)
    {
     // Cast to ElementWithExternalElement to set external element (if located)
     ElementWithExternalElement *el_pt=
      dynamic_cast<ElementWithExternalElement*>(mesh_pt->element_pt(e));
     if (!el_pt->is_halo())
      {
       // Loop over integration points
       unsigned n_intpt=el_pt->integral_pt()->nweight();
       for (unsigned ipt=0;ipt<n_intpt;ipt++)
        {
         // Has an external element been assigned to this integration point?
         if (External_element_located[e][ipt]==0)
          {

           // Was a (non-halo) element located for this integration point
           if (((Found_zeta[Count_zeta_dim]-1)==my_rank) || 
               (Found_zeta[Count_zeta_dim]==0))
            {
             // Either it was already found, or not found on the current set
             // In either case, we don't need to do anything for this
             // integration point
            }
           else
            {
             // Get the process number on which the element was located
             unsigned loc_p=Found_zeta[Count_zeta_dim]-1;

             // Is it a new external halo element or not?
             // If so, then create it, populate it, and add it as a
             // source; if not, then find the right one which
             // has already been created and use it as the source
             // element. 

             // FiniteElement stored at this integration point
             FiniteElement* f_el_pt=0;

             // Is it a new element?
             if (Located_zetas[Count_zeta_dim]==New)
              {
               // Create a new element from the communicated values
               // and coords from the process that located zeta
               GeneralisedElement *new_el_pt= new EXT_ELEMENT;

               // Add external halo element to this mesh
               external_mesh_pt->
                add_external_halo_element_pt(loc_p, new_el_pt);
 
               // Cast to the FE pointer
               f_el_pt=dynamic_cast<FiniteElement*>(new_el_pt);

               // We need the number of interpolated values if Refineable
               int n_cont_inter_values;
               if (dynamic_cast<RefineableElement*>(new_el_pt)!=0)
                {
                 n_cont_inter_values=dynamic_cast<RefineableElement*>
                  (new_el_pt)->ncont_interpolated_values();
                }
               else
                {
                 n_cont_inter_values=-1;
                }

               // If we're using macro elements to update
               if (Unsigned_values[Count_unsigned_values]==1)
                {
                 Count_unsigned_values++;

                 // Set the macro element
                 MacroElementNodeUpdateMesh* macro_mesh_pt=
                  dynamic_cast<MacroElementNodeUpdateMesh*>
                  (external_mesh_pt);
                 unsigned macro_el_num=Unsigned_values[Count_unsigned_values];
                 f_el_pt->set_macro_elem_pt
                  (macro_mesh_pt->macro_domain_pt()->
                   macro_element_pt(macro_el_num));
                 Count_unsigned_values++;

                 // We need to receive the lower left
                 // and upper right coordinates of the macro element
                 QElementBase* q_el_pt=
                  dynamic_cast<QElementBase*>(new_el_pt);
                 if (q_el_pt!=0)
                  {
                   unsigned el_dim=q_el_pt->dim();
                   for (unsigned i_dim=0;i_dim<el_dim;i_dim++)
                    {
                     q_el_pt->s_macro_ll(i_dim)=
                      Double_values[Count_double_values];
                     Count_double_values++;
                     q_el_pt->s_macro_ur(i_dim)=
                      Double_values[Count_double_values];
                     Count_double_values++;
                    }
                  }
                 else // Throw an error, since this is only implemented for Q
                  {
                   std::ostringstream error_stream;
                   error_stream << "Using MacroElement node update\n"
                                << "in a case with non-QElements\n"
                                << "has not yet been implemented.\n";
                   throw OomphLibError
                    (error_stream.str(),
                     "Multi_domain_functions::create_external_elements()",
                     OOMPH_EXCEPTION_LOCATION);

                  }
                }
               else // Not using macro elements
                {
                 Count_unsigned_values++;
                }

               // Now we add nodes to the new element
               unsigned n_node=f_el_pt->nnode();
               for (unsigned j=0;j<n_node;j++)
                {
                 Node* new_nod_pt=0;

                 // Call the add external halo node helper function
                 add_external_halo_node_to_storage<EXT_ELEMENT>
                  (new_nod_pt,external_mesh_pt,loc_p,j,f_el_pt,
                   n_cont_inter_values,problem_pt);
                }
              }
             else // the element already exists as an external_halo
              {
               // The index itself is in Unsigned_values[...]
               unsigned external_halo_el_index=
                Unsigned_values[Count_unsigned_values];
               Count_unsigned_values++;

               // Use this index to get the element
               f_el_pt=dynamic_cast<FiniteElement*>(external_mesh_pt->
                external_halo_element_pt
                (loc_p,external_halo_el_index));

               //If it's not a finite element die
               if(f_el_pt==0)
                {
                 throw OomphLibError(
                  "External halo element is not a FiniteElement\n",
                  "Multi_domain_functions::create_external_halo_elements",
                  OOMPH_EXCEPTION_LOCATION);
                }
              }

             // The source element storage was initialised but
             // not filled earlier, so do it now
             // The located coordinates are required
             // (which could be a different dimension to zeta, e.g. in FSI)
             unsigned el_dim=f_el_pt->dim();
             Vector<double> s_located(el_dim);
             for (unsigned i=0;i<el_dim;i++)
              {
               s_located[i]=Located_coord[Count_located_coord];
               Count_located_coord++;
              }

             // Set the element for this integration point
             el_pt->external_element_pt(interaction_index,ipt)=f_el_pt;
             el_pt->
              external_element_local_coord(interaction_index,ipt)=s_located;

             // Set the lookup array to true
             External_element_located[e][ipt]=1;
            }
           // Increment the integration point counter
           Count_zeta_dim++;

          }

        } // end loop over integration points

      }
    } // end loop over local processor's elements

  }


//============start of add_external_halo_node_to_storage===============
/// Helper function to add external halo nodes, including any masters,
/// based on information received from the haloed process
//=========================================================================
 template<class EXT_ELEMENT>
  void Multi_domain_functions::add_external_halo_node_to_storage
  (Node* &new_nod_pt, Mesh* const &external_mesh_pt, unsigned& loc_p,
   unsigned& node_index, FiniteElement* const &new_el_pt, 
   int& n_cont_inter_values,
   Problem* problem_pt)
  {
   // Add the external halo node if required
   add_external_halo_node_helper(new_nod_pt,external_mesh_pt,loc_p,
                                 node_index,new_el_pt,
                                 n_cont_inter_values,problem_pt);
   
   for (int i_cont=-1;i_cont<n_cont_inter_values;i_cont++)
    {
     if (Unsigned_values[Count_unsigned_values]==1)
      {
       Count_unsigned_values++;
       unsigned n_master=Unsigned_values
        [Count_unsigned_values];
       Count_unsigned_values++;
       // Setup new HangInfo
       HangInfo* hang_pt=new HangInfo(n_master);
       for (unsigned m=0;m<n_master;m++)
        {
         Node* master_nod_pt=0;
         // Get the master node (creating and adding it if required)
         add_external_halo_master_node_helper<EXT_ELEMENT>
          (master_nod_pt,new_nod_pt,external_mesh_pt,loc_p,
           n_cont_inter_values,problem_pt);

         // Get the weight and set the HangInfo
         double master_weight=Double_values
          [Count_double_values];
         Count_double_values++;
         hang_pt->set_master_node_pt(m,master_nod_pt,master_weight);
        }
       new_nod_pt->set_hanging_pt(hang_pt,i_cont);
      }
     else // Not a hanging node
      {
       Count_unsigned_values++;
      }
    } // end loop over continous interpolated values

  }

//========================================================================
/// Helper function to add external halo node that is a master
//========================================================================
template<class EXT_ELEMENT>
 void Multi_domain_functions::add_external_halo_master_node_helper
  (Node* &new_master_nod_pt, Node* &new_nod_pt, Mesh* const &external_mesh_pt,
   unsigned& loc_p, int& ncont_inter_values,Problem* problem_pt)
 {
  // Given the node and the external mesh, and received information
  // about them from process loc_p, construct them on the current process
  if (Unsigned_values[Count_unsigned_values]==1)
   {
    // Increment counter
    Count_unsigned_values++;
    // Construct a new node based upon sent information
    construct_new_external_halo_master_node_helper<EXT_ELEMENT>
     (new_master_nod_pt,new_nod_pt,loc_p,external_mesh_pt,problem_pt);
   }
  else
   {
    // Increment counter (node already exists)
    Count_unsigned_values++;
    // Copy node from received location
    new_master_nod_pt=external_mesh_pt->external_halo_node_pt
     (loc_p,Unsigned_values[Count_unsigned_values]);
    // Increment counter
    Count_unsigned_values++;
   }
 }

//======start of construct_new_external_halo_master_node_helper===========
/// Helper function which constructs a new external halo master node
/// with the required information sent from the haloed process
//========================================================================
template<class EXT_ELEMENT>
 void Multi_domain_functions::construct_new_external_halo_master_node_helper
 (Node* &new_master_nod_pt, Node* &nod_pt, unsigned& loc_p,
  Mesh* const &external_mesh_pt, Problem* problem_pt)
 {
  // First three sent numbers are dimension, position type and nvalue
  // (to be used in Node constructors)
  unsigned n_dim=Unsigned_values[Count_unsigned_values];
  Count_unsigned_values++;
  unsigned n_position_type=Unsigned_values
   [Count_unsigned_values];
  Count_unsigned_values++;
  unsigned n_value=Unsigned_values
   [Count_unsigned_values];
  Count_unsigned_values++;
  

  // If it's a solid node also receive the lagrangian dimension and pos type
  SolidNode* solid_nod_pt=dynamic_cast<SolidNode*>(nod_pt);
  unsigned n_lag_dim;
  unsigned n_lag_type;
  if (solid_nod_pt!=0)
   {
    n_lag_dim=Unsigned_values[Count_unsigned_values];
    Count_unsigned_values++;
    n_lag_type=Unsigned_values[Count_unsigned_values];
    Count_unsigned_values++;
   }

  // Null TimeStepper for now
  TimeStepper* time_stepper_pt=0;
  // Default number of previous values to 1
  unsigned n_prev=1;

  // The first entry in nodal_info indicates
  // the timestepper required for this halo node
  if (Unsigned_values
      [Count_unsigned_values]==1)
   {
    Count_unsigned_values++;
    // Index minus one!
    time_stepper_pt=problem_pt->time_stepper_pt
     (Unsigned_values[Count_unsigned_values]);
    Count_unsigned_values++;
    // Check whether number of prev values is "sent" across
    n_prev+=time_stepper_pt->nprev_values();
   }
  else
   {
    Count_unsigned_values++;
   }

  // Is the node for which the master is required Algebraic, Macro or Solid?
  AlgebraicNode* alg_nod_pt=dynamic_cast<AlgebraicNode*>(nod_pt);
  MacroElementNodeUpdateNode* macro_nod_pt=
   dynamic_cast<MacroElementNodeUpdateNode*>(nod_pt);

  // What type of node was the node for which we are constructing a master?
  if (alg_nod_pt!=0)
   {
    // The master node should also be algebraic

    // If this master node's haloed copy is on a boundary then 
    // it needs to be on the same boundary here
    if (Unsigned_values[Count_unsigned_values]==1)
     {
      Count_unsigned_values++;
      // Create a new BoundaryNode (not attached to an element)
      if (time_stepper_pt!=0)
       {
        new_master_nod_pt = new BoundaryNode<AlgebraicNode>
         (time_stepper_pt,n_dim,n_position_type,n_value);
       }
      else
       {
        new_master_nod_pt = new BoundaryNode<AlgebraicNode>
         (n_dim,n_position_type,n_value);
       }
      // How many boundaries on the external mesh?
      unsigned n_bnd=external_mesh_pt->nboundary();
      for (unsigned i_bnd=0;i_bnd<n_bnd;i_bnd++)
       {
        if (Unsigned_values[Count_unsigned_values]==1)
         {
          // Add to current boundary; increment counter
          external_mesh_pt->add_boundary_node(i_bnd,new_master_nod_pt);
          Count_unsigned_values++;
         }
        else
         {
          // Not on this boundary; incremenet counter
          Count_unsigned_values++;
         }
       }
     }
    else
     {
      // Not on any boundary, incremenet counter
      Count_unsigned_values++;

      // Create node (not attached to any element)
      if (time_stepper_pt!=0)
       {
        new_master_nod_pt = new AlgebraicNode
         (time_stepper_pt,n_dim,n_position_type,n_value);
       }
      else
       {
        new_master_nod_pt = new AlgebraicNode
         (n_dim,n_position_type,n_value);
       }
     }

    // Add this as an external halo node BEFORE considering node update!
    external_mesh_pt->add_external_halo_node_pt(loc_p,new_master_nod_pt);

    // The external mesh is itself Algebraic...
    AlgebraicMesh* alg_mesh_pt=dynamic_cast<AlgebraicMesh*>
     (external_mesh_pt);

    /// The first entry of All_unsigned_values is the default node update id
    unsigned update_id=Unsigned_values
     [Count_unsigned_values];
    Count_unsigned_values++;

    // Setup algebraic node update info for this new node
    Vector<double> ref_value;

    // The size of this vector is in the next entry
    unsigned n_ref_val=Unsigned_values
     [Count_unsigned_values];
    Count_unsigned_values++;

    // The reference values are in the subsequent entries of All_double_values
    ref_value.resize(n_ref_val);
    for (unsigned i_ref=0;i_ref<n_ref_val;i_ref++)
     {
      ref_value[i_ref]=Double_values
       [Count_double_values];
      Count_double_values++;
     }

    // Also require a Vector of geometric objects
    Vector<GeomObject*> geom_object_pt;

    // The size of this vector is in the next entry of All_unsigned_values
    unsigned n_geom_obj=Unsigned_values
     [Count_unsigned_values];
    Count_unsigned_values++;

    // The remaining indices are in the rest of 
    // All_alg_nodal_info
    geom_object_pt.resize(n_geom_obj);
    for (unsigned i_geom=0;i_geom<n_geom_obj;i_geom++)
     {
      unsigned geom_index=Unsigned_values
       [Count_unsigned_values];
      Count_unsigned_values++;
      // This index indicates which (if any) of the AlgebraicMesh's
      // stored geometric objects should be used
      geom_object_pt[i_geom]=alg_mesh_pt->geom_object_list_pt(geom_index);
     }

    AlgebraicNode* alg_master_nod_pt=
     dynamic_cast<AlgebraicNode*>(new_master_nod_pt);

    /// ... so for the specified update_id, call
    /// add_node_update_info
    alg_master_nod_pt->add_node_update_info
     (update_id,alg_mesh_pt,geom_object_pt,ref_value);

    /// Now call update_node_update
    alg_mesh_pt->update_node_update(alg_master_nod_pt);
   }
  else if (macro_nod_pt!=0)
   {
    // The master node should also be a macro node
    // If this master node's haloed copy is on a boundary then 
    // it needs to be on the same boundary here
    if (Unsigned_values[Count_unsigned_values]==1)
     {
      Count_unsigned_values++;
      // Create a new BoundaryNode (not attached to an element)
      if (time_stepper_pt!=0)
       {
        new_master_nod_pt = new BoundaryNode<MacroElementNodeUpdateNode>
         (time_stepper_pt,n_dim,n_position_type,n_value);
       }
      else
       {
        new_master_nod_pt = new BoundaryNode<MacroElementNodeUpdateNode>
         (n_dim,n_position_type,n_value);
       }
      // How many boundaries on the external mesh?
      unsigned n_bnd=external_mesh_pt->nboundary();
      for (unsigned i_bnd=0;i_bnd<n_bnd;i_bnd++)
       {
        if (Unsigned_values[Count_unsigned_values]==1)
         {
          // Add to current boundary; increment counter
          external_mesh_pt->add_boundary_node(i_bnd,new_master_nod_pt);
          Count_unsigned_values++;
         }
        else
         {
          // Not on this boundary; incremenet counter
          Count_unsigned_values++;
         }
       }
     }
    else
     {
      // Not on boundary, incremenet counter
      Count_unsigned_values++;

      // Create node (not attached to any element)
      if (time_stepper_pt!=0)
       {
        new_master_nod_pt = new MacroElementNodeUpdateNode
         (time_stepper_pt,n_dim,n_position_type,n_value);
       }
      else
       {
        new_master_nod_pt = new MacroElementNodeUpdateNode
         (n_dim,n_position_type,n_value);
       }
     }

    // Add this as an external halo node
    external_mesh_pt->add_external_halo_node_pt(loc_p,new_master_nod_pt);

    // Create a new node update element for this master node if required
    FiniteElement *new_node_update_f_el_pt=0;
    if (Unsigned_values[Count_unsigned_values]==1)
     {
      Count_unsigned_values++;
      GeneralisedElement* new_node_update_el_pt = new EXT_ELEMENT; 

      //Add external hal element to this mesh
      external_mesh_pt->add_external_halo_element_pt(
       loc_p,new_node_update_el_pt);

      //Cast to finite element
      new_node_update_f_el_pt = 
       dynamic_cast<FiniteElement*>(new_node_update_el_pt);

      // Need number of interpolated values if Refineable
      int n_cont_inter_values;
      if (dynamic_cast<RefineableElement*>(new_node_update_f_el_pt)!=0)
       {
        n_cont_inter_values=dynamic_cast<RefineableElement*>
         (new_node_update_f_el_pt)->ncont_interpolated_values();
       }
      else
       {
        n_cont_inter_values=-1;
       }

      // If we're using macro elements to update,
      if (Unsigned_values[Count_unsigned_values]==1)
       {
        Count_unsigned_values++;

        // Set the macro element
        MacroElementNodeUpdateMesh* macro_mesh_pt=
         dynamic_cast<MacroElementNodeUpdateMesh*>
         (external_mesh_pt);
        unsigned macro_el_num=
         Unsigned_values[Count_unsigned_values];
        new_node_update_f_el_pt->set_macro_elem_pt
         (macro_mesh_pt->macro_domain_pt()->macro_element_pt(macro_el_num));
        Count_unsigned_values++;

        // we need to receive
        // the lower left and upper right coordinates of the macro
        QElementBase* q_el_pt=
         dynamic_cast<QElementBase*>(new_node_update_f_el_pt);
        if (q_el_pt!=0)
         {
          unsigned el_dim=q_el_pt->dim();
          for (unsigned i_dim=0;i_dim<el_dim;i_dim++)
           {
            q_el_pt->s_macro_ll(i_dim)=Double_values
             [Count_double_values];
            Count_double_values++;
            q_el_pt->s_macro_ur(i_dim)=Double_values
             [Count_double_values];
            Count_double_values++;
           }
         }
        else // Throw an error
         {
          std::ostringstream error_stream;
          error_stream << "You are using a MacroElement node update\n"
                       << "in a case with non-QElements. This has not\n"
                       << "yet been implemented.\n";
          throw OomphLibError
           (error_stream.str(),
            "Multi_domain_functions::construct_new_external_halo_master_...()",
            OOMPH_EXCEPTION_LOCATION);
         }
       }
      else // No macro element
       {
        Count_unsigned_values++;
       }


      unsigned n_node=new_node_update_f_el_pt->nnode();
      for (unsigned j=0;j<n_node;j++)
       {
        Node* new_nod_pt=0;
        add_external_halo_node_to_storage<EXT_ELEMENT>
         (new_nod_pt,external_mesh_pt,loc_p,j,new_node_update_f_el_pt,
          n_cont_inter_values,problem_pt);
       }

     }
    else // The node update element exists already
     {
      Count_unsigned_values++;
      new_node_update_f_el_pt=dynamic_cast<FiniteElement*>(
       external_mesh_pt->external_halo_element_pt
       (loc_p,Unsigned_values[Count_unsigned_values]));
      Count_unsigned_values++;
     }

    // Remaining required information to create functioning
    // MacroElementNodeUpdateNode...

    // Get the required geom objects for the node update
    // from the mesh
    Vector<GeomObject*> geom_object_vector_pt;
    MacroElementNodeUpdateMesh* macro_mesh_pt=
     dynamic_cast<MacroElementNodeUpdateMesh*>
     (external_mesh_pt);
    geom_object_vector_pt=macro_mesh_pt->geom_object_vector_pt();

    // Cast to MacroElementNodeUpdateNode
    MacroElementNodeUpdateNode* macro_master_nod_pt=
     dynamic_cast<MacroElementNodeUpdateNode*>(new_master_nod_pt);

    // Set all required information - node update element,
    // local coordinate in this element, and then set node update info
    macro_master_nod_pt->node_update_element_pt()=
     new_node_update_f_el_pt;

    // Need to get the local node index of the macro_master_nod_pt
    unsigned local_node_index;
    unsigned n_node=new_node_update_f_el_pt->nnode();
    for (unsigned j=0;j<n_node;j++)
     {
      if (macro_master_nod_pt==new_node_update_f_el_pt->node_pt(j))
       {
        local_node_index=j;
        break;
       }
     }

    Vector<double> s_in_macro_node_update_element;
    new_node_update_f_el_pt->local_coordinate_of_node
     (local_node_index,s_in_macro_node_update_element);

    macro_master_nod_pt->set_node_update_info
     (new_node_update_f_el_pt,s_in_macro_node_update_element,
      geom_object_vector_pt);
   }
  else if (solid_nod_pt!=0)
   {
    // The master node should also be a SolidNode
    // If this node was on a boundary then it needs to
    // be on the same boundary here
    if (Unsigned_values[Count_unsigned_values]==1)
     {
      Count_unsigned_values++;
      // Construct a new boundary node
      if (time_stepper_pt!=0)
       {
        new_master_nod_pt=new BoundaryNode<SolidNode>
         (time_stepper_pt,n_lag_dim,n_lag_type,n_dim,n_position_type,n_value);
       }
      else
       {
        new_master_nod_pt=new BoundaryNode<SolidNode>
         (n_lag_dim,n_lag_type,n_dim,n_position_type,n_value);
       }
      // How many boundaries on the external mesh?
      unsigned n_bnd=external_mesh_pt->nboundary();
      for (unsigned i_bnd=0;i_bnd<n_bnd;i_bnd++)
       {
        if (Unsigned_values[Count_unsigned_values]==1)
         {
          // Add to current boundary; increment counter
          external_mesh_pt->add_boundary_node(i_bnd,
                                              new_master_nod_pt);
          Count_unsigned_values++;
         }
        else
         {
          // Not on this boundary; increment counter
          Count_unsigned_values++;
         }
       }
     }
    else
     {
      // Not on boundary, increment counter
      Count_unsigned_values++;
      // Construct an ordinary (non-boundary) node
      if (time_stepper_pt!=0)
       {
        new_master_nod_pt=new SolidNode
         (time_stepper_pt,n_lag_dim,n_lag_type,n_dim,n_position_type,n_value);
       }
      else
       {
        new_master_nod_pt=new SolidNode
         (n_lag_dim,n_lag_type,n_dim,n_position_type,n_value);
       }
     }

    // Add this as an external halo node
    external_mesh_pt->add_external_halo_node_pt(loc_p,new_master_nod_pt);

    // Copy across particular info required for SolidNode
    // NOTE: Are there any problems with additional values for SolidNodes?
    SolidNode* solid_master_nod_pt=dynamic_cast<SolidNode*>(new_master_nod_pt);
    unsigned n_solid_val=solid_master_nod_pt->variable_position_pt()->nvalue();
    for (unsigned i_val=0;i_val<n_solid_val;i_val++)
     {
      for (unsigned t=0;t<n_prev;t++)
       {
        solid_master_nod_pt->variable_position_pt()->
         set_value(t,i_val,
                   Double_values[Count_double_values]);
	Count_double_values++;
       }
     }
   }
  else // Just an ordinary node!
   {
    // If this node was on a boundary then it needs to
    // be on the same boundary here
    if (Unsigned_values[Count_unsigned_values]==1)
     {
      Count_unsigned_values++;
      // Construct a new boundary node
      if (time_stepper_pt!=0)
       {
        new_master_nod_pt=new BoundaryNode<Node>
         (time_stepper_pt,n_dim,n_position_type,n_value);
       }
      else
       {
        new_master_nod_pt=new BoundaryNode<Node>
         (n_dim,n_position_type,n_value);
       }
      // How many boundaries on the external mesh?
      unsigned n_bnd=external_mesh_pt->nboundary();
      for (unsigned i_bnd=0;i_bnd<n_bnd;i_bnd++)
       {
        if (Unsigned_values[Count_unsigned_values]==1)
         {
          // Add to current boundary; increment counter
          external_mesh_pt->add_boundary_node(i_bnd,
                                              new_master_nod_pt);
          Count_unsigned_values++;
         }
        else
         {
          // Not on this boundary; increment counter
          Count_unsigned_values++;
         }
       }
     }
    else
     {
      // Not on boundary, increment counter
      Count_unsigned_values++;
      // Construct an ordinary (non-boundary) node
      if (time_stepper_pt!=0)
       {
        new_master_nod_pt=new Node
         (time_stepper_pt,n_dim,n_position_type,n_value);
       }
      else
       {
        new_master_nod_pt=new Node(n_dim,n_position_type,n_value);
       }
     }

    // Add this as an external halo node
    external_mesh_pt->add_external_halo_node_pt(loc_p,new_master_nod_pt);

   }

  // Remaining info received for all node types
  // Get copied history values
  //  unsigned n_val=new_master_nod_pt->nvalue();
  for (unsigned i_val=0;i_val<n_value;i_val++)
   {
    for (unsigned t=0;t<n_prev;t++)
     {
      new_master_nod_pt->set_value(t,i_val,Double_values
                                   [Count_double_values]);
      Count_double_values++;
     }
   }

  // Get copied history values for positions
  unsigned n_nod_dim=new_master_nod_pt->ndim();
  for (unsigned idim=0;idim<n_nod_dim;idim++)
   {
    for (unsigned t=0;t<n_prev;t++)
     {
      // Copy to coordinate
      new_master_nod_pt->x(t,idim)=Double_values
       [Count_double_values];
      Count_double_values++;
     }
   }

 }


#endif


}

#endif




 
