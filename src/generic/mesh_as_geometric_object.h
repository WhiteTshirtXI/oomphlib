//LIC// ====================================================================
//LIC// This file forms part of oomph-lib, the object-oriented, 
//LIC// multi-physics finite-element library, available 
//LIC// at http://www.oomph-lib.org.
//LIC// 
//LIC//           Version 0.85. June 9, 2008.
//LIC// 
//LIC// Copyright (C) 2006-2008 Matthias Heil and Andrew Hazel
//LIC// 
//LIC// This library is free software; you can redistribute it and/or
//LIC// modify it under the terms of the GNU Lesser General Public
//LIC// License as published by the Free Software Foundation; either
//LIC// version 2.1 of the License, or (at your option) any later version.
//LIC// 
//LIC// This library is distributed in the hope that it will be useful,
//LIC// but WITHOUT ANY WARRANTY; without even the implied warranty of
//LIC// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//LIC// Lesser General Public License for more details.
//LIC// 
//LIC// You should have received a copy of the GNU Lesser General Public
//LIC// License along with this library; if not, write to the Free Software
//LIC// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
//LIC// 02110-1301  USA.
//LIC// 
//LIC// The authors may be contacted at oomph-lib@maths.man.ac.uk.
//LIC// 
//LIC//====================================================================
//Header file for a class that is used to represent a mesh
//as a geometric object

//Include guards to prevent multiple inclusion of the header
#ifndef OOMPH_MESH_AS_GEOMETRIC_OBJECT_HEADER
#define OOMPH_MESH_AS_GEOMETRIC_OBJECT_HEADER

// Config header generated by autoconfig
#ifdef HAVE_CONFIG_H
  #include <oomph-lib-config.h>
#endif

//Include the geometric obeject header file
#include "geom_objects.h"

namespace oomph
{

//========================================================================
/// This class provides a GeomObject representation of a given
/// finite element mesh. The template parameters specify the
/// Lagrangian and Eulerian coordinates of the mesh. 
/// The consitituent elements of the mesh must have their own
/// GeomObject representations and they become sub-objects
/// in this compound GeomObject.
//========================================================================
template<unsigned DIM_LAGRANGIAN, unsigned DIM_EULERIAN, class ELEMENT>
class MeshAsGeomObject : public GeomObject
{

private:

 /// \short Vector of pointers to Data items that affects the object's shape
 Vector<Data*> Geom_data_pt;

 ///Internal storage for the elements that constitute the object
 Vector<ELEMENT*> Sub_geom_object_pt;
 
public:
 
 ///Constructor, pass the pointer to the mesh
 MeshAsGeomObject(Mesh* const &mesh_pt) : 
  GeomObject(DIM_LAGRANGIAN,DIM_EULERIAN)
  {
   // Create temporary storage for geometric Data (don't count 
   // Data twice!
   std::set<Data*> tmp_geom_data;
   
   //Copy all the elements in the mesh into local storage
   //N.B. elements must be able to have a geometric object representation.
   unsigned n_sub_object = mesh_pt->nelement();
   Sub_geom_object_pt.resize(n_sub_object);
   for(unsigned e=0;e<n_sub_object;e++)
    {

     // (Try to) cast to an ELEMENT:
     Sub_geom_object_pt[e]=dynamic_cast<ELEMENT*>(mesh_pt->element_pt(e));

#ifdef PARANOID
     if (Sub_geom_object_pt[e]==0)
      {
       std::ostringstream error_message;
       error_message << "Unable to dynamic cast element: " << std::endl
                     << "into an ELEMENT\n";
       throw OomphLibError(
        error_message.str(),
        "MeshAsGeomObject::MeshAsGeomObject(...)",
        OOMPH_EXCEPTION_LOCATION);
      }
#endif

     // Add the geometric Data of each element into set
     unsigned ngeom=Sub_geom_object_pt[e]->ngeom_data();
     for (unsigned i=0;i<ngeom;i++)
      {
       tmp_geom_data.insert(Sub_geom_object_pt[e]->geom_data_pt(i));
      }
    }

   // Now copy unique geom Data values across into vector
   unsigned ngeom=tmp_geom_data.size();
   Geom_data_pt.resize(ngeom);
   typedef std::set<Data*>::iterator IT;
   unsigned count=0;
   for (IT it=tmp_geom_data.begin();it!=tmp_geom_data.end();it++)
    {
     Geom_data_pt[count]=*it;
     count++;
    }

 }

 /// Empty constructor
 MeshAsGeomObject(){} 

 /// Broken copy constructor
 MeshAsGeomObject(const MeshAsGeomObject&) 
  { 
   BrokenCopy::broken_copy("MeshAsGeomObject");
  } 
 
 /// Broken assignment operator
 void operator=(const MeshAsGeomObject&) 
  {
   BrokenCopy::broken_assign("MeshAsGeomObject");
  }



 /// How many items of Data does the shape of the object depend on?
 unsigned ngeom_data() const {return Geom_data_pt.size();}
 
 /// \short Return pointer to the j-th Data item that the object's 
 /// shape depends on 
 Data* geom_data_pt(const unsigned& j) {return Geom_data_pt[j];}
 

 /// \short Find the sub geometric object and local coordinate therein that
 /// corresponds to the intrinsic coordinate zeta. If sub_geom_object_pt=0
 /// on return from this function, none of the constituent sub-objects 
 /// contain the required coordinate. 
 void locate_zeta(const Vector<double>& zeta, 
                  GeomObject*& sub_geom_object_pt, 
                  Vector<double>& s) 
  {
   // Initialise return to null -- if it's still null when we're
   // leaving we've failed!
   sub_geom_object_pt=0;

   // Loop over sub-elements to check if they contain the zeta coordinate
   unsigned n_sub = Sub_geom_object_pt.size();
   for(unsigned e=0;e<n_sub;e++)
    {
     //Test whether zeta is in the sub object or not
     Sub_geom_object_pt[e]->locate_zeta(zeta,sub_geom_object_pt,s);
     //If we've found zeta, then break
     if (sub_geom_object_pt!=0)
      {
       break;
      }
    }
  }

 /// \short Return the position as a function of the intrinsic coordinate zeta.
 /// This provides an (expensive!) default implementation in which
 /// we loop over all the constituent sub-objects and check if they
 /// contain zeta and then evaluate their position() function.
 void position(const Vector<double> &zeta, Vector<double> &r) const
  {
   // Call position function at current timestep:
   unsigned t=0;
   position(t,zeta,r);
  }


 /// \short Parametrised position on object: r(zeta). Evaluated at
 /// previous timestep. t=0: current time; t>0: previous
 /// timestep. This provides an (expensive!) default implementation in which
 /// we loop over all the constituent sub-objects and check if they
 /// contain zeta and then evaluate their position() function. 
 void position(const unsigned& t, const Vector<double>& zeta,
               Vector<double>& r) const
  {
   // Storage for the GeomObject that contains the zeta coordinate
   // and the intrinsic coordinate within it.
   GeomObject* sub_geom_object_pt;
   Vector<double> s(DIM_LAGRANGIAN);

   //Find the sub object containing zeta, and the local intrinsic coordinate
   //within it
   const_cast<MeshAsGeomObject*>(this)->locate_zeta(zeta,sub_geom_object_pt,s);
   if(sub_geom_object_pt == 0) 
    {
     std::ostringstream error_message;
     error_message << "Cannot locate zeta ";
     for(unsigned i=0;i<DIM_LAGRANGIAN;i++)
      {
       error_message << zeta[i] << " ";
      }
     error_message << std::endl;
     throw OomphLibError(error_message.str(),
                         "MeshAsGeomObject::position()",
                         OOMPH_EXCEPTION_LOCATION);
    }
   //Call that sub-object's position function
   sub_geom_object_pt->position(t,s,r);

  } // end of position



 ///Return the derivative of the position
 void dposition(const Vector<double> &xi, DenseMatrix<double> &drdxi) const
  {
   throw OomphLibError("dposition() not implemented",
                       "MeshAsGeomObject::dposition()",
                       OOMPH_EXCEPTION_LOCATION);
  }

 
};

}

#endif
