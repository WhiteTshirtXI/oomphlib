//LIC// ====================================================================
//LIC// This file forms part of oomph-lib, the object-oriented, 
//LIC// multi-physics finite-element library, available 
//LIC// at http://www.oomph-lib.org.
//LIC// 
//LIC//           Version 0.85. June 9, 2008.
//LIC// 
//LIC// Copyright (C) 2006-2008 Matthias Heil and Andrew Hazel
//LIC// 
//LIC// This library is free software; you can redistribute it and/or
//LIC// modify it under the terms of the GNU Lesser General Public
//LIC// License as published by the Free Software Foundation; either
//LIC// version 2.1 of the License, or (at your option) any later version.
//LIC// 
//LIC// This library is distributed in the hope that it will be useful,
//LIC// but WITHOUT ANY WARRANTY; without even the implied warranty of
//LIC// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//LIC// Lesser General Public License for more details.
//LIC// 
//LIC// You should have received a copy of the GNU Lesser General Public
//LIC// License along with this library; if not, write to the Free Software
//LIC// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
//LIC// 02110-1301  USA.
//LIC// 
//LIC// The authors may be contacted at oomph-lib@maths.man.ac.uk.
//LIC// 
//LIC//====================================================================
//The actual solve functions for Iterative solvers.


// Config header generated by autoconfig
#ifdef HAVE_CONFIG_H
  #include <oomph-lib-config.h>
#endif

//oomph-lib includes
#include "iterative_linear_solver.h"


namespace oomph
{


//==================================================================
/// \short Default preconditioner for iterative solvers: The base
/// class for preconditioners is a fully functional (if trivial!)
/// preconditioner.
//==================================================================
IdentityPreconditioner IterativeLinearSolver::Default_preconditioner;


///////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////







//==================================================================
/// \short Re-solve the system defined by the last assembled Jacobian
/// and the rhs vector specified here. Solution is returned in 
/// the vector result.
//==================================================================
template<typename MATRIX>
void BiCGStab<MATRIX>::resolve(const Vector<double> &rhs,
                               Vector<double> &result)
{
 
 // We are re-solving
 Resolving=true;

#ifdef PARANOID
 if (Matrix_pt==0)
  {
   throw OomphLibError(
    "No matrix was stored -- cannot re-solve",
    "BiCGStab<MATRIX>::resolve()",
    OOMPH_EXCEPTION_LOCATION);
  }
#endif

 // Call linear algebra-style solver
 this->solve(Matrix_pt,rhs,result);
  
 // Reset re-solving flag
 Resolving=false;

}



//==================================================================
/// Solver: Takes pointer to problem and returns the results vector
/// which contains the solution of the linear system defined by
/// the problem's fully assembled Jacobian and residual vector.
//==================================================================
template<typename MATRIX>
void BiCGStab<MATRIX>::solve(Problem* const &problem_pt, 
                             Vector<double> &result)
{ 
 
 //Find # of degrees of freedom (variables)
 unsigned n_dof = problem_pt->ndof();
 
 // Initialise timer
#ifdef OOMPH_HAS_MPI   
 double t_start = MPI_Wtime();
#else
 clock_t t_start = clock();
#endif
 
 // We're not re-solving
 Resolving=false;

 // Get rid of any previously stored data
 clean_up_memory();

 // Get Jacobian matrix in format specified by template parameter
 // and nonlinear residual vector
 Matrix_pt=new MATRIX;
 Vector<double> f(n_dof); 
 problem_pt->get_jacobian(f,*Matrix_pt);  
 
 // We've made the matrix, we can delete it...
 Matrix_can_be_deleted=true;

 // Doc time for setup
#ifdef OOMPH_HAS_MPI   
 double t_end = MPI_Wtime();
 Jacobian_setup_time= t_end-t_start;
#else
 clock_t t_end = clock();
 Jacobian_setup_time=double(t_end-t_start)/CLOCKS_PER_SEC;
#endif

 if(Doc_time)
  {
   oomph_info << std::endl << "Time for setup of Jacobian [sec]: "
              << Jacobian_setup_time << std::endl;
  }

 // Call linear algebra-style solver
 this->solve_helper(Matrix_pt,f,result,problem_pt);
  
 // Kill matrix unless it's still required for resolve
 if (!Enable_resolve) clean_up_memory();

};




//==================================================================
/// Linear-algebra-type solver: Takes pointer to a matrix and rhs vector 
/// and returns the solution of the linear system. Problem pointer defaults 
/// to NULL and can be omitted in linear-algebra-type solves in which
/// the preconditioner doesn't (mustn't!) require a pointer to an
/// associated Problem. \n\n
/// Algorithm and variable names based on "Numerical Linear Algebra
/// for High-Performance Computers" by Dongarra, Duff, Sorensen & van 
/// der Vorst. SIAM  (1998), page 185. 
//==================================================================
template<typename MATRIX>
void BiCGStab<MATRIX>::solve_helper(DoubleMatrixBase* const &matrix_pt,
                                    const Vector<double> &rhs,
                                    Vector<double> &solution,
                                    Problem* problem_pt)
{
 // Get number of dofs
 unsigned n_dof=rhs.size();
 
 // Time solver
#ifdef OOMPH_HAS_MPI   
 double t_start = MPI_Wtime();
#else
 clock_t t_start = clock();
#endif

 // Initialise: Zero initial guess so the initial residual is 
 // equal to the RHS, i.e. the nonlinear residual
 Vector<double> x(n_dof,0.0);
 Vector<double> residual(n_dof);
 double residual_norm=0.0;
 for(unsigned i=0;i<n_dof;i++)
  {      
   residual[i]=rhs[i];
   residual_norm+=residual[i]*residual[i];      
  } 

 residual_norm=sqrt(residual_norm);
 double rhs_norm=residual_norm;
 if (rhs_norm==0.0) rhs_norm=1.0;

 // Hat residual by copy operation
 Vector<double> r_hat(residual);
 
 // Normalised residual
 double normalised_residual_norm=residual_norm/rhs_norm;

 // if required will document convergence history to screen or file (if
 // stream open)
 if (Doc_convergence_history)
  {
   if (!Output_file_stream.is_open())
    {
     oomph_info << 0 << " " 
                << normalised_residual_norm << std::endl;
    }
   else
    {
     Output_file_stream << 0 << " "
                        << normalised_residual_norm << std::endl;
    }
  }
 
 // Check immediate convergence
 if (normalised_residual_norm<Tolerance)
  {
   if(Doc_time)
    {
     oomph_info << "BiCGStab converged immediately" << std::endl;
    }
   solution=x;
   
   // Doc time for solver
#ifdef OOMPH_HAS_MPI   
   double t_end = MPI_Wtime();
   Solution_time = t_end-t_start;
#else
   clock_t t_end = clock();
   Solution_time = double(t_end-t_start)/CLOCKS_PER_SEC;
#endif
 
   if(Doc_time)
    {  
     oomph_info << "Time for solve with BiCGStab  [sec]: "
                << Solution_time << std::endl;
    }
   return;
  }
 
 // Setup preconditioner only if we're not re-solving
 if (!Resolving)
  {
   //Setup preconditioner from the Jacobian matrix
#ifdef OOMPH_HAS_MPI   
   double t_start_prec = MPI_Wtime();
#else
   clock_t t_start_prec = clock();
#endif
   
   preconditioner_pt()->setup(problem_pt,matrix_pt);

   // Doc time for setup of preconditioner
#ifdef OOMPH_HAS_MPI   
   double t_end_prec = MPI_Wtime();
   Preconditioner_setup_time = t_end_prec-t_start_prec;
#else
   clock_t t_end = clock();
   Preconditioner_setup_time = double(t_end-t_start_prec)/CLOCKS_PER_SEC;
#endif

   if(Doc_time)
    {  
     oomph_info << "Time for setup of preconditioner  [sec]: "
                << Preconditioner_setup_time << std::endl;
    }
  }
 else
  {
   if(Doc_time)
    {
     oomph_info << "Setup of preconditioner is bypassed in resolve mode" 
                << std::endl;
    }
  }
 
 // Some auxiliary variables
 double rho_prev=0.0;
 double alpha=0.0;
 double omega=0.0;
 double rho,beta,dot_prod,dot_prod_tt,dot_prod_ts;
 double s_norm,r_norm;
 
 // Some vectors
 Vector<double> p(n_dof),p_hat(n_dof),v(n_dof),z(n_dof),t(n_dof),s(n_dof);
 
 // Loop over max. number of iterations
 for (unsigned iter=1;iter<=Max_iter;iter++)
  {
   // Dot product for rho    
   rho=0.0;
   for (unsigned i=0;i<n_dof;i++)
    {
     rho+=r_hat[i]*residual[i];
    }
   
   // Breakdown?
   if (rho==0.0)
    {
     oomph_info << "BiCGStab has broken down after " << iter 
               << " iterations" << std::endl;
     oomph_info << "Returning with current normalised residual of "
               << normalised_residual_norm << std::endl;
    }
   
   // First step is different
   if (iter==1)
    {
     for (unsigned i=0;i<n_dof;i++)
      {
       p[i]=residual[i];
      }
    }
   else
    {
     beta=(rho/rho_prev)*(alpha/omega);
     for (unsigned i=0;i<n_dof;i++)
      {
       p[i] = residual[i] + beta*(p[i]-omega*v[i]);
      }
    }
   
   // Apply precondtitioner: p_hat=P^-1*p 
   preconditioner_pt()->preconditioner_solve(p,p_hat);
   
   // Matrix vector product: v=A*p_hat
   matrix_pt->multiply(p_hat,v);
   
   dot_prod=0.0;
   for (unsigned i=0;i<n_dof;i++)
    {
     dot_prod+=r_hat[i]*v[i];
    }     
   alpha=rho/dot_prod;
   
   
   s_norm=0.0;
   for (unsigned i=0;i<n_dof;i++)
    {
     s[i]=residual[i]-alpha*v[i];
     s_norm+=s[i]*s[i];
    }  
   
   // Normalised residual
   normalised_residual_norm=sqrt(s_norm)/rhs_norm;
   

   // Richard: Do we want this half-step convergence history?
   // What does matlab do?

   // if required will document convergence history to screen or file (if
   // stream open)
   if (Doc_convergence_history)
    {
     if (!Output_file_stream.is_open())
      {
       oomph_info << double(iter-0.5) << " " 
                  << normalised_residual_norm << std::endl;
      }
     else
      {
       Output_file_stream << double(iter-0.5) << " "
                          << normalised_residual_norm <<std::endl;
      }
    }
   
   // Converged?
   if (normalised_residual_norm<Tolerance)
    {
     for (unsigned i=0;i<n_dof;i++)
      {  
       solution[i]=x[i]+alpha*p_hat[i];
      }

     if(Doc_time)
      {
       oomph_info << std::endl;
       oomph_info << "BiCGStab converged. Normalised residual norm: " 
                  << normalised_residual_norm << std::endl;
       oomph_info << "Number of iterations to convergence: " 
                  << iter << std::endl;
       oomph_info << std::endl;
      }

     // Store number of iterations taken
     Iterations = iter; 

     // Doc time for solver
#ifdef OOMPH_HAS_MPI   
     double t_end = MPI_Wtime();
     Solution_time = t_end-t_start;
#else
     clock_t t_end = clock();
     Solution_time = double(t_end-t_start)/CLOCKS_PER_SEC;
#endif
     
     if(Doc_time)
      {
       oomph_info << "Time for solve with BiCGStab  [sec]: "
                  << Solution_time << std::endl;
      }
       
     return;
    }
   
   //Apply precondtitioner: z=P^-1*s 
   preconditioner_pt()->preconditioner_solve(s,z);
   
   // Matrix vector product: t=A*z
   matrix_pt->multiply(z,t);
   
   dot_prod_ts=0.0;
   dot_prod_tt=0.0;
   for (unsigned i=0;i<n_dof;i++)
    {  
     dot_prod_tt+=t[i]*t[i];
     dot_prod_ts+=t[i]*s[i];
    }
   omega=dot_prod_ts/dot_prod_tt;
   
   r_norm=0.0;
   for (unsigned i=0;i<n_dof;i++)
    {  
     x[i]+=alpha*p_hat[i]+omega*z[i];
     residual[i]=s[i]-omega*t[i];
     r_norm+=residual[i]*residual[i];
    }
   rho_prev=rho;
   
   
   
   // Check convergence again
   normalised_residual_norm=sqrt(r_norm)/rhs_norm;
   
   // if required will document convergence history to screen or file (if
   // stream open)
   if (Doc_convergence_history)
    {
     if (!Output_file_stream.is_open())
      {
       oomph_info <<  iter << " " 
                  << normalised_residual_norm << std::endl;
      }
     else
      {
       Output_file_stream << iter << " "
                          << normalised_residual_norm << std::endl;
      }
    }
   
   
   if (normalised_residual_norm<Tolerance)
    {
     if(Doc_time)
      {
       oomph_info << std::endl;
       oomph_info << "BiCGStab converged. Normalised residual norm: " 
                  << normalised_residual_norm << std::endl;
       oomph_info << "Number of iterations to convergence: " 
                  << iter << std::endl;
       oomph_info << std::endl;
      }
     solution=x;  
     
     // Store the number of itertions taken.
     Iterations = iter; 

     // Doc time for solver
#ifdef OOMPH_HAS_MPI   
     double t_end = MPI_Wtime();
     Solution_time = t_end-t_start;
#else
     clock_t t_end = clock();
     Solution_time = double(t_end-t_start)/CLOCKS_PER_SEC;
#endif
     
     if(Doc_time)
      {
       oomph_info << "Time for solve with BiCGStab  [sec]: "
                  << Solution_time << std::endl;
      }
     return;
    }
   
   
   // Breakdown: Omega has to be >0 for to be able to continue
   if (omega == 0.0)
    {
     oomph_info << std::endl;
     oomph_info << "BiCGStab breakdown with omega=0.0. " 
                << "Normalised residual norm: " 
                << normalised_residual_norm << std::endl;
     oomph_info << "Number of iterations so far: " << iter << std::endl;
     oomph_info << std::endl;
     solution=x;   

     // Store the number of itertions taken.
     Iterations = iter; 

     // Doc time for solver
#ifdef OOMPH_HAS_MPI   
     double t_end = MPI_Wtime();
     Solution_time = t_end-t_start;
#else
     clock_t t_end = clock();
     Solution_time = double(t_end-t_start)/CLOCKS_PER_SEC;
#endif

     if(Doc_time)
      {
       oomph_info << "Time for solve with BiCGStab  [sec]: "
                  << Solution_time << std::endl;
      }
     return;
    }
   
   
   
  } // end of iteration loop
 
 
 // No convergence
 oomph_info << std::endl;
 oomph_info << "BiCGStab did not converge to required tolerance! "
            << std::endl;
 oomph_info << "Returning with normalised residual norm: " 
            << normalised_residual_norm << std::endl;
 oomph_info << "after " << Max_iter<< " iterations." << std::endl;
 oomph_info << std::endl;

 solution=x;   
 
 // Doc time for solver
#ifdef OOMPH_HAS_MPI   
 double t_end = MPI_Wtime();
 Solution_time = t_end-t_start;
#else
 clock_t t_end = clock();
 Solution_time = double(t_end-t_start)/CLOCKS_PER_SEC;
#endif
 
 if(Doc_time)
  {
   oomph_info << "Time for solve with BiCGStab  [sec]: "
              << Solution_time << std::endl;
  }
 
}


//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////



//==================================================================
/// Linear-algebra-type solver: Takes pointer to a matrix and rhs vector 
/// and returns the solution of the linear system. Problem pointer defaults 
/// to NULL and can be omitted in linear-algebra-type solves in which
/// the preconditioner doesn't (mustn't!) require a pointer to an
/// associated Problem. \n\n
/// Algorithm and variable names based on "Matrix Computations,
/// 2nd Ed." Golub & van Loan, John Hopkins University Press(1989),
/// page 529.
//==================================================================
template<typename MATRIX>
void CG<MATRIX>::solve_helper(DoubleMatrixBase* const &matrix_pt,
                              const Vector<double> &rhs,
                              Vector<double> &solution,
                              Problem* problem_pt)
{
 // Get number of dofs
 unsigned n_dof=rhs.size();
 
 // Initialise counter
 unsigned counter = 1; 

 // Time solver
#ifdef OOMPH_HAS_MPI   
 double t_start = MPI_Wtime();
#else
 clock_t t_start = clock();
#endif
 
 // Initialise: Zero initial guess so the initial residual is 
 // equal to the RHS
 Vector<double> x(n_dof,0.0);
 Vector<double> residual(n_dof);
 double residual_norm=0.0;
 for(unsigned i=0;i<n_dof;i++)
  {      
   residual[i]=rhs[i];
   residual_norm+=residual[i]*residual[i];      
  } 
 residual_norm=sqrt(residual_norm);
 double rhs_norm=residual_norm;
 if (rhs_norm==0.0) rhs_norm=1.0;
 
 // Normalised residual
 double normalised_residual_norm=residual_norm/rhs_norm;
 
 // if required will document convergence history to screen or file (if
 // stream open)
 if (Doc_convergence_history)
  {
   if (!Output_file_stream.is_open())
    {
     oomph_info  << 0 << " "  
                 << normalised_residual_norm <<std::endl;
    }
   else
    {
     Output_file_stream << 0 << " "  
                        << normalised_residual_norm <<std::endl;
    }
  }

 // Check immediate convergence
 if (normalised_residual_norm<Tolerance)
  {
   if(Doc_time)
    {
     oomph_info << "CG converged immediately" << std::endl;
    }
   solution=x;
   
   // Doc time for solver
#ifdef OOMPH_HAS_MPI   
   double t_end = MPI_Wtime();
   Solution_time = t_end-t_start;
#else
   clock_t t_end = clock();
   Solution_time = double(t_end-t_start)/CLOCKS_PER_SEC;
#endif
   
   if(Doc_time)
    {
     oomph_info << "Time for solve with CG  [sec]: "
                << Solution_time << std::endl;
    }
   return;
  }
 

 // Setup preconditioner only if we're not re-solving
 if (!Resolving)
  {
   //Setup preconditioner from the Jacobian matrix
#ifdef OOMPH_HAS_MPI   
   double t_start_prec = MPI_Wtime();
#else
   clock_t t_start_prec = clock();
#endif
   
   preconditioner_pt()->setup(problem_pt,matrix_pt);

   // Doc time for setup of preconditioner
#ifdef OOMPH_HAS_MPI   
   double t_end_prec = MPI_Wtime();
   Preconditioner_setup_time = t_end_prec-t_start_prec;
#else
   clock_t t_end = clock();
   Preconditioner_setup_time = double(t_end-t_start_prec)/CLOCKS_PER_SEC;
#endif

   if(Doc_time)
    {
     oomph_info << "Time for setup of preconditioner  [sec]: "
                << Preconditioner_setup_time << std::endl;   
    }
  }
 else
  {
   if(Doc_time)
    {
     oomph_info << "Setup of preconditioner is bypassed in resolve mode" 
                << std::endl;
    }
  }


 // Auxiliary vectors
 Vector<double> z(n_dof),p(n_dof),jacobian_times_p(n_dof,0.0);
 
 // Auxiliary values
 double alpha,beta,rz;
 double prev_rz=0.0;
 
 // Main iteration
 while((normalised_residual_norm>Tolerance)&&(counter!=Max_iter))
  {  
   
   //Apply precondtitioner: z=P^-1*r
   preconditioner_pt()->preconditioner_solve(residual,z);
   
   // P vector is computed differently for first and subsequent steps
   if(counter==1)
    {
     // r \cdot z is needed for next step
     rz=0.0;
     for (unsigned i=0;i<n_dof;i++)
      {
       p[i]=z[i];
       rz+=residual[i]*z[i]; 
      }
    }
   // Subsequent steps
   else
    {
     rz=0.0;
     for (unsigned i=0;i<n_dof;i++)
      {
       rz+=residual[i]*z[i];
      }       
     beta=rz/prev_rz;
     for (unsigned i=0;i<n_dof;i++)
      {	  
       p[i]=z[i]+beta*p[i];
      }	
    }
   
   
   // Matrix vector product
   matrix_pt->multiply(p,jacobian_times_p);     
   double pq=0.0;
   for(unsigned i=0;i<n_dof;i++)
    {
     pq+=p[i]*jacobian_times_p[i];
    }     
   alpha=rz/pq;
   
   // Update
   prev_rz=rz;
   for(unsigned i=0;i<n_dof;i++)
    {
     x[i]+=alpha*p[i];
     residual[i]-=alpha*jacobian_times_p[i];
    }
   
   
   //Calculate the 2norm
   residual_norm=0.0;
   for(unsigned i=0;i<n_dof;i++)
    {
     residual_norm+=residual[i]*residual[i];
    }
   
   //Difference between the initial and current 2norm residual
   normalised_residual_norm=sqrt(residual_norm)/rhs_norm;
   
   // if required will document convergence history to screen or file (if
   // stream open)
   if (Doc_convergence_history)
    {
     if (!Output_file_stream.is_open())
      {
       oomph_info <<  counter << " " 
                  << normalised_residual_norm << std::endl;
      }
     else
      {
       Output_file_stream << counter << " "
                          << normalised_residual_norm << std::endl;
      }
    }
   
   counter=counter+1;
   
  }//end while
 
 
 if (counter>Max_iter)
  {  
   oomph_info << std::endl;
   oomph_info << "CG did not converge to required tolerance! " << std::endl;
   oomph_info << "Returning with normalised residual norm: " 
        << normalised_residual_norm << std::endl;
   oomph_info << "after " << counter << " iterations." << std::endl;
   oomph_info << std::endl;
  }
 else
  {
   if(Doc_time)
    {
     oomph_info << std::endl;
     oomph_info << "CG converged. Normalised residual norm: " 
                << normalised_residual_norm << std::endl;
     oomph_info << "Number of iterations to convergence: " 
                << counter << std::endl;
     oomph_info << std::endl;
    }
  }
 
 
 // Store number if iterations taken
 Iterations = counter;
	 
 // Copy result back
 solution=x;   

 // Doc time for solver
#ifdef OOMPH_HAS_MPI   
   double t_end = MPI_Wtime();
   Solution_time = t_end-t_start;
#else
   clock_t t_end = clock();
   Solution_time = double(t_end-t_start)/CLOCKS_PER_SEC;
#endif

 if(Doc_time)
  {
   oomph_info << "Time for solve with CG  [sec]: "
              << Solution_time << std::endl;
  }

}//end CG


//==================================================================
/// \short Re-solve the system defined by the last assembled Jacobian
/// and the rhs vector specified here. Solution is returned in 
/// the vector result.
//==================================================================
template<typename MATRIX>
void CG<MATRIX>::resolve(const Vector<double> &rhs,
                         Vector<double> &result)
{
 
 // We are re-solving
 Resolving=true;

#ifdef PARANOID
 if (Matrix_pt==0)
  {
   throw OomphLibError(
    "No matrix was stored -- cannot re-solve",
    "CG<MATRIX>::resolve()",
    OOMPH_EXCEPTION_LOCATION);
  }
#endif

 // Call linear algebra-style solver
 this->solve(Matrix_pt,rhs,result);
  
 // Reset re-solving flag
 Resolving=false;

}



//==================================================================
/// Solver: Takes pointer to problem and returns the results vector
/// which contains the solution of the linear system defined by
/// the problem's fully assembled Jacobian and residual vector.
//==================================================================
template<typename MATRIX>
void CG<MATRIX>::solve(Problem* const &problem_pt, Vector<double> &result)
{ 
 
 //Find # of degrees of freedom (variables)
 unsigned n_dof = problem_pt->ndof();
 
 // Initialise timer
#ifdef OOMPH_HAS_MPI   
 double t_start = MPI_Wtime();
#else
 clock_t t_start = clock();
#endif

 // We're not re-solving
 Resolving=false;

 // Get rid of any previously stored data
 clean_up_memory();

 // Get Jacobian matrix in format specified by template parameter
 // and nonlinear residual vector
 Matrix_pt=new MATRIX;
 Vector<double> f(n_dof); 
 problem_pt->get_jacobian(f,*Matrix_pt);  
 
 // We've made the matrix, we can delete it...
 Matrix_can_be_deleted=true;

 // Doc time for setup
#ifdef OOMPH_HAS_MPI   
 double t_end = MPI_Wtime();
 Jacobian_setup_time= t_end-t_start;
#else
 clock_t t_end = clock();
 Jacobian_setup_time=double(t_end-t_start)/CLOCKS_PER_SEC;
#endif

 if(Doc_time)
  {
   oomph_info << std::endl << "Time for setup of Jacobian [sec]: "
              << Jacobian_setup_time << std::endl;
  }

 // Call linear algebra-style solver
 this->solve_helper(Matrix_pt,f,result,problem_pt);
  
 // Kill matrix unless it's still required for resolve
 if (!Enable_resolve) clean_up_memory();

};



///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////




//==================================================================
/// \short Re-solve the system defined by the last assembled Jacobian
/// and the rhs vector specified here. Solution is returned in 
/// the vector result.
//==================================================================
template<typename MATRIX>
void GS<MATRIX>::resolve(const Vector<double> &rhs,
                         Vector<double> &result)
{
 
 // We are re-solving
 Resolving=true;

#ifdef PARANOID
 if (Matrix_pt==0)
  {
   throw OomphLibError(
    "No matrix was stored -- cannot re-solve",
    "GS<MATRIX>::resolve()",
    OOMPH_EXCEPTION_LOCATION);
  }
#endif

 // Call linear algebra-style solver
 this->solve(Matrix_pt,rhs,result);
  
 // Reset re-solving flag
 Resolving=false;

}



//==================================================================
/// Solver: Takes pointer to problem and returns the results vector
/// which contains the solution of the linear system defined by
/// the problem's fully assembled Jacobian and residual vector.
//==================================================================
template<typename MATRIX>
void GS<MATRIX>::solve(Problem* const &problem_pt, Vector<double> &result)
{ 
 
 //Find # of degrees of freedom (variables)
 unsigned n_dof = problem_pt->ndof();
 
 // Initialise timer
#ifdef OOMPH_HAS_MPI   
 double t_start = MPI_Wtime();
#else
 clock_t t_start = clock();
#endif

 // We're not re-solving
 Resolving=false;

 // Get rid of any previously stored data
 clean_up_memory();

 // Get Jacobian matrix in format specified by template parameter
 // and nonlinear residual vector
 Matrix_pt=new MATRIX;
 Vector<double> f(n_dof); 
 problem_pt->get_jacobian(f,*Matrix_pt);  
 
 // We've made the matrix, we can delete it...
 Matrix_can_be_deleted=true;

 // Doc time for setup
#ifdef OOMPH_HAS_MPI   
 double t_end = MPI_Wtime();
 Jacobian_setup_time= t_end-t_start;
#else
 clock_t t_end = clock();
 Jacobian_setup_time=double(t_end-t_start)/CLOCKS_PER_SEC;
#endif

 if(Doc_time)
  {
   oomph_info << std::endl << "Time for setup of Jacobian [sec]: "
              << Jacobian_setup_time << std::endl;
  }

 // Call linear algebra-style solver
 this->solve_helper(Matrix_pt,f,result,problem_pt);
  
 // Kill matrix unless it's still required for resolve
 if (!Enable_resolve) clean_up_memory();

};


//==================================================================
/// Linear-algebra-type solver: Takes pointer to a matrix and rhs vector 
/// and returns the solution of the linear system. Problem pointer defaults 
/// to NULL and can be omitted in linear-algebra-type solves in which
/// the preconditioner doesn't (mustn't!) require a pointer to an
/// associated Problem. \n\n
//==================================================================
template<typename MATRIX>
void GS<MATRIX>::solve_helper(DoubleMatrixBase* const &matrix_pt,
                              const Vector<double> &rhs,
                              Vector<double> &solution,
                              Problem* problem_pt)
{

 // Get number of dofs
 unsigned n_dof=rhs.size();

 // Initialise
 unsigned counter=1;

 // Initialise timer
#ifdef OOMPH_HAS_MPI   
 double t_start = MPI_Wtime();
#else
 clock_t t_start = clock();
#endif

 // Initial guess is zero so the residual is equal to the RHS
 Vector<double> x(n_dof,0.0);
 Vector<double> local_residual(n_dof);
 for(unsigned i=0;i<n_dof;i++)
  {   
   local_residual[i]=rhs[i];
  }
 
 //Calculate the 2 norm
 double add_squared=0.0;
 for(unsigned i=0;i<n_dof;i++)
  {          
   add_squared+=local_residual[i]*local_residual[i];
  }
 double norm_res=sqrt(add_squared);
 double norm_f=norm_res;

 // if required will document convergence history to screen or file (if
 // stream open)
 if (Doc_convergence_history)
  {
   if (!Output_file_stream.is_open())
    {
     oomph_info <<  0 << " "<< norm_res << std::endl;
    }
   else
    {
     Output_file_stream << 0 << " " << norm_res <<std::endl;
    }
  }
 
 Vector<double> current_residual(n_dof);
 // Start of the main GS loop
 while((norm_res>Tolerance)&&(counter!=Max_iter))
  {
   
   // Loop over rows
   for(unsigned i=0;i<n_dof;i++)
    {
     double dummy=local_residual[i];
     for (unsigned j=0;j<i;j++)
      {
       dummy-=(*matrix_pt)(i,j)*x[j];
      }
     for (unsigned j=(i+1);j<n_dof;j++)
      {
       dummy-=(*matrix_pt)(i,j)*x[j];
      }
     x[i]=dummy/(*matrix_pt)(i,i);
    }
   
   // Get residual
   matrix_pt->residual(x,rhs,current_residual);
   
   //calculate the 2 norm
   add_squared=0.0;
   for(unsigned i=0;i<n_dof;i++)
    {
     add_squared+=current_residual[i]*current_residual[i];
    }
   
   norm_res=sqrt(add_squared)/norm_f;
   
   // if required will document convergence history to screen or file (if
   // stream open)
   if (Doc_convergence_history)
    {
     if (!Output_file_stream.is_open())
      {
       oomph_info << counter << " "
                  << norm_res << std::endl;
      }
     else
      {
       Output_file_stream << counter << " " 
                          << norm_res << std::endl;
      }
    }
   counter=counter+1;
   
   
  }//end while (number of smoothes or relaxations)
 
 if(Doc_time)
  {
   oomph_info << std::endl;
   oomph_info << "GS converged. Residual norm: " << norm_res << std::endl;
   oomph_info << "Number of iterations to convergence: "<< counter<<std::endl;
   oomph_info << std::endl;
  }

 // copy number of iterations taken
 Iterations=counter;
 
 //Copy result into result
 solution = x;
 
 // Doc time for solver
#ifdef OOMPH_HAS_MPI   
   double t_end = MPI_Wtime();
   Solution_time = t_end-t_start;
#else
   clock_t t_end = clock();
   Solution_time = double(t_end-t_start)/CLOCKS_PER_SEC;
#endif

 if(Doc_time)
  {
   oomph_info << "Time for solve with GS  [sec]: "
              << Solution_time << std::endl;
  }

}//end Gauss Seidel






//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////



//==================================================================
/// \short Re-solve the system defined by the last assembled Jacobian
/// and the rhs vector specified here. Solution is returned in 
/// the vector result.
//==================================================================
template<typename MATRIX>
void GMRES<MATRIX>::resolve(const Vector<double> &rhs,
                            Vector<double> &result)
{
 
 // We are re-solving
 Resolving=true;

#ifdef PARANOID
 if (Matrix_pt==0)
  {
   throw OomphLibError(
    "No matrix was stored -- cannot re-solve",
    "GMRES<MATRIX>::resolve()",
    OOMPH_EXCEPTION_LOCATION);
  }
#endif

 // Call linear algebra-style solver
 this->solve(Matrix_pt,rhs,result);
  
 // Reset re-solving flag
 Resolving=false;

}



//==================================================================
/// Solver: Takes pointer to problem and returns the results vector
/// which contains the solution of the linear system defined by
/// the problem's fully assembled Jacobian and residual vector.
//==================================================================
template<typename MATRIX>
void GMRES<MATRIX>::solve(Problem* const &problem_pt, Vector<double> &result)
{ 
 
 //Find # of degrees of freedom (variables)
 unsigned n_dof = problem_pt->ndof();
 
 // Initialise timer
#ifdef OOMPH_HAS_MPI   
 double t_start = MPI_Wtime();
#else
 clock_t t_start = clock();
#endif

 // We're not re-solving
 Resolving=false;

 // Get rid of any previously stored data
 clean_up_memory();

 // Get Jacobian matrix in format specified by template parameter
 // and nonlinear residual vector
 Matrix_pt=new MATRIX;
 Vector<double> f(n_dof); 
 problem_pt->get_jacobian(f,*Matrix_pt);  
 
 // We've made the matrix, we can delete it...
 Matrix_can_be_deleted=true;

 // Doc time for setup
#ifdef OOMPH_HAS_MPI   
 double t_end = MPI_Wtime();
 Jacobian_setup_time= t_end-t_start;
#else
 clock_t t_end = clock();
 Jacobian_setup_time=double(t_end-t_start)/CLOCKS_PER_SEC;
#endif

 if(Doc_time)
  {
   oomph_info << std::endl << "Time for setup of Jacobian [sec]: "
              << Jacobian_setup_time << std::endl;
  }

 // Call linear algebra-style solver
 this->solve_helper(Matrix_pt,f,result,problem_pt);
  
 // Kill matrix unless it's still required for resolve
 if (!Enable_resolve) clean_up_memory();

};


//=============================================================================
/// Linear-algebra-type solver: Takes pointer to a matrix and rhs vector 
/// and returns the solution of the linear system. Problem pointer defaults 
/// to NULL and can be omitted in linear-algebra-type solves in which
/// the preconditioner doesn't (mustn't!) require a pointer to an
/// associated Problem. \n\n
/// based on the algorithm presented in Templates for the
/// Solution of Linear Systems: Building Blocks for Iterative Methods, Barrett,
/// Berry et al, SIAM, 2006 and the implementation in the IML++ library :
/// http://math.nist.gov/iml++/ 
//=============================================================================
template <typename MATRIX>
void GMRES<MATRIX>::solve_helper(DoubleMatrixBase* const &matrix_pt,
                                 const Vector<double> &rhs,
                                 Vector<double> &solution,
                                 Problem* problem_pt)
{

 // Get number of dofs
 unsigned n_dof=rhs.size();


//  {
//   unsigned n=rhs.size();
//   for (unsigned i=0;i<n;i++)
//    {
//     std::cout << rhs[i] << std::endl;
//    }
//   pause("done in solve_helper bla [1.01]");
//  }

 
 // Resize and initialise
 solution.resize(n_dof);
 for (unsigned i=0;i<n_dof;i++) {solution[i]=0.0;}


//  {
//   unsigned n=rhs.size();
//   for (unsigned i=0;i<n;i++)
//    {
//     std::cout << rhs[i] << std::endl;
//    }
//   pause("done in solve_helper bla [1.02]");
//  }

 
 // Time solver
#ifdef OOMPH_HAS_MPI   
 double t_start = MPI_Wtime();
#else
 clock_t t_start = clock();
#endif

 // relative residual
 double resid;

 // iteration counter
 unsigned iter = 1;

 // if not using iteration restart set Restart to n_dof
 if (!Iteration_restart)
  {
   Restart = n_dof;
  }

 // initialise vectors 
 Vector<double> s(Restart + 1,0);
 Vector<double> cs(Restart + 1);
 Vector<double> sn(Restart + 1);
 Vector<double> w(n_dof);
 

 // Setup preconditioner only if we're not re-solving
 if (!Resolving)
  {
   //Setup preconditioner from the Jacobian matrix
#ifdef OOMPH_HAS_MPI   
   double t_start_prec = MPI_Wtime();
#else
   clock_t t_start_prec = clock();
#endif
   
   preconditioner_pt()->setup(problem_pt,matrix_pt);

   // Doc time for setup of preconditioner
#ifdef OOMPH_HAS_MPI   
   double t_end_prec = MPI_Wtime();
   Preconditioner_setup_time = t_end_prec-t_start_prec;
#else
   clock_t t_end = clock();
   Preconditioner_setup_time = double(t_end-t_start_prec)/CLOCKS_PER_SEC;
#endif

   if(Doc_time)
    {
     oomph_info << "Time for setup of preconditioner  [sec]: "
                << Preconditioner_setup_time << std::endl;     
    }
  }
 else
  {
   if(Doc_time)
    {
     oomph_info << "Setup of preconditioner is bypassed in resolve mode" 
                << std::endl;
    }
  } 
 
 // solve b-Jx = Mr for r (assumes x = 0);
 Vector<double> r(n_dof);
 preconditioner_pt()->preconditioner_solve(rhs,r); 
 double normb = 0;
 
 // compute norm(r)
 for (unsigned i = 0; i < n_dof; i++)
  {
   normb += r[i] * r[i];
  }
 normb = sqrt(normb);

 // set beta (the initial residual) 
 double beta = normb;
 
 // compute initial relative residual
 if (normb == 0.0) normb = 1;
 resid = beta / normb;
 
 // if required will document convergence history to screen or file (if
 // stream open)
 if (Doc_convergence_history)
  {
   if (!Output_file_stream.is_open())
    {
     oomph_info <<  0 << " "<< resid << std::endl;
    }
   else
    {
     Output_file_stream << 0 << " " << resid <<std::endl;
    }
  }
 
 // if GMRES converges immediately
 if (resid <= Tolerance)
  {
   if(Doc_time)
    {
     oomph_info << "GMRES converged immediately. Normalised residual norm: " 
                << resid << std::endl;
    }
   // Doc time for solver
#ifdef OOMPH_HAS_MPI   
   double t_end = MPI_Wtime();
   Solution_time = t_end-t_start;
#else
   clock_t t_end = clock();
   Solution_time = double(t_end-t_start)/CLOCKS_PER_SEC;
#endif

   if(Doc_time)
    {
     oomph_info << "Time for solve with GMRES  [sec]: "
                << Solution_time << std::endl;
    }
   return;
  }

 
 // initialise vector of orthogonal basis vectors (v) and upper hessenberg 
 // matrix H
 // NOTE: for implementation purpose the upper hessenbery matrix indexes are
 // are swapped so the matrix is effectively transposed
 Vector<Vector<double> > v(Restart + 1);
 Vector<Vector<double> > H(Restart + 1);

 // while...
 while (iter <= Max_iter)
  {

   // set zeroth basis vector v[0] to r/beta
   v[0].resize(n_dof);
   for (unsigned i = 0; i < n_dof; i++)
    {
     v[0][i] = r[i] / beta;
    }

   // 
   s[0] = beta;
    
   // inner iteration counter for restarted version
   unsigned iter_restart;

   // perform iterations
   for (iter_restart = 0; iter_restart < Restart && iter <= Max_iter; 
        iter_restart++, iter++)
    {

     // resize next column of upper hessenberg matrix
     H[iter_restart].resize(iter_restart+2);

     // solve Jv[i] = Mw for w
     {
      Vector<double> temp(n_dof);
      matrix_pt->multiply(v[iter_restart],temp);
      preconditioner_pt()->preconditioner_solve(temp,w);
     }

     //
     for (unsigned k = 0; k <= iter_restart; k++)
      {
       
       // 
       H[iter_restart][k] = 0.0;
       for (unsigned i = 0; i < n_dof; i++)
        {
         H[iter_restart][k] += w[i]*v[k][i];
        }

       //
       for (unsigned i = 0; i < n_dof; i++)
        {
         w[i] -= H[iter_restart][k] * v[k][i];
        }
      }
     
     // 
     {
      double temp_norm_w = 0.0;
      for (unsigned i = 0; i < n_dof; i++)
       {
        temp_norm_w += w[i]*w[i];
       }
      temp_norm_w = sqrt(temp_norm_w);
      H[iter_restart][iter_restart+1] = temp_norm_w;
     }
    
     // 
     v[iter_restart + 1].resize(n_dof);
     for (unsigned i = 0; i < n_dof; i++)
      {
       v[iter_restart + 1][i] = w[i] / H[iter_restart][iter_restart+1];
      }

     //
     for (unsigned k = 0; k < iter_restart; k++)
      {
       apply_plane_rotation(H[iter_restart][k], H[iter_restart][k+1], cs[k], 
                          sn[k]); 
      }
     generate_plane_rotation(H[iter_restart][iter_restart], 
                             H[iter_restart][iter_restart+1], 
                             cs[iter_restart], 
                             sn[iter_restart]); 
     apply_plane_rotation(H[iter_restart][iter_restart], 
                          H[iter_restart][iter_restart+1], cs[iter_restart], 
                          sn[iter_restart]);
     apply_plane_rotation(s[iter_restart],s[iter_restart+1],cs[iter_restart],
                          sn[iter_restart]);
     
     // compute current residual
     beta = fabs(s[iter_restart+1]);

     // compute relative residual
     resid = beta/normb;

     // if required will document convergence history to screen or file (if
     // stream open)
     if (Doc_convergence_history)
      {
       if (!Output_file_stream.is_open())
        {
         oomph_info << iter << " "<< resid << std::endl;
        }
       else
        {
         Output_file_stream << iter << " " << resid <<std::endl;
        }
      }

     // if required tolerance found
     if (resid < Tolerance)
      {
       // update result vector
       update(iter_restart, H, s, v, solution);

       // document convergence
       if(Doc_time)
        {
         oomph_info << std::endl;
         oomph_info << "GMRES converged (1). Normalised residual norm: " 
                    << resid << std::endl;
         oomph_info << "Number of iterations to convergence: " 
                    << iter << std::endl;
         oomph_info << std::endl;
        }
       
       // Doc time for solver
#ifdef OOMPH_HAS_MPI   
       double t_end = MPI_Wtime();
       Solution_time = t_end-t_start;
#else
       clock_t t_end = clock();
       Solution_time = double(t_end-t_start)/CLOCKS_PER_SEC;
#endif

       if(Doc_time)
        {
         oomph_info << "Time for solve with GMRES  [sec]: "
                    << Solution_time << std::endl;
        }
       return;
      }
    }
   
   // update
   if (iter_restart>0) update((iter_restart - 1), H, s, v, solution);
   
   // solve Mr = (b-Jx) for r
   {
    Vector<double> temp(n_dof);
    matrix_pt->multiply(solution,temp);
    for (unsigned i = 0; i < n_dof; i++)
     {
      temp[i] = rhs[i] - temp[i];
     }
    preconditioner_pt()->preconditioner_solve(temp,r); 
   } 
   
   // compute current residual
   beta = 0.0;
   for (unsigned i = 0; i < n_dof; i++)
    {
     beta += r[i] * r[i];
    }
   beta = sqrt(beta);

   // if relative residual within tolerance
   resid = beta / normb;
   if (resid < Tolerance)
    {
     if(Doc_time)
      {
       oomph_info << std::endl;
       oomph_info << "GMRES converged (2). Normalised residual norm: " 
                  << resid << std::endl;
       oomph_info << "Number of iterations to convergence: " 
                  << iter << std::endl;
       oomph_info << std::endl;
      }
     
     // Doc time for solver
#ifdef OOMPH_HAS_MPI   
     double t_end = MPI_Wtime();
     Solution_time = t_end-t_start;
#else
     clock_t t_end = clock();
     Solution_time = double(t_end-t_start)/CLOCKS_PER_SEC;
#endif
     
     if(Doc_time)
      {
       oomph_info << "Time for solve with GMRES  [sec]: "
                  << Solution_time << std::endl;
      }
     return;
    }
  }
  
 
 // otherwise GMRES failed convergence
 oomph_info << std::endl;
 oomph_info << "GMRES did not converge to required tolerance! "
            << std::endl;
 oomph_info << "Returning with normalised residual norm: " 
            << resid << std::endl;
 oomph_info << "after " << Max_iter<< " iterations." << std::endl;
 oomph_info << std::endl;
 return;
  
}//end GMRES



//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////




//Ensure build of required objects
template class BiCGStab<CCDoubleMatrix>;
template class BiCGStab<CRDoubleMatrix>;
template class BiCGStab<DenseDoubleMatrix>;

template class CG<CCDoubleMatrix>;
template class CG<CRDoubleMatrix>;
template class CG<DenseDoubleMatrix>;

template class GS<CCDoubleMatrix>;
template class GS<CRDoubleMatrix>;
template class GS<DenseDoubleMatrix>;

template class GMRES<CCDoubleMatrix>;
template class GMRES<CRDoubleMatrix>;
template class GMRES<DenseDoubleMatrix>;


}
