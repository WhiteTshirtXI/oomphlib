//LIC// ====================================================================
//LIC// This file forms part of oomph-lib, the object-oriented, 
//LIC// multi-physics finite-element library, available 
//LIC// at http://www.oomph-lib.org.
//LIC// 
//LIC//           Version 0.90. August 3, 2009.
//LIC// 
//LIC// Copyright (C) 2006-2009 Matthias Heil and Andrew Hazel
//LIC// 
//LIC// This library is free software; you can redistribute it and/or
//LIC// modify it under the terms of the GNU Lesser General Public
//LIC// License as published by the Free Software Foundation; either
//LIC// version 2.1 of the License, or (at your option) any later version.
//LIC// 
//LIC// This library is distributed in the hope that it will be useful,
//LIC// but WITHOUT ANY WARRANTY; without even the implied warranty of
//LIC// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//LIC// Lesser General Public License for more details.
//LIC// 
//LIC// You should have received a copy of the GNU Lesser General Public
//LIC// License along with this library; if not, write to the Free Software
//LIC// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
//LIC// 02110-1301  USA.
//LIC// 
//LIC// The authors may be contacted at oomph-lib@maths.man.ac.uk.
//LIC// 
//LIC//====================================================================
// Common base class for all Triangle Meshes
#ifndef OOMPH_TRIMESH_HEADER
#define OOMPH_TRIMESH_HEADER

// Config header generated by autoconfig
#ifdef HAVE_CONFIG_H
  #include <oomph-lib-config.h>
#endif

//oomph-lib includes
#include "Vector.h"
#include "nodes.h"
#include "matrices.h"
#include "mesh.h"

namespace oomph
{

//=====================================================================
/// The Triangle data structure, modified from the triangle.h header
/// supplied with triangle 1.6. by J. R. Schewchuk. We need to define
/// this here separately because we can't include a c header directly
/// into C++ code!
//=====================================================================
struct TriangulateIO 
{
 ///Pointer to list of points x coordinate followed by y coordinate
 double *pointlist;

 ///Pointer to list of point attributes
 double *pointattributelist;

 ///Pointer to list of point markers
 int *pointmarkerlist;
 int numberofpoints;
 int numberofpointattributes;
 
 int *trianglelist;
 double *triangleattributelist;
 double *trianglearealist;
 int *neighborlist;
 int numberoftriangles;
 int numberofcorners;
 int numberoftriangleattributes;
 
 int *segmentlist;
 int *segmentmarkerlist;
 int numberofsegments;
 
 double *holelist;
 int numberofholes;
 
 double *regionlist;
 int numberofregions;
 
 int *edgelist;
 int *edgemarkerlist;  // <---- contains boundary ID (offset by one)
 double *normlist;
 int numberofedges;

};








///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////


//==================================================================
/// Helper namespace for triangle meshes
//==================================================================
namespace TriangleHelper
{
 /// Clear TriangulateIO structure
 extern void clear_triangulateio(TriangulateIO& triangulate_io,
                                 const bool& clear_hole_data=true);

 /// Initialise TriangulateIO structure
 extern void initialise_triangulateio(TriangulateIO& triangle_io);

 /// \short Make (partial) deep copy of TriangulateIO object. We only copy
 /// those items we need within oomph-lib's adaptation procedures.
 /// Warnings are issued if triangulate_io contains data that is not
 /// not copied, unless quiet=true;
 extern TriangulateIO deep_copy_of_triangulateio_representation(
  TriangulateIO& triangle_io, const bool& quiet=false);

 /// \short Write the triangulateio data to disk as a poly file,
 /// mainly used for debugging
 extern void write_triangulateio_to_polyfile(TriangulateIO &triangle_io,
                                             std::ostream &poly_file);


 /// \short Create a triangulateio data file from ele node and poly
 /// files.
 extern void create_triangulateio_from_polyfiles(
  const std::string& node_file_name,
  const std::string& element_file_name,
  const std::string& poly_file_name, TriangulateIO &triangle_io);
  

 /// \short Dump the triangulatio data into a dump file
 extern void dump_triangulateio(TriangulateIO &triangle_io,
                                std::ostream &dump_file);

 /// \short Read the triangulateio data from a dump file
 extern void read_triangulateio(std::istream &dump_fil,
                                TriangulateIO &triangulate_io);
}


////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////



//=====================================================================
/// Class defining a polyline for use in Triangle Mesh generation
//=====================================================================
class TriangleMeshPolyLine
{
 
public:
 
 /// \short Constructor: Takes vectors of vertex coordinates in order
 /// Also allows the optional specification of a boundary ID -- useful
 /// in a mesh generation context. If not specified it defaults to zero.
 /// Note: boundary id is stored with a -1 because of the different
 /// enumeration between oomph_lib mesh and triangulateio object
 TriangleMeshPolyLine(const Vector<Vector<double> >& vertex_coordinate,
                      const unsigned &boundary_id=0) :
  Vertex_coordinate(vertex_coordinate), Boundary_id(boundary_id-1)
  {
#ifdef PARANOID
   unsigned nvert=Vertex_coordinate.size();
   for (unsigned i=0;i<nvert;i++)
    {
     if (Vertex_coordinate[i].size()!=2)
      {
       std::ostringstream error_stream;
       error_stream 
        << "TriangleMeshPolyLine should only be used in 2D!\n"
        << "Your Vector of coordinates, contains data for " 
        << Vertex_coordinate[i].size() 
        << "-dimensional coordinates." << std::endl;
       throw OomphLibError(error_stream.str(),
                           "TriangleMeshPolyLine::TriangleMeshPolyLine()",
                           OOMPH_EXCEPTION_LOCATION);
      }
    }
#endif   
  }
 

 /// Empty destructor
 ~TriangleMeshPolyLine() {}

 
 /// Number of vertices
 unsigned nvertex() const {return Vertex_coordinate.size();}
   
 /// Number of segments
 unsigned nsegment() const {return Vertex_coordinate.size()-1;}
  
 /// Boundary id
 unsigned boundary_id() const {return Boundary_id;}
  
 /// Coordinate vector of i-th vertex (const version)
 Vector<double> vertex_coordinate(const unsigned& i) const
  {
   return Vertex_coordinate[i];
  }   

 /// Coordinate vector of i-th vertex
 Vector<double>& vertex_coordinate(const unsigned& i)
  {
   return Vertex_coordinate[i];
  }
  
 /// Output the polyline -- close it if optional boolean flag is true
 void output(std::ostream &outfile, const bool& close_it=false)
  {
   outfile <<"ZONE T=\"TriangleMeshPolyLine with boundary ID" 
           << Boundary_id<<"\""<<std::endl;
   unsigned nvert=Vertex_coordinate.size();
   for(unsigned i=0;i<nvert;i++)
    {
     outfile << Vertex_coordinate[i][0] << " " 
             << Vertex_coordinate[i][1] << std::endl;
    }
   if (close_it)
    {
     outfile << Vertex_coordinate[0][0] << " " 
             << Vertex_coordinate[0][1] << std::endl;
    }
  }

private:
  
 /// Vector of Vector of vertex coordinates
 Vector<Vector<double> > Vertex_coordinate;
   
 /// Boundary ID
 unsigned Boundary_id;

};


/// \short Namespace that allows the specification of a tolerance 
/// between vertices at the ends of polylines that are supposed
/// to be at the same position.
namespace ToleranceForVertexMismatchInPolygons
{
 
 /// \short Acceptable discrepancy for mismatch in vertex coordinates.
 /// In paranoid mode, the code will die if the beginning/end of
 /// two adjacent polylines differ by more than that. If the
 /// discrepancy is smaller (but nonzero) one of the vertex coordinates
 /// get adjusted to match perfectly; without paranoia the vertex
 /// coordinates are taken as they come...
 extern double Tolerable_error;

}

///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////

//=====================================================================
/// Class defining a (closed!) polygon for the Triangle mesh generation
//=====================================================================
class TriangleMeshPolygon
{
  
public:
  
 /// \short Constructor: Specify vector of pointers to TriangleMeshPolyLines
 /// that define the boundary of the segments of the polygon.
 /// Each TriangleMeshPolyLine has its own boundary ID and can contain
 /// multiple (straight-line) segments. If there is just a single
 /// polyline, the first and last vertices should not coincide -- we 
 /// will close the polygon for you! However, if there multiple
 /// polylines their joint vertices must be specified in both
 /// polylines (since the polylines may be used in isolation). 
 TriangleMeshPolygon(const Vector<TriangleMeshPolyLine*>& 
                     boundary_polyline_pt);
   


 /// Empty virtual destructor
 virtual ~TriangleMeshPolygon() {}
 
 /// Number of constituent polylines
 unsigned npolyline() const {return Boundary_polyline_pt.size();}
  
 /// Coordinate of i-th constituent polyline
 TriangleMeshPolyLine* polyline_pt(const unsigned& i) const
  {
   return Boundary_polyline_pt[i];
  }
  
 /// Total number of segments
 unsigned nsegment()
  {
   unsigned npolyline=this->npolyline();
   unsigned nseg=0;
   for(unsigned j=0;j<npolyline;j++)
    {
     nseg += this->polyline_pt(j)->nsegment();      
    }  
   // If there's just one boundary poly line we have another segment
   // connecting the last vertex to the first one
   if(npolyline==1){nseg+=1;}

   return nseg;
  }
  
  
 /// Return vector of boundary ids of associated polylines
 Vector<unsigned> polygon_boundary_id()
  {     
   // Get the number of polylines
   unsigned nline=npolyline();
   Vector<unsigned> boundary_id(nline);
    
   // Loop over the polyline to get the id
   for(unsigned iline=0;iline<nline;iline++)
    {
     boundary_id[iline]=Boundary_polyline_pt[iline]->boundary_id();
    }
   return boundary_id;
  }
   

 /// Number of vertices
 unsigned nvertex()
  {
   unsigned n_polyline=this->npolyline();
   unsigned nvertices=0;
   for(unsigned j=0;j<n_polyline;j++)
    {
     // Storing the number of the vertices
     nvertices += this->polyline_pt(j)->nvertex()-1;
    }
   // If there's just one boundary. All the vertices should be counted   
   if(n_polyline==1)
    {
     nvertices+=1;
    }
   return nvertices;
  } 
  
 /// Pointer to i-th constituent polyline
 TriangleMeshPolyLine* &polyline_pt(const unsigned& i)
  {
   return Boundary_polyline_pt[i];
  }

  
 /// Output the constituent polylines
 void output(std::ostream &outfile)
  {
   unsigned nbound=Boundary_polyline_pt.size();
   bool close_it=false;
   if (nbound==1) close_it=true;
   for(unsigned j=0;j<nbound;j++)
    {
     Boundary_polyline_pt[j]->output(outfile,close_it);
    }
  }

protected:
   
 /// Vector of pointers to constituent polylines
 Vector<TriangleMeshPolyLine*> Boundary_polyline_pt;
   
};




//=====================================================================
/// Class upgrading a TriangleMeshPolygon to a "hole" for use during 
/// triangle mesh generation. For mesh generation purposes, the main (and only)
/// addition to the base class is the provision of the coordinates
/// of a hole inside the polygon. 
//=====================================================================
class TriangleMeshHolePolygon : public TriangleMeshPolygon
{
 
public:
 
 /// \short Constructor: Specify coordinates of a point inside the hole
 /// and a vector of pointers to TriangleMeshPolyLines
 /// that define the boundary segments of the polygon.
 /// Each TriangleMeshPolyLine has its own boundary ID and can contain
 /// multiple (straight-line) segments.
 TriangleMeshHolePolygon(const Vector<double>& hole_centre,
                         const Vector<TriangleMeshPolyLine*>& 
                         boundary_polyline_pt) :
  TriangleMeshPolygon(boundary_polyline_pt), Hole_coordinate(hole_centre)
  {
  
  }
 
 /// \short Empty Destuctor
 virtual ~TriangleMeshHolePolygon() { }
 
 // hierher provide lambda squared and use it
 
 /// Coordinate of the point located in the hole 
 Vector<double> hole_coordinate() const
  {
   return Hole_coordinate;
  }
   
 /// Coordinate of the point located in the hole 
 Vector<double> &hole_coordinate() 
  {
   return Hole_coordinate;
  }

  private:
 
 /// Vector of vertex coordinates
 Vector<double> Hole_coordinate;

};


/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////


//================================================================
/// Base class for triangle meshes (meshes made of 2D triangle elements).
//================================================================
class TriangleMeshBase : public virtual Mesh
{

public:

 /// Constructor 
 TriangleMeshBase() 
  {
   //Initialise the TriangulateIO Data structure
   TriangleHelper::initialise_triangulateio(Triangulateio);
  }

 /// Broken copy constructor
 TriangleMeshBase(const TriangleMeshBase& node) 
  { 
   BrokenCopy::broken_copy("TriangleMeshBase");
  } 
 
 /// Broken assignment operator
 void operator=(const TriangleMeshBase&) 
  {
   BrokenCopy::broken_assign("TriangleMeshBase");
  }
 
 /// Destructor (empty)
 virtual ~TriangleMeshBase()
  {
   //Clear the triangulate data structure 
   TriangleHelper::clear_triangulateio(Triangulateio);
  }

 /// Setup lookup schemes which establish whic elements are located
 /// next to mesh's boundaries (wrapper to suppress doc).
 void setup_boundary_element_info()
  {
   std::ofstream outfile;
   setup_boundary_element_info(outfile);
  }

 /// \short Setup lookup schemes which establish which elements are located
 /// next to mesh's boundaries. Doc in outfile (if it's open).
 void setup_boundary_element_info(std::ostream &outfile);

 /// Access to the triangulateio representation of the mesh
 TriangulateIO& triangulateio_representation() {return Triangulateio;}
 
 /// \short Helper function. Write a TriangulateIO object file with all the 
 /// triangulateio fields. String s is add to assign a different value for
 /// the input and/or output structure
 void write_triangulateio(TriangulateIO& triangulate_io, std::string& s);
 
 /// \short Helper function. Clean up the memory associated with the
 /// TriangulateIO object. This should really only be used to save
 /// memory in extremely tight situations.
 void clear_triangulateio()
  {TriangleHelper::clear_triangulateio(Triangulateio);}

 /// \short Dump the triangulateio structure to a dump file
 void dump_triangulateio(std::ostream &dump_file)
  {TriangleHelper::dump_triangulateio(Triangulateio,dump_file);}

 /// \short Regenerate the mesh from a dumped triangulateio file
 void remesh_from_triangulateio(std::istream &restart_file)
  {
   //Clear the existing triangulate io
   TriangleHelper::clear_triangulateio(Triangulateio);
   //Read the data into the file
   TriangleHelper::read_triangulateio(restart_file,Triangulateio);
   //Now remesh from the new data structure
   this->remesh_from_internal_triangulateio();
  }

 ///Virtual function that is used for specific remeshing from the triangulateio
 virtual void remesh_from_internal_triangulateio() 
  {
   std::ostringstream error_stream;
   error_stream << "Empty default remesh function called.\n";
   error_stream << "This should be overloaded in a specific TriangleMesh\n";
   throw OomphLibError(error_stream.str(),
                       "TriangleBaseMesh::remesh_from_triangulateio()",
                       OOMPH_EXCEPTION_LOCATION);
  }

  protected:

 ///\short TriangulateIO representation of the mesh
 TriangulateIO Triangulateio;
 
 
};




}

#endif

