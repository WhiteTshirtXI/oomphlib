//LIC// ====================================================================
//LIC// This file forms part of oomph-lib, the object-oriented, 
//LIC// multi-physics finite-element library, available 
//LIC// at http://www.oomph-lib.org.
//LIC// 
//LIC//           Version 0.90. August 3, 2009.
//LIC// 
//LIC// Copyright (C) 2006-2009 Matthias Heil and Andrew Hazel
//LIC// 
//LIC// This library is free software; you can redistribute it and/or
//LIC// modify it under the terms of the GNU Lesser General Public
//LIC// License as published by the Free Software Foundation; either
//LIC// version 2.1 of the License, or (at your option) any later version.
//LIC// 
//LIC// This library is distributed in the hope that it will be useful,
//LIC// but WITHOUT ANY WARRANTY; without even the implied warranty of
//LIC// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//LIC// Lesser General Public License for more details.
//LIC// 
//LIC// You should have received a copy of the GNU Lesser General Public
//LIC// License along with this library; if not, write to the Free Software
//LIC// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
//LIC// 02110-1301  USA.
//LIC// 
//LIC// The authors may be contacted at oomph-lib@maths.man.ac.uk.
//LIC// 
//LIC//====================================================================
// Common base class for all Triangle Meshes
#ifndef OOMPH_TRIMESH_HEADER
#define OOMPH_TRIMESH_HEADER

// Config header generated by autoconfig
#ifdef HAVE_CONFIG_H
  #include <oomph-lib-config.h>
#endif

//oomph-lib includes
#include "Vector.h"
#include "nodes.h"
#include "matrices.h"
#include "mesh.h"

namespace oomph
{
//=====================================================================
/// Class defining a polyline for use in Triangle Mesh generation
//=====================================================================
class TriangleMeshPolyLine
{
 
public:
 
 /// \short Constructor: Takes vectors of vertex coordinates in order
 /// Also allows the optional specification of a boundary ID -- useful
 /// in a mesh generation context. If not specified it defaults to zero.
 /// Note: boundary id is stored with a -1 because of the different
 /// enumeration between oomph_lib mesh and triangulateio object
 TriangleMeshPolyLine(const Vector<Vector<double> >& vertex_coordinate,
                      const unsigned &boundary_id=0) :
  Vertex_coordinate(vertex_coordinate), Boundary_id(boundary_id-1)
  {
#ifdef PARANOID
   unsigned nvert=Vertex_coordinate.size();
   for (unsigned i=0;i<nvert;i++)
    {
     if (Vertex_coordinate[i].size()!=2)
      {
       std::ostringstream error_stream;
       error_stream 
        << "TriangleMeshPolyLine should only be used in 2D!\n"
        << "Your Vector of coordinates, contains data for " 
        << Vertex_coordinate[i].size() 
        << "-dimensional coordinates." << std::endl;
       throw OomphLibError(error_stream.str(),
                           "TriangleMeshPolyLine::TriangleMeshPolyLine()",
                           OOMPH_EXCEPTION_LOCATION);
      }
    }
#endif   
  }
 

 /// Empty destructor
 ~TriangleMeshPolyLine() {}

 
 /// Number of vertices
 unsigned nvertex() const {return Vertex_coordinate.size();}
   
 /// Number of segments
 unsigned nsegment() const {return Vertex_coordinate.size()-1;}
  
 /// Boundary id
 unsigned boundary_id() const {return Boundary_id;}
  
 /// Coordinate vector of i-th vertex (const version)
 Vector<double> vertex_coordinate(const unsigned& i) const
  {
   return Vertex_coordinate[i];
  }   

 /// Coordinate vector of i-th vertex
 Vector<double>& vertex_coordinate(const unsigned& i)
  {
   return Vertex_coordinate[i];
  }
  
 /// Output the polyline -- close it if optional boolean flag is true
 void output(std::ostream &outfile, const bool& close_it=false)
  {
   outfile <<"ZONE T=\"TriangleMeshPolyLine with boundary ID" 
           << Boundary_id<<"\""<<std::endl;
   unsigned nvert=Vertex_coordinate.size();
   for(unsigned i=0;i<nvert;i++)
    {
     outfile << Vertex_coordinate[i][0] << " " 
             << Vertex_coordinate[i][1] << std::endl;
    }
   if (close_it)
    {
     outfile << Vertex_coordinate[0][0] << " " 
             << Vertex_coordinate[0][1] << std::endl;
    }
  }

private:
  
 /// Vector of Vector of vertex coordinates
 Vector<Vector<double> > Vertex_coordinate;
   
 /// Boundary ID
 unsigned Boundary_id;

};


/// \short Namespace that allows the specification of a tolerance 
/// between vertices at the ends of polylines that are supposed
/// to be at the same position.
namespace ToleranceForVertexMismatchInPolygons
{
 
 /// \short Acceptable discrepancy for mismatch in vertex coordinates.
 /// In paranoid mode, the code will die if the beginning/end of
 /// two adjacent polylines differ by more than that. If the
 /// discrepancy is smaller (but nonzero) one of the vertex coordinates
 /// get adjusted to match perfectly; without paranoia the vertex
 /// coordinates are taken as they come...
 extern double Tolerable_error;

}

///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////

//=====================================================================
/// Class defining a (closed!) polygon for the Triangle mesh generation
//=====================================================================
class TriangleMeshPolygon
{
  
public:
  
 /// \short Constructor: Specify vector of pointers to TriangleMeshPolyLines
 /// that define the boundary of the segments of the polygon.
 /// Each TriangleMeshPolyLine has its own boundary ID and can contain
 /// multiple (straight-line) segments. If there is just a single
 /// polyline, the first and last vertices should not coincide -- we 
 /// will close the polygon for you! However, if there multiple
 /// polylines their joint vertices must be specified in both
 /// polylines (since the polylines may be used in isolation). 
 TriangleMeshPolygon(const Vector<TriangleMeshPolyLine*>& 
                     boundary_polyline_pt);
   


 /// Empty virtual destructor
 virtual ~TriangleMeshPolygon() {}
 
 /// Number of constituent polylines
 unsigned npolyline() const {return Boundary_polyline_pt.size();}
  
 /// Coordinate of i-th constituent polyline
 TriangleMeshPolyLine* polyline_pt(const unsigned& i) const
  {
   return Boundary_polyline_pt[i];
  }
  
 /// Total number of segments
 unsigned nsegment()
  {
   unsigned npolyline=this->npolyline();
   unsigned nseg=0;
   for(unsigned j=0;j<npolyline;j++)
    {
     nseg += this->polyline_pt(j)->nsegment();      
    }  
   // If there's just one boundary poly line we have another segment
   // connecting the last vertex to the first one
   if(npolyline==1){nseg+=1;}

   return nseg;
  }
  
  
 /// Return vector of boundary ids of associated polylines
 Vector<unsigned> polygon_boundary_id()
  {     
   // Get the number of polylines
   unsigned nline=npolyline();
   Vector<unsigned> boundary_id(nline);
    
   // Loop over the polyline to get the id
   for(unsigned iline=0;iline<nline;iline++)
    {
     boundary_id[iline]=Boundary_polyline_pt[iline]->boundary_id();
    }
   return boundary_id;
  }
   

 /// Number of vertices
 unsigned nvertex()
  {
   unsigned n_polyline=this->npolyline();
   unsigned nvertices=0;
   for(unsigned j=0;j<n_polyline;j++)
    {
     // Storing the number of the vertices
     nvertices += this->polyline_pt(j)->nvertex()-1;
    }
   // If there's just one boundary. All the vertices should be counted   
   if(n_polyline==1)
    {
     nvertices+=1;
    }
   return nvertices;
  } 
  
 /// Pointer to i-th constituent polyline
 TriangleMeshPolyLine* &polyline_pt(const unsigned& i)
  {
   return Boundary_polyline_pt[i];
  }

  
 /// Output the constituent polylines
 void output(std::ostream &outfile)
  {
   unsigned nbound=Boundary_polyline_pt.size();
   bool close_it=false;
   if (nbound==1) close_it=true;
   for(unsigned j=0;j<nbound;j++)
    {
     Boundary_polyline_pt[j]->output(outfile,close_it);
    }
  }

protected:
   
 /// Vector of pointers to constituent polylines
 Vector<TriangleMeshPolyLine*> Boundary_polyline_pt;
   
};




//=====================================================================
/// Class upgrading a TriangleMeshPolygon to a "hole" for use during 
/// triangle mesh generation. For mesh generation purposes, the main (and only)
/// addition to the base class is the provision of the coordinates
/// of a hole inside the polygon. 
//=====================================================================
class TriangleMeshHolePolygon : public TriangleMeshPolygon
{
 
public:
 
 /// \short Constructor: Specify coordinates of a point inside the hole
 /// and a vector of pointers to TriangleMeshPolyLines
 /// that define the boundary segments of the polygon.
 /// Each TriangleMeshPolyLine has its own boundary ID and can contain
 /// multiple (straight-line) segments.
 TriangleMeshHolePolygon(const Vector<double>& hole_centre,
                         const Vector<TriangleMeshPolyLine*>& 
                         boundary_polyline_pt) :
  TriangleMeshPolygon(boundary_polyline_pt), Hole_coordinate(hole_centre)
  {
  
  }
 
 /// \short Empty Destuctor
 virtual ~TriangleMeshHolePolygon() { }
 
 // hierher provide lambda squared and use it
 
 /// Coordinate of the point located in the hole 
 Vector<double> hole_coordinate() const
  {
   return Hole_coordinate;
  }
   
 /// Coordinate of the point located in the hole 
 Vector<double> &hole_coordinate() 
  {
   return Hole_coordinate;
  }

  private:
 
 /// Vector of vertex coordinates
 Vector<double> Hole_coordinate;

};


/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////


//================================================================
/// Base class for triangle meshes (meshes made of 2D triangle elements).
//================================================================
class TriangleMeshBase : public virtual Mesh
{

public:

 /// Constructor (empty)
 TriangleMeshBase() {}

 /// Broken copy constructor
 TriangleMeshBase(const TriangleMeshBase& node) 
  { 
   BrokenCopy::broken_copy("TriangleMeshBase");
  } 
 
 /// Broken assignment operator
 void operator=(const TriangleMeshBase&) 
  {
   BrokenCopy::broken_assign("TriangleMeshBase");
  }
 
 /// Destructor (empty)
 virtual ~TriangleMeshBase(){}

 /// Setup lookup schemes which establish whic elements are located
 /// next to mesh's boundaries (wrapper to suppress doc).
 void setup_boundary_element_info()
  {
   std::ofstream outfile;
   setup_boundary_element_info(outfile);
  }

 /// \short Setup lookup schemes which establish which elements are located
 /// next to mesh's boundaries. Doc in outfile (if it's open).
 void setup_boundary_element_info(std::ostream &outfile);

};




}

#endif

