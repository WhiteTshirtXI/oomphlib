//LIC// ====================================================================
//LIC// This file forms part of oomph-lib, the object-oriented, 
//LIC// multi-physics finite-element library, available 
//LIC// at http://www.oomph-lib.org.
//LIC// 
//LIC//           Version 0.85. June 9, 2008.
//LIC// 
//LIC// Copyright (C) 2006-2008 Matthias Heil and Andrew Hazel
//LIC// 
//LIC// This library is free software; you can redistribute it and/or
//LIC// modify it under the terms of the GNU Lesser General Public
//LIC// License as published by the Free Software Foundation; either
//LIC// version 2.1 of the License, or (at your option) any later version.
//LIC// 
//LIC// This library is distributed in the hope that it will be useful,
//LIC// but WITHOUT ANY WARRANTY; without even the implied warranty of
//LIC// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//LIC// Lesser General Public License for more details.
//LIC// 
//LIC// You should have received a copy of the GNU Lesser General Public
//LIC// License along with this library; if not, write to the Free Software
//LIC// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
//LIC// 02110-1301  USA.
//LIC// 
//LIC// The authors may be contacted at oomph-lib@maths.man.ac.uk.
//LIC// 
//LIC//====================================================================
//Header file for multi-domain functions, including the class
//ElementWithExternalElement which stores pointers to external elements

//Include guards to prevent multiple inclusion of the header
#ifndef OOMPH_MULTI_DOMAIN_HEADER
#define OOMPH_MULTI_DOMAIN_HEADER

// Config header generated by autoconfig
#ifdef HAVE_CONFIG_H
#include <oomph-lib-config.h>
#endif

//Oomph-lib headers
#include "geom_objects.h"
#include "problem.h"
#include "shape.h"

#include "mesh.h"
#include "mesh_as_geometric_object.h"
#include "algebraic_elements.h"
#include "macro_element_node_update_element.h"
#include "Qelements.h"
#include "element_with_external_element.h"

namespace oomph
{
//======================================================================
// Namespace for "global" multi-domain functions
//======================================================================
namespace Multi_domain_functions
 {

  // List of all Vectors used by the external storage routines 
  
  /// \short Vector of (local) coordinates at integration points of
  /// elements on current processor
  extern Vector<double> Zetas;

  /// \short Vector of the dimension of the element on current processor
  extern Vector<unsigned> Zeta_dim;

  /// \short Vector to indicate which processor a coordinate is located on
  extern Vector<int> Found_zeta;

  /// \short Vector of any elements found locally by current processor
  extern Vector<FiniteElement*> Found_element;

  /// \short Vector of local coordinates within any elements found
  /// locally by current processor
  extern Vector<Vector<double> > Found_ss;

  /// \short Global vector which combines all Found_zeta vectors on
  /// every processor
  extern Vector<int> All_found_zeta;

  /// \short Vector to indicate (on another process) whether a
  /// located element should be newly created (2), already exists (1), or
  /// is not on the current process at all (0)
  extern Vector<unsigned> Located_element;

  /// \short Vector of the local coordinates for each entry in Located_element
  extern Vector<double> Located_coord;

  /// \short Vector of doubles to be sent from another processor
  extern Vector<double> Double_values;

  /// \short Vector of unsigneds to be sent from another processor
  extern Vector<unsigned> Unsigned_values;

  // Counters for arrays used in the external storage routines
  extern unsigned Count_double_values;
  extern unsigned Count_unsigned_values;
  extern unsigned Count_located_coord;
  extern unsigned Count_found_elements;
  extern unsigned Count_zeta_dim;
  extern unsigned Count_zetas;

  // The following Vector of Vectors (of size Nproc) store each required 
  // set of the above information from each process required to create 
  // external (halo) elements and nodes
  extern Vector<Vector<unsigned> > All_located_zetas;
  extern Vector<Vector<double> > All_located_coord;
  extern Vector<Vector<double> > All_double_values;
  extern Vector<Vector<unsigned> > All_unsigned_values;

  // These Vectors help to count through the above Vectors of Vectors
  extern Vector<unsigned> All_count_double_values;
  extern Vector<unsigned> All_count_located_coord;
  extern Vector<unsigned> All_count_unsigned_values;



  /// Default parameters for binning method to be passed to MeshAsGeomObject

  /// \short Bool to tell the MeshAsGeomObject to setup bins again
  /// (should only be used in conjunction with a change from default N*_bin;
  ///  the minimum and maximum of the Mesh can also be specified)
  extern bool Setup_bins_again;

  /// \short Number of bins along each dimension in binning method in
  /// set_external_storage(). Default value of 10.
  extern unsigned Nx_bin;
  extern unsigned Ny_bin;
  extern unsigned Nz_bin;

  /// \short Minimum and maximum coordinates for
  /// each dimension of the bin structure used in
  /// MeshAsGeomObject::locate_zeta(...). 
  /// No defaults; can be set by user if they know their mesh's coordinates
  /// (the MeshAsGeomObject calculates these values by default based
  ///  upon the mesh itself; see MeshAsGeomObject::get_max_and_min_coords(...))
  extern double X_min;
  extern double X_max;
  extern double Y_min;
  extern double Y_max;
  extern double Z_min;
  extern double Z_max;

  /// \short Percentage offset to add to each extreme of the bin structure.
  /// Default value of 0.05.
  extern double Percentage_offset;

  /// \short Boolean to indicate when to use the bulk element as the
  /// external element.  Defaults to false, you must have set up FaceElements
  /// properly first in order for it to work
  extern bool Use_bulk_element_as_external;

  /// \short Boolean to indicate whether to doc timings or not.
  extern bool Doc_timings;

  /// \short Boolean to indicate whether to output info during
  ///        set_external_storage routines
  extern bool Shut_up;

  /// Set the source element and source functions for the problem
  /// This is a two-mesh example where mesh_pt(0) and mesh_pt(1)
  /// occupy the same physical space and are populated by
  /// ELEMENT_0 and ELEMENT_1 respectively
  /// The interaction indices default to zero
  template<class ELEMENT_0,class ELEMENT_1,unsigned EL_0_DIM,unsigned EL_1_DIM>
   void set_sources(Problem* problem_pt, 
                    Mesh* const &first_mesh_pt, Mesh* const &second_mesh_pt, 
                    const unsigned& first_interaction=0, 
                    const unsigned& second_interaction=0);

  /// Helper function to set the external storage structures
  /// When this is called the ELEMENTs should be in the current mesh
  /// and the EXT_ELEMENTs should be in external_mesh_pt; the GEOM_OBJECT
  /// should be the objects that are used to make the MeshAsGeomObject
  /// (in some cases this will be the same as EXT_ELEMENT)
  /// The interaction index defaults to zero
  /// The final default argument is a face mesh created from the external
  /// mesh, which needs to be set in FSI problems
  template<class ELEMENT,class EXT_ELEMENT,class GEOM_OBJECT,
   unsigned EL_DIM_LAG,unsigned EL_DIM_EUL>
   void set_external_storage(Problem* problem_pt,
                             Mesh* const &mesh_pt,
                             Mesh* const &external_mesh_pt,
                             const unsigned& interaction_index=0,
                             Mesh* const &external_face_mesh_pt=0);

#ifdef OOMPH_HAS_MPI
  /// \short A helper function to remove duplicate data that 
  /// are created due to coincident nodes between external halo elements 
  /// on different processors
  void remove_duplicate_data(Mesh* const &mesh_pt);
#endif

  /// Helper function to add external data from source elements at each
  /// integration point of the specified mesh's elements
  void add_external_data_from_source_elements
   (Mesh* const &mesh_pt,const unsigned& interaction_index);

  /// Helper function to broadcast local zeta coordinates from current process
  void broadcast_local_zeta(int& iproc, Mesh* const &mesh_pt);

  /// Helper function to perform "parallel" locate zeta on each process and
  /// return results in correct format to create external halo(ed) elements
  /// and nodes as necessary
  template<class GEOM_OBJECT,unsigned EL_DIM_LAG,unsigned EL_DIM_EUL>
   void simultaneous_locate_zeta(int& iproc,
                                 Mesh* const &external_mesh_pt,
                                 Problem* problem_pt,
                                 MeshAsGeomObject<EL_DIM_LAG,EL_DIM_EUL,
                                 GEOM_OBJECT >* &mesh_geom_obj_pt);

#ifdef OOMPH_HAS_MPI
  /// Helper function to prepare and send external haloed information from
  /// non-loop process to loop process to create external halo information
  void prepare_and_send_external_element_info(int& iproc,
                                              Mesh* const &external_mesh_pt,
                                              Problem* problem_pt);
#endif

  /// Helper function to create external (halo) elements on the loop process
  /// based on the information received from each locate_zeta call on others
  template<class ELEMENT,class EXT_ELEMENT,class GEOM_OBJECT,
   unsigned EL_DIM_LAG,unsigned EL_DIM_EUL>
   void create_external_elements(int& iproc, Mesh* const &mesh_pt,
                                 Mesh* const &external_mesh_pt,
                                 Problem* problem_pt,
                                 const unsigned& interaction_index);

#ifdef OOMPH_HAS_MPI
  // Helper functions for external haloed node identification

  // Helper function to add external haloed nodes, including any masters
  void add_external_haloed_node_to_storage(int& iproc, Node* nod_pt,
                                           Problem* problem_pt,
                                           Mesh* const &external_mesh_pt,
                                           int& n_cont_inter_values,
                                           FiniteElement* f_el_pt);

  // Helper function to add external haloed node that is not a master
  void add_external_haloed_node_helper(int& iproc, Node* nod_pt,
                                       Problem* problem_pt,
                                       Mesh* const &external_mesh_pt,
                                       int& n_cont_inter_values,
                                       FiniteElement* f_el_pt);

  // Helper function to add external haloed node that is a master
  void add_external_haloed_master_node_helper(int& iproc,Node* master_nod_pt,
                                              Node* nod_pt,Problem* problem_pt,
                                              Mesh* const &external_mesh_pt,
                                              int& n_cont_inter_values);

  /// Helper function to get the required nodal information from an
  /// external haloed node so that a fully-functional external halo
  /// node (and therefore element) can be created on the receiving process
  void get_required_nodal_information_helper(int& iproc, Node* nod_pt,
                                             Problem* problem_pt,
                                             Mesh* const &external_mesh_pt,
                                             int& n_cont_inter_values,
                                             FiniteElement* f_el_pt);

  /// Helper function to get the required master nodal information from an
  /// external haloed master node so that a fully-functional external halo
  /// master node (and possible element) can be created on the receiving proc
  void get_required_master_nodal_information_helper
   (int& iproc, Node* master_nod_pt, Node* nod_pt, Problem* problem_pt,
    Mesh* const &external_mesh_pt, int& n_cont_inter_values);

  /// The following are the equivalent helper functions for external halo nodes

  /// Helper function to add external halo nodes, including any masters,
  /// based on information received from the haloed process
  template<class EXT_ELEMENT>
   void add_external_halo_node_to_storage(Node* &new_nod_pt,
                                          Mesh* const &external_mesh_pt,
                                          unsigned& loc_p,
                                          unsigned& node_index,
                                          EXT_ELEMENT* new_el_pt,
                                          int& n_cont_inter_values,
                                          Problem* problem_pt);

  /// Helper function to add external halo node that is not a master
  template<class EXT_ELEMENT>
   void add_external_halo_node_helper(Node* &new_nod_pt,
                                      Mesh* const &external_mesh_pt,
                                      unsigned& loc_p,
                                      unsigned& node_index,
                                      EXT_ELEMENT* new_el_pt,
                                      int& n_cont_inter_values,
                                      Problem* problem_pt);

  /// Helper function to add external halo node that is a master
  template<class EXT_ELEMENT>
   void add_external_halo_master_node_helper(Node* &new_master_nod_pt,
                                             Node* &new_nod_pt,
                                             Mesh* const &external_mesh_pt,
                                             unsigned& loc_p,
                                             EXT_ELEMENT* new_el_pt,
                                             int& n_cont_inter_values,
                                             Problem* problem_pt);


  /// Helper function which constructs a new external halo node (on an element)
  /// with the required information sent from the haloed process
  template<class EXT_ELEMENT>
   void construct_new_external_halo_node_helper(Node* &new_nod_pt,
                                                unsigned& loc_p,
                                                unsigned& node_index,
                                                EXT_ELEMENT* new_el_pt,
                                                Mesh* const &external_mesh_pt,
                                                Problem* problem_pt);

  /// Helper function which constructs a new external halo master node
  /// with the required information sent from the haloed process
  template<class EXT_ELEMENT>
   void construct_new_external_halo_master_node_helper
   (Node* &new_master_nod_pt,Node* &nod_pt,unsigned& loc_p,
    EXT_ELEMENT* new_el_pt,Mesh* const &external_mesh_pt,Problem* problem_pt);

#endif

  /// Helper function that clears all the intermediate information used
  /// during the external storage creation at the end of the procedure
  void clean_up();

 }

//// Templated helper functions for multi-domain methods using locate_zeta

//========================================================================
/// Set the source element(s) for each element in each mesh
/// Each time this routine is called it needs to start from scratch
/// with new external halo(ed) elements and nodes, and add their data
/// as external data.
/// This is an example for a two-domain problem where the meshes occupy
/// the same physical space.
//========================================================================
 template<class ELEMENT_0,class ELEMENT_1,unsigned EL_0_DIM,unsigned EL_1_DIM>
  void Multi_domain_functions::set_sources(Problem* problem_pt,
                                           Mesh* const &first_mesh_pt,
                                           Mesh* const &second_mesh_pt,
                                           const unsigned& first_interaction,
                                           const unsigned& second_interaction)
  {
   // Flush all the current external halo(ed) element and node storage
   first_mesh_pt->flush_all_external_storage();

   // Call set_external_storage in both directions
   // (NB the GEOM_OBJECT and the EXT_ELEMENT should be the same in this case)
   set_external_storage<ELEMENT_0,ELEMENT_1,ELEMENT_1,EL_0_DIM,EL_1_DIM>
    (problem_pt,first_mesh_pt,second_mesh_pt,first_interaction);

   set_external_storage<ELEMENT_1,ELEMENT_0,ELEMENT_0,EL_1_DIM,EL_0_DIM>
    (problem_pt,second_mesh_pt,first_mesh_pt,second_interaction);

   // Check for and remove duplicate equation numbers between external halo
   // storage across different processors
   // NB this only needs to be called in parallel
#ifdef OOMPH_HAS_MPI
   if (MPI_Helpers::Nproc!=1)
    {
     oomph_info << "Duplicate removal, number of global equation numbers:"
                << problem_pt->assign_eqn_numbers(false) << std::endl;

     remove_duplicate_data(first_mesh_pt);
     remove_duplicate_data(second_mesh_pt);
    }
   else
    {
     if (!Shut_up)
      {
       oomph_info << "INFO: No need to remove duplicate equation numbers"
                  << " on a single-process run, continuing" << std::endl;
      }
    }
#endif
  }


//========================================================================
/// This routine calls the locate_zeta routine (simultaneously on each 
/// processor for each individual processor's element set if necessary)
/// and sets up the external (halo) element and node storage as
/// necessary.  The locate_zeta procedure here works for all multi-domain
/// problems where either two meshes occupy the same physical space but have
/// differing element types (e.g. a Boussinesq convection problem where
/// AdvectionDiffusion elements interact with Navier-Stokes type elements)
/// or two meshes interact along some boundary of the external mesh,
/// represented by a "face mesh", such as an FSI problem.
//========================================================================
 template<class ELEMENT,class EXT_ELEMENT,class GEOM_OBJECT,
  unsigned EL_DIM_LAG,unsigned EL_DIM_EUL>
  void Multi_domain_functions::set_external_storage
  (Problem* problem_pt, Mesh* const &mesh_pt, Mesh* const &external_mesh_pt,
   const unsigned& interaction_index, Mesh* const &external_face_mesh_pt)
  {
   double t_start=0.0;
   double t_end=0.0;
   double t_set=0.0;
   double t_locate=0.0;
   double t_create=0.0;

   if (Doc_timings) 
    {
     t_start=TimingHelpers::timer();
    }

#ifdef OOMPH_HAS_MPI
   // Print a warning for the case where the external mesh is solid and 
   // the problem has been distributed - this has not yet been tested
   if (problem_pt->problem_has_been_distributed())
    {
     SolidMesh* solid_mesh_pt=dynamic_cast<SolidMesh*>(external_mesh_pt);
     if (solid_mesh_pt!=0)
      {
       std::ostringstream warning_stream;
       warning_stream << "Multi-domain method has not been comprehensively "
                      << "tested for \n distributed problems where the "
                      << "external mesh is a SolidMesh." << std::endl;
       OomphLibWarning(
        warning_stream.str(),
        "Multi_domain_functions::set_external_storage(...)",
        OOMPH_EXCEPTION_LOCATION);
      }
    }
#endif

   // Geometric object used to represent the external (face) mesh
   MeshAsGeomObject<EL_DIM_LAG,EL_DIM_EUL,GEOM_OBJECT >* mesh_geom_obj_pt;

   // Are bulk elements used as external elements?
   if (!Use_bulk_element_as_external)
    {
     // Set the geometric object from the external mesh
     mesh_geom_obj_pt=new MeshAsGeomObject<EL_DIM_LAG,EL_DIM_EUL,GEOM_OBJECT >
      (external_mesh_pt);
    }
   else
    {
     // Set the geometric object from the external face mesh argument
     mesh_geom_obj_pt=new MeshAsGeomObject<EL_DIM_LAG,EL_DIM_EUL,GEOM_OBJECT >
      (external_face_mesh_pt);
    }

   if (Setup_bins_again)
    {
     // New values for number of bins in each direction
     mesh_geom_obj_pt->nx_bin()=Nx_bin;

     // New maxima and minima to be used in each direction
     mesh_geom_obj_pt->x_min()=X_min-Percentage_offset*(X_max-X_min);
     mesh_geom_obj_pt->x_max()=X_max+Percentage_offset*(X_max-X_min);
     if (EL_DIM_LAG>=2)
      {
       mesh_geom_obj_pt->ny_bin()=Ny_bin;
       mesh_geom_obj_pt->y_min()=Y_min-Percentage_offset*(Y_max-Y_min);
       mesh_geom_obj_pt->y_max()=Y_max+Percentage_offset*(Y_max-Y_min);
      }
     if (EL_DIM_LAG==3)
      {
       mesh_geom_obj_pt->nz_bin()=Nz_bin;
       mesh_geom_obj_pt->z_min()=Z_min-Percentage_offset*(Z_max-Z_min);;
       mesh_geom_obj_pt->z_max()=Z_max+Percentage_offset*(Z_max-Z_min);;
      }
     
     // (Re-)create the bin structure
     mesh_geom_obj_pt->create_bins_of_objects();

    }

   if (Doc_timings) 
    {
     t_set=TimingHelpers::timer();
     oomph_info << std::endl << "CPU for bin creation: "
                << t_set-t_start << std::endl;
    }

   // Loop over processes
   for (int iproc=0;iproc<MPI_Helpers::Nproc;iproc++)
    {
     // Broadcast the local zeta coordinates to all processors
     broadcast_local_zeta(iproc, mesh_pt);// zetas, zeta_dim, count_zeta_dim);

     // Simultaneously perform locate_zeta on each process (including local)
     simultaneous_locate_zeta<GEOM_OBJECT,EL_DIM_LAG,EL_DIM_EUL>
      (iproc, external_mesh_pt, problem_pt, mesh_geom_obj_pt);

     if (Doc_timings)
      {
       t_locate=TimingHelpers::timer();
       oomph_info << std::endl << "CPU for element location: "
                  << t_locate-t_set << std::endl;
      }

     // Prepare and send information from non-loop processes to the loop
     // process in order to create external (halo) elements.
     // This routine is only necessary in a parallel job.
#ifdef OOMPH_HAS_MPI
     prepare_and_send_external_element_info
      (iproc, external_mesh_pt, problem_pt);
#endif

     // Now create the external (halo) elements and nodes on the loop processor
     create_external_elements
      <ELEMENT,EXT_ELEMENT,GEOM_OBJECT,EL_DIM_LAG,EL_DIM_EUL>
      (iproc, mesh_pt, external_mesh_pt, problem_pt, interaction_index);

     if (Doc_timings)
      {
       t_create=TimingHelpers::timer();
       oomph_info << std::endl << "CPU for element creation: "
                  << t_create-t_locate << std::endl;
      }

    } // end loop over processes

   // Delete the geometric object representing the mesh
   delete mesh_geom_obj_pt;

   // Clean up all the (extern) Vectors associated with creating the
   // external storage information
   clean_up();

   // Doc timings if required
   if (Doc_timings)
    {
     t_end=TimingHelpers::timer();
     oomph_info << std::endl << "CPU for set_external_storage: "
                << t_end-t_start << std::endl;
    }

#ifdef OOMPH_HAS_MPI
   // Output information about external storage if required
   if (!Shut_up)
    {
     // How many external elements does the external mesh have now?
     oomph_info << "------------------------------------------" << std::endl;
     oomph_info << "External mesh: I have " << external_mesh_pt->nelement()
                << " elements, of which "
                << external_mesh_pt->nroot_halo_element()
                << " are root halo elements, and "
                << external_mesh_pt->nroot_haloed_element() 
                << " are root haloed elements, and there are " 
                << external_mesh_pt->nexternal_halo_element()
                << " external halo elements, "
                << external_mesh_pt->nexternal_haloed_element()
                << " external haloed elements, and "
                << external_mesh_pt->nexternal_element()
                << " external elements (on this process)." << std::endl;

     // How many external nodes does each submesh have now?
     oomph_info << "------------------------------------------" << std::endl;
     oomph_info << "External mesh: I have " << external_mesh_pt->nnode()
                << " nodes, of which " << external_mesh_pt->nhalo_node()
                << " are halo nodes, and "
                << external_mesh_pt->nhaloed_node() << " are haloed "
                << "nodes" << std::endl
                << "and there are " << external_mesh_pt->nexternal_halo_node()
                << " external halo nodes, "
                << external_mesh_pt->nexternal_haloed_node()
                << " external haloed nodes, and "
                << external_mesh_pt->nexternal_node()
                << " external nodes (already on this process)." << std::endl;

     // How many elements does this submesh have for each of the processors?
     for (int iproc=0;iproc<MPI_Helpers::Nproc;iproc++)
      {
       oomph_info << "----------------------------------------" << std::endl;
       oomph_info << "With process " << iproc << " there are "
                  << external_mesh_pt->nroot_halo_element(iproc)
                  << " root halo elements, and "
                  << external_mesh_pt->nroot_haloed_element(iproc)
                  << " root haloed elements" << std::endl
                  << "and there are "
                  << external_mesh_pt->nexternal_halo_element(iproc)
                  << " external halo elements, and "
                  << external_mesh_pt->nexternal_haloed_element(iproc)
                  << " external haloed elements." << std::endl;

       oomph_info << "----------------------------------------" << std::endl;
       oomph_info << "With process " << iproc << " there are "
                  << external_mesh_pt->nhalo_node(iproc)
                  << " halo nodes, and "
                  << external_mesh_pt->nhaloed_node(iproc)
                  << " haloed nodes" << std::endl
                  << "and there are "
                  << external_mesh_pt->nexternal_halo_node(iproc)
                  << " external halo nodes, and "
                  << external_mesh_pt->nexternal_haloed_node(iproc)
                  << " external haloed nodes." << std::endl;
      }
     oomph_info << "-----------------------------------------" << std::endl
                << std::endl;
    }
#endif

  } // end of set_external_storage



//======================================================================
/// Performs locate_zeta procedure simultaneously on all processors, 
/// on the coordinates (and dims) specified in zetas (zeta_dim) array.  
/// Returns information required to create external (haloed) elements 
/// and nodes as necessary for the problem.
//======================================================================
 template<class GEOM_OBJECT,unsigned EL_DIM_LAG,unsigned EL_DIM_EUL>
  void Multi_domain_functions::simultaneous_locate_zeta
  (int& iproc, Mesh* const &external_mesh_pt, Problem* problem_pt,
   MeshAsGeomObject<EL_DIM_LAG,EL_DIM_EUL,GEOM_OBJECT >* &mesh_geom_obj_pt)
  {
   // Set sizes...
   Found_zeta.resize(Count_zeta_dim);
   All_found_zeta.resize(Count_zeta_dim);
   Located_element.resize(Count_zeta_dim);

   // Resize to zero the Found_element, Found_ss (locals found by locate_zeta),
   // Double_values, Unsigned_values (doubles and unsigned to send),
   // and Located_coord (non-local coordinates found by locate zeta)
   Found_element.resize(0);
   Found_ss.resize(0);
   Double_values.resize(0);
   Unsigned_values.resize(0);
   Located_coord.resize(0);

   // Nil out the entries to kill any previous storage
   for (unsigned i=0;i<Count_zeta_dim;i++)
    {
     Located_element[i]=0;
     Found_zeta[i]=0;
    }

   // (Re)set counters
   unsigned Count_found_elements=0;
   unsigned Count_zetas=0;
   Count_double_values=0;
   Count_unsigned_values=0;
   Count_located_coord=0;

   // Now each process has the zeta array for the loop process
   for (unsigned i=0;i<Count_zeta_dim;i++)
    {
     // The global coordinates are in zetas,
     // dimensions of this array were sent in zeta_dim
     unsigned el_dim=Zeta_dim[i];
     Vector<double> x_global(el_dim);
     // Loop to fill in coordinates
     for (unsigned ii=0;ii<el_dim;ii++)
      {
       x_global[ii]=Zetas[Count_zetas];
       Count_zetas++;
      }

     // Perform locate_zeta for these coordinates
     // Note that every process should now go into this function
     // at the "same time" with the same x_global
     GeomObject *sub_geom_obj_pt;
     Vector<double> ss(el_dim);
     bool called_simultaneously=true;
     mesh_geom_obj_pt->locate_zeta(x_global,sub_geom_obj_pt,ss,
                                   called_simultaneously);

#ifdef OOMPH_HAS_MPI
     // Deal with the possibility that two (or more) processes succeed
     unsigned test_success;
     if (sub_geom_obj_pt!=0)
      {
       FiniteElement *source_el_pt;
       if (!Use_bulk_element_as_external)
        {
         source_el_pt=dynamic_cast<FiniteElement*>(sub_geom_obj_pt);
        }
       else
        {
         FaceElement *face_el_pt=dynamic_cast<FaceElement*>(sub_geom_obj_pt);
         source_el_pt=dynamic_cast<FiniteElement*>(face_el_pt->
                                                   bulk_element_pt());
        }
       if (!source_el_pt->is_halo())
        {
         test_success=1;
        }
       else
        {
         test_success=0;
        }
      }
     else
      {
       test_success=0;
      }

     unsigned total_successes;
     if (MPI_Helpers::Nproc>1)
      {
       MPI_Allreduce(&test_success,&total_successes,1,MPI_INT,MPI_SUM,
                     MPI_COMM_WORLD);
      }
     else
      {
       total_successes=test_success;
      }

     // If total_successes=0, we have a problem
     if (total_successes==0)
      {           
       // Throw an error
       std::ostringstream error_message;
       error_message << "Geometric object not located anywhere for coords: ";
       for(unsigned i=0;i<el_dim;i++)
        {
         error_message << x_global[i] << " ";
        }
       error_message << std::endl;
       throw OomphLibError(error_message.str(),
                          "Multi_domain_functions::simultaneous_locate_zeta()",
                           OOMPH_EXCEPTION_LOCATION);
      }
     // If total_successes>1 then we also have a problem,
     // but it can be dealt with!
     else if (total_successes>1)
      {
       // Create vector of size Nproc to indicate success or not
       Vector<unsigned> success(MPI_Helpers::Nproc,0);
       Vector<unsigned> all_success(MPI_Helpers::Nproc,0);

       // If true locally fill in that part of the vector
       if (test_success==1)
        {
         success[MPI_Helpers::My_rank]=test_success;
        }

       MPI_Allreduce(&success[0],&all_success[0],MPI_Helpers::Nproc,MPI_INT,
                     MPI_SUM,MPI_COMM_WORLD);

       // If the "local" entry (i.e. iproc) is non-zero, then
       // null out sub_geom_obj_pt everywhere else
       if (all_success[iproc]==1)
        {
         if (iproc!=MPI_Helpers::My_rank)
          {
           sub_geom_obj_pt=0;
          }
        }
       // Otherwise, find the first location in this vector which is
       // non-zero and null out sub_geom_obj_pt on every other process
       else
        {
         for (int dd=0;dd<MPI_Helpers::Nproc;dd++)
          {
           if (all_success[dd]==1)
            {
             // Null everything EXCEPT dd
             if (dd!=MPI_Helpers::My_rank)
              {
               sub_geom_obj_pt=0;
              }
             // Get out of the loop
             break;
            }
          }
        }

      }
#endif // end MPI check for more than one success in location

     // Now we have the correct sub_geom_obj_pt; if it is on current process,
     // then add to external_element storage; if not, package the information
     // required to send to the current process 
     if (iproc==MPI_Helpers::My_rank)
      {
       // Did locate_zeta work?
       if (sub_geom_obj_pt!=0)
        {
         // Use the bulk element attached to the element if required
         FiniteElement *source_el_pt;
         if (!Use_bulk_element_as_external)
          {
           source_el_pt=dynamic_cast<FiniteElement*>(sub_geom_obj_pt);
          }
         else
          {
           // Cast to a FaceElement first
           FaceElement *face_el_pt=dynamic_cast<FaceElement*>(sub_geom_obj_pt);
           // Use the bulk element attached to this FaceElement as the source
           source_el_pt=dynamic_cast<FiniteElement*>(face_el_pt->
                                                     bulk_element_pt());
          }

         // Check the resulting element's halo status
#ifdef OOMPH_HAS_MPI
         if (!source_el_pt->is_halo()) // Use this one
#endif
          {
           // Indicate which process this has been located on
           // (add 1 to distinguish first proc from 0, which indicates failure)
           Found_zeta[i]=iproc+1;
           // Store the source element and coordinates in vectors for later
           Found_element.push_back(source_el_pt);
           // If the source element is a bulk element then a translation of
           // coordinates is needed
           if (!Use_bulk_element_as_external)
            {
             Found_ss.push_back(ss);
            }
           else
            {
             // The translation is from Lagrangian to Eulerian
             Vector<double> s_trans(EL_DIM_EUL);
             FaceElement *face_el_pt=
              dynamic_cast<FaceElement*>(sub_geom_obj_pt);
             face_el_pt->get_local_coordinate_in_bulk(ss,s_trans);
             Found_ss.push_back(s_trans);
            }
           Count_found_elements++;
          }
#ifdef OOMPH_HAS_MPI
         else // Another process will find the non-halo version
          {
           Found_zeta[i]=0;
          }
#endif
        }
       else // locate_zeta did not work locally
        {
         Found_zeta[i]=0;
        }

      }
     else // not the loop process
      {
#ifdef OOMPH_HAS_MPI
       if (sub_geom_obj_pt!=0)
        {
         // We are on another process, and need to send information
         // to the loop process in order to create external halo
         // storage for elements and nodes; setup the vectors required
         // here (i.e. setup external haloed structure ready to be "sent")

         // Create the external haloed elements first
         FiniteElement *source_el_pt;

         // Is it an FSI problem or not?
         if (!Use_bulk_element_as_external)
          {
           source_el_pt=dynamic_cast<FiniteElement*>(sub_geom_obj_pt);
          }
         else // It is an FSI problem, so need to add the adjacent bulk mesh
          // element as the external haloed element
          {
           // Cast to a FaceElement first
           FaceElement *face_el_pt=dynamic_cast<FaceElement*>(sub_geom_obj_pt);
           // Use the bulk element attached to the FaceElement as the source
           source_el_pt=dynamic_cast<FiniteElement*>(face_el_pt->
                                                     bulk_element_pt());
          }

         // Check whether this geometric object is a halo element
         // If it is, then wait until we find the haloed equivalent
         if (!source_el_pt->is_halo())
          {
           Found_zeta[i]=MPI_Helpers::My_rank+1;
           // This source element is an external halo on process iproc...
           // ... but it should only be added to the storage if it hasn't
           // been added already, and this information also needs to be
           // communicated over to the other process
           unsigned n_extern_haloed=external_mesh_pt->
            nexternal_haloed_element(iproc);

           bool already_external_element=false;
           unsigned external_haloed_el_index;
           // Is this already set as an external haloed element?
           for (unsigned eh=0;eh<n_extern_haloed;eh++)
            {
             if (source_el_pt==external_mesh_pt->
                 external_haloed_element_pt(iproc,eh))
              {
               // It's already there, so...
               already_external_element=true;
               // ...set the index of this element
               external_haloed_el_index=eh;
               break;
              }
            }

           if (!already_external_element)
            {
             // Add as an external haloed element to the external mesh
             // i.e. the mesh in which zeta has been located
             external_mesh_pt->add_external_haloed_element_pt
              (iproc,source_el_pt);
             // Index of 2 indicates it should be newly created
             Located_element[i]=2;

             int n_cont_inter_values;
             if (dynamic_cast<RefineableElement*>(source_el_pt)!=0)
              {
               n_cont_inter_values=dynamic_cast<RefineableElement*>
                (source_el_pt)->ncont_interpolated_values();
              }
             else
              {
               n_cont_inter_values=-1;
              }

             // Since it is (externally) haloed from the current process,
             // the info required to create a new element in the equivalent
             // external halo layer on process iproc needs to be sent there

             // If we're using macro elements to update...
             MacroElementNodeUpdateMesh* macro_mesh_pt=
              dynamic_cast<MacroElementNodeUpdateMesh*>(external_mesh_pt);
             if (macro_mesh_pt!=0)
              {
               Unsigned_values.push_back(1);
               Count_unsigned_values++;

               MacroElement* macro_el_pt=source_el_pt->macro_elem_pt();
               // Send the macro element number across
               unsigned macro_el_num=macro_el_pt->macro_element_number();
               Unsigned_values.push_back(macro_el_num);
               Count_unsigned_values++;

               // we need to send
               // the lower left and upper right coordinates of the macro
               QElementBase* q_el_pt=dynamic_cast<QElementBase*>(source_el_pt);
               if (q_el_pt!=0)
                {
                 // The macro element needs to be set first before
                 // its lower left and upper right coordinates can be accessed
                 // Now send the lower left and upper right coordinates
                 unsigned el_dim=q_el_pt->dim();
                 for (unsigned i_dim=0;i_dim<el_dim;i_dim++)
                  {
                   Double_values.push_back(q_el_pt->s_macro_ll(i_dim));
                   Count_double_values++;
                   Double_values.push_back(q_el_pt->s_macro_ur(i_dim));
                   Count_double_values++;
                  }
                }
               else // Throw an error
                {
                 std::ostringstream error_stream;
                 error_stream << "You are using a MacroElement node update\n"
                              << "in a case with non-QElements. This has not\n"
                              << "yet been implemented.\n";
                 throw OomphLibError
                  (error_stream.str(),
                   "Multi_domain_functions::simultaneous_locate_zeta()",
                   OOMPH_EXCEPTION_LOCATION);
                }

              }
             else // Not using macro elements to update
              {
               Unsigned_values.push_back(0);
               Count_unsigned_values++;
              }

             // Loop over the nodes of the new source element
             unsigned n_node=source_el_pt->nnode();
             for (unsigned j=0;j<n_node;j++)
              {
               Node* nod_pt=source_el_pt->node_pt(j);

               // Add the node to the storage; this routine
               // also takes care of any master nodes if the
               // node is hanging
               add_external_haloed_node_to_storage(iproc,nod_pt,
                                                   problem_pt,
                                                   external_mesh_pt,
                                                   n_cont_inter_values,
                                                   source_el_pt);
              }

            }
           else // it has already been added, so tell the other process
            {
             // Index of 1 indicates an element has already been added
             Located_element[i]=1;
             Unsigned_values.push_back(external_haloed_el_index);
             Count_unsigned_values++;
            }

           // The coordinates returned by locate_zeta are also needed
           // in the setup of the source elements on the other process
           if (!Use_bulk_element_as_external)
            {
             for (unsigned i=0;i<el_dim;i++)
              {
               Located_coord.push_back(ss[i]);
               Count_located_coord++;
              }
            }
           else // translate the coordinates to the bulk element
            {
             // The translation is from Lagrangian to Eulerian
             Vector<double> s_trans(EL_DIM_EUL);
             FaceElement *face_el_pt=
              dynamic_cast<FaceElement*>(sub_geom_obj_pt);
             face_el_pt->get_local_coordinate_in_bulk(ss,s_trans);
             for (unsigned i=0;i<EL_DIM_EUL;i++)
              {
               Located_coord.push_back(s_trans[i]);
               Count_located_coord++;
              }
            }
          }
         else // It's a halo element, so another process will locate
          {
           Found_zeta[i]=0;
           Located_element[i]=0;
          }
        }
       else // It wasn't found on this process
        {
         Found_zeta[i]=0;
         Located_element[i]=0;
        }
#endif
      }

    } // end loop over zeta coordinates

//  std::cout << "simultaneous_locate_zeta complete" << std::endl << std::endl;

   // Do an MPI_Allreduce on the found_zeta array to pool the information
   // onto the current loop process
#ifdef OOMPH_HAS_MPI
   if (Count_zeta_dim!=0)
    {
     if (MPI_Helpers::Nproc>1)
      {
       MPI_Allreduce(&Found_zeta[0],&All_found_zeta[0],Count_zeta_dim,
                     MPI_INT,MPI_MAX,MPI_COMM_WORLD);
      }
     else
      {
       // Copy from Found_zeta to All_found_zeta which is used in
       // create_external_elements later on
       for (unsigned i=0;i<Count_zeta_dim;i++)
        {
         All_found_zeta[i]=Found_zeta[i];
        }
      }
    }
#else
   // Copy from Found_zeta to All_found_zeta which is used in
   // create_external_elements later on
   for (unsigned i=0;i<Count_zeta_dim;i++)
    {
     All_found_zeta[i]=Found_zeta[i];
    }
#endif


  }


//=====================================================================
/// Creates external (halo) elements on the loop process based on the
/// information received from each locate_zeta call on other processes
//=====================================================================
 template<class ELEMENT,class EXT_ELEMENT,class GEOM_OBJECT,
  unsigned EL_DIM_LAG,unsigned EL_DIM_EUL>
  void Multi_domain_functions::create_external_elements
  (int& iproc, Mesh* const &mesh_pt, Mesh* const &external_mesh_pt, 
   Problem* problem_pt, const unsigned& interaction_index)
  {
   // Reset counters to zero
   unsigned Count_zeta_dim=0;
   unsigned Count_found_elements=0;

   // Reset counters for all processors
#ifdef OOMPH_HAS_MPI
   for (int d=0;d<MPI_Helpers::Nproc;d++)
    {
     All_count_double_values[d]=0;
     All_count_located_coord[d]=0;
     All_count_unsigned_values[d]=0;
    }
#endif

   // Loop over the curret loop processor's elements and integration points 
   // again to set "other" (i.e. source and external halo(ed) elements),
   // either locally or from the communicated arrays
   if (iproc==MPI_Helpers::My_rank)
    {
     unsigned n_element=mesh_pt->nelement();
     for (unsigned e=0;e<n_element;e++)
      {
       // Need to dynamic_cast in order to use external_element_pt
       ELEMENT *el_pt=dynamic_cast<ELEMENT*>
        (mesh_pt->element_pt(e));
       // Only need to work on non-halo elements
#ifdef OOMPH_HAS_MPI
       if (!el_pt->is_halo())
#endif
        {

         //We need to allocate storage for the external elements
         //within the element. Memory will actually only be 
         //allocated the first time this function is called for 
         //each element, or if the number of interactions or integration
         //points within the element has changed.
         el_pt->initialise_external_element_storage();

         // Find number of Gauss points and element dimension
         unsigned n_intpt=el_pt->integral_pt()->nweight();

         // Loop over integration points
         for (unsigned ipt=0;ipt<n_intpt;ipt++)
          {
           // Test whether zeta was found locally; if not, then use sent
           // information
           if ((All_found_zeta[Count_zeta_dim]-1)==iproc)
            {
             FiniteElement *source_el_pt=
              Found_element[Count_found_elements];
             // The dimension of the local coordinates is the source
             // element's dimension
             unsigned el_dim=source_el_pt->dim();
             Vector<double> ss(el_dim);
             ss=Found_ss[Count_found_elements];
             Count_found_elements++;
             // Set this element as the source element
             el_pt->external_element_pt(interaction_index,ipt)=source_el_pt;
             el_pt->external_element_local_coord(interaction_index,ipt)=ss;

             // Has this been used as a source for this element already?
             bool source_already_used=false;
             for (unsigned jpt=0;jpt<ipt;jpt++)
              {
               if (source_el_pt==
                   el_pt->external_element_pt(interaction_index,jpt))
                {
                 source_already_used=true;
                }
              }
             if (!source_already_used)
              {
               // Add the element to the external element storage if
               // it's not already there
               FiniteElement* f_el_pt=
                dynamic_cast<FiniteElement*>(source_el_pt);
               bool already_external_element=false;
               unsigned n_ext_el=external_mesh_pt->nexternal_element();
               for (unsigned e_ext=0;e_ext<n_ext_el;e_ext++)
                {
                 if (f_el_pt==
                     external_mesh_pt->external_element_pt(e_ext))
                  {
                   already_external_element=true;
                   break;
                  }
                }
               if (!already_external_element)
                {
                 external_mesh_pt->add_external_element_pt(f_el_pt);
                 // Loop over the nodes of this external element
                 // and add (uniquely) as external nodes
                 unsigned n_node=f_el_pt->nnode();
                 for (unsigned j=0; j<n_node; j++)
                  {
                   Node* nod_pt=f_el_pt->node_pt(j);
                   bool node_is_external=false;
                   unsigned n_ext_nod=external_mesh_pt->nexternal_node();
                   for (unsigned j_ext=0;j_ext<n_ext_nod;j_ext++)
                    {
                     if (nod_pt==
                         external_mesh_pt->external_node_pt(j_ext))
                      {
                       node_is_external=true;
                       break;
                      }
                    }
                   if (!node_is_external)
                    {
                     external_mesh_pt->add_external_node_pt(nod_pt);

                     // Now do the same for any master nodes
                     if (dynamic_cast<RefineableElement*>(f_el_pt)!=0)
                      {
                       int n_cont=dynamic_cast<RefineableElement*>
                        (f_el_pt)->ncont_interpolated_values();
                       for (int i_cont=-1;i_cont<n_cont;i_cont++)
                        {
                         // Is this a hanging node in this variable?
                         if (nod_pt->is_hanging(i_cont))
                          {
                           HangInfo* hang_pt=nod_pt->
                            hanging_pt(i_cont);
                           // Loop over the master nodes
                           unsigned n_master=hang_pt->nmaster();
                           for (unsigned m=0; m<n_master; m++)
                            {
                             Node* master_nod_pt=
                              hang_pt->master_node_pt(m);
                             // Check if the node is already there
                             bool master_is_external=false;
                             unsigned n_ext_nod=external_mesh_pt->
                              nexternal_node();
                             for (unsigned j_ext=0;j_ext<n_ext_nod;
                                  j_ext++)
                              {
                               if (master_nod_pt==external_mesh_pt->
                                   external_node_pt(j_ext))
                                {
                                 master_is_external=true;
                                 break;
                                }
                              }
                             if (!master_is_external)
                              {
                               external_mesh_pt->
                                add_external_node_pt(master_nod_pt);
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
#ifdef OOMPH_HAS_MPI // Zeta should always be located locally in serial
           else // iproc!=(found_zeta[Count_zeta_dim]-1)
            {
             // Get the locating process
             unsigned loc_p=All_found_zeta[Count_zeta_dim]-1;

             // Access the Vector of Vectors that is indexed
             // first by locating process
             // ... was it located by process loc_p? (communicated)
             if (All_located_zetas[loc_p][Count_zeta_dim]>=1)
              {
               // Is it a new external halo element or not?
               // If so, then create it, populate it, and add it as a
               // source; if not, then find the right one which
               // has already been created and use it as the source
               // element: it is a new element if the value of 
               // located_zetas[Count_zeta_dim] matches the
               // counter, which is increased every time a new
               // external halo element is added
               EXT_ELEMENT *new_el_pt;
               // Index of 2 indicates new element required
               if (All_located_zetas[loc_p][Count_zeta_dim]==2)
                {
                 // Create a new element from the communicated values
                 // and coords from the process that located zeta
                 new_el_pt=new EXT_ELEMENT;

                 // Add it to the external halo element storage
                 // (Why is a dynamic_cast needed here??)
                 FiniteElement *f_el_pt=
                  dynamic_cast<FiniteElement*>(new_el_pt);
                 // Add external halo element to this mesh
                 external_mesh_pt->
                  add_external_halo_element_pt(loc_p,f_el_pt);

                 // We need the number of interpolated values if Refineable
                 int n_cont_inter_values;
                 if (dynamic_cast<RefineableElement*>(new_el_pt)!=0)
                  {
                   n_cont_inter_values=dynamic_cast<RefineableElement*>
                    (new_el_pt)->ncont_interpolated_values();
                  }
                 else
                  {
                   n_cont_inter_values=-1;
                  }

                 // If we're using macro elements to update,
                 if (All_unsigned_values[loc_p]
                     [All_count_unsigned_values[loc_p]]==1)
                  {
                   All_count_unsigned_values[loc_p]++;

                   // Set the macro element
                   MacroElementNodeUpdateMesh* macro_mesh_pt=
                    dynamic_cast<MacroElementNodeUpdateMesh*>
                    (external_mesh_pt);
                   unsigned macro_el_num=All_unsigned_values[loc_p]
                    [All_count_unsigned_values[loc_p]];
                   new_el_pt->set_macro_elem_pt
                    (macro_mesh_pt->macro_domain_pt()->
                     macro_element_pt(macro_el_num));
                   All_count_unsigned_values[loc_p]++;

                   // we need to receive
                   // the lower left and upper right coordinates of the macro
                   QElementBase* q_el_pt=
                    dynamic_cast<QElementBase*>(new_el_pt);
                   if (q_el_pt!=0)
                    {
                     unsigned el_dim=q_el_pt->dim();
                     for (unsigned i_dim=0;i_dim<el_dim;i_dim++)
                      {
                       q_el_pt->s_macro_ll(i_dim)=All_double_values[loc_p]
                        [All_count_double_values[loc_p]];
                       All_count_double_values[loc_p]++;
                       q_el_pt->s_macro_ur(i_dim)=All_double_values[loc_p]
                        [All_count_double_values[loc_p]];
                       All_count_double_values[loc_p]++;
                      }
                    }
                   else // Throw an error
                    {
                     std::ostringstream error_stream;
                     error_stream << "Using MacroElement node update\n"
                                  << "in a case with non-QElements\n"
                                  << "has not yet been implemented.\n";
                     throw OomphLibError
                      (error_stream.str(),
                       "Multi_domain_functions::create_external_elements()",
                       OOMPH_EXCEPTION_LOCATION);

                    }
                  }
                 else // No macro element
                  {
                   All_count_unsigned_values[loc_p]++;
                  }

                 unsigned n_node=new_el_pt->nnode();
                 for (unsigned j=0;j<n_node;j++)
                  {
                   Node* new_nod_pt=0;

                   // Call the add external halo node helper function
                   add_external_halo_node_to_storage<EXT_ELEMENT>
                    (new_nod_pt,external_mesh_pt,loc_p,j,new_el_pt,
                     n_cont_inter_values,problem_pt);
                  }
                }
               else // the element already exists as an external_halo
                // (the value in All_located_zetas[...] should be 1)
                {
                 // The index itself is in All_unsigned_values[...]
                 unsigned external_halo_el_index=
                  All_unsigned_values[loc_p][All_count_unsigned_values[loc_p]];
                 All_count_unsigned_values[loc_p]++;
                 // Use this index to get the element
                 FiniteElement *f_el_pt=external_mesh_pt->
                  external_halo_element_pt
                  (loc_p,external_halo_el_index);
                 // Cast to EXT_ELEMENT to use external_element_pt
                 new_el_pt=dynamic_cast<EXT_ELEMENT*>(f_el_pt);
                }
               // The source element storage was initialised but
               // not filled earlier, so do it now
               // The located coordinates are required
               // (which could be a different dimension to zeta, e.g. in FSI)
               unsigned el_dim=new_el_pt->dim();
               Vector<double> s_located(el_dim);
               for (unsigned i=0;i<el_dim;i++)
                {
                 s_located[i]=All_located_coord[loc_p]
                  [All_count_located_coord[loc_p]];
                 All_count_located_coord[loc_p]++;
                }
               // Set the element for this integration point
               el_pt->external_element_pt(interaction_index,ipt)=new_el_pt;
               el_pt->
                external_element_local_coord(interaction_index,ipt)=s_located;
              }
            } // end ifs to check whether zeta's located on this process
#endif // (OOMPH_HAS_MPI)
           Count_zeta_dim++;
          }
        }

      } // end loop over elements

    } // end if iproc==MPI_Helpers::My_rank

  }

#ifdef OOMPH_HAS_MPI

//============start of add_external_halo_node_to_storage===================
/// Helper function to add external halo nodes, including any masters,
/// based on information received from the haloed process
//=========================================================================
 template<class EXT_ELEMENT>
  void Multi_domain_functions::add_external_halo_node_to_storage
  (Node* &new_nod_pt, Mesh* const &external_mesh_pt, unsigned& loc_p,
   unsigned& node_index, EXT_ELEMENT* new_el_pt, int& n_cont_inter_values,
   Problem* problem_pt)
  {
   // Add the external halo node if required
   add_external_halo_node_helper<EXT_ELEMENT>
    (new_nod_pt,external_mesh_pt,loc_p,node_index,new_el_pt,
     n_cont_inter_values,problem_pt);

   for (int i_cont=-1;i_cont<n_cont_inter_values;i_cont++)
    {
     if (All_unsigned_values[loc_p][All_count_unsigned_values[loc_p]]==1)
      {
       All_count_unsigned_values[loc_p]++;
       unsigned n_master=All_unsigned_values[loc_p]
        [All_count_unsigned_values[loc_p]];
       All_count_unsigned_values[loc_p]++;
       // Setup new HangInfo
       HangInfo* hang_pt=new HangInfo(n_master);
       for (unsigned m=0;m<n_master;m++)
        {
         Node* master_nod_pt=0;
         // Get the master node (creating and adding it if required)
         add_external_halo_master_node_helper<EXT_ELEMENT>
          (master_nod_pt,new_nod_pt,external_mesh_pt,loc_p,new_el_pt,
           n_cont_inter_values,problem_pt);

         // Get the weight and set the HangInfo
         double master_weight=All_double_values[loc_p]
          [All_count_double_values[loc_p]];
         All_count_double_values[loc_p]++;
         hang_pt->set_master_node_pt(m,master_nod_pt,master_weight);
        }
       new_nod_pt->set_hanging_pt(hang_pt,i_cont);
      }
     else // Not a hanging node
      {
       All_count_unsigned_values[loc_p]++;
      }
    } // end loop over continous interpolated values

  }

//=======start of add_external_halo_node_helper===========================
/// Helper functiono to add external halo node that is not a master
//========================================================================
template<class EXT_ELEMENT>
 void Multi_domain_functions::add_external_halo_node_helper
  (Node* &new_nod_pt, Mesh* const &external_mesh_pt, unsigned& loc_p,
   unsigned& node_index, EXT_ELEMENT* new_el_pt, int& n_cont_inter_values,
   Problem* problem_pt)
 {
  // Given the node and the external mesh, and received information
  // about them from process loc_p, construct them on the current process
  if (All_unsigned_values[loc_p][All_count_unsigned_values[loc_p]]==1)
   {
    // Increment counter
    All_count_unsigned_values[loc_p]++;
    // Construct a new node based upon sent information
    construct_new_external_halo_node_helper<EXT_ELEMENT>
     (new_nod_pt,loc_p,node_index,new_el_pt,external_mesh_pt,problem_pt);
   }
  else
   {
    // Increment counter (node already exists)
    All_count_unsigned_values[loc_p]++;
    // Copy node from received location
    new_nod_pt=external_mesh_pt->external_halo_node_pt
     (loc_p,All_unsigned_values[loc_p][All_count_unsigned_values[loc_p]]);
    new_el_pt->node_pt(node_index)=new_nod_pt;
    // Increment counter
    All_count_unsigned_values[loc_p]++;
   }
 }

//========================================================================
/// Helper function to add external halo node that is a master
//========================================================================
template<class EXT_ELEMENT>
 void Multi_domain_functions::add_external_halo_master_node_helper
  (Node* &new_master_nod_pt, Node* &new_nod_pt, Mesh* const &external_mesh_pt,
   unsigned& loc_p, EXT_ELEMENT* new_el_pt, int& ncont_inter_values,
   Problem* problem_pt)
 {
  // Given the node and the external mesh, and received information
  // about them from process loc_p, construct them on the current process
  if (All_unsigned_values[loc_p][All_count_unsigned_values[loc_p]]==1)
   {
    // Increment counter
    All_count_unsigned_values[loc_p]++;
    // Construct a new node based upon sent information
    construct_new_external_halo_master_node_helper<EXT_ELEMENT>
     (new_master_nod_pt,new_nod_pt,loc_p,new_el_pt,
      external_mesh_pt,problem_pt);
   }
  else
   {
    // Increment counter (node already exists)
    All_count_unsigned_values[loc_p]++;
    // Copy node from received location
    new_master_nod_pt=external_mesh_pt->external_halo_node_pt
     (loc_p,All_unsigned_values[loc_p][All_count_unsigned_values[loc_p]]);
    // Increment counter
    All_count_unsigned_values[loc_p]++;
   }
 }


//========start of construct_new_external_halo_node_helper=================
/// Helper function which constructs a new external halo node (on new element)
/// with the required information sent from the haloed process
//========================================================================
template<class EXT_ELEMENT>
 void Multi_domain_functions::construct_new_external_halo_node_helper
 (Node* &new_nod_pt, unsigned& loc_p, unsigned& node_index,
  EXT_ELEMENT* new_el_pt, Mesh* const &external_mesh_pt, Problem* problem_pt)
 {
  // Null TimeStepper for now
  TimeStepper* time_stepper_pt=0;
  // Default number of previous values to 1
  unsigned n_prev=1;

  // The first entry in nodal_info indicates
  // if a timestepper is required for this halo node
  if (All_unsigned_values[loc_p]
      [All_count_unsigned_values[loc_p]]==1)
   {
    All_count_unsigned_values[loc_p]++;
    // Index
    time_stepper_pt=problem_pt->time_stepper_pt
     (All_unsigned_values[loc_p][All_count_unsigned_values[loc_p]]);
    All_count_unsigned_values[loc_p]++;
    // Check whether number of prev values is "sent" across
    n_prev+=time_stepper_pt->nprev_values();
   }
  else
   {
    // No timestepper, increment counter
    All_count_unsigned_values[loc_p]++;
   }

  // If this node was on a boundary then it needs to
  // be on the same boundary here
  if (All_unsigned_values[loc_p][All_count_unsigned_values[loc_p]]==1)
   {
    All_count_unsigned_values[loc_p]++;

    // Construct a new boundary node
    if (time_stepper_pt!=0)
     {
      new_nod_pt=new_el_pt->construct_boundary_node
       (node_index,time_stepper_pt);
     }
    else
     {
      new_nod_pt=new_el_pt->construct_boundary_node(node_index);
     }

    // How many boundaries on the external mesh?
    unsigned n_bnd=external_mesh_pt->nboundary();
    for (unsigned i_bnd=0;i_bnd<n_bnd;i_bnd++)
     {
      if (All_unsigned_values[loc_p]
          [All_count_unsigned_values[loc_p]]==1)
       {
        // Add to current boundary; increment counter
        external_mesh_pt->add_boundary_node(i_bnd,
                                            new_nod_pt);
        All_count_unsigned_values[loc_p]++;
       }
      else
       {
        // Not on this boundary; increment counter
        All_count_unsigned_values[loc_p]++;
       }
     }
   }
  else
   {
    // Not on boundary, increment counter
    All_count_unsigned_values[loc_p]++;

    // Construct an ordinary (non-boundary) node
    if (time_stepper_pt!=0)
     {
      new_nod_pt=new_el_pt->construct_node
       (node_index,time_stepper_pt);
     }
    else
     {
      new_nod_pt=new_el_pt->construct_node(node_index);
     }
   }

  // Node constructed: add to external halo nodes
  external_mesh_pt->add_external_halo_node_pt(loc_p,new_nod_pt);

  // Is the new constructed node Algebraic?
  AlgebraicNode* new_alg_nod_pt=dynamic_cast<AlgebraicNode*>
   (new_nod_pt);

  // If it is algebraic, its node update functions will
  // not yet have been set up properly
  if (new_alg_nod_pt!=0)
   {
    // The AlgebraicMesh is the external mesh
    AlgebraicMesh* alg_mesh_pt=dynamic_cast<AlgebraicMesh*>
     (external_mesh_pt);

    /// The first entry of All_alg_nodal_info contains
    /// the default node update id
    /// e.g. for the quarter circle there are 
    /// "Upper_left_box", "Lower right box" etc...
    unsigned update_id=All_unsigned_values[loc_p]
     [All_count_unsigned_values[loc_p]];
    All_count_unsigned_values[loc_p]++;

    Vector<double> ref_value;

    // The size of this vector is in the next entry
    // of All_alg_nodal_info
    unsigned n_ref_val=All_unsigned_values[loc_p]
     [All_count_unsigned_values[loc_p]];
    All_count_unsigned_values[loc_p]++;

    // The reference values themselves are in
    // All_alg_ref_value
    ref_value.resize(n_ref_val);
    for (unsigned i_ref=0;i_ref<n_ref_val;i_ref++)
     {
      ref_value[i_ref]=All_double_values[loc_p]
       [All_count_double_values[loc_p]];
      All_count_double_values[loc_p]++;
     }

    Vector<GeomObject*> geom_object_pt;
    /// again we need the size of this vector as it varies
    /// between meshes; we also need some indication
    /// as to which geometric object should be used...

    // The size of this vector is in the next entry
    // of All_alg_nodal_info
    unsigned n_geom_obj=All_unsigned_values[loc_p]
     [All_count_unsigned_values[loc_p]];
    All_count_unsigned_values[loc_p]++;

    // The remaining indices are in the rest of 
    // All_alg_nodal_info
    geom_object_pt.resize(n_geom_obj);
    for (unsigned i_geom=0;i_geom<n_geom_obj;i_geom++)
     {
      unsigned geom_index=All_unsigned_values[loc_p]
       [All_count_unsigned_values[loc_p]];
      All_count_unsigned_values[loc_p]++;
      // This index indicates which of the AlgebraicMesh's
      // stored geometric objects should be used
      // (0 is a null pointer; everything else should have
      //  been filled in by the specific Mesh).  If it
      // hasn't been filled in then the update_node_update
      // call should fix it
      geom_object_pt[i_geom]=alg_mesh_pt->
       geom_object_list_pt(geom_index);
     }

    /// For the received update_id, ref_value, geom_object
    /// call add_node_update_info
    new_alg_nod_pt->add_node_update_info
     (update_id,alg_mesh_pt,geom_object_pt,ref_value);

    /// Now call update_node_update
    alg_mesh_pt->update_node_update(new_alg_nod_pt);
   }

  // Is the node a MacroElementNodeUpdateNode?
  MacroElementNodeUpdateNode* macro_nod_pt=
   dynamic_cast<MacroElementNodeUpdateNode*>(new_nod_pt);

  if (macro_nod_pt!=0)
   {
    // Need to call set_node_update_info; this requires
    // a Vector<GeomObject*> (taken from the mesh)
    Vector<GeomObject*> geom_object_vector_pt;

    // Access the required geom objects from the
    // MacroElementNodeUpdateMesh
    MacroElementNodeUpdateMesh* macro_mesh_pt=
     dynamic_cast<MacroElementNodeUpdateMesh*>
     (external_mesh_pt);
    geom_object_vector_pt=
     macro_mesh_pt->geom_object_vector_pt();

    // Get local coordinate of node in new element
    Vector<double> s_in_macro_node_update_element;
    new_el_pt->local_coordinate_of_node
     (node_index,s_in_macro_node_update_element);

    // Set node update info for this node
    macro_nod_pt->set_node_update_info
     (new_el_pt,s_in_macro_node_update_element,
      geom_object_vector_pt);
   }

  // Is the new node a SolidNode?
  SolidNode* solid_nod_pt=dynamic_cast<SolidNode*>(new_nod_pt);
  if (solid_nod_pt!=0)
   {
    unsigned n_val=solid_nod_pt->variable_position_pt()->nvalue();
    for (unsigned i_val=0;i_val<n_val;i_val++)
     {
      for (unsigned t=0;t<n_prev;t++)
       {
        solid_nod_pt->variable_position_pt()->
         set_value(t,i_val,
                   All_double_values[loc_p][All_count_double_values[loc_p]]);
        All_count_double_values[loc_p]++;
       }
     }
   }

  // Get copied history values
  unsigned n_val=new_nod_pt->nvalue();
  for (unsigned i_val=0;i_val<n_val;i_val++)
   {
    for (unsigned t=0;t<n_prev;t++)
     {
      new_nod_pt->set_value(t,i_val,All_double_values[loc_p]
                            [All_count_double_values[loc_p]]);
      All_count_double_values[loc_p]++;
     }
   }

  // Get copied history values for positions
  unsigned n_dim=new_nod_pt->ndim();
  for (unsigned idim=0;idim<n_dim;idim++)
   {
    for (unsigned t=0;t<n_prev;t++)
     {
      // Copy to coordinate
      new_nod_pt->x(t,idim)=All_double_values[loc_p]
       [All_count_double_values[loc_p]];
      All_count_double_values[loc_p]++;
     }
   }

 }

//======start of construct_new_external_halo_master_node_helper===========
/// Helper function which constructs a new external halo master node
/// with the required information sent from the haloed process
//========================================================================
template<class EXT_ELEMENT>
 void Multi_domain_functions::construct_new_external_halo_master_node_helper
 (Node* &new_master_nod_pt, Node* &nod_pt, unsigned& loc_p,
  EXT_ELEMENT* new_el_pt, Mesh* const &external_mesh_pt, Problem* problem_pt)
 {
  // First three sent numbers are dimension, position type and nvalue
  // (to be used in Node constructors)
  unsigned n_dim=All_unsigned_values[loc_p][All_count_unsigned_values[loc_p]];
  All_count_unsigned_values[loc_p]++;
  unsigned n_position_type=All_unsigned_values[loc_p]
   [All_count_unsigned_values[loc_p]];
  All_count_unsigned_values[loc_p]++;
  unsigned n_value=All_unsigned_values[loc_p]
   [All_count_unsigned_values[loc_p]];
  All_count_unsigned_values[loc_p]++;
  

  // If it's a solid node also receive the lagrangian dimension and pos type
  SolidNode* solid_nod_pt=dynamic_cast<SolidNode*>(nod_pt);
  unsigned n_lag_dim;
  unsigned n_lag_type;
  if (solid_nod_pt!=0)
   {
    n_lag_dim=All_unsigned_values[loc_p][All_count_unsigned_values[loc_p]];
    All_count_unsigned_values[loc_p]++;
    n_lag_type=All_unsigned_values[loc_p][All_count_unsigned_values[loc_p]];
    All_count_unsigned_values[loc_p]++;
   }

  // Null TimeStepper for now
  TimeStepper* time_stepper_pt=0;
  // Default number of previous values to 1
  unsigned n_prev=1;

  // The first entry in nodal_info indicates
  // the timestepper required for this halo node
  if (All_unsigned_values[loc_p]
      [All_count_unsigned_values[loc_p]]==1)
   {
    All_count_unsigned_values[loc_p]++;
    // Index minus one!
    time_stepper_pt=problem_pt->time_stepper_pt
     (All_unsigned_values[loc_p][All_count_unsigned_values[loc_p]]);
    All_count_unsigned_values[loc_p]++;
    // Check whether number of prev values is "sent" across
    n_prev+=time_stepper_pt->nprev_values();
   }
  else
   {
    All_count_unsigned_values[loc_p]++;
   }

  // Is the node for which the master is required Algebraic, Macro or Solid?
  AlgebraicNode* alg_nod_pt=dynamic_cast<AlgebraicNode*>(nod_pt);
  MacroElementNodeUpdateNode* macro_nod_pt=
   dynamic_cast<MacroElementNodeUpdateNode*>(nod_pt);

  // What type of node was the node for which we are constructing a master?
  if (alg_nod_pt!=0)
   {
    // The master node should also be algebraic

    // If this master node's haloed copy is on a boundary then 
    // it needs to be on the same boundary here
    if (All_unsigned_values[loc_p][All_count_unsigned_values[loc_p]]==1)
     {
      All_count_unsigned_values[loc_p]++;
      // Create a new BoundaryNode (not attached to an element)
      if (time_stepper_pt!=0)
       {
        new_master_nod_pt = new BoundaryNode<AlgebraicNode>
         (time_stepper_pt,n_dim,n_position_type,n_value);
       }
      else
       {
        new_master_nod_pt = new BoundaryNode<AlgebraicNode>
         (n_dim,n_position_type,n_value);
       }
      // How many boundaries on the external mesh?
      unsigned n_bnd=external_mesh_pt->nboundary();
      for (unsigned i_bnd=0;i_bnd<n_bnd;i_bnd++)
       {
        if (All_unsigned_values[loc_p][All_count_unsigned_values[loc_p]]==1)
         {
          // Add to current boundary; increment counter
          external_mesh_pt->add_boundary_node(i_bnd,new_master_nod_pt);
          All_count_unsigned_values[loc_p]++;
         }
        else
         {
          // Not on this boundary; incremenet counter
          All_count_unsigned_values[loc_p]++;
         }
       }
     }
    else
     {
      // Not on any boundary, incremenet counter
      All_count_unsigned_values[loc_p]++;

      // Create node (not attached to any element)
      if (time_stepper_pt!=0)
       {
        new_master_nod_pt = new AlgebraicNode
         (time_stepper_pt,n_dim,n_position_type,n_value);
       }
      else
       {
        new_master_nod_pt = new AlgebraicNode
         (n_dim,n_position_type,n_value);
       }
     }

    // Add this as an external halo node BEFORE considering node update!
    external_mesh_pt->add_external_halo_node_pt(loc_p,new_master_nod_pt);

    // The external mesh is itself Algebraic...
    AlgebraicMesh* alg_mesh_pt=dynamic_cast<AlgebraicMesh*>
     (external_mesh_pt);

    /// The first entry of All_unsigned_values is the default node update id
    unsigned update_id=All_unsigned_values[loc_p]
     [All_count_unsigned_values[loc_p]];
    All_count_unsigned_values[loc_p]++;

    // Setup algebraic node update info for this new node
    Vector<double> ref_value;

    // The size of this vector is in the next entry
    unsigned n_ref_val=All_unsigned_values[loc_p]
     [All_count_unsigned_values[loc_p]];
    All_count_unsigned_values[loc_p]++;

    // The reference values are in the subsequent entries of All_double_values
    ref_value.resize(n_ref_val);
    for (unsigned i_ref=0;i_ref<n_ref_val;i_ref++)
     {
      ref_value[i_ref]=All_double_values[loc_p]
       [All_count_double_values[loc_p]];
      All_count_double_values[loc_p]++;
     }

    // Also require a Vector of geometric objects
    Vector<GeomObject*> geom_object_pt;

    // The size of this vector is in the next entry of All_unsigned_values
    unsigned n_geom_obj=All_unsigned_values[loc_p]
     [All_count_unsigned_values[loc_p]];
    All_count_unsigned_values[loc_p]++;

    // The remaining indices are in the rest of 
    // All_alg_nodal_info
    geom_object_pt.resize(n_geom_obj);
    for (unsigned i_geom=0;i_geom<n_geom_obj;i_geom++)
     {
      unsigned geom_index=All_unsigned_values[loc_p]
       [All_count_unsigned_values[loc_p]];
      All_count_unsigned_values[loc_p]++;
      // This index indicates which (if any) of the AlgebraicMesh's
      // stored geometric objects should be used
      geom_object_pt[i_geom]=alg_mesh_pt->geom_object_list_pt(geom_index);
     }

    AlgebraicNode* alg_master_nod_pt=
     dynamic_cast<AlgebraicNode*>(new_master_nod_pt);

    /// ... so for the specified update_id, call
    /// add_node_update_info
    alg_master_nod_pt->add_node_update_info
     (update_id,alg_mesh_pt,geom_object_pt,ref_value);

    /// Now call update_node_update
    alg_mesh_pt->update_node_update(alg_master_nod_pt);
   }
  else if (macro_nod_pt!=0)
   {
    // The master node should also be a macro node
    // If this master node's haloed copy is on a boundary then 
    // it needs to be on the same boundary here
    if (All_unsigned_values[loc_p][All_count_unsigned_values[loc_p]]==1)
     {
      All_count_unsigned_values[loc_p]++;
      // Create a new BoundaryNode (not attached to an element)
      if (time_stepper_pt!=0)
       {
        new_master_nod_pt = new BoundaryNode<MacroElementNodeUpdateNode>
         (time_stepper_pt,n_dim,n_position_type,n_value);
       }
      else
       {
        new_master_nod_pt = new BoundaryNode<MacroElementNodeUpdateNode>
         (n_dim,n_position_type,n_value);
       }
      // How many boundaries on the external mesh?
      unsigned n_bnd=external_mesh_pt->nboundary();
      for (unsigned i_bnd=0;i_bnd<n_bnd;i_bnd++)
       {
        if (All_unsigned_values[loc_p][All_count_unsigned_values[loc_p]]==1)
         {
          // Add to current boundary; increment counter
          external_mesh_pt->add_boundary_node(i_bnd,new_master_nod_pt);
          All_count_unsigned_values[loc_p]++;
         }
        else
         {
          // Not on this boundary; incremenet counter
          All_count_unsigned_values[loc_p]++;
         }
       }
     }
    else
     {
      // Not on boundary, incremenet counter
      All_count_unsigned_values[loc_p]++;

      // Create node (not attached to any element)
      if (time_stepper_pt!=0)
       {
        new_master_nod_pt = new MacroElementNodeUpdateNode
         (time_stepper_pt,n_dim,n_position_type,n_value);
       }
      else
       {
        new_master_nod_pt = new MacroElementNodeUpdateNode
         (n_dim,n_position_type,n_value);
       }
     }

    // Add this as an external halo node BEFORE considering node update!
    external_mesh_pt->add_external_halo_node_pt(loc_p,new_master_nod_pt);

    // Create a new node update element for this master node if required
    EXT_ELEMENT *new_node_update_el_pt;
    if (All_unsigned_values[loc_p][All_count_unsigned_values[loc_p]]==1)
     {
      All_count_unsigned_values[loc_p]++;
      new_node_update_el_pt=new EXT_ELEMENT;

      FiniteElement *f_el_pt=
       dynamic_cast<FiniteElement*>(new_node_update_el_pt);
      external_mesh_pt->add_external_halo_element_pt(loc_p,f_el_pt);

      // Need number of interpolated values if Refineable
      int n_cont_inter_values;
      if (dynamic_cast<RefineableElement*>(new_node_update_el_pt)!=0)
       {
        n_cont_inter_values=dynamic_cast<RefineableElement*>
         (new_node_update_el_pt)->ncont_interpolated_values();
       }
      else
       {
        n_cont_inter_values=-1;
       }

      // If we're using macro elements to update,
      if (All_unsigned_values[loc_p][All_count_unsigned_values[loc_p]]==1)
       {
        All_count_unsigned_values[loc_p]++;

        // Set the macro element
        MacroElementNodeUpdateMesh* macro_mesh_pt=
         dynamic_cast<MacroElementNodeUpdateMesh*>
         (external_mesh_pt);
        unsigned macro_el_num=
         All_unsigned_values[loc_p][All_count_unsigned_values[loc_p]];
        new_node_update_el_pt->set_macro_elem_pt
         (macro_mesh_pt->macro_domain_pt()->macro_element_pt(macro_el_num));
        All_count_unsigned_values[loc_p]++;

        // we need to receive
        // the lower left and upper right coordinates of the macro
        QElementBase* q_el_pt=
         dynamic_cast<QElementBase*>(new_node_update_el_pt);
        if (q_el_pt!=0)
         {
          unsigned el_dim=q_el_pt->dim();
          for (unsigned i_dim=0;i_dim<el_dim;i_dim++)
           {
            q_el_pt->s_macro_ll(i_dim)=All_double_values[loc_p]
             [All_count_double_values[loc_p]];
            All_count_double_values[loc_p]++;
            q_el_pt->s_macro_ur(i_dim)=All_double_values[loc_p]
             [All_count_double_values[loc_p]];
            All_count_double_values[loc_p]++;
           }
         }
        else // Throw an error
         {
          std::ostringstream error_stream;
          error_stream << "You are using a MacroElement node update\n"
                       << "in a case with non-QElements. This has not\n"
                       << "yet been implemented.\n";
          throw OomphLibError
           (error_stream.str(),
            "Multi_domain_functions::construct_new_external_halo_master_...()",
            OOMPH_EXCEPTION_LOCATION);
         }
       }
      else // No macro element
       {
        All_count_unsigned_values[loc_p]++;
       }


      unsigned n_node=new_node_update_el_pt->nnode();
      for (unsigned j=0;j<n_node;j++)
       {
        Node* new_nod_pt=0;
        add_external_halo_node_to_storage<EXT_ELEMENT>
         (new_nod_pt,external_mesh_pt,loc_p,j,new_node_update_el_pt,
          n_cont_inter_values,problem_pt);
       }

     }
    else // The node update element exists already
     {
      All_count_unsigned_values[loc_p]++;
      new_node_update_el_pt=dynamic_cast<EXT_ELEMENT*>
       (external_mesh_pt->external_halo_element_pt
        (loc_p,All_unsigned_values[loc_p][All_count_unsigned_values[loc_p]]));
      All_count_unsigned_values[loc_p]++;
     }

    // Remaining required information to create functioning
    // MacroElementNodeUpdateNode...

    // Get the required geom objects for the node update
    // from the mesh
    Vector<GeomObject*> geom_object_vector_pt;
    MacroElementNodeUpdateMesh* macro_mesh_pt=
     dynamic_cast<MacroElementNodeUpdateMesh*>
     (external_mesh_pt);
    geom_object_vector_pt=macro_mesh_pt->geom_object_vector_pt();

    // Cast to MacroElementNodeUpdateNode
    MacroElementNodeUpdateNode* macro_master_nod_pt=
     dynamic_cast<MacroElementNodeUpdateNode*>(new_master_nod_pt);

    // Set all required information - node update element,
    // local coordinate in this element, and then set node update info
    macro_master_nod_pt->node_update_element_pt()=
     new_node_update_el_pt;

    // Need to get the local node index of the macro_master_nod_pt
    unsigned local_node_index;
    unsigned n_node=new_node_update_el_pt->nnode();
    for (unsigned j=0;j<n_node;j++)
     {
      if (macro_master_nod_pt==new_node_update_el_pt->node_pt(j))
       {
        local_node_index=j;
        break;
       }
     }

    Vector<double> s_in_macro_node_update_element;
    new_node_update_el_pt->local_coordinate_of_node
     (local_node_index,s_in_macro_node_update_element);

    macro_master_nod_pt->set_node_update_info
     (new_node_update_el_pt,s_in_macro_node_update_element,
      geom_object_vector_pt);
   }
  else if (solid_nod_pt!=0)
   {
    // The master node should also be a SolidNode
    // If this node was on a boundary then it needs to
    // be on the same boundary here
    if (All_unsigned_values[loc_p][All_count_unsigned_values[loc_p]]==1)
     {
      All_count_unsigned_values[loc_p]++;
      // Construct a new boundary node
      if (time_stepper_pt!=0)
       {
        new_master_nod_pt=new BoundaryNode<SolidNode>
         (time_stepper_pt,n_lag_dim,n_lag_type,n_dim,n_position_type,n_value);
       }
      else
       {
        new_master_nod_pt=new BoundaryNode<SolidNode>
         (n_lag_dim,n_lag_type,n_dim,n_position_type,n_value);
       }
      // How many boundaries on the external mesh?
      unsigned n_bnd=external_mesh_pt->nboundary();
      for (unsigned i_bnd=0;i_bnd<n_bnd;i_bnd++)
       {
        if (All_unsigned_values[loc_p][All_count_unsigned_values[loc_p]]==1)
         {
          // Add to current boundary; increment counter
          external_mesh_pt->add_boundary_node(i_bnd,
                                              new_master_nod_pt);
          All_count_unsigned_values[loc_p]++;
         }
        else
         {
          // Not on this boundary; increment counter
          All_count_unsigned_values[loc_p]++;
         }
       }
     }
    else
     {
      // Not on boundary, increment counter
      All_count_unsigned_values[loc_p]++;
      // Construct an ordinary (non-boundary) node
      if (time_stepper_pt!=0)
       {
        new_master_nod_pt=new SolidNode
         (time_stepper_pt,n_lag_dim,n_lag_type,n_dim,n_position_type,n_value);
       }
      else
       {
        new_master_nod_pt=new SolidNode
         (n_lag_dim,n_lag_type,n_dim,n_position_type,n_value);
       }
     }

    // Add this as an external halo node
    external_mesh_pt->add_external_halo_node_pt(loc_p,new_master_nod_pt);

    // Copy across particular info required for SolidNode
    SolidNode* solid_master_nod_pt=dynamic_cast<SolidNode*>(new_master_nod_pt);
    unsigned n_val=solid_master_nod_pt->variable_position_pt()->nvalue();
    for (unsigned i_val=0;i_val<n_val;i_val++)
     {
      for (unsigned t=0;t<n_prev;t++)
       {
        solid_master_nod_pt->variable_position_pt()->
         set_value(t,i_val,
                   All_double_values[loc_p][All_count_double_values[loc_p]]);
       }
     }

   }
  else // Just an ordinary node!
   {
    // If this node was on a boundary then it needs to
    // be on the same boundary here
    if (All_unsigned_values[loc_p][All_count_unsigned_values[loc_p]]==1)
     {
      All_count_unsigned_values[loc_p]++;
      // Construct a new boundary node
      if (time_stepper_pt!=0)
       {
        new_master_nod_pt=new BoundaryNode<Node>
         (time_stepper_pt,n_dim,n_position_type,n_value);
       }
      else
       {
        new_master_nod_pt=new BoundaryNode<Node>
         (n_dim,n_position_type,n_value);
       }
      // How many boundaries on the external mesh?
      unsigned n_bnd=external_mesh_pt->nboundary();
      for (unsigned i_bnd=0;i_bnd<n_bnd;i_bnd++)
       {
        if (All_unsigned_values[loc_p][All_count_unsigned_values[loc_p]]==1)
         {
          // Add to current boundary; increment counter
          external_mesh_pt->add_boundary_node(i_bnd,
                                              new_master_nod_pt);
          All_count_unsigned_values[loc_p]++;
         }
        else
         {
          // Not on this boundary; increment counter
          All_count_unsigned_values[loc_p]++;
         }
       }
     }
    else
     {
      // Not on boundary, increment counter
      All_count_unsigned_values[loc_p]++;
      // Construct an ordinary (non-boundary) node
      if (time_stepper_pt!=0)
       {
        new_master_nod_pt=new Node
         (time_stepper_pt,n_dim,n_position_type,n_value);
       }
      else
       {
        new_master_nod_pt=new Node(n_dim,n_position_type,n_value);
       }
     }

    // Add this as an external halo node
    external_mesh_pt->add_external_halo_node_pt(loc_p,new_master_nod_pt);

   }

  // Remaining info received for all node types
  // Get copied history values
  unsigned n_val=new_master_nod_pt->nvalue();
  for (unsigned i_val=0;i_val<n_val;i_val++)
   {
    for (unsigned t=0;t<n_prev;t++)
     {
      new_master_nod_pt->set_value(t,i_val,All_double_values[loc_p]
                                   [All_count_double_values[loc_p]]);
      All_count_double_values[loc_p]++;
     }
   }

  // Get copied history values for positions
  unsigned n_nod_dim=new_master_nod_pt->ndim();
  for (unsigned idim=0;idim<n_nod_dim;idim++)
   {
    for (unsigned t=0;t<n_prev;t++)
     {
      // Copy to coordinate
      new_master_nod_pt->x(t,idim)=All_double_values[loc_p]
       [All_count_double_values[loc_p]];
      All_count_double_values[loc_p]++;
     }
   }

 }


#endif


}

#endif




 
