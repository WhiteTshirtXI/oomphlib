//LIC// ====================================================================
//LIC// This file forms part of oomph-lib, the object-oriented, 
//LIC// multi-physics finite-element library, available 
//LIC// at http://www.oomph-lib.org.
//LIC// 
//LIC//           Version 0.85. June 9, 2008.
//LIC// 
//LIC// Copyright (C) 2006-2008 Matthias Heil and Andrew Hazel
//LIC// 
//LIC// This library is free software; you can redistribute it and/or
//LIC// modify it under the terms of the GNU Lesser General Public
//LIC// License as published by the Free Software Foundation; either
//LIC// version 2.1 of the License, or (at your option) any later version.
//LIC// 
//LIC// This library is distributed in the hope that it will be useful,
//LIC// but WITHOUT ANY WARRANTY; without even the implied warranty of
//LIC// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//LIC// Lesser General Public License for more details.
//LIC// 
//LIC// You should have received a copy of the GNU Lesser General Public
//LIC// License along with this library; if not, write to the Free Software
//LIC// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
//LIC// 02110-1301  USA.
//LIC// 
//LIC// The authors may be contacted at oomph-lib@maths.man.ac.uk.
//LIC// 
//LIC//====================================================================
//This header file contains classes and inline function definitions for
//matrices and their derived types

//Include guards to prevent multiple inclusion of the header
#ifndef OOMPH_MATRICES_HEADER
#define OOMPH_MATRICES_HEADER

// Config header generated by autoconfig
#ifdef HAVE_CONFIG_H
#include <oomph-lib-config.h>
#endif

//oomph-lib headers
#include "Vector.h"
#include "oomph_utilities.h"

#ifdef HAVE_TRILINOS
#include "trilinos_helpers.h"
#endif

#ifdef OOMPH_HAS_MPI
#include "mpi.h"
#include "distribution_info.h"
#include "distributed_vector.h"
#endif

namespace oomph
{

// Initialise dense pointer-based matrices/tensors?
#define OOMPH_INITIALISE_DENSE_MATRICES
#undef  OOMPH_INITIALISE_DENSE_MATRICES

//=================================================================
/// \short Abstract base class for matrices, templated by
/// the type of object that is stored in them and the type of matrix.
/// The MATRIX_TYPE template argument is used as part of the 
/// Curiously Recurring Template Pattern, see
/// http://en.wikipedia.org/wiki/Curiously_Recurring_Template_Pattern
/// The pattern is used to force the inlining of the round bracket access 
/// functions by ensuring that they are NOT virtual functions. 
//=================================================================
template<class T, class MATRIX_TYPE>
class Matrix
{

  protected:

 /// \short Range check to catch when an index is out of bounds, if so, it
 /// issues a warning message and dies by throwing an \c OomphLibError
 void range_check(const unsigned long& i, const unsigned long& j) const
  {
   if (i>=nrow())
    {
     std::ostringstream error_message;
     error_message << "Range Error: i=" << i << " is not in the range (0," 
                   << nrow()-1 << ")." << std::endl;
   
     throw OomphLibError(error_message.str(),
                         "Matrix::range_check()",
                         OOMPH_EXCEPTION_LOCATION);
    }
   else if (j>=ncol())
    {
     std::ostringstream error_message;
     error_message << "Range Error: j=" << j << " is not in the range (0," 
                   << ncol()-1 << ")." << std::endl;

      throw OomphLibError(error_message.str(),
                         "Matrix::range_check()",
                         OOMPH_EXCEPTION_LOCATION);
    }
  }


  public: 

 /// (Empty) constructor
 Matrix() {}

 /// Broken copy constructor
 Matrix(const Matrix& matrix) 
  {
   BrokenCopy::broken_copy("Matrix");
  } 
 
 /// Broken assignment operator
 void operator=(const Matrix&) 
  {
   BrokenCopy::broken_assign("Matrix");
  }

 /// Virtual (empty) destructor
 virtual ~Matrix(){}

 /// Return the number of rows of the matrix
 virtual unsigned long nrow() const=0;
 
 /// Return the number of columns of the matrix
 virtual unsigned long ncol() const=0;

 /// \short Round brackets to give access as a(i,j) for read only
 /// (we're not providing a general interface for component-wise write
 /// access since not all matrix formats allow efficient direct access!)
 /// The function uses the  MATRIX_TYPE template parameter to call the
 /// get_entry() function which must be defined in all derived classes
 /// that are to be fully instantiated.
 inline const T& operator()(const unsigned long &i, 
                            const unsigned long &j) const
  {
   return static_cast<MATRIX_TYPE const *>(this)->get_entry(i,j);
  }
 
 /// \short  Round brackets to give access as a(i,j) for read-write 
 /// access.
 /// The function uses the  MATRIX_TYPE template parameter to call the
 /// entry() function which must be defined in all derived classes
 /// that are to be fully instantiated. If the particular Matrix does
 /// not allow write access, the function should break with an error
 /// message.
 inline T& operator()(const unsigned long &i, 
                      const unsigned long &j)
  {
   return static_cast<MATRIX_TYPE*>(this)->entry(i,j);
  }
 
 /// \short Output function to print a matrix row-by-row, in the form \n
 /// a(0,0) a(0,1) ... \n
 /// a(1,0) a(1,1) ... \n
 /// ... \n
 /// to the stream outfile.
 /// Broken virtual since it might not be sensible to implement this for 
 /// some sparse matrices.
 virtual void output(std::ostream &outfile)
  {
   throw OomphLibError(
    "Output function is not implemented for this matrix class",
    "Matrix::output()",
    OOMPH_EXCEPTION_LOCATION);
  }

 /// \short Indexed output function to print a matrix to the 
 /// stream outfile as i,j,a(i,j) for a(i,j)!=0 only
 virtual void sparse_indexed_output(std::ostream &outfile)=0;

};


/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////


//Forward definition of the linear solver class
 class LinearSolver; 

//===================================================================
/// \short Abstract base class for matrices of doubles -- adds 
/// abstract interfaces for solving, LU decomposition and 
/// multiplication by vectors.
//===================================================================
class DoubleMatrixBase
{
  protected:

 //Pointer to a linear solver
 LinearSolver* Linear_solver_pt;

 //Pointer to a default linear solver
 LinearSolver* Default_linear_solver_pt;

  public:

 /// (Empty) constructor. 
 DoubleMatrixBase() : Linear_solver_pt(0), Default_linear_solver_pt(0) {}

 /// Broken copy constructor
 DoubleMatrixBase(const DoubleMatrixBase& matrix) 
  {
   BrokenCopy::broken_copy("DoubleMatrixBase");
  } 
 
 /// Broken assignment operator
 void operator=(const DoubleMatrixBase&) 
  {
   BrokenCopy::broken_assign("DoubleMatrixBase");
  }

  /// Return the number of rows of the matrix
 virtual unsigned long nrow() const=0;
 
 /// Return the number of columns of the matrix
 virtual unsigned long ncol() const=0;

 /// virtual (empty) destructor
 virtual ~DoubleMatrixBase() { }

 /// \short Round brackets to give access as a(i,j) for read only
 /// (we're not providing a general interface for component-wise write
 /// access since not all matrix formats allow efficient direct access!)
 virtual const double& operator()(const unsigned long &i, 
                                  const unsigned long &j) const=0;

 
 /// Return a pointer to the linear solver object
 LinearSolver* &linear_solver_pt() {return Linear_solver_pt;}

 /// Return a pointer to the linear solver object (const version)
 LinearSolver* const &linear_solver_pt() const {return Linear_solver_pt;}

 /// \short Complete LU solve (replaces matrix by its LU decomposition
 /// and overwrites RHS with solution). The default should not need
 /// to be over-written
 void solve(Vector<double> &rhs);

 /// \short Complete LU solve (Nothing gets overwritten!). The default should
 /// not need to be overwritten
 void solve(const Vector<double> &rhs, Vector<double> &soln);
 
 /// \short Find the residual, i.e. r=b-Ax the residual
 virtual void residual(const Vector<double> &x, const Vector<double> &b, 
                       Vector<double> &residual)=0;
 
 /// \short Find the maximum residual r=b-Ax -- generic version, can be 
 /// overloaded for specific derived classes where the
 /// max. can be determined "on the fly"
 virtual double max_residual(const Vector<double> &x, 
                             const Vector<double> &rhs)
  {
   unsigned long n=rhs.size();
   Vector<double> res(n);
   residual(x,rhs,res);
   double ans=0.0;
   for (unsigned long i=0;i<n;i++)
    {
     ans = std::max(ans,res[i]);
    }
   return ans;
  }

 /// \short Multiply the matrix by the vector x: soln=Ax.
 virtual void multiply(const Vector<double> &x, Vector<double> &soln)=0;

 /// \short Multiply the  transposed matrix by the vector x: soln=A^T x
 virtual void multiply_transpose(const Vector<double> &x,
                                 Vector<double> &soln)=0;
  

 /// \short For every row, find the maximum absolute value of the
 /// entries in this row. Set all values that are less than alpha times
 /// this maximum to zero and return the resulting matrix in
 /// reduced_matrix. Note: Diagonal entries are retained regardless
 /// of their size. 
 //virtual void matrix_reduction(const double &alpha,
 //                              DoubleMatrixBase& reduced_matrix)=0;

};


/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////


//======================================================================
/// \short Class for dense matrices, storing all the values of the 
/// matrix as a pointer to a pointer with assorted output functions 
/// inherited from Matrix<T>. The curious recursive template pattern is
/// used here to pass the specific class to the base class so that
/// round bracket access can be inlined.
//======================================================================
template <class T>
class DenseMatrix : public Matrix<T, DenseMatrix<T> >
{

  protected:

 /// Internal representation of matrix as a pointer to data
 T* Matrixdata;

 /// Number of rows
 unsigned long N;
 
 /// Number of columns
 unsigned long M;
 
  public:

 /// Empty constructor, simply assign the lengths N and M to 0
 DenseMatrix() : Matrixdata(0), N(0), M(0) {}

 /// Copy constructor: Deep copy!
 DenseMatrix(const DenseMatrix& source_matrix) 
  {
   // Set row and column lengths
   N=source_matrix.nrow();
   M=source_matrix.ncol();
   // Assign space for the data
   Matrixdata = new T[N*M];
   // Copy the data across from the other matrix
   for(unsigned long i=0;i<N;i++)
    {
     for(unsigned long j=0;j<M;j++)
      {
       Matrixdata[M*i+j] = source_matrix(i,j);
      }
    }
  }

 /// Copy assignement 
 DenseMatrix& operator=(const DenseMatrix& source_matrix) 
  {
   // Don't create a new matrix if the assignement is the identity
   if (this != & source_matrix)
    {
     // Check row and column length
     unsigned long n=source_matrix.nrow();
     unsigned long m=source_matrix.ncol();
     if ( (N!=n) || (M!=m) )
      {
       resize(n,m);
      }
     // Copy entries across from the other matrix
     for (unsigned long i=0;i<N;i++)
      {
       for (unsigned long j=0;j<M;j++)
        {
         (*this)(i,j) = source_matrix(i,j);
        }
      }
    }
   // Return reference to object itself (i.e. de-reference this pointer)
   return *this;
  }
 
 /// \short The access function that will be called by the read-write
 /// round-bracket operator.
 inline T& entry(const unsigned long &i, const unsigned long &j) 
  {
#ifdef RANGE_CHECKING
   this->range_check(i,j);
#endif   
   return Matrixdata[M*i+j];
  }

 /// \short The access function the will be called by the read-only 
 /// (const version) round-bracket operator.
 inline const T& get_entry(const unsigned long &i, 
                           const unsigned long &j) const
  {
#ifdef RANGE_CHECKING
   this->range_check(i,j);
#endif  
   return Matrixdata[M*i+j];
  }

 /// Constructor to build a square n by n matrix
 DenseMatrix(const unsigned long &n);
 
 /// Constructor to build a matrix with n rows and m columns
 DenseMatrix(const unsigned long &n, const unsigned long &m);
 
 /// \short Constructor to build a matrix with n rows and m columns,
 /// with initial value initial_val
 DenseMatrix(const unsigned long &n, const unsigned long &m,
             const T &initial_val);
 
 /// Destructor, clean up the matrix data
 virtual ~DenseMatrix() {delete[] Matrixdata; Matrixdata=0;}
 
 /// Return the number of rows of the matrix
 inline unsigned long nrow() const {return N;} 

 /// Return the number of columns of the matrix
 inline  unsigned long ncol() const {return M;}
 
 /// Resize to a square nxn matrix;
 /// any values already present will be transfered
 void resize(const unsigned long &n) {resize(n,n);}
 
 /// \short Resize to a non-square n x m matrix;
 /// any values already present will be transfered
 void resize(const unsigned long &n, const unsigned long &m);
 
 /// \short Resize to a non-square n x m matrix and initialize the 
 /// new values to initial_value.
 void resize(const unsigned long &n, const unsigned long &m, 
             const T& initial_value);
 
 /// \short Initialize all values in the matrix to val.
 void initialise(const T& val)
  {for(unsigned long i=0;i<(N*M);++i) {Matrixdata[i] = val;}}
 
 /// Output function to print a matrix row-by-row to the stream outfile
 void output(std::ostream &outfile);
 
 /// Output function to print a matrix row-by-row to a file. Specify filename.
 void output(std::string filename);

 /// \short Indexed output function to print a matrix to the 
 /// stream outfile as i,j,a(i,j)
 void indexed_output(std::ostream &outfile);

 /// \short Indexed output function to print a matrix to a
 /// file as i,j,a(i,j). Specify filename.
 void indexed_output(std::string filename);

 /// \short Indexed output function to print a matrix to the 
 /// stream outfile as i,j,a(i,j) for a(i,j)!=0 only
 void sparse_indexed_output(std::ostream &outfile);
 
 /// \short Indexed output function to print a matrix to a 
 /// file as i,j,a(i,j) for a(i,j)!=0 only. Specify filename.
 void sparse_indexed_output(std::string filename);

};


///////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////


//================================================================
/// Class for sparse matrices, that store only the non-zero values
/// in a linear array in memory. The details of the array indexing
/// vary depending on the storage scheme used. The MATRIX_TYPE 
/// template parameter for use in the curious recursive template 
/// pattern is included and passed directly to the base Matrix class.
//=================================================================
template <class T, class MATRIX_TYPE>
class SparseMatrix : public Matrix<T,MATRIX_TYPE>
 {
   protected:

  /// Internal representation of the matrix values, a pointer
  T* Value;
  
  /// Number of rows
  unsigned long N;

  /// Number of columns
  unsigned long M;

  /// Number of non-zero values (i.e. size of Value array)
  unsigned long Nnz;

  /// Dummy zero
  static T Zero;
  
   public:
  
  /// Default constructor
  SparseMatrix() : Value(0), N(0), M(0), Nnz(0) {}
  
  /// Copy constructor
  SparseMatrix(const SparseMatrix& source_matrix)
   {
    // Number of nonzero entries
    Nnz=source_matrix.nnz();
    
    // Number of rows
    N=source_matrix.nrow();
    
    // Number of columns
    M=source_matrix.ncol();
    
    // Values stored in C-style array
    Value = new T[Nnz];
    
    // Assign the values
    for (unsigned long i=0;i<Nnz;i++) {Value[i]=source_matrix.value()[i];}
   }
 
  /// Broken assignment operator
  void operator=(const SparseMatrix&) 
   {
    BrokenCopy::broken_assign("SparseMatrix");
   }
  
  /// Destructor, delete the memory associated with the values
  virtual ~SparseMatrix() {delete[] Value; Value=0;}
  
  /// Access to C-style value array
  T* value() {return Value;}
 
  /// Access to C-style value array (const version)
  const T* value() const {return Value;}
  
  /// Return the number of rows of the matrix
  inline unsigned long nrow() const {return N;}
  
  /// Return the number of columns of the matrix
  inline unsigned long ncol() const {return M;}
  
  /// Return the number of nonzero entries
  inline unsigned long nnz() const {return Nnz;}
  
  /// \short Indexed output function to print a matrix to the
  /// stream outfile as i,j,a(i,j) for a(i,j)!=0 only
  virtual void sparse_indexed_output(std::ostream &outfile)
   {
    std::string error_message = 
     "SparseMatrix::sparse_indexed_output() is a virtual function.\n";
    error_message +=
     "It must be overloaded for specific sparse matrix storage formats\n";
    
    throw OomphLibError(error_message,
                        "SparseMatrix::sparse_indexed_output()",
                        OOMPH_EXCEPTION_LOCATION);
   }
  
  /// \short Indexed output function to print a matrix to a
  /// file as i,j,a(i,j) for a(i,j)!=0 only. Specify filename.
  void sparse_indexed_output(std::string filename)
   {
    // Open file
    std::ofstream some_file;
    some_file.open(filename.c_str());
    sparse_indexed_output(some_file);
    some_file.close();
   }
  
 };






//======================================================================
/// \short A class for compressed row matrices, a sparse storage format
/// Once again the recursive template trick is used to inform that base
/// class that is should use the access functions provided in the
/// CRMatrix class.
//=====================================================================
template<class T>
class CRMatrix : public SparseMatrix<T, CRMatrix<T> >
{

  public:


 /// Default constructor
 CRMatrix() : SparseMatrix<T, CRMatrix<T> >()
  {
   Column_index=0;
   Row_start=0;
  }


 /// \short Constructor: Pass vector of values, vector of column indices,
 /// vector of row starts and number of rows and columns
 /// Number of nonzero entries is read
 /// off from value, so make sure the vector has been shrunk
 /// to its correct length.
 CRMatrix(const Vector<T>& value, const Vector<int>& column_index,
          const Vector<int>& row_start, 
          const unsigned long &n,
          const unsigned long &m) :
  SparseMatrix<T, CRMatrix<T> >()
  {
   Column_index=0;
   Row_start=0;
   build(value,column_index,row_start,n,m);
  }
 
 /// \short Copy constructor
 CRMatrix(const CRMatrix& source_matrix) : 
  SparseMatrix<T, CRMatrix<T> >(source_matrix)
  {
   //NNz, N and M are set the the copy constructor of the SparseMatrix
   //called above
   // Column indices stored in C-style array
   Column_index = new int[this->Nnz];
 
   // Assign:
   for (unsigned long i=0;i<this->Nnz;i++)
    {
     Column_index[i]=source_matrix.column_index()[i];
    }
   
   // Row start:
   Row_start = new int[this->N+1];
   
   // Assign:
   for (unsigned long i=0;i<=this->N;i++)
    {
     Row_start[i]=source_matrix.row_start()[i];
    }
  }

  /// Broken assignment operator
 void operator=(const CRMatrix&) 
  {
   BrokenCopy::broken_assign("CRMatrix");
  }

 /// Destructor, delete any allocated memory
 virtual ~CRMatrix()
  {
   delete[] Column_index; Column_index = 0;
   delete[] Row_start; Row_start = 0;
  }
 
 /// \short Access function that will be called by the read-only round-bracket
 /// operator (const)
 const T& get_entry(const unsigned long &i, 
                    const unsigned long &j) const
  {
#ifdef RANGE_CHECKING
   this->range_check(i,j);
#endif   
   for (long k=Row_start[i];k<Row_start[i+1];k++)
    {
     if (unsigned(Column_index[k])==j)
      {
       return this->Value[k];
      }
    }
   return this->Zero;
  }

 /// The read-write access function is deliberately broken
 T& entry(const unsigned long &i, const unsigned long &j)
  {
   std::string error_string =
    "Non-const access not provided for the CRMatrix<T> class\n";
   error_string += "It is not possible to use round-bracket access: M(i,j)\n";
   error_string += "if M is not declared as const.\n";
   error_string += 
    "The solution (albeit ugly) is to create const reference to the matrix\n";
   error_string += " const CRMatrix<T>& read_M = M;\n";
   error_string += "Then read_M(i,j) is permitted\n";

   throw OomphLibError(error_string,
                       "CRMatrix<T>::entry()",
                       OOMPH_EXCEPTION_LOCATION);

   // Dummy return
   T dummy;
   return dummy;
  }

 /// Access to C-style row_start array
 int* row_start() {return Row_start;}

 /// Access to C-style row_start array (const version)
 const int* row_start() const {return Row_start;}

 /// Access to C-style column index array
 int* column_index() {return Column_index;}

 /// Access to C-style column index array (const version)
 const int* column_index() const {return Column_index;}

 /// \short Indexed output function to print a matrix to the
 /// stream outfile as i,j,a(i,j) for a(i,j)!=0 only
 void sparse_indexed_output(std::ostream &outfile)
  {
   for (unsigned long i=0;i<this->N;i++)
    {
     for (long j=Row_start[i];j<Row_start[i+1];j++)
      {
       outfile << i << " " << Column_index[j] << " " << this->Value[j]
               << std::endl;
      }
    }
  }


 /// \short Indexed output function to print a matrix to a
 /// file as i,j,a(i,j) for a(i,j)!=0 only. Specify filename.
 void sparse_indexed_output(std::string filename)
  {
   // Open file
   std::ofstream some_file;
   some_file.open(filename.c_str());
   sparse_indexed_output(some_file);
   some_file.close();
  }

 /// Wipe matrix data and set all values to 0.
 void clean_up_memory();

 /// \short Build matrix from compressed representation.
 /// Number of nonzero entries is read
 /// off from value, so make sure the vector has been shrunk
 /// to its correct length. The number of rows and columns must
 /// be passed as the final arguments.
 void build(const Vector<T>& value, const Vector<int>& column_index,
            const Vector<int>& row_start, 
            const unsigned long &n,
            const unsigned long &m);


 /// \short Function to build matrix from pointers to arrays 
 /// which hold the row starts, column indices and non-zero values.
 /// The final two arguments are the number of rows and columns.
 /// Note that, as the name suggests, this function does not
 /// make a copy of the data pointed to by the first three arguments!
 void build_without_copy(T* value,
                         int* column_index,
                         int* row_start,
                         const unsigned long& nnz,
                         const unsigned long& n,
                         const unsigned long& m);
 
 
  protected:

 /// Column index
 int* Column_index;

 /// Start index for row
 int* Row_start;
 
};


//Forward definition for the superlu solver
class SuperLU;


//=================================================================
/// \short A class for compressed row matrices
//=================================================================
class CRDoubleMatrix : public CRMatrix<double>,
                       public DoubleMatrixBase
{
 
  public:

 /// Default constructor
 CRDoubleMatrix();

 /// \short Constructor: Pass vector of values, vector of column indices,
 /// vector of row starts and number of rows and columns.
 CRDoubleMatrix(const Vector<double>& value, 
                const Vector<int>& column_index,
                const Vector<int>& row_start,
                const unsigned long &n,
                const unsigned long &m);

 /// Broken copy constructor
 CRDoubleMatrix(const CRDoubleMatrix& matrix) 
  {
   BrokenCopy::broken_copy("CRDoubleMatrix");
  } 


 /// Broken assignment operator
 void operator=(const CRDoubleMatrix&) 
  {
   BrokenCopy::broken_assign("CRDoubleMatrix");
  }

 /// Destructor
 virtual ~CRDoubleMatrix();

   /// Return the number of rows of the matrix
 inline unsigned long nrow() const {return CRMatrix<double>::nrow();}
 
 /// Return the number of columns of the matrix
 inline unsigned long ncol() const {return CRMatrix<double>::ncol();}

 /// Overload the round-bracket access operator for read-only access
 inline const double& operator()(const unsigned long &i, 
                                 const unsigned long &j) 
  const {return CRMatrix<double>::get_entry(i,j);}
 
 /// \short LU decomposition using SuperLU (default linear solver)
 virtual void ludecompose();

 /// \short LU back solve for given RHS
 virtual void lubksub(Vector<double> &rhs);

 /// \short Find the residual to x of Ax=b, i.e. r=b-Ax
 void residual(const Vector<double> &x, const Vector<double> &b, 
               Vector<double> &residual);

 /// \short Work out residual vector r = b-Ax for candidate solution x
 /// and return max. entry in residual vector.
 double residual(const Vector<double>& x,
                 const Vector<double>& b); 

 /// \short Multiply the matrix by the vector x: soln=Ax
 void multiply(const Vector<double> &x, Vector<double> &soln);  


 /// \short Multiply the  transposed matrix by the vector x: soln=A^T x
 void multiply_transpose(const Vector<double> &x,
                         Vector<double> &soln);


 /// \short Function to multiply this matrix by the CRDoubleMatrix matrix_in
 /// The multiplication method used can be selected using the flag
 /// Matrix_matrix_multiply_method. By default Method 2 is used.
 /// Method 1: First runs through this matrix and matrix_in to find the storage
 ///           requirements for result - arrays of the correct size are 
 ///           then allocated before performing the calculation.
 ///           Minimises memory requirements but more costly.
 /// Method 2: Grows storage for values and column indices of result 'on the
 ///           fly' using an array of maps. Faster but more memory
 ///           intensive.
 /// Method 3: Grows storage for values and column indices of result 'on the
 ///           fly' using a vector of vectors. Not particularly impressive
 ///           on the platforms we tried...
void multiply(const CRDoubleMatrix& matrix_in, CRDoubleMatrix& result);
 
  
 /// \short For every row, find the maximum absolute value of the
 /// entries in this row. Set all values that are less than alpha times
 /// this maximum to zero and return the resulting matrix in
 /// reduced_matrix. Note: Diagonal entries are retained regardless
 /// of their size. 
 void matrix_reduction(const double &alpha,
                       CRDoubleMatrix& reduced_matrix);

 /// \short Access function to Matrix_matrix_multiply_method, the flag
 /// which determines the matrix matrix multiplication method used.
 /// Method 1: First runs through this matrix and matrix_in to find the storage
 ///           requirements for result - arrays of the correct size are 
 ///           then allocated before performing the calculation.
 ///           Minimises memory requirements but more costly.
 /// Method 2: Grows storage for values and column indices of result 'on the
 ///           fly' using an array of maps. Faster but more memory
 ///           intensive.
 /// Method 3: Grows storage for values and column indices of result 'on the
 ///           fly' using a vector of vectors. Not particularly impressive
 ///           on the platforms we tried...
 unsigned& matrix_matrix_multiply_method() 
  { 
   return Matrix_matrix_multiply_method; 
  }

 private:

 /// Flag to determine which matrix-matrix multiplication method is used.
 unsigned Matrix_matrix_multiply_method;

};

#ifdef OOMPH_HAS_MPI

//=============================================================================
/// \short A class for distributed compressed row matrices. Each processor 
/// only stores a block of rows that make up the complete matrix. 
//=============================================================================
class DistributedCRDoubleMatrix : public CRDoubleMatrix
{

public:

 /// Default Constructor - empty matrix and the distribution is not setup
 DistributedCRDoubleMatrix(); 

 /// Constructor 
 DistributedCRDoubleMatrix(const DistributionInfo& distribution)
  : Matrix_distribution(distribution)
  {};

 /// \short Constructor: Pass vector of values, vector of column indices,
 /// and vector of row starts. Since the rows of the matrix are 
 /// distributed over several processors we also need to pass the 
 /// number of the first row and the number of local rows stored here. 
 /// n and m are the total number of rows and columns. 
 /// \b NOTE: Number of nonzero entries is read
 /// off from value, so make sure the vector has been shrunk
 /// to its correct length.
 DistributedCRDoubleMatrix(const Vector<double>& value, 
                           const Vector<int>& column_index,
                           const Vector<int>& row_start, 
                           const DistributionInfo& distribution,
                           const unsigned& n_col);

 /// Destructor (empty all the clean up happens in the base claases)
 virtual ~DistributedCRDoubleMatrix() {}
 
 /// \short Broken copy constructor
 DistributedCRDoubleMatrix(const DistributedCRDoubleMatrix& source_matrix)
  {
   BrokenCopy::broken_copy("DistributedCRDoubleMatrix");
  }

 /// Broken assignment operator
 void operator=(const DistributedCRDoubleMatrix&) 
  {
   BrokenCopy::broken_assign("DistributedCRDoubleMatrix");
  }

 /// \short Build matrix from compressed representation:
 /// Pass vector of values, vector of column indices,
 /// and vector of row starts. Since the rows of the matrix are 
 /// distributed over several processors we also need to pass the 
 /// number of the first row and the number of local rows stored here. 
 /// n and m are the total number of rows and columns. 
 /// \b NOTE: Number of nonzero entries is read
 /// off from value, so make sure the vector has been shrunk
 /// to its correct length.
 void build(const Vector<double>& value,
            const Vector<int>& column_index,
            const Vector<int>& row_start,
            const DistributionInfo& distribution,
            const unsigned& n_col);

 /// Delete data and set values to 0.
 void clean_up_memory();

 /// access function to first row 
 unsigned long first_row() const
  { return Matrix_distribution.first_row(); }
 
 /// access function to local_nrow
 unsigned long nrow_local() const
  { return Matrix_distribution.nrow_local(); }
 
 /// access function to global_nrow
 unsigned long nrow_global() const 
  { return Matrix_distribution.nrow_global(); }
 
  /// access function to the distribution
  DistributionInfo& distribution() { return Matrix_distribution; }

  /// access function to the distribution (const version)
  DistributionInfo distribution() const { return Matrix_distribution; }

 /// access function to setup
 bool setup() const { return Matrix_distribution.setup(); }
 
 /// Overload round brackets to give access as a(i,j)
 double& operator()(const unsigned long &i, const unsigned long &j) 
  {
   std::ostringstream error_message;
   error_message <<
    "Broken -- needs to be re-implemented for distributed memory version" 
                 << std::endl;
   throw OomphLibError(error_message.str(),
                       "DistributedCRDoubleMatrix::()",
                       OOMPH_EXCEPTION_LOCATION);
  }
 

 /// Overload round brackets to give access as a(i,j) (const version)
 const double& operator()
  (const unsigned long &i, const unsigned long &j) const;

 /// \short Indexed output function to print a matrix to the 
 /// stream outfile as i,j,a[i][j] for a[i][j]!=0 only
 void sparse_indexed_output(std::ostream &outfile)
  {
   for (unsigned long i=0; i< Matrix_distribution.nrow_local(); i++)
    {
     unsigned long row = Matrix_distribution.first_row() + i;
     for (long j=Row_start[i];j<Row_start[i+1];j++)
      {
       outfile << row << " " << Column_index[j] << " " << this->Value[j]
               << std::endl;
      }
    }
  }


 /// \short Indexed output function to print a matrix to the 
 /// stream outfile as i,j,a[i][j] for a[i][j]!=0 only
 void sparse_indexed_output(std::ostream &outfile,
                            const Vector<unsigned>& permute)
  {
   for (unsigned long i=0; i< Matrix_distribution.nrow_local(); i++)
    {
     unsigned long row = Matrix_distribution.first_row() + i;
     for (long j=Row_start[i];j<Row_start[i+1];j++)
      {
       outfile << permute[row] << " " << permute[Column_index[j]]
               << " " << this->Value[j]
               << std::endl;
      }
    }
  }



 /// \short Indexed output function to print a matrix to a 
 /// file as i,j,a[i][j] for a[i][j]!=0 only. Specify filename.
 void sparse_indexed_output(std::string filename)
  {
   // Open file
   std::ofstream some_file;
   some_file.open(filename.c_str());
   sparse_indexed_output(some_file);
   some_file.close();
  }

 /// \short Find the residual, i.e. Ax-b=r the residual
 void residual(const Vector<double> &x, const Vector<double> &b, 
                       Vector<double> &residual)
  {
   std::ostringstream error_message;
   error_message <<
    "Broken -- needs to be re-implemented for distributed memory version" 
                 << std::endl;
   throw OomphLibError(error_message.str(),
                       "DistributedCRDoubleMatrix::residual()",
                       OOMPH_EXCEPTION_LOCATION);
  }
 

 /// \short Find the maximum residual
 double residual(const Vector<double> &x, const Vector<double> &rhs)
  {
   std::ostringstream error_message;
   error_message <<
    "Broken -- needs to be re-implemented for distributed memory version" 
                 << std::endl;
   throw OomphLibError(error_message.str(),
                       "DistributedCRDoubleMatrix::residual()",
                       OOMPH_EXCEPTION_LOCATION);
   return 0.0;
  }

 /// \short Multiply the matrix by the vector x: soln=Ax.
 /// Currently this requires trilinos to be available. Will break
 /// otherwise.
 /// The vectors x and soln are both distributed vectors
 void multiply(const DistributedVector<double> &x, 
               DistributedVector<double> &soln);

 /// \short Multiply the  transposed matrix by the vector x: soln=A^T x BROKEN
 void multiply_transpose(const DistributedVector<double> &x,
                         DistributedVector<double> &soln)
  {
   throw OomphLibError("This function is not implemented yet",
                       "DistributedCRDoubleMatrix()::multiply_transpose()",
                       OOMPH_EXCEPTION_LOCATION);
  }

 /// \short For every row, find the maximum absolute value of the
 /// entries in this row. Set all values that are less than alpha times
 /// this maximum to zero and return the resulting matrix in
 /// reduced_matrix. Note: Diagonal entries are retained regardless
 /// of their size.  BROKEN
 void matrix_reduction(const double &alpha,
                       DoubleMatrixBase& reduced_matrix)
  {
   throw OomphLibError("This function is not implemented yet",
                       "DistributedCRDoubleMatrix()::matrix_reduction()",
                       OOMPH_EXCEPTION_LOCATION);
  }

 /// \short Function to multiply this matrix by the DistributedCRDoubleMatrix 
 /// matrix_in. This function requires Trilinos.
 /// If the flag Matrix_matrix_multiply_using_ml is set to true the faster ML
 /// method is used in Trilinos (default value is false).
 void multiply(DistributedCRDoubleMatrix& matrix_in,
               DistributedCRDoubleMatrix& result);


 /// \short Access function to Matrix_matrix_multiply_using_ml. If this flag
 /// is true the faster ML multiply function is used, otherwise the 
 /// EpetraExt::MatrixMatrix class function is used.
 bool& matrix_matrix_multiply_using_ml() 
  { 
   return Matrix_matrix_multiply_using_ml; 
  }

 private: 

 /// the distribution of this matrix
 DistributionInfo Matrix_distribution;

 /// When set to true the faster ml matrix-matrix multiplication method is used
 /// by Trilinos. Default value is false.
 bool Matrix_matrix_multiply_using_ml;


}; //end of DistributedCRDoubleMatrix
#endif


///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////


//Forward definition of the DenseLU class
class DenseLU;

//=================================================================
/// \short Class of matrices containing doubles, and stored as a 
/// DenseMatrix<double>, but with solving functionality inherited
/// from the abstract DoubleMatrix class. 
//=================================================================
class DenseDoubleMatrix : public DoubleMatrixBase,
                          public DenseMatrix<double>
{

  public:

 /// Constructor, set the default linear solver
 DenseDoubleMatrix();
 
 /// Constructor to build a square n by n matrix.
 DenseDoubleMatrix(const unsigned long &n);
 
 /// Constructor to build a matrix with n rows and m columns.
 DenseDoubleMatrix(const unsigned long &n, const unsigned long &m);

 /// \short Constructor to build a matrix with n rows and m columns,
 /// with initial value initial_val
 DenseDoubleMatrix(const unsigned long &n, const unsigned long &m,
                   const double &initial_val);

 /// Broken copy constructor
 DenseDoubleMatrix(const DenseDoubleMatrix& matrix) 
  {
   BrokenCopy::broken_copy("DenseDoubleMatrix");
  } 
 
 /// Broken assignment operator
 void operator=(const DenseDoubleMatrix&) 
  {
   BrokenCopy::broken_assign("DenseDoubleMatrix");
  }

 
 /// Return the number of rows of the matrix
 inline unsigned long nrow() const {return DenseMatrix<double>::nrow();}
 
 /// Return the number of columns of the matrix
 inline unsigned long ncol() const {return DenseMatrix<double>::ncol();}

 /// \short Overload the const version of the round-bracket access operator
 /// for read-only access.
 inline const double& operator()(const unsigned long &i, 
                                 const unsigned long &j) 
  const {return DenseMatrix<double>::get_entry(i,j);}
   
 /// \short Overload the non-const version of the round-bracket access
 /// operator for read-write access
 inline double& operator()(const unsigned long &i, const unsigned long &j) 
  {return DenseMatrix<double>::entry(i,j);}
 
 /// Destructor
 virtual ~DenseDoubleMatrix(); 
 
 /// \short LU decomposition using DenseLU (default linea solver)
 virtual void ludecompose();

 /// \short LU backsubstitution
 virtual void lubksub(Vector<double> &rhs);
 
 /// \short Determine eigenvalues and eigenvectors, using
 /// Jacobi rotations. Only for symmetric matrices. Nothing gets overwritten!
 /// - \c eigen_vect(i,j) = j-th component of i-th eigenvector.
 /// - \c eigen_val(i) is the i-th eigenvalue; same ordering as in eigenvectors
 void eigenvalues_by_jacobi(Vector<double> & eigen_val,
                            DenseMatrix<double> &eigen_vect) const;
 
 /// \short Find the residual of Ax=b, ie r=b-Ax for the
 /// "solution" x.
 void residual(const Vector<double>& x, const Vector<double>& rhs, 
               Vector<double>& residual);

 /// \short Multiply the matrix by the vector x: soln=Ax 
 void multiply(const Vector<double> &x, Vector<double> &soln);
 
 /// \short Multiply the  transposed matrix by the vector x: soln=A^T x
 void multiply_transpose(const Vector<double> &x,
                         Vector<double> &soln);

  
 /// \short For every row, find the maximum absolute value of the
 /// entries in this row. Set all values that are less than alpha times
 /// this maximum to zero and return the resulting matrix in
 /// reduced_matrix. Note: Diagonal entries are retained regardless
 /// of their size. 
 void matrix_reduction(const double &alpha,
                        DenseDoubleMatrix& reduced_matrix);

 /// Function to multiply this matrix by a DenseDoubleMatrix matrix_in
 void multiply(const DenseDoubleMatrix& matrix_in,
               DenseDoubleMatrix& result);
 
 /// \short Find the maximum residual of Ax=b, ie r=b-Ax
 /// for the "solution" x.
 double residual(const Vector<double> &x, const Vector<double> &b);

};

/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////



//=================================================================
///A Rank 3 Tensor class 
//=================================================================
template <class T>
class RankThreeTensor
{

  private:

 /// Private internal representation  as pointer to data
 T* Tensordata;
 
 /// 1st Tensor dimension
 unsigned N;

 /// 2nd Tensor dimension
 unsigned M;

 /// 3rd Tensor dimension
 unsigned P;

 /// \short Range check to catch when an index is out of bounds, if so, it
 /// issues a warning message and dies by throwing an \c OomphLibError
 void range_check(const unsigned long& i, 
                  const unsigned long& j,
                  const unsigned long& k) const
  {
   if (i>=N)
    {
     std::ostringstream error_message;
     error_message << "Range Error: i=" << i << " is not in the range (0," 
                   << N-1 << ")." << std::endl;
   
     throw OomphLibError(error_message.str(),
                         "RankThreeTensor::range_check()",
                         OOMPH_EXCEPTION_LOCATION);
    }
   else if (j>=M)
    {
     std::ostringstream error_message;
     error_message << "Range Error: j=" << j << " is not in the range (0," 
                   << M-1 << ")." << std::endl;

      throw OomphLibError(error_message.str(),
                         "RankThreeTensor::range_check()",
                         OOMPH_EXCEPTION_LOCATION);
    }
   else if (k>=P)
    {
     std::ostringstream error_message;
     error_message << "Range Error: k=" << k << " is not in the range (0," 
                   << P-1 << ")." << std::endl;

      throw OomphLibError(error_message.str(),
                         "RankThreeTensor::range_check()",
                         OOMPH_EXCEPTION_LOCATION);
    }
  }


  public:

 /// Empty constructor
 RankThreeTensor(): Tensordata(0), N(0), M(0), P(0) {}

 /// Copy constructor: Deep copy
 RankThreeTensor(const RankThreeTensor& source_tensor)
  {
   // Set row and column lengths
   N=source_tensor.nindex1();
   M=source_tensor.nindex2();
   P=source_tensor.nindex3();
   // Assign space for the data
   Tensordata = new T[N*M*P];
   // Copy the data across from the other matrix
   for(unsigned i=0;i<N;i++)
    {
     for(unsigned j=0;j<M;j++)
      {
       for(unsigned k=0;k<P;k++)
        {
         Tensordata[P*(M*i + j) +k] = source_tensor(i,j,k);
        }
      }
    }
  }

 /// Copy assignement 
 RankThreeTensor& operator=(const RankThreeTensor& source_tensor) 
  {
   // Don't create a new matrix if the assignement is the identity
   if (this != & source_tensor)
    {
     // Check row and column length
     unsigned long n=source_tensor.nindex1();
     unsigned long m=source_tensor.nindex2();
     unsigned long p=source_tensor.nindex3();
     //Resie the tensor to be the same size as the old tensor
     if ( (N!=n) || (M!=m) || (P!=p) ) {resize(n,m,p);}
     
     // Copy entries across from the other matrix
     for (unsigned long i=0;i<N;i++)
      {
       for (unsigned long j=0;j<M;j++)
        {
         for(unsigned long k=0;k<P;k++)
          {
           (*this)(i,j,k) = source_tensor(i,j,k);
          }
        }
      }
    }
   // Return reference to object itself (i.e. de-reference this pointer)
   return *this;
  }


 /// One parameter constructor produces a cubic nxnxn tensor
 RankThreeTensor(const unsigned long &n) 
  {
   // Set row and column lengths
   N=n; M=n; P=n;
   // Assign space for the n rows
   Tensordata = new T[N*M*P];
   //Initialise to zero if required
#ifdef OOMPH_INITIALISE_DENSE_MATRICES
   initialise(T(0));
#endif
  }

 /// Three parameter constructor, general non-square tensor
 RankThreeTensor(const unsigned long &n_index1, const unsigned long &n_index2,
                 const unsigned long &n_index3)
  {
   // Set row and column lengths
   N=n_index1; M=n_index2; P=n_index3;
   // Assign space for the n rows
   Tensordata = new T[N*M*P];
   //Initialise to zero if required
#ifdef OOMPH_INITIALISE_DENSE_MATRICES
   initialise(T(0));
#endif
  }


 /// Three parameter constructor, general non-square tensor
 RankThreeTensor(const unsigned long &n_index1, const unsigned long &n_index2,
                 const unsigned long &n_index3, const T &initial_val)
  {
   // Set row and column lengths
   N=n_index1; M=n_index2; P=n_index3;
   // Assign space for the n rows
   Tensordata = new T[N*M*P];
   //Initialise to the initial value
   initialise(initial_val);
  }

 /// Destructor: delete the pointers
 virtual ~RankThreeTensor() {delete[] Tensordata; Tensordata = 0;}

 /// Resize to a square nxnxn tensor
 void resize(const unsigned long &n) {resize(n,n,n);}
 
 /// Resize to a general tensor
 void resize(const unsigned long &n_index1, const unsigned long &n_index2,
             const unsigned long &n_index3)
  {
   //If the sizes have not changed do nothing
   if((n_index1==N) && (n_index2==M) && (n_index3==P)) {return;}
   // Store old sizes
   unsigned long n_old=N, m_old=M, p_old=P;
   // Reassign the sizes
   N=n_index1; M=n_index2; P=n_index3;
   // Store triple pointer to old matrix data
   T* temp_tensor = Tensordata;
   // Re-create Tensordata in new size
   Tensordata = new T[N*M*P];
#ifdef OOMPH_INITIALISE_DENSE_MATRICES
   initialise(T(0));
#endif
   // Transfer values
   unsigned long n_copy, m_copy, p_copy;
   n_copy = std::min(n_old,n_index1);
   m_copy = std::min(m_old,n_index2);
   p_copy = std::min(p_old,n_index3);
   // If matrix has values, transfer them to new matrix
   // Loop over rows
   for (unsigned long i=0;i<n_copy;i++)
    {
     // Loop over columns
     for (unsigned long j=0;j<m_copy;j++)
      {
       // Loop over columns
       for (unsigned long k=0;k<p_copy;k++)
        {
         // Transfer values from temp_tensor
         Tensordata[M*P*i + P*j + k] = 
          temp_tensor[m_old*p_old*i + p_old*j + k];
        }
      }
    }
   // Now kill storage for old tensor
   delete[] temp_tensor;
  }

 /// Resize to a general tensor
 void resize(const unsigned long &n_index1, const unsigned long &n_index2,
             const unsigned long &n_index3, const T &initial_value)
  {
   //If the sizes have not changed do nothing
   if((n_index1==N) && (n_index2==M) && (n_index3==P)) {return;}
   // Store old sizes
   unsigned long n_old=N, m_old=M, p_old=P;
   // Reassign the sizes
   N=n_index1; M=n_index2; P=n_index3;
   // Store triple pointer to old matrix data
   T* temp_tensor = Tensordata;
   // Re-create Tensordata in new size
   Tensordata = new T[N*M*P];
   //Initialise the newly allocated storage
   initialise(initial_value);

   // Transfer values
   unsigned long n_copy, m_copy, p_copy;
   n_copy = std::min(n_old,n_index1);
   m_copy = std::min(m_old,n_index2);
   p_copy = std::min(p_old,n_index3);
   // If matrix has values, transfer them to new matrix
   // Loop over rows
   for (unsigned long i=0;i<n_copy;i++)
    {
     // Loop over columns
     for (unsigned long j=0;j<m_copy;j++)
      {
       // Loop over columns
       for (unsigned long k=0;k<p_copy;k++)
        {
         // Transfer values from temp_tensor
         Tensordata[M*P*i + P*j + k] = 
          temp_tensor[m_old*p_old*i + p_old*j + k];
        }
      }
    }
   // Now kill storage for old tensor
   delete[] temp_tensor;
  }

 /// \short Initialise all values in the tensor to val
 void initialise(const T &val)
  {for(unsigned long i=0;i<(N*M*P);++i) {Tensordata[i] = val;}}

 /// Return the range of index 1 of the tensor
 unsigned long nindex1() const {return N;}
 
 /// Return the range of index 2 of the tensor
 unsigned long nindex2() const {return M;}

 /// Return the range of index 3 of the tensor
 unsigned long nindex3() const {return P;}

 /// Overload the round brackets to give access as a(i,j,k)
 inline T &operator()(const unsigned long &i, const unsigned long &j,
                      const unsigned long &k) 
  {
#ifdef RANGE_CHECKING
   this->range_check(i,j,k);
#endif   
   return Tensordata[P*(M*i + j) + k];
  }

 /// Overload a const version for read-only access as a(i,j,k)
 inline const T &operator()(const unsigned long &i, const unsigned long &j,
                            const unsigned long &k) const
  {
#ifdef RANGE_CHECKING
   this->range_check(i,j,k);
#endif  
   return Tensordata[P*(M*i + j) + k];
  }
 
};  

/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////



//=================================================================
///A Rank 4 Tensor class 
//=================================================================
template <class T>
class RankFourTensor
{

  private:

 /// Private internal representation  as pointer to data
 T* Tensordata;
 
 /// 1st Tensor dimension
 unsigned N;

 /// 2nd Tensor dimension
 unsigned M;

 /// 3rd Tensor dimension
 unsigned P;
 
 /// 4th Tensor dimension
 unsigned Q;
 
 /// \short Range check to catch when an index is out of bounds, if so, it
 /// issues a warning message and dies by throwing an \c OomphLibError
 void range_check(const unsigned long& i, 
                  const unsigned long& j,
                  const unsigned long& k,
                  const unsigned long& l) const
  {
   if (i>=N)
    {
     std::ostringstream error_message;
     error_message << "Range Error: i=" << i << " is not in the range (0," 
                   << N-1 << ")." << std::endl;
   
     throw OomphLibError(error_message.str(),
                         "RankFourTensor::range_check()",
                         OOMPH_EXCEPTION_LOCATION);
    }
   else if (j>=M)
    {
     std::ostringstream error_message;
     error_message << "Range Error: j=" << j << " is not in the range (0," 
                   << M-1 << ")." << std::endl;

      throw OomphLibError(error_message.str(),
                         "RankFourTensor::range_check()",
                         OOMPH_EXCEPTION_LOCATION);
    }
   else if (k>=P)
    {
     std::ostringstream error_message;
     error_message << "Range Error: k=" << k << " is not in the range (0," 
                   << P-1 << ")." << std::endl;

      throw OomphLibError(error_message.str(),
                         "RankFourTensor::range_check()",
                         OOMPH_EXCEPTION_LOCATION);
    }
   else if (l>=Q)
    {
     std::ostringstream error_message;
     error_message << "Range Error: l=" << l << " is not in the range (0," 
                   << Q-1 << ")." << std::endl;

      throw OomphLibError(error_message.str(),
                         "RankFourTensor::range_check()",
                         OOMPH_EXCEPTION_LOCATION);
    }
  }
  public:

 /// Empty constructor
 RankFourTensor(): Tensordata(0), N(0), M(0), P(0), Q(0) {}

 /// Copy constructor: Deep copy
 RankFourTensor(const RankFourTensor& source_tensor)
  {
   // Set row and column lengths
   N=source_tensor.nindex1();
   M=source_tensor.nindex2();
   P=source_tensor.nindex3();
   Q=source_tensor.nindex4();

   // Assign space for the data
   Tensordata = new T[N*M*P*Q];

   // Copy the data across from the other matrix
   for(unsigned i=0;i<N;i++)
    {
     for(unsigned j=0;j<M;j++)
      {
       for(unsigned k=0;k<P;k++)
        {
         for(unsigned l=0;l<Q;l++)
          {
         Tensordata[Q*(P*(M*i + j) +k)+l] = source_tensor(i,j,k,l);
          }
        }
      }
    }
  }
 
 /// Copy assignement 
 RankFourTensor& operator=(const RankFourTensor& source_tensor) 
  {
   // Don't create a new matrix if the assignement is the identity
   if (this != & source_tensor)
    {
     // Check row and column length
     unsigned long n=source_tensor.nindex1();
     unsigned long m=source_tensor.nindex2();
     unsigned long p=source_tensor.nindex3();
     unsigned long q=source_tensor.nindex4();
     //Resize the tensor to be the same size as the old tensor
     if ( (N!=n) || (M!=m) || (P!=p) || (Q!=q) ) {resize(n,m,p,q);}
     
     // Copy entries across from the other matrix
     for (unsigned long i=0;i<N;i++)
      {
       for (unsigned long j=0;j<M;j++)
        {
         for(unsigned long k=0;k<P;k++)
          {
           for(unsigned long l=0;l<Q;l++)
            {
             (*this)(i,j,k,l) = source_tensor(i,j,k,l);
            }
          }
        }
      }
    }
   // Return reference to object itself (i.e. de-reference this pointer)
   return *this;
  }


 /// One parameter constructor produces a  nxnxnxn tensor
 RankFourTensor(const unsigned long &n) 
  {
   // Set row and column lengths
   N=n; M=n; P=n; Q=n;
   // Assign space for the n rows
   Tensordata = new T[N*M*P*Q];
   //Initialise to zero if required
#ifdef OOMPH_INITIALISE_DENSE_MATRICES
   initialise(T(0));
#endif
  }
 
 /// Four parameter constructor, general non-square tensor
 RankFourTensor(const unsigned long &n_index1, const unsigned long &n_index2,
                const unsigned long &n_index3, const unsigned long &n_index4)
  {
   // Set row and column lengths
   N=n_index1; M=n_index2; P=n_index3; Q=n_index4;
   // Assign space for the n rows
   Tensordata = new T[N*M*P*Q];
   //Initialise to zero if required
#ifdef OOMPH_INITIALISE_DENSE_MATRICES
   initialise(T(0));
#endif
  }


 /// Four parameter constructor, general non-square tensor
 RankFourTensor(const unsigned long &n_index1, const unsigned long &n_index2,
                const unsigned long &n_index3, const unsigned long &n_index4, 
                const T &initial_val)
  {
   // Set row and column lengths
   N=n_index1; M=n_index2; P=n_index3; Q=n_index4;
   // Assign space for the n rows
   Tensordata = new T[N*M*P*Q];
   //Initialise to the initial value
   initialise(initial_val);
  }

 /// Destructor: delete the pointers
 virtual ~RankFourTensor() {delete[] Tensordata; Tensordata = 0;}

 /// Resize to a square nxnxnxn tensor
 void resize(const unsigned long &n) {resize(n,n,n,n);}
 
 /// Resize to a general tensor
 void resize(const unsigned long &n_index1, const unsigned long &n_index2,
             const unsigned long &n_index3, const unsigned long &n_index4)
  {
   //If the sizes have not changed do nothing
   if((n_index1==N) && (n_index2==M) && (n_index3==P) && (n_index4==Q)) 
    {return;}
   // Store old sizes
   unsigned long n_old=N, m_old=M, p_old=P, q_old=Q;
   // Reassign the sizes
   N=n_index1; M=n_index2; P=n_index3; Q=n_index4;
   // Store pointer to old matrix data
   T* temp_tensor = Tensordata;
   // Re-create Tensordata in new size
   Tensordata = new T[N*M*P*Q];
#ifdef OOMPH_INITIALISE_DENSE_MATRICES
   initialise(T(0));
#endif
   // Transfer values
   unsigned long n_copy, m_copy, p_copy, q_copy;
   n_copy = std::min(n_old,n_index1);
   m_copy = std::min(m_old,n_index2);
   p_copy = std::min(p_old,n_index3);
   q_copy = std::min(q_old,n_index4);
   // If matrix has values, transfer them to new matrix
   // Loop over rows
   for (unsigned long i=0;i<n_copy;i++)
    {
     // Loop over columns
     for (unsigned long j=0;j<m_copy;j++)
      {
       // Loop over columns
       for (unsigned long k=0;k<p_copy;k++)
        {
         // Loop over columns
         for (unsigned long l=0;l<q_copy;l++)
          {
           // Transfer values from temp_tensor
           Tensordata[Q*(M*P*i + P*j + k) +l] = 
            temp_tensor[q_old*(m_old*p_old*i + p_old*j + k)+ l];
          }
        }
      }
    }
   // Now kill storage for old tensor
   delete[] temp_tensor;
  }

 /// Resize to a general tensor
 void resize(const unsigned long &n_index1, const unsigned long &n_index2,
             const unsigned long &n_index3, const unsigned long &n_index4,
             const T &initial_value)
  {
   //If the sizes have not changed do nothing
   if((n_index1==N) && (n_index2==M) && (n_index3==P) && (n_index4==Q))
    {return;}
   // Store old sizes
   unsigned long n_old=N, m_old=M, p_old=P, q_old=Q;
   // Reassign the sizes
   N=n_index1; M=n_index2; P=n_index3; Q=n_index4;
   // Store triple pointer to old matrix data
   T* temp_tensor = Tensordata;
   // Re-create Tensordata in new size
   Tensordata = new T[N*M*P*Q];
   //Initialise the newly allocated storage
   initialise(initial_value);

   // Transfer values
   unsigned long n_copy, m_copy, p_copy, q_copy;
   n_copy = std::min(n_old,n_index1);
   m_copy = std::min(m_old,n_index2);
   p_copy = std::min(p_old,n_index3);
   q_copy = std::min(q_old,n_index4);
   // If matrix has values, transfer them to new matrix
   // Loop over rows
   for (unsigned long i=0;i<n_copy;i++)
    {
     // Loop over columns
     for (unsigned long j=0;j<m_copy;j++)
      {
       // Loop over columns
       for (unsigned long k=0;k<p_copy;k++)
        {
         // Loop over columns
         for (unsigned long l=0;l<q_copy;l++)
          {
           // Transfer values from temp_tensor
           Tensordata[Q*(M*P*i + P*j + k) +l] = 
            temp_tensor[q_old*(m_old*p_old*i + p_old*j + k)+ l];
          }
        }
      }
    }
   // Now kill storage for old tensor
   delete[] temp_tensor;
  }
 
 /// \short Initialise all values in the tensor to val
 void initialise(const T &val)
  {for(unsigned long i=0;i<(N*M*P*Q);++i) {Tensordata[i] = val;}}
 
 /// Return the range of index 1 of the tensor
 unsigned long nindex1() const {return N;}

 /// Return the range of index 2 of the tensor
 unsigned long nindex2() const {return M;}

 /// Return the range of index 3 of the tensor
 unsigned long nindex3() const {return P;}

 /// Return the range of index 4 of the tensor
 unsigned long nindex4() const {return Q;}
 
 /// Overload the round brackets to give access as a(i,j,k,l)
 inline T &operator()(const unsigned long &i, const unsigned long &j,
                      const unsigned long &k, const unsigned long &l) 
  {
#ifdef RANGE_CHECKING
   this->range_check(i,j,k,l);
#endif  
   return Tensordata[Q*(P*(M*i + j) + k)+l];
  }
 
 /// Overload a const version for read-only access as a(i,j,k,l)
 inline const T &operator()(const unsigned long &i, 
                            const unsigned long &j,
                            const unsigned long &k, 
                            const unsigned long &l) const
  {
#ifdef RANGE_CHECKING
   this->range_check(i,j,k,l);
#endif
   return Tensordata[Q*(P*(M*i + j) + k)+l];
  }
 
};  

//////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////

//=======================================================================
/// \short A class for compressed column matrices: a sparse matrix format
/// The class is passed as the MATRIX_TYPE paramater so that the base
/// class can use the specific access functions in the round-bracket
/// operator.
//=======================================================================
template<class T>
class CCMatrix : public SparseMatrix<T, CCMatrix<T> >
{

  public:

 /// Default constructor
 CCMatrix() : SparseMatrix<T, CCMatrix<T> >()
  {
   Row_index=0;
   Column_start=0;
  }


 /// \short Constructor: Pass vector of values, vector of row indices,
 /// vector of column starts and number of rows (can be suppressed
 /// for square matrices). Number of nonzero entries is read
 /// off from value, so make sure the vector has been shrunk
 /// to its correct length.
 CCMatrix(const Vector<T>& value, const Vector<int>& row_index,
          const Vector<int>& column_start,
          const unsigned long &n,
          const unsigned long &m) : SparseMatrix<T, CCMatrix<T> >()
  {
   Row_index=0;
   Column_start=0;
   build(value,row_index,column_start,n,m);
  }

 
 /// \short Copy constructor
 CCMatrix(const CCMatrix& source_matrix) : 
  SparseMatrix<T, CCMatrix<T> >(source_matrix)
  {
   //NNz, N and M are set the the copy constructor of the SparseMatrix
   //called above

   // Row indices stored in C-style array
   Row_index = new int[this->Nnz];
   
   // Assign:
   for (unsigned long i=0;i<this->Nnz;i++)
    {
     Row_index[i]=source_matrix.row_index()[i];
    }
   
   // Column start:
   Column_start = new int[this->M+1];
   
   // Assign:
   for (unsigned long i=0;i<=this->M;i++)
    {
     Column_start[i]=source_matrix.column_start()[i];
    }
  }

 /// Broken assignment operator
 void operator=(const CCMatrix&) 
  {
   BrokenCopy::broken_assign("CCMatrix");
  }

 
 /// Destructor, delete any allocated memory
 virtual ~CCMatrix()
  {
   delete[] Row_index; Row_index = 0;
   delete[] Column_start; Column_start = 0;
  }
 
 /// \short Access function that will be called by the read-only round-bracket
 /// operator (const)
 const T& get_entry(const unsigned long &i, const unsigned long &j) const
  {
#ifdef RANGE_CHECKING
   this->range_check(i,j);
#endif   
   for (long k=Column_start[j];k<Column_start[j+1];k++)
    {
     if (unsigned(Row_index[k])==i)
      {
       return this->Value[k];
      }
    }
   return this->Zero;
  }

 /// Read-write access is not permitted for these matrices and is
 /// deliberately broken.
 T& entry(const unsigned long &i, const unsigned long &j)
  {
   std::string error_string =
    "Non-const access not provided for the CCMatrix<T> class\n";
   error_string += "It is not possible to use round-bracket access: M(i,j)\n";
   error_string += "if M is not declared as const.\n";
   error_string += 
    "The solution (albeit ugly) is to create const reference to the matrix\n";
   error_string += " const CCMatrix<T>& read_M = M;\n";
   error_string += "Then read_M(i,j) is permitted\n";

   throw OomphLibError(error_string,
                       "CCMatrix<T>::entry()",
                       OOMPH_EXCEPTION_LOCATION);

   // Dummy return
   T dummy;
   return dummy;
  }
 
 /// Access to C-style column_start array
 int* column_start() {return Column_start;}

 /// Access to C-style column_start array (const version)
 const int* column_start() const {return Column_start;}

 /// Access to C-style row index array
 int* row_index() {return Row_index;}

 /// Access to C-style row index array (const version)
 const int* row_index() const {return Row_index;}

 /// \short Indexed output function to print a matrix to the
 /// stream outfile as i,j,a(i,j) for a(i,j)!=0 only
 void sparse_indexed_output(std::ostream &outfile)
  {
   for (unsigned long j=0;j<this->N;j++)
    {
     for (long k=Column_start[j];k<Column_start[j+1];k++)
      {
       outfile << Row_index[k] <<  " " << j
               <<  " " << this->Value[k] << std::endl;
      }
    }
  }


 /// \short Indexed output function to print a matrix to a
 /// file as i,j,a(i,j) for a(i,j)!=0 only. Specify filename.
 void sparse_indexed_output(std::string filename)
  {
   // Open file
   std::ofstream some_file;
   some_file.open(filename.c_str());
   sparse_indexed_output(some_file);
   some_file.close();
  }


 /// Wipe matrix data and set all values to 0.
 void clean_up_memory();


 /// \short Build matrix from compressed representation.
 /// Number of nonzero entries is read
 /// off from value, so make sure the vector has been shrunk
 /// to its correct length. 
 void build(const Vector<T>& value, const Vector<int>& row_index,
            const Vector<int>& column_start, 
            const unsigned long &n,
            const unsigned long &m);

 /// \short Function to build matrix from pointers to arrays 
 /// which hold the column starts, row indices and non-zero values.
 /// The final parameters specifies the number of rows and columns.
 /// Note that, as the name suggests, this function does not
 /// make a copy of the data pointed to by the first three arguments!
 void build_without_copy(T* value,
                         int* row_index,
                         int* column_start,
                         const unsigned long &nnz,
                         const unsigned long &n,
                         const unsigned long &m);


  protected:

 /// Row index
 int* Row_index;

 /// Start index for column
 int* Column_start;
 
};

///////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////


//=================================================================
/// \short A class for compressed column matrices that store doubles
//=================================================================
class CCDoubleMatrix : public DoubleMatrixBase,
                       public CCMatrix<double>
{
 
  public:

 /// Default constructor
 CCDoubleMatrix();
  
 /// \short Constructor: Pass vector of values, vector of row indices,
 /// vector of column starts and number of rows (can be suppressed
 /// for square matrices). Number of nonzero entries is read
 /// off from value, so make sure the vector has been shrunk
 /// to its correct length.
 CCDoubleMatrix(const Vector<double>& value,
                const Vector<int>& row_index,
                const Vector<int>& column_start,
                const unsigned long &n,
                const unsigned long &m);
 
 /// Broken copy constructor
 CCDoubleMatrix(const CCDoubleMatrix& matrix) 
  {
   BrokenCopy::broken_copy("CCDoubleMatrix");
  } 
 
 /// Broken assignment operator
 void operator=(const CCDoubleMatrix&) 
  {
   BrokenCopy::broken_assign("CCDoubleMatrix");
  }

 /// Destructor: Kill the LU factors if they have been setup.
 virtual ~CCDoubleMatrix();

  /// Return the number of rows of the matrix
 inline unsigned long nrow() const {return CCMatrix<double>::nrow();}
 
 /// Return the number of columns of the matrix
 inline unsigned long ncol() const {return CCMatrix<double>::ncol();}

 /// \short Overload the round-bracket access operator to provide
 /// read-only (const) access to the data
 inline const double& operator()(const unsigned long &i, 
                                 const unsigned long &j) 
  const {return CCMatrix<double>::get_entry(i,j);}
 
 /// \short LU decomposition using SuperLU
 virtual void ludecompose();

 /// \short LU back solve for given RHS
 virtual void lubksub(Vector<double> &rhs);

 /// \short Find the residulal to x of Ax=b, ie r=b-Ax
 void residual(const Vector<double> &x, const Vector<double> &b,
               Vector<double> &residual);

 /// \short Work out residual vector r = b-Ax for candidate solution x
 /// and return max. entry in residual vector.
 double residual(const Vector<double> &x,
                 const Vector<double> &b);

 /// \short Multiply the matrix by the vector x: soln=Ax
 void multiply(const Vector<double> &x, Vector<double> &soln);


 /// \short Multiply the  transposed matrix by the vector x: soln=A^T x
 void multiply_transpose(const Vector<double> &x,
                         Vector<double> &soln);


 /// \short Function to multiply this matrix by the CCDoubleMatrix matrix_in
 /// The multiplication method used can be selected using the flag
 /// Matrix_matrix_multiply_method. By default Method 2 is used.
 /// Method 1: First runs through this matrix and matrix_in to find the storage
 ///           requirements for result - arrays of the correct size are 
 ///           then allocated before performing the calculation.
 ///           Minimises memory requirements but more costly.
 /// Method 2: Grows storage for values and column indices of result 'on the
 ///           fly' using an array of maps. Faster but more memory
 ///           intensive.
 /// Method 3: Grows storage for values and column indices of result 'on the
 ///           fly' using a vector of vectors. Not particularly impressive
 ///           on the platforms we tried...
 void multiply(const CCDoubleMatrix& matrix_in, CCDoubleMatrix& result);
  
  
 /// \short For every row, find the maximum absolute value of the
 /// entries in this row. Set all values that are less than alpha times
 /// this maximum to zero and return the resulting matrix in
 /// reduced_matrix. Note: Diagonal entries are retained regardless
 /// of their size. 
 void matrix_reduction(const double &alpha,
                       CCDoubleMatrix& reduced_matrix);
 
 /// \short Access function to Matrix_matrix_multiply_method, the flag
 /// which determines the matrix matrix multiplication method used.
 /// Method 1: First runs through this matrix and matrix_in to find the storage
 ///           requirements for result - arrays of the correct size are 
 ///           then allocated before performing the calculation.
 ///           Minimises memory requirements but more costly.
 /// Method 2: Grows storage for values and column indices of result 'on the
 ///           fly' using an array of maps. Faster but more memory
 ///           intensive.
 /// Method 3: Grows storage for values and column indices of result 'on the
 ///           fly' using a vector of vectors. Not particularly impressive
 ///           on the platforms we tried...
 unsigned& matrix_matrix_multiply_method() 
  { 
   return Matrix_matrix_multiply_method; 
  }
 
  private:
 
 /// Flag to determine which matrix-matrix multiplication method is used.
 unsigned Matrix_matrix_multiply_method;

};




/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////



//============================================================================
/// Constructor to build a square n by n matrix
//============================================================================
template<class T>
DenseMatrix<T>::DenseMatrix(const unsigned long &n)
{
 // Set row and column lengths
 N=n; M=n;
 // Assign space for the n rows
 Matrixdata = new T[n*n];
 //Initialise to zero if required
#ifdef OOMPH_INITIALISE_DENSE_MATRICES
 initialise(T(0));
#endif
}


//============================================================================
/// Constructor to build a matrix with n rows and m columns
//============================================================================
template<class T>
DenseMatrix<T>::DenseMatrix(const unsigned long &n, 
                            const unsigned long &m)
{
 // Set row and column lengths
 N=n; M=m;
 // Assign space for the n rows
 Matrixdata = new T[n*m];
#ifdef OOMPH_INITIALISE_DENSE_MATRICES
 initialise(T(0));
#endif
}

//============================================================================
/// \short Constructor to build a matrix with n rows and m columns,
/// with initial value initial_val
//============================================================================
template<class T>
DenseMatrix<T>::DenseMatrix(const unsigned long &n, const unsigned long &m,
                            const T &initial_val)
{
 // Set row and column lengths
 N=n; M=m;
 // Assign space for the n rows
 Matrixdata = new T[n*m];
 initialise(initial_val);
}


//============================================================================
/// \short Resize to a non-square n_row x m_col matrix,
/// where any values already present will be transfered.
//============================================================================
template<class T>
void DenseMatrix<T>::resize(const unsigned long &n,
                            const unsigned long &m)
{
 //If the sizes are the same, do nothing
 if((n==N) && (m==M)) {return;}
 // Store old sizes
 unsigned long n_old=N, m_old=M;
 // Reassign the sizes
 N=n; M=m;
 // Store double pointer to old matrix data
 T* temp_matrix = Matrixdata;

 // Re-create Matrixdata in new size
 Matrixdata = new T[n*m];
 //Initialise to zero
#ifdef OOMPH_INITIALISE_DENSE_MATRICES 
 initialise(T(0));
#endif

 // Transfer previously existing values
 unsigned long n_copy, m_copy;
 n_copy = std::min(n_old,n); m_copy = std::min(m_old,m);

 // If matrix has values, transfer them to new matrix
 // Loop over rows
 for(unsigned long i=0;i<n_copy;i++)
  {
   // Loop over columns
   for (unsigned long j=0;j<m_copy;j++)
    {
     // Transfer values from temp_matrix
     Matrixdata[m*i+j] = temp_matrix[m_old*i+j];
    }
  }
 
 // Now kill storage for old matrix
 delete[] temp_matrix;
}



//============================================================================
/// \short Resize to a non-square n_row x m_col matrix and initialize the 
/// new entries to specified value.
//============================================================================
template<class T>
void DenseMatrix<T>::resize(const unsigned long &n,
                            const unsigned long &m, 
                            const T &initial_value)
{
 //If the size is not changed, just return
 if((n==N) && (m==M)) {return;}
 // Store old sizes
 unsigned long n_old=N, m_old=M;
 // Reassign the sizes
 N=n; M=m;
 // Store double pointer to old matrix data
 T* temp_matrix = Matrixdata;
 // Re-create Matrixdata in new size
 Matrixdata = new T[n*m];
 // Assign initial value (will use the newly allocated data)
 initialise(initial_value);
 
 // Transfering values
 unsigned long n_copy, m_copy;
 n_copy = std::min(n_old,n); m_copy = std::min(m_old,m);
 // If matrix has values, transfer them to temp_matrix
 // Loop over rows
 for (unsigned long i=0;i<n_copy;i++)
  {
   // Loop over columns
   for (unsigned long j=0;j<m_copy;j++)
    {
     // Transfer values to temp_matrix
     Matrixdata[m*i+j] = temp_matrix[m_old*i+j];
    }
  }

 // Now kill storage for old matrix
 delete[] temp_matrix;
}



//============================================================================
/// Output function to print a matrix row-by-row to the stream outfile
//============================================================================
template<class T>
void DenseMatrix<T>::output(std::ostream &outfile)
{
 //Loop over the rows
 for(unsigned i=0;i<N;i++)
  {
   //Loop over the columne
   for(unsigned j=0;j<M;j++)
    {
     outfile << (*this)(i,j) << " ";
    }
   //Put in a newline
   outfile << std::endl;
  }
}



//============================================================================
/// Output function to print a matrix row-by-row to a file. Specify filename.
//============================================================================
template<class T>
void DenseMatrix<T>::output(std::string filename)
{
 // Open file
 std::ofstream some_file;
 some_file.open(filename.c_str());
   
 output(some_file);
 some_file.close();
}



//============================================================================
/// Indexed output as i,j,a(i,j)
//============================================================================
template<class T>
void DenseMatrix<T>::indexed_output(std::ostream &outfile)
{
 //Loop over the rows
 for(unsigned i=0;i<N;i++)
  {
   //Loop over the columns
   for(unsigned j=0;j<M;j++)
    {
     outfile << i << " " << j << " " << (*this)(i,j) << std::endl;
    }
  }
}



//============================================================================
/// \short Indexed output function to print a matrix to a
/// file as i,j,a(i,j). Specify filename.
//============================================================================
template<class T>
void DenseMatrix<T>::indexed_output(std::string filename)
{
 // Open file
 std::ofstream some_file;
 some_file.open(filename.c_str());
 indexed_output(some_file);
 some_file.close();
}



//============================================================================
/// Sparse indexed output as i,j,a(i,j) for a(i,j)!=0 only
//============================================================================
template<class T>
void DenseMatrix<T>::sparse_indexed_output(std::ostream &outfile)
{
 //Loop over the rows
 for(unsigned i=0;i<N;i++)
  {
   //Loop over the columne
   for(unsigned j=0;j<M;j++)
    {
     if ((*this)(i,j)!=T(0))
      {
       outfile << i << " " << j << " " << (*this)(i,j) << std::endl;
      }
    }
  }
}



//============================================================================
/// \short Indexed output function to print a matrix to a 
/// file as i,j,a(i,j) for a(i,j)!=0 only. Specify filename.
//============================================================================
template<class T>
void DenseMatrix<T>::sparse_indexed_output(std::string filename)
{
 // Open file
 std::ofstream some_file;
 some_file.open(filename.c_str());
 sparse_indexed_output(some_file);
 some_file.close();
}



////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////


//=============================================================================
/// Wipe matrix data and set all values to 0.
//=============================================================================
template<class T>
void CCMatrix<T>::clean_up_memory()
{
 // delete any previously allocated  storage
 if (this->Value!=0)
 {
  delete[] this->Value;
  this->Value=0;
 }
 if (this->Row_index!=0)
 {
  delete[] this->Row_index;
  this->Row_index=0;
 }
 if (this->Column_start!=0)
 {
  delete[] this->Column_start;
  this->Column_start=0;
 }
 this->Nnz=0;
 this->N=0;
 this->M=0;
}



//=============================================================================
/// Build matrix from compressed representation.
/// Note that, as the name suggests, this function does not
/// make a copy of the data pointed to by the first three arguments!
//=============================================================================
template<class T>
void CCMatrix<T>::build_without_copy(T* value,
                                     int* row_index,
                                     int* column_start,
                                     const unsigned long& nnz,
                                     const unsigned long& n,
                                     const unsigned long& m)
{
 // Number of nonzero entries
 this->Nnz=nnz;

 // Number of rows
 this->N=n;

 // Number of columns
 this->M=m;

 // delete any previously allocated  storage
 if(this->Value!=0) {delete[] this->Value;}
 if(this->Row_index!=0) {delete[] this->Row_index;}
 if(this->Column_start!=0) {delete[] this->Column_start;}

 // set Value
 this->Value = value;

 // set Row_index
 this->Row_index = row_index;

 // set Column_start
 this->Column_start = column_start;

}


//===================================================================
/// Build matrix from compressed representation.
/// Number of nonzero entries is read
/// off from value, so make sure the vector has been shrunk
/// to its correct length. 
//===================================================================
template<class T>
void CCMatrix<T>::build(const Vector<T>& value, 
                        const Vector<int>& row_index,
                        const Vector<int>& column_start, 
                        const unsigned long &n,
                        const unsigned long &m)
{
 
#ifdef PARANOID
 if (value.size()!=row_index.size())
  {
   std::ostringstream error_message;
   error_message 
    << "length of value " << value.size() 
    << " and row_index vectors " << row_index.size() <<" should match " 
    << std::endl;

   throw OomphLibError(error_message.str(),
                       "CCMatrix::build()",
                       OOMPH_EXCEPTION_LOCATION);
  }
#endif
 
 // Number of nonzero entries
 this->Nnz = value.size();
 
 //Number of rows
 this->N = n;

 // Number of columns
 this->M = m;
 
 //We need to delete any previously allocated  storage
 if(this->Value!=0) {delete[] this->Value;}
 if(this->Row_index!=0) {delete[] this->Row_index;}
 if(this->Column_start!=0) {delete[] this->Column_start;}

 // Values stored in C-style array
 this->Value = new T[this->Nnz];
 
 // Row indices stored in C-style array
 this->Row_index = new int[this->Nnz];
 
 // Assign:
 for (unsigned long i=0;i<this->Nnz;i++)
  {
   this->Value[i]=value[i];
   this->Row_index[i]=row_index[i];
  }
 
 // Column start:
 //Find the size and aollcate
 unsigned long n_column_start = column_start.size();
 this->Column_start = new int[n_column_start];
 
 // Assign:
 for (unsigned long i=0;i<n_column_start;i++)
  {
   this->Column_start[i]=column_start[i];
  }
}

/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////




//=============================================================================
/// Wipe matrix data and set all values to 0.
//=============================================================================
template<class T>
void CRMatrix<T>::clean_up_memory()
{
 // delete any previously allocated  storage
 if (this->Value!=0)
 {
  delete[] this->Value;
  this->Value=0;
 }
 if (this->Column_index!=0)
 {
  delete[] this->Column_index;
  this->Column_index=0;
 }
 if (this->Row_start!=0)
 {
  delete[] this->Row_start;
  this->Row_start=0;
 }
 this->Nnz=0;
 this->N=0;
 this->M=0;
}



//=============================================================================
/// Function to build a CRMatrix from pointers to arrays which hold the
/// row starts, column indices and non-zero values
/// Note that, as the name suggests, this function does not
/// make a copy of the data pointed to by the first three arguments!
//=============================================================================
template<class T>
void CRMatrix<T>::build_without_copy(T* value,
                                     int* column_index,
                                     int* row_start,
                                     const unsigned long& nnz,
                                     const unsigned long& n,
                                     const unsigned long& m)
{
 // Number of nonzero entries
 this->Nnz = nnz;
 
 // Number of rows
 this->N = n;
 
 // Number of columns
 this->M = m;

 // delete any previously allocated  storage
 if(this->Value!=0) {delete[] this->Value;}
 if(this->Column_index!=0) {delete[] this->Column_index;}
 if(this->Row_start!=0) {delete[] this->Row_start;}

 // set Value
 this->Value = value;

 // set Column_index
 this->Column_index = column_index;

 // set Row_start
 this->Row_start = row_start;
}



//=================================================================
/// Build matrix from compressed representation.
/// Number of nonzero entries is read
/// off from value, so make sure the vector has been shrunk
/// to its correct length. The optional final
/// parameter specifies the number of columns. If it is not specified
/// the matrix is assumed to be quadratic.
//=================================================================
template<class T>
void CRMatrix<T>::build(const Vector<T>& value, 
                        const Vector<int>& column_index,
                        const Vector<int>& row_start,
                        const unsigned long &n,
                        const unsigned long &m)
{
 // Number of nonzero entries
 this->Nnz = value.size();
 
 // Number of rows
 this->N = n;
 
 // Number of columns
 this->M = m;
 
 //We need to delete any previously allocated  storage
 if(this->Value!=0) {delete[] this->Value;}
 if(this->Column_index!=0) {delete[] this->Column_index;}
 if(this->Row_start!=0) {delete[] this->Row_start;}

 // Values stored in C-style array
 this->Value = new T[this->Nnz];
 
 // Column indices stored in C-style array
 this->Column_index = new int[this->Nnz];
 
 // Assign:
 for (unsigned long i=0;i<this->Nnz;i++)
  {
   this->Value[i]=value[i];
   this->Column_index[i]=column_index[i];
  }
 
 // Row start:
 // Find the size and allocate
 unsigned long n_row_start = row_start.size();
 this->Row_start = new int[n_row_start];
 
 // Assign:
 for (unsigned long i=0;i<n_row_start;i++)
  {
   this->Row_start[i]=row_start[i];
  } 
}


//=================================================================
/// \short Dummy zero
//=================================================================
template<class T,class MATRIX_TYPE>
 T SparseMatrix<T,MATRIX_TYPE>::Zero=T(0);

}

#endif




