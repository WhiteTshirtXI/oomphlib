#ifndef OOMPH_COMMUNICATOR_CLASS_HEADER
#define OOMPH_COMMUNICATOR_CLASS_HEADER

// Config header generated by autoconfig
#ifdef HAVE_CONFIG_H
  #include <oomph-lib-config.h>
#endif

// MPI headers
#ifdef OOMPH_HAS_MPI
#include "mpi.h"
#endif

//Oomph-libe error handler
#include "oomph_definitions.h"
#include "oomph_utilities.h"

namespace oomph{

//=============================================================================
/// \short An oomph-lib wrapper to the MPI_Comm communicator object. Just 
/// contains an MPI_Comm object (which is a pointer) and wrappers to
/// the MPI_... methods.
//=============================================================================
class OomphCommunicator
{

  public:

#ifdef OOMPH_HAS_MPI
 /// Construct a communicator from a MPI_Comm object. \n
 /// if the bool owns_mpi_comm is true then this communicator is responsible
 /// for the destruction of the mpi_communicator. The mpi comm will be freed
 /// when the destructor is called.
 OomphCommunicator(const MPI_Comm mpi_communicator, 
                   const bool& owns_mpi_comm = false)
  : Serial_communicator(false)
  {
   // store a pointer to the communicator
   Comm = mpi_communicator;
   
   // hold owns_mpi_comm
   Owns_mpi_comm = owns_mpi_comm;
  }
#endif

 /// Serial constructor
 OomphCommunicator()
#ifdef OOMPH_HAS_MPI
  :  Owns_mpi_comm(false), Serial_communicator(true)
#endif
  {}

 /// Copy constructor.
 OomphCommunicator(const OomphCommunicator& communicator)
#ifdef OOMPH_HAS_MPI
  : Owns_mpi_comm(false)
  {
   if (communicator.serial_communicator())
    {
     Serial_communicator = true;
    }
   else
    {
     Comm = communicator.mpi_comm();
     Serial_communicator = false;
    }
  }
#else
 {}
#endif

 /// Pointer (copy) constructor.
 OomphCommunicator(const OomphCommunicator* communicator_pt)
#ifdef OOMPH_HAS_MPI
  : Owns_mpi_comm(false)
  {
   if (communicator_pt->serial_communicator())
    {
     Serial_communicator = true;
    }
   else
    {
     Comm = communicator_pt->mpi_comm();
     Serial_communicator = false;
    }
  }
#else
 {}
#endif

 /// \short Destructor. If MPI and this preconditioner owns the MPI_Comm 
 /// object then MPI_Comm_free is called, otherwise nothing happens as
 /// the destruction of the underlying MPI_Comm object is the responsibility
 /// of another communicator.
 ~OomphCommunicator()
  {
#ifdef OOMPH_HAS_MPI
   if (Owns_mpi_comm)
    {
     MPI_Comm_free(&Comm);
    }
#endif
  }

 /// assignment operator
 void operator=(const OomphCommunicator& communicator)
   {
#ifdef OOMPH_HAS_MPI
     if (Owns_mpi_comm)
       {
	 MPI_Comm_free(&Comm);
       }
     Owns_mpi_comm = false;
     if (communicator.serial_communicator())
      {
       Serial_communicator = true;
      }
     else
      {
       Serial_communicator = false;
       Comm = communicator.mpi_comm();
      }
#endif
   }
   
 /// number of processors
 int nproc() const
  {
#ifdef OOMPH_HAS_MPI
   if (Serial_communicator)
    {
     return 1;
    }
   else
    {
     int nproc;
     MPI_Comm_size(Comm,&nproc);
     return nproc;
    }
#else
   return 1;
#endif
  }

 /// my rank
 int my_rank() const
  {
#ifdef OOMPH_HAS_MPI
   if (Serial_communicator)
    {
     return 0;
    }
   else
    {
     int my_rank;
     MPI_Comm_rank(Comm,&my_rank);
     return my_rank;
    }
#else
   return 0;
#endif
  }

 /// \short == operator - only returns true if communicators are MPI_IDENT,
 /// i.e. if both group and context are the same
 bool operator==(const OomphCommunicator& other_comm)
  {
#ifdef OOMPH_HAS_MPI
   if (Serial_communicator != other_comm.serial_communicator())
    {
     return false;
    }
   else if (Serial_communicator)
    {
     return true;
    }
   else
    {
     int flag;
     MPI_Comm_compare(Comm,other_comm.mpi_comm(),&flag);
     if (flag == MPI_IDENT)
      {
       return true;
      }
     return false;
    }
#else
   return true;
#endif
  }

 /// \short != operator returns !(==operator) (see ==operator for more details)
 bool operator!=(const OomphCommunicator& other_comm)
  {
   return !(*this == other_comm);
  }

#ifdef OOMPH_HAS_MPI
 /// \short split the communicator: color is an integer label for the sub
 /// group of processors. key is the rank in this sub group
 OomphCommunicator* split(const int& color, const int& key)
  {
#ifdef PARANOID
   if (Serial_communicator)
    {
     std::ostringstream error_message_stream;                           
     error_message_stream                                        
      << "Attempted to split a serial communicator.";               
     throw OomphLibError(error_message_stream.str(),                  
                         "OomphCommunicator::split()",                             
                         OOMPH_EXCEPTION_LOCATION);         
    }
#endif

   // pointer for the split oomph-lib communicator
   OomphCommunicator* split_comm_pt;
   
   // the pointer for the new mpi communicator
   MPI_Comm* mpi_comm_pt = new MPI_Comm;

   // get the split communicator
   MPI_Comm_split(Comm,color,key,mpi_comm_pt);

   // assemble the new oomph-lib ocmmunicator
   // the new oomph-lib communicator owns the MPI_Comm at mpi_comm_pt
   // and is responsible for its destruction
   split_comm_pt = new OomphCommunicator(*mpi_comm_pt,true);

   // and return
   return split_comm_pt;
  }
#endif


#ifdef OOMPH_HAS_MPI
 /// access function to the underlying MPI_Comm object
 MPI_Comm mpi_comm() const 
  {
#ifdef PARANOID
   if (Serial_communicator)
    {
     std::ostringstream error_message_stream;                           
     error_message_stream                                        
      << "Requested the MPI_Comm object for a serial communicator.";               
     throw OomphLibError(error_message_stream.str(),                  
                         "OomphCommunicator::mpi_comm()",                             
                         OOMPH_EXCEPTION_LOCATION);         
    }
#endif
   return Comm;
  }
 

 /// access function to the serial communicator flag
 const bool serial_communicator() const
  {
   return Serial_communicator;
  }

#endif

  private:

#ifdef OOMPH_HAS_MPI
 /// the MPI_Comm communicator
 MPI_Comm Comm;

 /// \short boolean indiacting whether this communicator owns the underlying 
 /// MPI_Comm - if so the destructor will free
 /// the communicator
 bool Owns_mpi_comm;

 /// \short boolean to indicate if this communicator is for serial problems.\n
 /// This is true when serial codes are compiled under MPI
 bool Serial_communicator;

#endif
}; // end of class Communicator
} // end of oomph namespace
#endif
