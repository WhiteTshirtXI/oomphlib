//LIC// ====================================================================
//LIC// This file forms part of oomph-lib, the object-oriented, 
//LIC// multi-physics finite-element library, available 
//LIC// at http://www.oomph-lib.org.
//LIC// 
//LIC//           Version 0.85. June 9, 2008.
//LIC// 
//LIC// Copyright (C) 2006-2008 Matthias Heil and Andrew Hazel
//LIC// 
//LIC// This library is free software; you can redistribute it and/or
//LIC// modify it under the terms of the GNU Lesser General Public
//LIC// License as published by the Free Software Foundation; either
//LIC// version 2.1 of the License, or (at your option) any later version.
//LIC// 
//LIC// This library is distributed in the hope that it will be useful,
//LIC// but WITHOUT ANY WARRANTY; without even the implied warranty of
//LIC// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//LIC// Lesser General Public License for more details.
//LIC// 
//LIC// You should have received a copy of the GNU Lesser General Public
//LIC// License along with this library; if not, write to the Free Software
//LIC// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
//LIC// 02110-1301  USA.
//LIC// 
//LIC// The authors may be contacted at oomph-lib@maths.man.ac.uk.
//LIC// 
//LIC//====================================================================
#ifndef OOMPH_FSI_HEADER
#define OOMPH_FSI_HEADER

// Config header generated by autoconfig
#ifdef HAVE_CONFIG_H
  #include <oomph-lib-config.h>
#endif

#include<algorithm>

//oomph-lib headers
#include "elements.h"
#include "mesh.h"
#include "geom_objects.h"
#include "face_element_as_geometric_object.h"
#include "mesh_as_geometric_object.h"
#include "integral.h"

namespace oomph
{

class AlgebraicNode;


////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
// FSIFluidElement
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////


//=========================================================================
/// \short The FSIFluidElement class is a base class for all
/// fluid finite elements that apply a load (traction) onto an adjacent 
/// SolidFiniteElement. 
//=========================================================================
class FSIFluidElement : public virtual FiniteElement
{

  public:
 
 /// Constructor
 FSIFluidElement() : FiniteElement() {}
 

 /// Broken copy constructor
 FSIFluidElement(const FSIFluidElement&) 
  { 
   BrokenCopy::broken_copy("FSIFluidElement");
  } 
 
 /// Broken assignment operator
 void operator=(const FSIFluidElement&) 
  {
   BrokenCopy::broken_assign("FSIFluidElement");
  }

 /// \short Compute the load vector that is applied by current
 /// element (at its local coordinate s) onto the adjacent
 /// SolidElement. N is the outer unit normal on the FSIFluidElement.
 virtual void get_load(const Vector<double> &s, 
                       const Vector<double> &N,
                       Vector<double> &load)=0;
 

 /// \short Add to the set \c paired_load_data pairs containing
 /// - the pointer to a Data object
 /// and
 /// - the index of the value in that Data object
 /// .
 /// for all values (pressures, velocities) that affect the
 /// load computed in the \c get_load(...) function.
 virtual void identify_load_data(std::set<std::pair<Data*,unsigned> >&
                                 paired_load_data)=0;
 

};



/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////




//=========================================================================
/// \short This is a base class for all SolidFiniteElements
/// that participate in FSI computations. These elements
/// provide interfaces and generic funcionality for
/// the two additional roles that SolidFiniteElements play
/// in FSI problems:
/// -# They parameterise the domain boundary for the fluid domain.
///    To allow them to play this role, FSIWallElements are derived
///    from the SolidFiniteElement and the GeomObject class, 
///    indicating that the every specific FSIWallElement must
///    implement the pure virtual function GeomObject::position(...)
///    which should compute the position vector to a point in the
///    SolidFiniteElement, parametrised by its local coordinates.
/// -# In FSI problems fluid exerts a traction onto the wall and this traction
///    must be added to any other load terms (such as an external pressure 
///    acting on an elastic pipe) that are already applied to 
///    the SolidFiniteElements by other means.
/// .
/// \n 
/// The fluid-traction on the SolidFiniteElements 
/// depends on the fluid variables (velocities and pressures) in 
/// those fluid elements that are adjacent to the SolidFiniteElements' 
/// Gauss points. In an FSI problem these velocities and pressures 
/// are unknowns in the overall problem and the dependency of the 
/// SolidFiniteElement's residual vector on these
/// unknowns must be taken into account when computing the element's
/// Jacobian matrix.
/// \n 
/// For each Gauss point in the FSIWallElement, we therefore store:
/// - [a] pointer[s] to the FSIFluidElement[s] that is [are] "adjacent"
///   to the Gauss point in the FSIWallElement.
/// - the vector[s] of the local coordinates (in the fluid element[s]) 
///   that identify the point in the fluid element that is 
///   (deemed to be) "opposite" that Gauss point. (Note
///   that we do not require the discretisations of the
///   fluid and solid domains to match exactly, therefore,
///   small "gaps" may occur between fluid and solid elements.)
/// .
/// \n
/// By default, each FSIWallElement is assumed to be exposed to fluid
/// loading only on one of its faces. For elements that are immersed
/// into fluid, so that a fluid traction is "exerted from both sides",
/// the element can store pointers to multiple adjacent fluid elements
/// (and local coordindates in these). This capability must be enabled
/// by a call to FSIWallElement::enable_fluid_loading_on_both_sides().
/// \n
/// Since the fluid traction can involve derivatives 
/// of the velocity (think of Newtonian fluids), the traction is
/// also affected by changes in the nodal positions of the adjacent fluid 
/// elements. Since fluid and solid discretisations are not
/// required to match, the nodal positions in an adjacent fluid
/// element can be affected by the positional variables in
/// another FSIWallElement. To capture this influence, we
/// provide the function FSIWallElement::node_update_adjacent_fluid_elements()
/// which does exactly what it says....
/// \n \n
/// Finally, since oomph-lib's fluid and solid
/// elements tend to employ different non-dimensionalisations
/// for the stresses, the fluid traction (computed by
/// the adjacent fluid element, on the fluid stress-scale) may have to be 
/// scaled by the ratio \f$ Q \f$ of the stresses used to non-dimensionalise
/// the two sets of stresses. For instance, for a fluid stress
/// non-dimensionalisation based on the viscous scale \f$ \mu U / L\f$
/// (as in oomph-lib's Navier-Stokes elements) and a non-dimensionalisation
/// of the solid mechanics stresses, based on a Young's modulus \f$ E \f$,
/// as in oomph-lib's KirchhoffLoveBeamElements, the stress ratio is given
/// by
/// \f[ Q=\frac{\mu U}{LE} \f]
/// For other wall/fluid element combinations the definition of \f$ Q \f$
/// will differ -- check the documentation and/or implementation to see
/// which parameters are used to non-dimensionalise the stresses
/// in the respective elements!
/// \n  \n
/// The function FSIWallElement::fluid_load_vector(...) computes
/// the fluid traction on the wall on the wall stress-scale.
/// This function may be called in the get_load (say) function of
/// a specific FSIWallElement to add the fluid load to the
/// other tractions that may already be applied to the element by other
/// means. By default a stress-ratio  of \f$ Q = 1 \f$ is used 
/// but this may be overwritten with the 
/// access function FSIWallElement::q_pt().
//=========================================================================
class FSIWallElement : public virtual SolidFiniteElement, 
 public virtual GeomObject
{

  public:

 /// \short Constructor. Note that element is not fully-functional
 /// until its setup_fsi_wall_element() function has been called!
 FSIWallElement() : Only_front_is_loaded_by_fluid(true),
  Q_pt(&Default_Q_Value),  Add_external_load_data(true) {}

 /// Broken copy constructor
 FSIWallElement(const FSIWallElement&) 
  { 
   BrokenCopy::broken_copy("FSIWallElement");
  } 
 
 /// Broken assignment operator
 void operator=(const FSIWallElement&) 
  {
   BrokenCopy::broken_assign("FSIWallElement");
  }

 /// Empty virtual destructor for safety
 virtual ~FSIWallElement() {}

 /// \short Setup: Assign storage -- pass the Eulerian 
 /// dimension of the "adjacent" fluid elements and the
 /// number of local coordinates required to parametrise
 /// the wall element. E.g. for a FSIKirchhoffLoveBeam,
 /// bounding a 2D fluid domain ndim_fluid=2 and nlagr_solid=1
 void setup_fsi_wall_element(const unsigned& nlagr_solid, 
                             const unsigned& ndim_fluid);
 
 /// \short Return the ratio of the stress scales used to non-dimensionalise
 /// the fluid and solid equations. E.g. \f$ Q = \mu U/(LE) \f$
 /// if the fluid mechanics stresses (pressures) are scaled on the 
 /// viscous scale \f$ \mu U / L\f$ and the solid mechanics stresses
 /// on the solid's Young's modulus \f$ E \f$.  
 const double &q() const {return *Q_pt;}
 
 /// \short Return a pointer the ratio of stress scales used to 
 /// non-dimensionalise the fluid and solid equations.
 double* &q_pt() {return Q_pt;}

 /// \short Pointer to FSI fluid element that is adjacent to
 /// i-th Gauss point in wall element. face=0 refers to the 
 /// data associated with the fluid
 /// element "in front" of the FSIWallElement, and the one 
 /// "at the back" (if any) for face=1.
 FSIFluidElement*& adjacent_fluid_element_pt(const unsigned& face,
                                             const unsigned& i)
  {
   return Adjacent_fluid_element_pt[face][i];
  }

 /// \short Vector of local coordinates (in the
 /// FSI fluid element) that identify the point "opposite" the  
 /// i-th Gauss point in the wall element. face=0 refers to the 
 /// data associated with the fluid
 /// element "in front" of the FSIWallElement, and the one 
 /// "at the back" (if any) for face=1.
 Vector<double>& adjacent_fluid_local_coord(const unsigned& face,
                                            const unsigned& i)
  {
   return Adjacent_fluid_local_coord[face][i];
  }

 /// \short Allow element to be loaded by fluid on both
 /// sides. (Resizes containers for lookup schemes and initialises
 /// data associated with elements at the "back" of the FSIWallElement
 /// to NULL.
 void enable_fluid_loading_on_both_sides();


 /// \short Is the element exposed to (and hence loaded by)
 /// fluid only on its "front"? True by default. This flag is set to 
 /// false if the FSIWallElement is immersed in fluid in which case
 /// each integration point is loaded by two adjacent
 /// fluid elements, one at the "front" and one at the "back".
 /// This is a read-only function -- the ability have loading
 /// from both sides must be enabled by a call to
 /// FSIWallElement::enable_fluid_loading_on_both_sides();
 bool only_front_is_loaded_by_fluid() const
  {return Only_front_is_loaded_by_fluid;}


 /// \short Do not include any external data that affects the load
 /// in the computation of element's Jacobian matrix. This 
 /// functionality is provided to allow the  "user" to deem the coupling 
 /// to the fluid equations to be
 /// irrelevant and to facilitate the solution of a auxiliary solids-only
 /// problems, e.g. during the assignment of initial conditions
 /// for a time-dependent FSI problem.
 void exclude_external_load_data() {Add_external_load_data=false;}

 /// \short Include external data that affects the load in the
 /// computation of the element's Jacobian matrix
 void include_external_load_data() {Add_external_load_data=true;}

 /// \short Update the nodal positions in all fluid elements that affect 
 /// the traction on this FSIWallElement
 void node_update_adjacent_fluid_elements();

 /// \short Return the number of Data items that affect the 
 /// fluid traction  on this element. This includes e.g. fluid velocities
 /// and pressures in adjacent fluid elements, and any geometric Data
 /// in the problem that affects the nodal positions in these fluid elements. 
 /// Note that any Data items that are already included in the
 /// FSIWallElement's internal, external or nodal Data are \b not included 
 /// its the load Data to avoid double-counting.
 unsigned nload_data() const {return Load_data_pt.size();}
   

 /// \short Return vector of pointers to the Data objects that affect the load
 /// on the element. 
 Vector<Data*> load_data_pt() const {return Load_data_pt;}

 /// \short Overload the SolidFiniteElement::assign_solid_local_eqn_numbers 
 /// function to include the load Data into the local equation 
 /// numbering procedure
 void assign_solid_local_eqn_numbers()
  {
   SolidFiniteElement::assign_solid_local_eqn_numbers();
   assign_load_data_local_eqn_numbers();
  }

 /// Fill in the element's contribution to the Jacobian matrix
 /// and the residual vector: Done by finite differencing the
 /// residual vector w.r.t. all nodal, internal, external and load Data.
 void fill_in_contribution_to_jacobian(Vector<double> &residuals,
                                       DenseMatrix<double> &jacobian)
  {
   //Add the contribution to the residuals
   fill_in_contribution_to_residuals(residuals);
   //Now do the position and other terms by finite differences
   fill_in_jacobian_from_solid_position_and_external_by_fd(jacobian);
  }



  protected:


 /// \short Get FE Jacobian by systematic finite differencing w.r.t.
 /// nodal positition Data, internal and external Data and any
 /// load Data that is not included in the previous categories.
 /// This is a re-implementation of the generic FD routines with 
 /// they key difference being that any updates of values are followed
 /// by a node update in the adjacent fluid elements since their
 /// position (and hence the shear stresses they exert onto the solid)
 /// may be indirectly affected by these. For greater efficiency
 /// this may be overloaded in derived classes, e.g. if it is known
 /// that for a specific FSIWallElement, the internal Data does not
 /// affect the nodal positions in adjacent fluid elements.
 void fill_in_jacobian_from_solid_position_and_external_by_fd(
  DenseMatrix<double>& jacobian);

 
 /// \short  Get the contribution to the load vector provided by 
 /// the adjacent fluid element: Pass number of integration point
 /// in solid element, and the unit normal vector (pointing into the fluid!) 
 /// and return the load vector.
 /// Note that the load is non-dimensionalised on the wall-stress scale, 
 /// i.e. it is obtained by computing the traction (on the fluid stress-scale)
 /// from the adjacent fluid element and then multiplying it by 
 /// the stress-scale-ratio \f$ Q. \f$. 
 void fluid_load_vector(const unsigned& intpt,
                        const Vector<double>& N,
                        Vector<double>& load);


  private:

 /// \short Assign the local equation numbers for those 
 /// Data values that affect the load on the element
 void assign_load_data_local_eqn_numbers();

 /// \short Static default value for the ratio of stress scales
 /// used in the fluid and solid equations (default is 1.0)
 static double Default_Q_Value;

 /// \short Is the element exposed to (and hence loaded by)
 /// fluid only on its "front"? True by default. This flag is set to 
 /// false if the FSIWallElement is immersed in fluid in which case
 /// each integration point is loaded by two adjacent
 /// fluid elements, one at the "front" and one at the "back".
 bool Only_front_is_loaded_by_fluid;

 /// \short Vector storing the pointers to the FSI fluid elements that
 /// overlap with the Gauss points in this FSIWallElement. This is
 /// a vector of vectors to cover the case in which the element is
 /// immersed in (and therefore loaded by) fluid from two sides.
 /// Adjacent_fluid_element_pt[0][i] points to the fluid element
 /// adjacent to the element's i-th integration point at the
 /// "front"; Adjacent_fluid_element_pt[1][i] points to the fluid
 /// element at the "back"
 Vector<Vector<FSIFluidElement*> > Adjacent_fluid_element_pt;

 /// \short Vector storing the vectors of local coordinates (in the
 /// FSI fluid element) that identify the point "opposite" the  
 /// Gauss points in this FSIWallElement. This is
 /// a vector of vectors to cover the case in which the element is
 /// immersed in (and therefore loaded by) fluid from two sides.
 /// Adjacent_fluid_local_coord[0][...][...] refers to the fluid element
 /// adjacent to the element's i-th integration point at the
 /// "front"; Adjacent_fluid_local_coord[1][...][...] refers to the fluid
 /// element at the "back"
 Vector<Vector<Vector<double> > > Adjacent_fluid_local_coord;

 /// \short Vector of pointers to external Data that affect the load
 /// on the element. N.B. This must be the same size
 /// as Load_data_index.
 Vector<Data*> Load_data_pt;

 /// \short Vector of indices of the values in the external Data addressed
 /// by Load_data_pt that affect the load on the element. N.B. This 
 /// must be the same size as Load_data_pt
 Vector<unsigned> Load_data_index;

 /// \short Vector that holds the local equation numbers associated with
 /// the external data that affects the fluid load. N.B. Must be the
 /// same size as Load_data_pt
 Vector<int> Load_data_local_eqn;

 /// \short Pointer to the ratio, \f$ Q \f$ , of the stress used to
 /// non-dimensionalise the fluid stresses to the stress used to
 /// non-dimensionalise the solid stresses.
 double *Q_pt;

 /// \short Boolean flag used to determine whether to add the external data
 /// that affects that load. Such data should *NOT* be added when SolidIC
 /// Problems are being solved.
 bool Add_external_load_data;



};


////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////




//======================================================================
// Namespace for "global" FSI functions
//======================================================================
namespace FSI_functions
{

 //============================================================================
 /// \short Apply no-slip condition for N.St. on a moving wall node,
 /// u = St dR/dt, where the Strouhal number St = a/(UT) is defined by
 /// FSI_functions::Strouhal_for_no_slip and is initialised to 1.0.
 /// Note: This requires the x,y,[z] velocity components to be stored
 /// in nodal values 0,1,[2]. This is the default for all currently
 /// existing Navier-Stokes elements. If you use any others, 
 /// use this function at your own risk. 
 //============================================================================
 extern void apply_no_slip_on_moving_wall(Node* node_pt);


 //============================================================================
 /// \short Strouhal number St = a/(UT) for application of no slip condition.
 /// Initialised to 1.0.
 //============================================================================
 extern double Strouhal_for_no_slip;

 //============================================================================
 /// \short A class to do comparison of the elements by lexicographic
 /// ordering, based on the boundary coordinates at the element's first node. 
 //============================================================================
 template<class ELEMENT>
 class CompareBoundaryCoordinate
  {
    public:
   
   ///The actual comparison operator
   int operator() (GeneralisedElement* const &element1_pt,
                   GeneralisedElement* const &element2_pt)
    {
     //OK Dynamic cast the elements
     FaceElementAsGeomObject<ELEMENT> *cast_element1_pt = 
      dynamic_cast<FaceElementAsGeomObject<ELEMENT>*>(element1_pt);
     FaceElementAsGeomObject<ELEMENT> *cast_element2_pt = 
      dynamic_cast<FaceElementAsGeomObject<ELEMENT>*>(element2_pt);

#ifdef PARANOID
     if (cast_element1_pt==0)
      {
       std::ostringstream error_message;
       error_message 
        << "Failed to cast element1_pt to a FaceElementAsGeomObject"
        << std::endl;
       throw OomphLibError(error_message.str(),
                           "CompareBoundaryCoordinate::()",
                           OOMPH_EXCEPTION_LOCATION);
      }

     if (cast_element2_pt==0)
      {
       std::ostringstream error_message;
       error_message 
        << "Failed to cast element2_pt to a FaceElementAsGeomObject"
        << std::endl;
       throw OomphLibError(error_message.str(),
                           "CompareBoundaryCoordinate::()",
                           OOMPH_EXCEPTION_LOCATION);
      }
#endif


     // Warning that this still needs to be generalised to higher
     // dimensions (don't want to implement it until I can test it
     // -- at the moment, the ordering isn't particularly important
     // anyway...
//      if (cast_element1_pt->dim()!=1)
//       {
//        std::ostringstream warn_message;
//        warn_message
//         << "Warning: Ordering of elements is currently based on their \n"
//         << "zero-th surface coordinate. This may not be appropriate for\n"
//         << cast_element1_pt->dim() << "-dimensional elements. \n";
//         OomphLibWarning(warn_message.str(),
//                         "CompareBoundaryCoordinate::()",
//                         OOMPH_EXCEPTION_LOCATION);
//       }


     return 
      cast_element1_pt->zeta_nodal(0,0,0) < 
      cast_element2_pt->zeta_nodal(0,0,0);
    }
  };
 
 
 //============================================================================
 /// \short Set up the information that the FSIWallElements
 /// in the specified solid mesh require to obtain the fluid loading from the
 /// adjacent fluid elements in the specified fluid mesh.
 /// The parameter b specifies the boundary in the fluid mesh
 /// that is adjacent to the solid mesh. The template parameters
 /// specify the type of the fluid element and their spatial
 /// dimension. The optional final argument, face, identifies the
 /// face of the FSIWallElements that is exposed to the fluid. face
 /// defaults to 0, indicating that the front is loaded along the
 /// specified fluid mesh boundary. Set it to 1 to set up the FSI lookup
 /// schemes for fluid loading along the "back" of the FSIWallElements.
 //============================================================================
 template<class FLUID_ELEMENT, unsigned DIM_FLUID>
  void setup_fluid_load_info_for_solid_elements(
   const unsigned &boundary_in_fluid_mesh,
   Mesh* const &fluid_mesh_pt,
   Mesh* const &solid_mesh_pt,
   const unsigned& face=0)
  
  {
   // Create a face mesh adjacent to the fluid mesh's b-th boundary. 
   // The face mesh consists of FaceElements that may also be 
   // interpreted as GeomObjects
   Mesh* fluid_face_mesh_pt = new Mesh;
   fluid_mesh_pt->template build_face_mesh
    <FLUID_ELEMENT,FaceElementAsGeomObject>(boundary_in_fluid_mesh,
                                            fluid_face_mesh_pt);
   

   // Loop over these new face elements and tell them the boundary number
   // from the bulk fluid mesh -- this is required to they can
   // get access to the boundary coordinates!
   unsigned n_face_element = fluid_face_mesh_pt->nelement();
   for(unsigned e=0;e<n_face_element;e++)
    {
     //Cast the element pointer to the correct thing!
     dynamic_cast<FaceElementAsGeomObject<FLUID_ELEMENT>*>
      (fluid_face_mesh_pt->element_pt(e))->
      set_boundary_number_in_bulk_mesh(boundary_in_fluid_mesh);
    }

   // Now sort the elements based on the boundary coordinates.
   // This may allow a faster implementation of the locate_zeta
   // function for the MeshAsGeomObject representation of this
   // mesh, but also creates a unique ordering of the elements
   std::sort(fluid_face_mesh_pt->element_pt().begin(),
             fluid_face_mesh_pt->element_pt().end(),
             CompareBoundaryCoordinate<FLUID_ELEMENT>());
   
   // Re-represent the surface mesh on the fluid mesh's b-th boundary
   // as a GeomObject. The GeomObject has the same number of
   // Eulerian coordinates as the fluid mesh itself but it is
   // parametrised by surface ("Lagrangian") coordinates of lower dimension
   MeshAsGeomObject<DIM_FLUID-1,DIM_FLUID,
    FaceElementAsGeomObject<FLUID_ELEMENT> >* fluid_face_mesh_geom_object_pt = 
    new MeshAsGeomObject<DIM_FLUID-1,DIM_FLUID,
    FaceElementAsGeomObject<FLUID_ELEMENT> >(fluid_face_mesh_pt);
 
   //Loop over the solid elements in the solid mesh
   unsigned n_solid_element = solid_mesh_pt->nelement();
   for(unsigned e=0;e<n_solid_element;e++)
    {
     //Cast each element to an FSIWallElement
     FSIWallElement *solid_element_pt = dynamic_cast<FSIWallElement*>(
      solid_mesh_pt->element_pt(e));


#ifdef PARANOID
     //If the dynamic cast hasn't worked, die
     if(solid_element_pt==0)
      {
       std::ostringstream error_message;
       error_message << e 
                     << "th element in solid_mesh is not an FSIWallElement"
                     << std::endl;

       throw OomphLibError(
        error_message.str(),
        "FSIProblem::setup_fluid_load_info_for_solid_elements()",
        OOMPH_EXCEPTION_LOCATION);
      }
     // We've successfully cast to an FSIWallElement -- check
     // if the "back" of the element is supposed to be loaded
     // even though this capability hasn't been enabled
     if ((face==1)&&(solid_element_pt->only_front_is_loaded_by_fluid()))
      {
       std::ostringstream error_message;
       error_message 
        << "Trying to set fluid load on the `back' of FSIWallElement "
        << e << std::endl
        << "which is (still) assumed to be loaded on the `front' only."
        << std::endl 
        << "You should call FSIWallElement::enable_fluid_loading_on_both_sides() first!"
        << std::endl;
       
       throw OomphLibError(
        error_message.str(),
        "FSIProblem::setup_fluid_load_info_for_solid_elements()",
        OOMPH_EXCEPTION_LOCATION);
      }
#endif
     
     //Find the number of Gauss points of the element
     unsigned n_intpt = solid_element_pt->integral_pt()->nweight();

     //Find the dimension of the element (i.e. its number of local coordinates)
     unsigned el_dim = solid_element_pt->dim();

     // Set storage for the local coordinates of the Gauss points
     // in the solid and face elements
     Vector<double> s_solid(el_dim), s_face(el_dim);

     // Set storage for the zeta (the intrinsic coordinate in the 
     // GeomObject representation of the fluid face mesh) at the Gauss point 
     Vector<double> zeta(el_dim);

     // Define storage for the pointer to the geometric (sub-)object in the
     // fluid face mesh that contains the Gauss point
     GeomObject *sub_obj_pt; 
     
     //Loop over the integration points
     for(unsigned ipt=0;ipt<n_intpt;ipt++)
      {
       //Loop over the dimension of the solid element and find the local
       //coordinates of the Gauss points
       for(unsigned i=0;i<el_dim;i++) 
        {
         s_solid[i] = solid_element_pt->integral_pt()->knot(ipt,i);
        }

       // Get the value of zeta at the integration point from the
       // pure virtual function FSIWallElement::interpolated_zeta()
       solid_element_pt->interpolated_zeta(s_solid,zeta);
       
       //Find the geometric (sub-)object and local coordinate within that
       //object for the given value of the intrinsic coordinate, zeta.
       //If no sub-object can be found, this function will return
       //sub_obj_pt=0.
       fluid_face_mesh_geom_object_pt->locate_zeta(zeta, sub_obj_pt, s_face);

       //Check that we've been able to find the value of zeta in our mesh
       if(sub_obj_pt==0) 
        {
         std::ostringstream error_message;
         error_message << "Unable to locate zeta: "
                       << std::endl << "   ";
         for(unsigned i=0;i<el_dim;i++) {error_message << zeta[i] << " ";}
         error_message << std::endl
                       << " on the face of any element in the surface mesh\n"
                       << " You might need to adjust the Tolerances in\n"
                       << " the locate_zeta() routines\n";
         
         throw OomphLibError(
          error_message.str(),
          "FSI_functions::set_boundary_adjacent_to_solid()",
          OOMPH_EXCEPTION_LOCATION);
        }
       
       //Cast the returned geometric (sub-)object into a FaceElement
       FaceElementAsGeomObject<FLUID_ELEMENT>* face_element_geom_object_pt = 
        dynamic_cast<FaceElementAsGeomObject<FLUID_ELEMENT>*>(sub_obj_pt);

       // The bulk fluid element adjacent to the integration point is 
       // the bulk fluid element used to create the face element
       // that contained the required zeta coordinate
       solid_element_pt->adjacent_fluid_element_pt(face,ipt) = 
        dynamic_cast<FSIFluidElement*>(face_element_geom_object_pt->
                                       bulk_element_pt());
       
       //Determine the local coordinate of the integration point
       //within the fluid bulk element (the dimension of the bulk element is
       //one higher than that of the face element).
       Vector<double> local_s_fluid_bulk(el_dim+1);
       face_element_geom_object_pt->
        get_local_coordinate_in_bulk(s_face,local_s_fluid_bulk);
      
       //Set the value of the local coordinates in the fluid bulk element
       solid_element_pt->adjacent_fluid_local_coord(face,ipt) = 
        local_s_fluid_bulk;
      }
    }
   
   //Clean up the memory allocated:

   //Can delete the Geometric object representation of the face 
   //mesh -- no problem.
   delete fluid_face_mesh_geom_object_pt;

   //Must be careful with the FaceMesh, because we cannot delete the nodes
   //Loop over the elements backwards (paranoid!) and delete them
   for(unsigned e=n_face_element;e>0;e--)
    {
     delete fluid_face_mesh_pt->element_pt(e-1);
     fluid_face_mesh_pt->element_pt(e-1) = 0;
    }
   //Now clear all element and node storage (should maybe fine-grain this)
   fluid_face_mesh_pt->flush_element_and_node_storage();

   //Finally delete the mesh
   delete fluid_face_mesh_pt;
  }


//============================================================================
/// Doc FSI: 
/// -# Which Data values affect the traction onto the FSIWallElements
///    and what type of Data is it stored in ([fluid-]nodes, internal 
///    Data [in fluid elements] or SolidNodes?
/// -# Which SolidNodes affect the node update of the fluid nodes?
/// .
/// Output is in tecplot readable form: Use fs1.mcr and fsi2.mcr
/// (or straightforward modifications thereof), stored in
/// doc/interaction/fsi_collapsible_channel/nondist_figures to process.
/// \n\n
/// Pass pointer to fluid and solid meshes and pointer to the 
/// DocInfo object that specifies the directory and the overall
/// step number. \n
/// Template parameter specifies the type of node that is used
/// to implement the node update strategy.
//============================================================================
template<class NODE>
void doc_fsi(Mesh* fluid_mesh_pt,
             SolidMesh* wall_mesh_pt,
             DocInfo& doc_info)
{ 
 
 std::ofstream some_file;
 char filename[100];
 
 // Number of plot points
 unsigned npts;
 npts=5; 
 
 // Part 1: Doc which dofs affect the fluid traction on solid
 //==========================================================

 // Tecplot helpers
 Vector<std::string> label(3);
 label[0]="X=";
 label[1]="Y=";
 label[2]="Z=";

 // Output fluid solution/mesh
 //---------------------------
 sprintf(filename,"%s/fsi_doc_fluid_mesh%i.dat",doc_info.directory().c_str(),
         doc_info.number());
 some_file.open(filename);
 fluid_mesh_pt->output(some_file,npts);
 some_file.close();
 



 // Setup map that links the positional Data of SolidNodes with
 //------------------------------------------------------------
 // the nodes
 //----------
 std::map<Data*,Node*> solid_node_pt;
 unsigned nnod=wall_mesh_pt->nnode();
 for (unsigned j=0;j<nnod;j++)
  {
   solid_node_pt[wall_mesh_pt->node_pt(j)->variable_position_pt()]=
    wall_mesh_pt->node_pt(j);
  }



 // Setup map that links the internal (pressure) Data of fluid elements with
 //-------------------------------------------------------------------------
 // those fluid elements
 //---------------------
 std::map<Data*,FiniteElement*> internal_data_element_pt;
 unsigned nelemf=fluid_mesh_pt->nelement();
 for (unsigned e=0;e<nelemf;e++)
  {
   unsigned ninternal=fluid_mesh_pt->element_pt(e)->ninternal_data();
   for (unsigned k=0;k<ninternal;k++)
    {
     internal_data_element_pt[
      fluid_mesh_pt->element_pt(e)->internal_data_pt(k)]=
      fluid_mesh_pt->finite_element_pt(e);
    }
  }





 // Loop over all wall elements
 //----------------------------
 unsigned nelem=wall_mesh_pt->nelement();
 for (unsigned e=0;e<nelem;e++)
  {
   sprintf(filename,"%s/fsi_doc_wall_element%i-%i.dat",
           doc_info.directory().c_str(),
           doc_info.number(),e);
   some_file.open(filename);
   
   // Get pointer to wall element
   FSIWallElement* el_pt=
    dynamic_cast<FSIWallElement*>(wall_mesh_pt->finite_element_pt(e));
   
   // Storage for local and global coords
   unsigned ndim_local = el_pt->dim();
   Vector<double> s(ndim_local);
   unsigned ndim_eulerian = el_pt->nodal_dimension();
   Vector<double> x(ndim_eulerian);
   

   // Map to indicate if the internal Data for a given 
   // fluid element has been plotted already
   std::map<FiniteElement*,bool> element_internal_data_has_been_plotted;

   // Loop over Gauss points and doc their position
   //-----------------------------------------------
   unsigned nint=el_pt->integral_pt()->nweight();
   some_file << "ZONE I=" << nint << std::endl;
   for (unsigned i=0;i<nint;i++)
    {
     for (unsigned j=0;j<ndim_local;j++)
      {
       s[j]=el_pt->integral_pt()->knot(i,j);
      }
     el_pt->interpolated_x(s,x);
     for (unsigned j=0;j<ndim_eulerian;j++)
      {
       some_file << x[j] << " ";
      }
     some_file << i <<  std::endl;
    }


   // Loop over Gauss points again to find corresponding points in fluid
   //--------------------------------------------------------------------
   // elements
   //---------
    
   // Loop over front and back if required: Get number of fluid-loaded faces
   unsigned n_loaded_face=2;
   if (el_pt->only_front_is_loaded_by_fluid()) n_loaded_face=1;
  
   for (unsigned face=0;face<n_loaded_face;face++)
    {
     some_file << "ZONE I=" << nint << std::endl;
     for (unsigned i=0;i<nint;i++)
      {
       // Get corresponding fluid element
       FSIFluidElement* fluid_el_pt=dynamic_cast<FSIFluidElement*>(
        el_pt->adjacent_fluid_element_pt(face,i));
       
       // Get local coordinates in fluid element by copy operation
       Vector<double> s_fluid(el_pt->adjacent_fluid_local_coord(face,i));
       
       // Get Eulerian position in fluid element
       fluid_el_pt->interpolated_x(s_fluid,x);
       for (unsigned j=0;j<ndim_eulerian;j++)
        {
         some_file << x[j] << " ";
        }
       some_file << i << std::endl;
      }
    }


   // Get the multiplicity of data that affects the load on this wall element
   //------------------------------------------------------------------------
   std::map<Data*,unsigned> data_count;
   std::map<FiniteElement*,unsigned> internal_data_count;
   Vector<Data*> load_data_pt(el_pt->load_data_pt());
   unsigned nload=load_data_pt.size();
   for (unsigned l=0;l<nload;l++)
    {
     data_count[load_data_pt[l]]++;
     if (internal_data_element_pt[load_data_pt[l]]!=0)
      {
       internal_data_count[internal_data_element_pt[load_data_pt[l]]]++;
      }
    }


   // Loop over unique data entries
   //------------------------------
   for(std::map<Data*,unsigned>::iterator it=data_count.begin();
       it != data_count.end(); it++)
    {
     Data* unique_data_pt=it->first;

     // Try to cast to a Node
     //----------------------
     Node* node_pt=dynamic_cast<Node*>(unique_data_pt);
     if (node_pt==0)
      {
       //oomph_info << "Is not a node: Repeats:" << it->second;

       // Is it a solid node? NOTE: This query makes sense as we're
       //----------------------------------------------------------
       // checking for the SolidNode's *positional* Data, not for
       //--------------------------------------------------------
       // the SolidNode itself!
       //----------------------
       if (solid_node_pt[unique_data_pt]!=0)
        {
         //oomph_info << "... it's a solid node! " ;
         some_file << "TEXT " ;
         for (unsigned j=0;j<ndim_eulerian;j++)
          {
           some_file << label[j] << solid_node_pt[unique_data_pt]->x(j) 
                     << " ";
          }

         some_file <<"CS=GRID, HU=FRAME, H=2.5, AN=MIDCENTER, C=GREEN "
                   << "T=\"" <<  it->second << "\"" << std::endl;
        }       

       // Is it internal (pressure) Data in a fluid element?
       //---------------------------------------------------
       else if (internal_data_element_pt[unique_data_pt]!=0)
        {
         //oomph_info << "... it's internal (pressure) Data! " ;
         if (!element_internal_data_has_been_plotted[
              internal_data_element_pt[unique_data_pt]])
          {
           some_file << "TEXT " ;
           // Pointer to fluid element that contains this internal data
           FiniteElement* fluid_el_pt=internal_data_element_pt[unique_data_pt];
           
           // Get the plot coordinates in this element: centre + a bit of
           // offset
           double s_max=fluid_el_pt->s_max();
           double s_min=fluid_el_pt->s_min();
           Vector<double> s_fluid(ndim_eulerian);
           Vector<double> x_fluid(ndim_eulerian);
           for (unsigned k=0;k<ndim_eulerian;k++)
            {
             s_fluid[k]=0.5*(s_max+s_min)+0.1*(s_max-s_min);
            }
           fluid_el_pt->interpolated_x(s_fluid,x_fluid);
           for (unsigned j=0;j<ndim_eulerian;j++)
            {           
             some_file << label[j] << x_fluid[j] << " ";
            }
           
           some_file <<"CS=GRID, HU=FRAME, H=2.5, AN=MIDCENTER, C=BLUE "
                     << "T=\"" << it->second << "\"" 
            // internal_data_count[fluid_el_pt] 
                     << std::endl;
           
           // Now we have plotted it....
           element_internal_data_has_been_plotted[
            internal_data_element_pt[unique_data_pt]]=true;
          }

        }
       else
        {
         std::ostringstream error_message;
         error_message 
          << "Data that affects the load on an FSIWallElement\n" 
          << "is neither a (fluid) Node, nor a SolidNode nor\n" 
          << "internal Data in a (fluid) element\n" 
          << "I don't think this should happen..."
          << std::endl;
         throw OomphLibError(error_message.str(),
                             "FSI_functions::doc_fsi()",
                             OOMPH_EXCEPTION_LOCATION);
        }
      }
     // It must be a node then
     //-----------------------
     else
      {
       //oomph_info << "Is a node: Repeats:"  << it->second << std::endl;
       some_file << "TEXT " ;
       for (unsigned j=0;j<ndim_eulerian;j++)
        {
         some_file << label[j] << node_pt->x(j) << ", ";         
        }
       some_file <<"CS=GRID, HU=FRAME, H=2.5, AN=MIDCENTER, C=RED "<< "T=\""
                 <<  it->second << "\"" 
                 << std::endl;
      }
    }
   some_file.close(); 
  }
 
 // Part 2: Doc which dofs affect the node update functions
 //========================================================


 // Counter for the number of nodes that are actually
 // affected by wall motion
 unsigned count=0;

 // Loop over nodes in fluid mesh
 unsigned nnode_fluid=fluid_mesh_pt->nnode();
 for (unsigned j=0;j<nnode_fluid;j++)
  {

   // Upcast node to appropriate type
   NODE* node_pt=dynamic_cast<NODE*>(fluid_mesh_pt->node_pt(j));

   unsigned ndim_eulerian=node_pt->ndim();

   sprintf(filename,"%s/fsi_doc_fluid_element%i-%i.dat",
           doc_info.directory().c_str(),
           doc_info.number(),count);
   some_file.open(filename);
   some_file << "ZONE" << std::endl;
   for (unsigned i=0;i<ndim_eulerian;i++)
    {
     some_file << node_pt->x(i) << " ";
    }
   some_file << std::endl;

   // Extract geom objects that affect the nodal position
   Vector<GeomObject*> geom_obj_pt(node_pt->vector_geom_object_pt());


   // Get the multiplicity of data that affects this node
   //----------------------------------------------------
   std::map<Data*,unsigned> data_count;
   unsigned ngeom=geom_obj_pt.size();
   for (unsigned i=0;i<ngeom;i++)
    {
     unsigned ngeom_dat=geom_obj_pt[i]->ngeom_data();
     for (unsigned k=0;k<ngeom_dat;k++)
      {
       data_count[geom_obj_pt[i]->geom_data_pt(k)]++;
      }
    }
   
   // Haven't actually doced any dependcies for this node
   bool written_something=false;

   // Loop over unique data entries
   //------------------------------
   for(std::map<Data*,unsigned>::iterator it=data_count.begin();
       it != data_count.end(); it++)
    {
     Data* unique_data_pt=it->first;

     // Is it a solid node?
     if (solid_node_pt[unique_data_pt]!=0)
      {
       //oomph_info << "Fluid node is affected by solid node! " ;
       some_file << "TEXT " ;
       for (unsigned j=0;j<ndim_eulerian;j++)
        {
         some_file << label[j] << solid_node_pt[unique_data_pt]->x(j) 
                   << " ";
        }
       
       some_file <<"CS=GRID, HU=FRAME, H=2.5, AN=MIDCENTER, C=GREEN "<< "T=\""
                 << unique_data_pt->nvalue() << "\"" 
                 << std::endl;
       
       // We've actually produced some output
       written_something=true;
      }
     // It's not a solid node --> ??
     else
      {
       std::ostringstream warn_message;
       warn_message 
        << "Info: Position of a fluid node is affected by Data that"
        << "is not a SolidNode --> Can't plot this Data. \n\n" 
        << "(You may also want to check if this is exepcted or likely to\n"
        << "indicate a bug in your code...)"
        << std::endl;
       throw OomphLibWarning(warn_message.str(),
                             "FSI_functions::doc_fsi()",
                             OOMPH_EXCEPTION_LOCATION);
      }     
    }


   some_file.close();  

   // If we've written something for the last node, bump up
   // counter for file so we don't overwrite
   if (written_something) count++;

  }

} // end_of_doc_fsi

}

}

#endif
