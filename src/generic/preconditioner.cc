//LIC// ====================================================================
//LIC// This file forms part of oomph-lib, the object-oriented, 
//LIC// multi-physics finite-element library, available 
//LIC// at http://www.oomph-lib.org.
//LIC// 
//LIC//           Version 0.85. June 9, 2008.
//LIC// 
//LIC// Copyright (C) 2006-2008 Matthias Heil and Andrew Hazel
//LIC// 
//LIC// This library is free software; you can redistribute it and/or
//LIC// modify it under the terms of the GNU Lesser General Public
//LIC// License as published by the Free Software Foundation; either
//LIC// version 2.1 of the License, or (at your option) any later version.
//LIC// 
//LIC// This library is distributed in the hope that it will be useful,
//LIC// but WITHOUT ANY WARRANTY; without even the implied warranty of
//LIC// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//LIC// Lesser General Public License for more details.
//LIC// 
//LIC// You should have received a copy of the GNU Lesser General Public
//LIC// License along with this library; if not, write to the Free Software
//LIC// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
//LIC// 02110-1301  USA.
//LIC// 
//LIC// The authors may be contacted at oomph-lib@maths.man.ac.uk.
//LIC// 
//LIC//====================================================================
// Config header generated by autoconfig
#ifdef HAVE_CONFIG_H
  #include <oomph-lib-config.h>
#endif


//oomph-lib includes
#include "preconditioner.h"


namespace oomph
{

//=============================================================
/// \short Setup diagonal preconditioner: Store the inverse of the 
/// diagonal entries from the fully
/// assembled matrix. Problem pointer is ignored.
//=============================================================
void MatrixBasedDiagPreconditioner::setup(Problem* problem_pt, 
                                          DoubleMatrixBase* matrix_pt)
{
#ifdef OOMPH_HAS_MPI
 bool cast_failed = true;

 // first attempt to cast to DistributedCRDoubleMatrix
 DistributedCRDoubleMatrix* dist_cr_matrix_pt = 
  dynamic_cast<DistributedCRDoubleMatrix*>(matrix_pt);
 if (dist_cr_matrix_pt != 0)
  {
   // store the distribution
   Preconditioner_distribution = dist_cr_matrix_pt->distribution();

   // Resize the Inv_diag vector to accommodate the # of
   // diagonal entries
   Inv_diag.resize(Preconditioner_distribution.nrow_local());

   //Extract the diagonal entries
   for(unsigned i=0; i < Preconditioner_distribution.nrow_local(); i++)
    {
     unsigned index = i + Preconditioner_distribution.first_row();
#ifdef PARANOID
     if ((*matrix_pt)(i,index)==0.0)
      {
       throw OomphLibError(
        "Zero diagonal in matrix --> Cannot use diagonal preconditioner.",
        "MatrixBasedDiagPreconditioner::setup()",
        OOMPH_EXCEPTION_LOCATION);
      }
#endif
     Inv_diag[i] = 1.0/(*matrix_pt)(i,index);
    }
      
   cast_failed = false;
  }

 if (cast_failed)
  {
   // then cr double matrix
   CRDoubleMatrix* cr_matrix_pt =
    dynamic_cast<CRDoubleMatrix*>(matrix_pt);
   if (cr_matrix_pt != 0)
    {
     // number of rows in the global matrix
     unsigned nrow = cr_matrix_pt->nrow();
     
     // store the distribution
     // NOTE use of MPI_COMM_WORLD
     Preconditioner_distribution.distribute(MPI_COMM_WORLD,nrow);
     
     // cache first_row and nrow_local
     unsigned nrow_local = Preconditioner_distribution.nrow_local();
     unsigned first_row = Preconditioner_distribution.first_row();
     
     // Resize the Inv_diag vector to accommodate the # of
     // diagonal entries
     Inv_diag.resize(nrow_local);
     
     //Extract the diagonal entries
     for(unsigned i=0; i < nrow_local; i++)
      {
#ifdef PARANOID
       if ((*matrix_pt)(i,first_row + i)==0.0)
        {
         throw OomphLibError(
          "Zero diagonal in matrix --> Cannot use diagonal preconditioner.",
          "MatrixBasedDiagPreconditioner::setup()",
          OOMPH_EXCEPTION_LOCATION);
        }
#endif
       Inv_diag[i] = 1.0/(*matrix_pt)(i,first_row + i);
      }
     
     // succeeded
     cast_failed = false;
    }
  }


#ifdef PARANOID
 if (cast_failed)
  {
   throw OomphLibError(
    "Matrix must be CRDoubleMatrix or DistributedCRDoubleMatrix",
    "MatrixBasedDiagPreconditioner::setup()",
    OOMPH_EXCEPTION_LOCATION);

  }
#endif
#else
 // # of rows in the matrix
 unsigned n_row=matrix_pt->nrow();
 
 // Resize the Inv_diag vector to accommodate the # of 
 //diagonal entries
 Inv_diag.resize(n_row);
 
 //Extract the diagonal entries
 for(unsigned i=0;i<n_row;i++)
  {
#ifdef PARANOID
   if ((*matrix_pt)(i,i)==0.0) 
   {
    throw OomphLibError(
     "Zero diagonal in matrix --> Cannot use diagonal preconditioner.",
     "MatrixBasedDiagPreconditioner::setup()",
     OOMPH_EXCEPTION_LOCATION);
   }
   else
#endif
    {
     Inv_diag[i]=1.0/(*matrix_pt)(i,i);
    }   
  }
#endif
}


//=============================================================================
/// Apply preconditioner: Multiply r by the inverse of the diagonal.
//=============================================================================
 void MatrixBasedDiagPreconditioner::preconditioner_solve(
  const Vector<double> &r,Vector<double>& z)
{
#ifdef OOMPH_HAS_MPI
 // create the distributed vectors
 DistributedVector<double> dist_r(Preconditioner_distribution,r);
 DistributedVector<double> dist_z;
 
 // apply the preconditioner
 preconditioner_solve(dist_r,dist_z);

 // copy the results back to serial z
 dist_z.global_vector(z);

#else
 // serial preconditioner application
 unsigned n=r.size();
  for (unsigned i=0;i<n;i++)
   {      
    z[i]=Inv_diag[i]*r[i];   
   }
#endif
}

#ifdef OOMPH_HAS_MPI
//=============================================================================
/// Apply preconditioner: Multiply r by the inverse of the diagonal.
//=============================================================================
void MatrixBasedDiagPreconditioner::preconditioner_solve(
 const DistributedVector<double> &r,DistributedVector<double>& z)
{
 // apply the preconditioner
 unsigned n=Preconditioner_distribution.nrow_local();
 for (unsigned i=0;i<n;i++)
  {
   z[i]=Inv_diag[i]*r[i];
  }
}
#endif

//=============================================================================
/// setup ILU(0) preconditioner for Matrices of CCDoubleMatrix type
//=============================================================================
void ILUZeroPreconditioner<CCDoubleMatrix>::setup(Problem* problem_pt, 
                                                  DoubleMatrixBase* matrix_pt)
{	
 
 // cast the Double Base Matrix to Compressed Column Double Matrix
 CCDoubleMatrix* cc_matrix_pt = dynamic_cast<CCDoubleMatrix*>(matrix_pt);
 
 // number of rows in matrix
 int n_row=cc_matrix_pt->nrow();
 
 // declares variables to store number of non zero entires in L and U
 int l_nz = 0; 
 int u_nz = 0;
 
 // create space for m matrix
 int* m_column_start;
 int* m_row_index;
 double* m_value;
 
 // get the m matrix
 m_column_start = cc_matrix_pt->column_start();
 m_row_index = cc_matrix_pt->row_index();
 m_value = cc_matrix_pt->value();
 
 // find number non zero entries in L and U
 for (int i = 0; i < n_row; i++)
  {
   for (int j = m_column_start[i]; j < m_column_start[i+1]; j++)
    {
     if (m_row_index[j] > i)
      {
       l_nz++;
      }
     else
      {
       u_nz++;
      }
    }
  }
 
 //resize vectors to store the data for the lower prior to building the 
 //matrices
 L_column_start.resize(n_row+1);
 L_row_entry.resize(l_nz);
 
 // and the upper matrix
 U_column_start.resize(n_row+1);
 U_row_entry.resize(u_nz);
 
 // set first column pointers to zero
 L_column_start[0] = 0;
 U_column_start[0] = 0;
 
 //split the matrix into L and U
 for (int i = 0; i < n_row; i++)
  {
   L_column_start[i+1] = L_column_start[i];
   U_column_start[i+1] = U_column_start[i];
   for (int j = m_column_start[i]; j < m_column_start[i+1]; j++)
    {
     if (m_row_index[j] > i)
      {
       int k = L_column_start[i+1]++;
       L_row_entry[k].index() = m_row_index[j];
       L_row_entry[k].value() = m_value[j];
      }
     else
      {
       int k = U_column_start[i+1]++;       
       U_row_entry[k].index() = m_row_index[j];
       U_row_entry[k].value() = m_value[j];
      }
    }
  }

 // sort each row entry vector into row index order for each column

 // loop over the columns
 for (unsigned i = 0; i < unsigned(n_row); i++) 
  {
   // sort the columns of the L matrix
   std::sort(L_row_entry.begin() + L_column_start[i],
             L_row_entry.begin() + L_column_start[i+1]);

   // sort the columns of the U matrix
   std::sort(U_row_entry.begin() + U_column_start[i],
             U_row_entry.begin() + U_column_start[i+1]);
  }



 // factorise matrix	
 int i; unsigned  j, pn, qn, rn; pn = 0; qn=0; rn = 0;
 double multiplier;
 for (i = 0; i < n_row - 1; i++) {
  multiplier = U_row_entry[U_column_start[i+1]-1].value();
  for (j = L_column_start[i]; j < L_column_start[i+1]; j++)
   L_row_entry[j].value() /= multiplier; 
  for (j = U_column_start[i+1]; j < U_column_start[i+2]-1; j++)
   {
    multiplier = U_row_entry[j].value();
    qn = j + 1;
    rn = L_column_start[i+1];
    for (pn = L_column_start[U_row_entry[j].index()]; 
         pn < L_column_start[U_row_entry[j].index()+1] && 
          static_cast<int>(L_row_entry[pn].index()) <= i + 1; pn++)
     {
      while (qn < U_column_start[i+2] && 
             U_row_entry[qn].index() < L_row_entry[pn].index())
       qn++;
      if (qn < U_column_start[i+2] && 
          L_row_entry[pn].index() == U_row_entry[qn].index())
       U_row_entry[qn].value() -= multiplier * L_row_entry[pn].value();
     }
    for ( ; pn < L_column_start[U_row_entry[j].index()+1]; pn++)
     {
      while (rn < L_column_start[i+2] && 
             L_row_entry[rn].index() < L_row_entry[pn].index())
       rn++;
      if (rn < L_column_start[i+2] && 
          L_row_entry[pn].index() == L_row_entry[rn].index())
       L_row_entry[rn].value() -= multiplier * L_row_entry[pn].value();
     }
   }
 }
}


//=============================================================================
/// setup ILU(0) preconditioner for Matrices of CRDoubleMatrix Type
//=============================================================================
void ILUZeroPreconditioner<CRDoubleMatrix>::setup(Problem* problem_pt, 
                                                  DoubleMatrixBase* matrix_pt)
{	
 // cast the Double Base Matrix to Compressed Column Double Matrix
 CRDoubleMatrix* cr_matrix_pt = dynamic_cast<CRDoubleMatrix*>(matrix_pt);
 
 // number of rows in matrix
 int n_row=cr_matrix_pt->nrow();
 
 // declares variables to store number of non zero entires in L and U
 int l_nz = 0; 
 int u_nz = 0;
 
 // create space for m matrix
 int* m_row_start;
 int* m_column_index;
 double* m_value;
 
 // get the m matrix
 m_row_start = cr_matrix_pt->row_start();
 m_column_index = cr_matrix_pt->column_index();
 m_value = cr_matrix_pt->value();

  // find number non zero entries in L and U
 for (int i = 0; i < n_row; i++)
  {
   for (int j = m_row_start[i]; j < m_row_start[i+1]; j++)
    {
     if (m_column_index[j] < i)
      {
       l_nz++;
      }
     else
      {
       u_nz++;
      }
    }
  }
 
 //resize vectors to store the data for the lower prior to building the 
 //matrices
 L_row_start.resize(n_row+1);
 L_column_index.resize(l_nz);
 L_value.resize(l_nz);
 
 // and the upper matrix
 U_row_start.resize(n_row+1);
 U_column_index.resize(u_nz);
 U_value.resize(u_nz);
 
 // set first column pointers to zero
 L_row_start[0] = 0;
 U_row_start[0] = 0;

 //split the matrix into L and U
 for (int i = 0; i < n_row; i++)
  {
   L_row_start[i+1] = L_row_start[i];
   U_row_start[i+1] = U_row_start[i];
   for (int j = m_row_start[i]; j < m_row_start[i+1]; j++)
    {
     if (m_column_index[j] < i)
      {
       int k = L_row_start[i+1]++;
       L_value[k] = m_value[j];
       L_column_index[k] = m_column_index[j];
      }
     else
      {
       int k = U_row_start[i+1]++;
       U_value[k] = m_value[j];
       U_column_index[k] = m_column_index[j];
      }
    }
  }
 

 // factorise matrix	
 unsigned i, j, pn, qn, rn; pn = 0; qn=0; rn = 0;
 double multiplier;
 for (i = 1; i < static_cast<unsigned>(n_row); i++) {
  for (j = L_row_start[i]; j < L_row_start[i+1]; j++)
   {
    pn = U_row_start[L_column_index[j]];
    multiplier = (L_value[j] /= U_value[pn]);
    qn = j + 1;
    rn = U_row_start[i];
    for (pn++; pn < U_row_start[L_column_index[j]+1] && U_column_index[pn] < i;
         pn++)
     {
      while (qn < L_row_start[i+1] && L_column_index[qn] < U_column_index[pn])
       qn++;
      if (qn < L_row_start[i+1] && U_column_index[pn] == L_column_index[qn])
       L_value[qn] -= multiplier * U_value[pn];
     }
    for ( ; pn < U_row_start[L_column_index[j]+1]; pn++)
     {
      while (rn < U_row_start[i+1] && U_column_index[rn] < U_column_index[pn])
       rn++;
      if (rn < U_row_start[i+1] && U_column_index[pn] == U_column_index[rn])
       U_value[rn] -= multiplier * U_value[pn];
     }
   }
 }
}




//=============================================================================
/// \short Apply ILU(0) preconditioner for CCDoubleMatrix: Solve Ly=r then Uz=y
/// and return z
//=============================================================================
void ILUZeroPreconditioner<CCDoubleMatrix>::preconditioner_solve(
  const Vector<double>& r,Vector<double>& z)
{
 // # of rows in the matrix
 int n_row=r.size();

 // copy r to z
 for (int i = 0; i < n_row; i++)
  {
   z[i] = r[i];
  }

 // solve Ly=r (note L matrix is unit and diagonal is not stored)
 for (unsigned i = 0; i < static_cast<unsigned>(n_row); i++)
  {
   for (unsigned j = L_column_start[i]; j < L_column_start[i+1]; j++)
    {
     z[L_row_entry[j].index()] = z[L_row_entry[j].index()] - 
      z[i]*L_row_entry[j].value();
    }	
  }
 
 // solve Uz=y 
 double x;
 for(int i =n_row-1; i >= 0; i--)
  {
   x = z[i]/U_row_entry[U_column_start[i+1]-1].value();
   z[i] = x;
   for (unsigned j = U_column_start[i]; j < U_column_start[i+1]-1;j++)
    {
     z[U_row_entry[j].index()] = z[U_row_entry[j].index()]
      -x*U_row_entry[j].value();
    }
  }
}

//=============================================================================
/// \short Apply ILU(0) preconditioner for CRDoubleMatrix: Solve Ly=r then Uz=y
///  and return z
//=============================================================================
void ILUZeroPreconditioner<CRDoubleMatrix>::preconditioner_solve(
 const Vector<double>& r,Vector<double>& z)
{
 // # of rows in the matrix
 int n_row=r.size();
 
 // copy r to z
 for (int i = 0; i < n_row; i++)
  {
   z[i] = r[i];
  }
 
 // solve Ly=r (note L matrix is unit and diagonal is not stored)
 double t;
 for (int i = 0; i < n_row; i++)
  {
   t = 0;
   for (unsigned j = L_row_start[i]; j <  L_row_start[i+1]; j++)
    {
     t = t + L_value[j] * z[L_column_index[j]];
    }
   z[i] = z[i] - t;
  }
 
 // solve Uz=y
 for (int i = n_row-1; i >= 0; i--)
  {
   t = 0;
   for (unsigned j = U_row_start[i]+1; j < U_row_start[i+1]; j++)
    {
     t = t + U_value[j] * z[U_column_index[j]];
    }
   z[i] = z[i] - t;
   z[i] = z[i] / U_value[U_row_start[i]];
  }
}


}

