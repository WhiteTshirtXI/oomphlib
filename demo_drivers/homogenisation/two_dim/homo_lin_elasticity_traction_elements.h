//Header file for elements that are used to apply surface loads to 
//the equations of elasticity

#ifndef OOMPH_HOMOGENISED_LINEAR_ELASTICITY_TRACTION_ELEMENTS_HEADER
#define OOMPH_HOMOGENISED_LINEAR_ELASTICITY_TRACTION_ELEMENTS_HEADER

// Config header generated by autoconfig
#ifdef HAVE_CONFIG_H
  #include <oomph-lib-config.h>
#endif


//OOMPH-LIB headers
#include "generic/Qelements.h"

namespace oomph
{

//======================================================================
/// A class for elements that allow the imposition of an applied traction
/// in the principle of virtual displacements.
/// The geometrical information can be read from the FaceGeometry<ELEMENT> 
/// class and and thus, we can be generic enough without the need to have
/// a separate equations class.
//======================================================================
template <class ELEMENT>
class HomogenisedLinearElasticityTractionElement : 
 public virtual FaceGeometry<ELEMENT>, 
  public virtual FaceElement
{
  protected:
 
 /// Index at which the i-th velocity component is stored
 Vector<unsigned> U_index_linear_elasticity_traction;

public:

 /// \short Constructor, which takes a "bulk" element and the 
 /// value of the index and its limit
 HomogenisedLinearElasticityTractionElement(FiniteElement* const &element_pt, 
                                            const int &face_index) : 
  FaceGeometry<ELEMENT>(), FaceElement()
  { 
#ifdef PARANOID
   {
  //Check that the element is not a refineable 3d element
  ELEMENT* elem_pt = new ELEMENT;
  //If it's three-d
  if(elem_pt->dim()==3)
   {
    //Is it refineable
    if(dynamic_cast<RefineableElement*>(elem_pt))
     {
      //Issue a warning
      OomphLibWarning(
       "This flux element will not work correctly if nodes are hanging\n",
       "HomogenisedLinearElasticityTractionElement::Constructor",
       OOMPH_EXCEPTION_LOCATION);
     }
   }
 }
#endif
 
   //Attach the geometrical information to the element. N.B. This function
   //also assigns nbulk_value from the required_nvalue of the bulk element
   element_pt->build_face_element(face_index,this);

   //Find the index at which the displacmenet unknowns are stored
   ELEMENT* cast_element_pt = dynamic_cast<ELEMENT*>(element_pt);
   //Three displacement components
   this->U_index_linear_elasticity_traction.resize(3);
   for(unsigned i=0;i<3;i++)
    {
     this->U_index_linear_elasticity_traction[i] = 
      cast_element_pt->u_index_linear_elasticity(i);
    }
  }

 /// \short Output function
 void output(std::ostream &outfile)
  {FiniteElement::output(outfile);}

 /// \short Output function
 void output(std::ostream &outfile, const unsigned &n_plot)
  //{FiniteElement::output(outfile,n_plot);}
  {FaceGeometry<ELEMENT>::output(outfile,n_plot);}

 /// \short C_style output function
 void output(FILE* file_pt)
  {FiniteElement::output(file_pt);}

 /// \short C-style output function
 void output(FILE* file_pt, const unsigned &n_plot)
  {FiniteElement::output(file_pt,n_plot);}
 
 /// \short compute the integral of the displacement components around the 
 /// face
 void calculate_H(DenseMatrix<double> &H)
  {
   //Find out how many nodes there are
   unsigned n_node = this->nnode();
   
   //Find out how many positional dofs there are
   unsigned n_position_type = this->nnodal_position_type();
   
   
   if(n_position_type != 1)
    {
     throw OomphLibError(
      "HomogenisedLinearElasticity is not yet implemented for more than one position type",
      "HomogenisedLinearElasticityEquationsBase<DIM>::get_strain()",
      OOMPH_EXCEPTION_LOCATION);
    }
   
   
   //Find out the dimension of the node
   unsigned n_dim = this->nodal_dimension();
   
   //Cache the nodal indices at which the displacement components are stored
   unsigned u_nodal_index[3];
   for(unsigned i=0;i<3;i++)
    {
     u_nodal_index[i] = this->U_index_linear_elasticity_traction[i];
    }
   
   //Set up memory for the shape functions
   //Note that in this case, the number of lagrangian coordinates is always
   //equal to the dimension of the nodes
   Shape psi(n_node);
   DShape dpsids(n_node,n_dim-1); 
   
   //Set the value of n_intpt
   unsigned n_intpt = this->integral_pt()->nweight();
   
   //Loop over the integration points
   for(unsigned ipt=0;ipt<n_intpt;ipt++)
    {
     //Get the integral weight
     double w = this->integral_pt()->weight(ipt);
     
     //Only need to call the local derivatives
     this->dshape_local_at_knot(ipt,psi,dpsids);
     
     //Calculate the Eulerian and Lagrangian coordinates 
     Vector<double> interpolated_x(n_dim,0.0);
     
     Vector<double> interpolated_u(3,0.0);

     //Also calculate the surface Vectors (derivatives wrt local coordinates)
     DenseMatrix<double> interpolated_A(n_dim-1,n_dim,0.0);   
     
     //Calculate displacements and derivatives
     for(unsigned l=0;l<n_node;l++) 
      {
       //Loop over positional dofs
       for(unsigned k=0;k<n_position_type;k++)
        {
         //Loop over displacement components (deformed position)
         for(unsigned i=0;i<n_dim;i++)
          {
           const double x_local = this->nodal_position(l,i);
           //Calculate the Eulerian and Lagrangian positions
           interpolated_x[i] += x_local*psi(l,k);

           //Loop over LOCAL derivative directions, to calculate the tangent(s)
           for(unsigned j=0;j<n_dim-1;j++)
            {
             interpolated_A(j,i) += x_local*dpsids(l,j);
            }
          }

         for(unsigned i=0;i<3;i++)
          {
           interpolated_u[i] += this->nodal_value(l,u_nodal_index[i])*psi(l,k);
          }
        }
      }

   //Now find the local metric tensor from the tangent Vectors
   DenseMatrix<double> A(n_dim-1);
   for(unsigned i=0;i<n_dim-1;i++)
    {
     for(unsigned j=0;j<n_dim-1;j++)
      {
       //Initialise surface metric tensor to zero
       A(i,j) = 0.0;
       //Take the dot product
       for(unsigned k=0;k<n_dim;k++)
        { 
         A(i,j) += interpolated_A(i,k)*interpolated_A(j,k);
        }
      }
    }

   //Get the outer unit normal
   Vector<double> interpolated_normal(n_dim);
   this->outer_unit_normal(ipt,interpolated_normal);
   
   //Find the determinant of the metric tensor
   double Adet =0.0;
   switch(n_dim)
    {
    case 2:
     Adet = A(0,0);
     break;
    case 3:
     Adet = A(0,0)*A(1,1) - A(0,1)*A(1,0);
     break;
    default:
     throw 
      OomphLibError("Wrong dimension in HomogenisedLinearElasticityTractionElement",
                    "HomogenisedLinearElasticityTractionElement::fill_in_contribution_to_residuals()",
                    OOMPH_EXCEPTION_LOCATION);
    }

   //Premultiply the weights and the square-root of the determinant of 
   //the metric tensor
   double W = w*sqrt(Adet);
   
   //=====LOAD TERMS  FROM PRINCIPLE OF VIRTUAL DISPLACEMENTS========
       
   //The sign of the normal is reversed
   for(unsigned i=0;i<3;i++)
    {
     for(unsigned j=0;j<n_dim;j++)
      {
       H(i,j) += interpolated_u[i]*interpolated_normal[j]*W;
      }
    }

  } //End of loop over integration points

  }


}; 

}

#endif
