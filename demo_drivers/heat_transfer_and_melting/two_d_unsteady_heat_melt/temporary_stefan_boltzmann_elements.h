//LIC// ====================================================================
//LIC// This file forms part of oomph-lib, the object-oriented, 
//LIC// multi-physics finite-element library, available 
//LIC// at http://www.oomph-lib.org.
//LIC// 
//LIC//           Version 0.90. August 3, 2009.
//LIC// 
//LIC// Copyright (C) 2006-2009 Matthias Heil and Andrew Hazel
//LIC// 
//LIC// This library is free software; you can redistribute it and/or
//LIC// modify it under the terms of the GNU Lesser General Public
//LIC// License as published by the Free Software Foundation; either
//LIC// version 2.1 of the License, or (at your option) any later version.
//LIC// 
//LIC// This library is distributed in the hope that it will be useful,
//LIC// but WITHOUT ANY WARRANTY; without even the implied warranty of
//LIC// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//LIC// Lesser General Public License for more details.
//LIC// 
//LIC// You should have received a copy of the GNU Lesser General Public
//LIC// License along with this library; if not, write to the Free Software
//LIC// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
//LIC// 02110-1301  USA.
//LIC// 
//LIC// The authors may be contacted at oomph-lib@maths.man.ac.uk.
//LIC// 
//LIC//====================================================================
// Header file for elements that are used to impose Stefan Boltzmann radiation
// on the surface of unsteady heat elements

#ifndef OOMPH_hierher_HEAT_TRANSFER_AND_MELT_ELEMENTS_HEADER
#define OOMPH_hierher_HEAT_TRANSFER_AND_MELT_ELEMENTS_HEADER

// Config header generated by autoconfig
#ifdef HAVE_CONFIG_H
  #include <oomph-lib-config.h>
#endif

//Standard libray headers
#include <cmath>

// oomph-lib includes
#include "generic.h" // ../generic/Qelements.h"


namespace oomph
{

//=======start_namespace==========================================
/// Namespace for intersection checker
//================================================================
namespace IntersectionChecker
{

 /// \short Check if finite-length line segments specified by end points
 /// intersect (true) or not (false). From
 /// http://paulbourke.net/geometry/lineline2d/
 /// C++ contribution by Damian Coventry.
 bool intersects(const Vector<Vector<double> >& first_segment_vertex,
                 const Vector<Vector<double> >& second_segment_vertex,
                 const double& epsilon_parallel=1.0e-15)
 {
  
  double denom = ((first_segment_vertex[1][1] - first_segment_vertex[0][1])*
                  (second_segment_vertex[1][0] - second_segment_vertex[0][0])) -
   ((first_segment_vertex[1][0] - first_segment_vertex[0][0])*
    (second_segment_vertex[1][1] - second_segment_vertex[0][1]));
  
  double nume_a = ((first_segment_vertex[1][0] - first_segment_vertex[0][0])*
                   (second_segment_vertex[0][1] - first_segment_vertex[0][1])) -
   ((first_segment_vertex[1][1] - first_segment_vertex[0][1])*
    (second_segment_vertex[0][0] - first_segment_vertex[0][0]));
  
  double nume_b = ((second_segment_vertex[1][0] - second_segment_vertex[0][0])*
                   (second_segment_vertex[0][1] - first_segment_vertex[0][1])) -
   ((second_segment_vertex[1][1] - second_segment_vertex[0][1])*
    (second_segment_vertex[0][0] - first_segment_vertex[0][0]));
  
  if(std::fabs(denom) < epsilon_parallel)
   {
    if( (std::fabs(nume_a) < epsilon_parallel) &&
        (std::fabs(nume_b) < epsilon_parallel) )
     {
      return false; //COINCIDENT;
     }
    return false; //PARALLEL;
   }
  
  double ua = nume_a / denom;
  double ub = nume_b / denom;
  
  if( (ua >= 0.0) && (ua <= 1.0) && (ub >= 0.0) && (ub <= 1.0) )
   {
    /* // Get the intersection point. */
    /* intersection[0] = second_segment_vertex[0][0] +  */
    /*  ua*(second_segment_vertex[1][0] - second_segment_vertex[0][0]); */
    /* intersection[1] = second_segment_vertex[0][1] +  */
    /*  ua*(second_segment_vertex[1][1] - second_segment_vertex[0][1]); */
    
    return true; //INTERESECTING;
   }
  
  return false; //NOT_INTERESECTING;
 }

}



/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////



//======================================================================
/// Template-free base class for elements that are illuminated 
/// by (and illuminate) other Stefan Boltzmann elements
//======================================================================
class StefanBoltzmannRadiationBase :
public virtual FiniteElement,
 public virtual FaceElement,
 public virtual TemplateFreeUnsteadyHeatBaseFaceElement
{
 
public:

 /// Constructor
 StefanBoltzmannRadiationBase()
  {
   // Pointer to non-dim Stefan Boltzmann constant
   Sigma_pt=0;
   
   // Pointer to non-dim zero centrigrade offset in Stefan Boltzmann law
   Theta_0_pt=0;
   
   // Make space for Stefan Boltzmann illumination info
   unsigned n_intpt = integral_pt()->nweight();
   Stefan_boltzmann_illumination_info.resize(n_intpt);
  }
 
 /// Pointer to non-dim Stefan Boltzmann constant
 double*& sigma_pt(){return Sigma_pt;}
 
 /// Pointer to non-dim zero centrigrade offset in Stefan Boltzmann law
 double*& theta_0_pt(){return Theta_0_pt;}

 /// Non-dim Stefan Boltzmann constant (switched off by default)
 double sigma()
  {
   if (Sigma_pt==0)
    {
     return 0.0;
    }
   else
    {
     return *Sigma_pt;
    }
  }

 /// Non-dim zero centrigrade offset in Stefan Boltzmann law
 /// (must be set if effect is enabled i.e. if non-default
 /// non-dim Stefan Boltzmann constant has been set)
 double theta_0()
  {
   if (Sigma_pt==0)
    {
     return 0.0;
    }
   else
    {
     if (Theta_0_pt==0)
      {
       throw OomphLibError("Non-dim zero-centrigrade offset not set",
                           OOMPH_CURRENT_FUNCTION,
                           OOMPH_EXCEPTION_LOCATION);
      }
     else
      {
       return *Theta_0_pt;
      }
    }
  }


 /// \short Compute the element's contribution to Stefan Boltzmann
 /// radiation onto point at r_illuminated with local outer unit
 /// normal n_illuminated,
 /// using the integration points (in current element) contained
 /// in visible_intpts_in_current_element.
 double contribution_to_stefan_boltzmann_radiation(
  const Vector<double>& r_illuminated,
  const Vector<double>& n_illuminated,
  const Vector<unsigned>& visible_intpts_in_current_element)
  {
   // Dummy file
   std::ofstream outfile;
   return contribution_to_stefan_boltzmann_radiation(
    r_illuminated,
    n_illuminated,
    visible_intpts_in_current_element,
    outfile);
  }

 /// \short Compute the element's contribution to Stefan Boltzmann
 /// radiation onto point at r_illuminated with local outer unit
 /// normal n_illuminated,
 /// using the integration points (in current element) contained
 /// in visible_intpts_in_current_element; output in outfile
 double contribution_to_stefan_boltzmann_radiation(
  const Vector<double>& r_illuminated,
  const Vector<double>& n_illuminated,
  const Vector<unsigned>& visible_intpts_in_current_element,
  std::ofstream& outfile);
   
 /// Wipe illumination info
 void wipe_stefan_boltzmann_illumination_info()
 {
  unsigned nint=Stefan_boltzmann_illumination_info.size();
  for (unsigned ipt=0;ipt<nint;ipt++)
   {
    Stefan_boltzmann_illumination_info[ipt].clear();
   }
 }
       
 /// \short Set illumination info: For integration point, ipt,
 /// we store all pairs identifying illuminating elements
 /// (via pointer to element and indices of illuminating
 /// integration points):
 /// Stefan_boltzmann_illumination_info[ipt].size() = number of illuminating
 ///       elements
 /// Stefan_boltzmann_illumination_info[ipt][e].first = pointer to e-th
 ///       illuminating element
 /// Stefan_boltzmann_illumination_info[ipt][e].second = vector containing
 ///       indices of integration points in e-th illuminating element
 ///       that are visible from current element's ipt'th integration point.
 /// Optional boolean  add_solid_position_data (default: true) adds 
 /// nodal position data if the nodes are solid nodes.
 void add_stefan_boltzmann_illumination_info(
  const unsigned& ipt,
  StefanBoltzmannRadiationBase* illuminating_el_pt,
  Vector<unsigned>& illuminating_integration_point_index,
  const bool& add_solid_position_data=true)
  {
#ifdef PARANOID
   unsigned n=Stefan_boltzmann_illumination_info[ipt].size();
   for (unsigned e=0;e<n;e++)
    {
     if (Stefan_boltzmann_illumination_info[ipt][e].first==illuminating_el_pt)
      {
       throw OomphLibError(
        "Element has already been added!",
        OOMPH_CURRENT_FUNCTION,
        OOMPH_EXCEPTION_LOCATION);
      }
    }
#endif

   Stefan_boltzmann_illumination_info[ipt].push_back(
    std::make_pair(illuminating_el_pt,illuminating_integration_point_index));

   // Add nodal Data of illuminating elements as external data
   unsigned nnod=illuminating_el_pt->nnode();
   for (unsigned j=0;j<nnod;j++)
    {
     Node* ext_node_pt=illuminating_el_pt->node_pt(j);
     bool own=false;
     for (unsigned jj=0;jj<nnod;jj++)
      {
       if (node_pt(jj)==ext_node_pt)
        {
         own=true;
         break;
        }
      }
     if (!own)
      {
       add_external_data(ext_node_pt);
       if (add_solid_position_data)
        {
         SolidNode* solid_node_pt=dynamic_cast<SolidNode*>(ext_node_pt);
         if (solid_node_pt!=0)
          {
           // hierher
           oomph_info << "Adding solid position data!\n";
           add_external_data(solid_node_pt->variable_position_pt());
          }
        }
      }
    }

  }

 /// \short Output Stefan Boltzmann radiation: x,y,in,out,n_x,n_y
 void output_stefan_boltzmann_radiation(std::ostream &outfile);

 /// \short Output Stefan Boltzmann radiation: Plots rays from illuminated
 /// integration point to illuminating ones (and back).
 void output_stefan_boltzmann_radiation_rays(
  std::ostream &outfile, 
  const unsigned& integration_point=0); 

  protected:

 /// \short Compute the incoming Stefan Boltzmann radiation
 /// onto integration point ipt -- input externally pre-computed
 /// Eulerian coordinate of illuminated integration point, r_illuminated,
 /// and outer unit normal to that point, n_illuminated.
 double incoming_stefan_boltzmann_radiation(const unsigned& ipt,
                                            const Vector<double>& r_illuminated,
                                            const Vector<double>& n_illuminated)
 {
  // Initialise flux
  double flux=0.0;

  /// Number of contributing (illuminating) elements
  unsigned n_contrib=Stefan_boltzmann_illumination_info[ipt].size();
  for (unsigned e=0;e<n_contrib;e++)
   {
    // Pointer to contributing (illuminating) element
    StefanBoltzmannRadiationBase* el_pt=
     Stefan_boltzmann_illumination_info[ipt][e].first;
    
    // Indices of illuminating integration points that contribute
    Vector<unsigned> visible_integration_points=
     Stefan_boltzmann_illumination_info[ipt][e].second;
    
    // Add contribution
    flux+=el_pt->contribution_to_stefan_boltzmann_radiation
     (r_illuminated,n_illuminated,visible_integration_points);
   }
  
  return flux;
 }


 /// Pointer to non-dim Stefan Boltzmann constant
 double* Sigma_pt;

 /// Pointer to non-dim zero centrigrade offset in Stefan Boltzmann law
 double* Theta_0_pt;

 /// \short Illumination info: For each integration point, ipt,
 /// we store all pairs identifying illuminating elements
 /// (via pointer to element and illumnating integration points):
 ///
 /// Stefan_boltzmann_illumination_info[ipt].size() = number of illuminating
 ///       elements
 /// Stefan_boltzmann_illumination_info[ipt][e].first = pointer to e-th
 ///       illuminating element
 /// Stefan_boltzmann_illumination_info[ipt][e].second = vector containing
 ///       index of integration points in e-th illuminating element that are
 ///       visible from current element's ipt'th integration point.
 Vector<Vector<std::pair<StefanBoltzmannRadiationBase*,Vector<unsigned> > > >
 Stefan_boltzmann_illumination_info;


};



//=====================================================================
/// \short Compute the element's contribution to Stefan Boltzmann radiation
/// onto point at r_illuminated with local outer unit normal n_illuminated,
/// using the integration points (in current element) contained
/// in visible_intpts_in_current_element.
//=====================================================================
double StefanBoltzmannRadiationBase::contribution_to_stefan_boltzmann_radiation(
 const Vector<double>& r_illuminated,
 const Vector<double>& n_illuminated,
 const Vector<unsigned>& visible_intpts_in_current_element,
 std::ofstream &outfile)
{

 if (outfile.is_open())
  {
   outfile << "ZONE\n";
   outfile  << r_illuminated[0] << " "
            << r_illuminated[1] << "0 0\n";
  }

 // Initialise
 double contribution=0.0;
 
 //Find out how many nodes there are
 unsigned n_node = nnode();

 //Set up memory for the shape functions
 Shape psi(n_node);
 DShape dpsids(n_node,1);
 
 // Local coordinate
 Vector<double> s(1);

 // Loop over contributing integration points
 unsigned nint=visible_intpts_in_current_element.size();
 for (unsigned ii=0;ii<nint;ii++)
  {
   // Get integration point
   unsigned ipt=visible_intpts_in_current_element[ii];
   
   //Only need to call the local derivatives
   dshape_local_at_knot(ipt,psi,dpsids);
   
   //Get the integral weight
   double w = integral_pt()->weight(ipt);
   
   //Calculate the coords and tangent vector
   Vector<double> r_illuminating(2,0.0);
   Vector<double> interpolated_dxds(2,0.0);
   double interpolated_u=0;
   
   //Loop over nodes
   for(unsigned l=0;l<n_node;l++)
    {
     // Add to temperature
     interpolated_u+=
      node_pt(l)->value(U_index_ust_heat)*psi[l];
     
     //Loop over directions
     for(unsigned i=0;i<2;i++)
      {
       s[i]=this->integral_pt()->knot(ipt,i);
       r_illuminating[i] += nodal_position(l,i)*psi(l);
       interpolated_dxds[i] += nodal_position(l,i)*dpsids(l,0);
      }
    }
   
   /* // Get outer unit normal */
   /* Vector<double> n_illuminating(Dim); */
   /* outer_unit_normal(s,n_illuminating); */

   /* // Jacobian of mapping */
   /* double arclength=sqrt(interpolated_dxds[0]*interpolated_dxds[0]+ */
   /*                       interpolated_dxds[1]*interpolated_dxds[1]); */

   // Vector from illuminated to illuminated point
   Vector<double> ray(2);
   ray[0]=r_illuminating[0]-r_illuminated[0];
   ray[1]=r_illuminating[1]-r_illuminated[1];
   

   // Get inverse length
   double inv_length=1.0/sqrt(ray[0]*ray[0]+ray[1]*ray[1]);
   
   // e_phi (phi measured in mathematically negative sense
   // from vertically above illuminated point -- 'cos that's
   // what it is in my sketch..
   Vector<double> e_phi(2);
   e_phi[0]= inv_length*ray[1];
   e_phi[1]=-inv_length*ray[0];
   
   // Angles
   double cos_phi=inv_length*(n_illuminated[0]*ray[0]+
                              n_illuminated[1]*ray[1]);
   
   // INTEGRAL IS:
   // \int sigma T^4 1/2 \cos \varphi d \varphi =
   // where
   // d\varphi=1/|{\bf R}| \partial {\bf R}/\partial s \cdot {\bf e}_\varphi ds
   
   double integrand=
    this->sigma()*pow((interpolated_u+this->theta_0()),4)*
    0.5*cos_phi*std::fabs(inv_length*(interpolated_dxds[0]*e_phi[0]+
                                      interpolated_dxds[1]*e_phi[1]));
   
   /* double integrand= */
   /*  -this->sigma()*pow((interpolated_u+this->theta_0()),4)* */
   /*  0.5* */
   /*  (ray[0]*n_illuminating[0]+ray[1]*n_illuminating[1])* */
   /*  (ray[0]*n_illuminated [0]+ray[1]*n_illuminated [1])/ */
   /*  pow(ray[0]*ray[0]+ray[1]*ray[1],1.5)*arclength; */


   // Add it in...
   contribution+=integrand*w;
   
   if (outfile.is_open())
    {
     outfile << r_illuminating[0] << " "
             << r_illuminating[1] << " "
             << cos_phi << " "
             << integrand << " "
             << "\n";
    }
  }
 
 return contribution;
}




//=====================================================================
/// Output Stefan Boltzmann radiation. Plots rays from illuminated
/// integration point to illuminating ones (and back).
//=====================================================================
void StefanBoltzmannRadiationBase::output_stefan_boltzmann_radiation_rays(
 std::ostream &outfile, const unsigned& integration_point)
{

 // Vector to illuminated/ing Gauss points
 Vector<double> r_illuminated(2);
 Vector<double> s_illuminated(1);
 Vector<double> unit_normal_illuminated(2);
 Vector<double> r_illuminating(2);
 Vector<double> s_illuminating(1);
 Vector<double> unit_normal_illuminating(2);
 
 unsigned ipt_lo=0;
 unsigned ipt_hi=this->integral_pt()->nweight()-1;
 if (integration_point!=0)
  {
   ipt_lo=integration_point;
   ipt_hi=integration_point;
  }

 // Loop over integration points
 for (unsigned ipt=ipt_lo;ipt<=ipt_hi;ipt++)
  {
   // Local coordinate of integration point
   s_illuminated[0]=this->integral_pt()->knot(ipt,0);
   
   // Get coordinate of illuminated integration point
   this->interpolated_x(s_illuminated,r_illuminated);
      
   // Plot illuminted point
   outfile << "ZONE\n";
   outfile << r_illuminated[0] << " " << r_illuminated[1] << "\n";
   
   // Number of illuminating elements
   unsigned n_illuminating=Stefan_boltzmann_illumination_info[ipt].size();
   for (unsigned i2=0;i2<n_illuminating;i2++)
    {
     // Get pointer to illuminating element
     FiniteElement* el_pt=
      (//dynamic_cast<FiniteElement*>(
       Stefan_boltzmann_illumination_info[ipt][i2].first);
     
     // Illuminating Gauss points in illuminating element
     unsigned n_pts=(Stefan_boltzmann_illumination_info[ipt][i2].second).size();
     for (unsigned ipt2=0;ipt2<n_pts;ipt2++)
      {
       // Illuminating integration point
       unsigned ipt_illum=
        (Stefan_boltzmann_illumination_info[ipt][i2].second)[ipt2];
       
       // Get local coordinate of that integration point
       s_illuminating[0]=el_pt->integral_pt()->knot(ipt_illum,0);
       
       // Get coordinate of illuminating integration point
       el_pt->interpolated_x(s_illuminating,r_illuminating);
       
       // Plot ray to illuminting point and back
       outfile << r_illuminating[0] << " " << r_illuminating[1] << "\n";
       outfile << r_illuminated[0] << " " << r_illuminated[1] << "\n";
      }
    }
  }
}



/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////



//======================================================================
/// \short A class for elements that allow the imposition of (mutual)
/// Stefan Boltzmann heat flux on the boundaries of UnsteadyHeat elements.
/// The element geometry is obtained from the  FaceGeometry<ELEMENT>
/// policy class.
//======================================================================
template <class ELEMENT>
class StefanBoltzmannUnsteadyHeatFluxElement :
public virtual FaceGeometry<ELEMENT>,
 public virtual FaceElement,
 public virtual StefanBoltzmannRadiationBase, 
 public virtual UnsteadyHeatBaseFaceElement<ELEMENT>
{
 
public:

 /// \short Constructor, takes the pointer to the "bulk" element and the
 /// index of the face to be created
 StefanBoltzmannUnsteadyHeatFluxElement(FiniteElement* const &bulk_el_pt,
                              const int &face_index);
 
 /// Broken copy constructor
 StefanBoltzmannUnsteadyHeatFluxElement(
  const StefanBoltzmannUnsteadyHeatFluxElement& dummy)
  {
   BrokenCopy::broken_copy("StefanBoltzmannUnsteadyHeatFluxElement");
  }
 
 /// Broken assignment operator
 void operator=(const StefanBoltzmannUnsteadyHeatFluxElement&)
  {
   BrokenCopy::broken_assign("StefanBoltzmannUnsteadyHeatFluxElement");
  }
 
 /// Compute the element residual vector
 inline void fill_in_contribution_to_residuals(Vector<double> &residuals)
  {
   //Call the generic residuals function with flag set to 0
   //using a dummy matrix argument
   fill_in_generic_residual_contribution_solar_ust_heat_flux(
    residuals,GeneralisedElement::Dummy_matrix,0);
  }


 // // FD-ed now that we've made it nonlinear with Stefan Boltzmann
 // // radiation
 // /// Compute the element's residual vector and its Jacobian matrix
 // inline void fill_in_contribution_to_jacobian(Vector<double> &residuals,
 //                                          DenseMatrix<double> &jacobian)
 //  {
 //   //Call the generic routine with the flag set to 1
 //   fill_in_generic_residual_contribution_solar_ust_heat_flux(residuals,jacobian,1);
 //  }

 /// \short Change integration scheme (overloads underlying version and
 /// and resizes lookup schemes introduced in this class.
 void set_integration_scheme(Integral* const &integral_pt)
 {
  FiniteElement::set_integration_scheme(integral_pt);
  unsigned n_intpt = integral_pt->nweight();
  Stefan_boltzmann_illumination_info.resize(n_intpt);
 }

 /// \short Specify the value of nodal zeta from the face geometry:
 /// The "global" intrinsic coordinate of the element when
 /// viewed as part of a geometric object should be given by
 /// the FaceElement representation, by default (needed to break
 /// indeterminacy if bulk element is SolidElement)
 double zeta_nodal(const unsigned &n, const unsigned &k,
                   const unsigned &i) const
 {return FaceElement::zeta_nodal(n,k,i);}


  /// Output function
  void output(std::ostream &outfile) 
  {
   unsigned nplot=5;
   output(outfile,nplot);
  }
  
  
  /// \short Output function. Note: nplot is ignored since we can only
  /// output at integration points
  void output(std::ostream &outfile, const unsigned &n_plot)
  { 
   unsigned n_dim = this->nodal_dimension();
   
   Vector<double> x(n_dim);
   Vector<double> s(n_dim-1);
   Vector<double> dx_dt(n_dim);
   
   //Set the value of n_intpt
   unsigned n_intpt = integral_pt()->nweight();
   
   outfile << "ZONE\n";
   
   //Loop over the integration points
   for(unsigned ipt=0;ipt<n_intpt;ipt++)
    {
     // Local coordinate of integration point
     for (unsigned i=0;i<n_dim-1;i++)
      {
       s[i]=integral_pt()->knot(ipt,i);
      }
     
     // Get Eulerian coordinates and their time derivative
     this->interpolated_x(s,x);
     this->interpolated_dxdt(s,1,dx_dt);
     
     // Get temperature
     double interpolated_u=0;
     this->interpolated_u(s,interpolated_u);
     
     // Outer unit normal
     Vector<double> unit_normal(n_dim);
     outer_unit_normal(s,unit_normal);
     
     
     // Get flux into adjacent bulk element
     //------------------------------------
     
     // Get pointer to bulk element
     ELEMENT* bulk_el_pt=dynamic_cast<ELEMENT*>(this->bulk_element_pt());
     
     // Local coordinates in bulk element
     Vector<double> s_bulk(n_dim);
     s_bulk=local_coordinate_in_bulk(s);
     
     // Get flux from bulk element (flux[i] = du/dx_i)
     Vector<double> flux_vector(n_dim);
     bulk_el_pt->get_flux(s_bulk,flux_vector);
     
     // Work out heat flux seen by adjacent bulk element
     // du/dn > 0: Hotter on surface than on inside of bulk
     // so net flux (from hot to cold) is into the bulk.
     double beta_dtheta_dn=0.0;
     for (unsigned i=0;i<n_dim;i++)
      {
       beta_dtheta_dn+=flux_vector[i]*unit_normal[i];
      }
     beta_dtheta_dn*= bulk_el_pt->beta();
     
     // Outgoing Stefan Boltzmann radiation
     //-------------------------------------
     double outgoing_sb_radiation=
      this->sigma()*pow((interpolated_u+this->theta_0()),4);
     
     // Incoming Stefan Boltzmann radiation
     //------------------------------------
     double incoming_sb_radiation=incoming_stefan_boltzmann_radiation
      (ipt,x,unit_normal);
     
     //Output the x,y,..
     for(unsigned i=0;i<n_dim;i++)
      {outfile << x[i] << " ";}
     
     // Output radiative gains
     outfile << incoming_sb_radiation << " ";
     
     // Output radiative losses
     outfile <<  outgoing_sb_radiation << " ";
     
     // Net heat flux into adjacent bulk
     outfile << beta_dtheta_dn << " ";
     
     // Temperature
     outfile << interpolated_u << " ";
     
     // Output mesh velocity
     for(unsigned i=0;i<n_dim;i++)
      {
       outfile << dx_dt[i] << " ";
      }
     // Output normal
     for(unsigned i=0;i<n_dim;i++)
      {
       outfile << unit_normal[i] << " ";
      }
     
     outfile << std::endl;
    }
  }

protected:
 
 /// \short Function to compute the shape and test functions and to return
 /// the Jacobian of mapping between local and global (Eulerian)
 /// coordinates
 inline double shape_and_test(const Vector<double> &s, Shape &psi, Shape &test)
  const
  {
   //Find number of nodes
   unsigned n_node = nnode();

   //Get the shape functions
   shape(s,psi);

   //Set the test functions to be the same as the shape functions
   for(unsigned i=0;i<n_node;i++) {test[i] = psi[i];}

   //Return the value of the jacobian
   return J_eulerian(s);
  }



private:

 /// \short Compute the element residual vector.
 /// flag=1(or 0): do (or don't) compute the Jacobian as well.
 void fill_in_generic_residual_contribution_solar_ust_heat_flux(
  Vector<double> &residuals, DenseMatrix<double> &jacobian,
  unsigned flag);
 
};

////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////

//===========================================================================
/// Constructor, takes the pointer to the "bulk" element and the
/// index of the face to be created.
//===========================================================================
template<class ELEMENT>
StefanBoltzmannUnsteadyHeatFluxElement<ELEMENT>::
StefanBoltzmannUnsteadyHeatFluxElement(FiniteElement* const &bulk_el_pt,
                             const int &face_index) :
 FaceGeometry<ELEMENT>(), FaceElement()
{
 


#ifdef PARANOID
 {
  // hierher 

  //Check that the element is not a refineable 3d element
  ELEMENT* elem_pt = new ELEMENT;
  //If it's three-d
  if(elem_pt->dim()==3)
   {
    //Is it refineable
    if(dynamic_cast<RefineableElement*>(elem_pt))
     {
      //Issue a warning
      OomphLibWarning(
       "This flux element will not work correctly if nodes are hanging\n",
       OOMPH_CURRENT_FUNCTION,
       OOMPH_EXCEPTION_LOCATION);
     }
   }
 }
#endif
  
 // Let the bulk element build the FaceElement, i.e. setup the pointers
 // to its nodes (by referring to the appropriate nodes in the bulk
 // element), etc.
 bulk_el_pt->build_face_element(face_index,this);

 // Extract index of nodal value that stores temperature from
 // bulk elements
 this->extract_temperature_index_from_bulk_element(bulk_el_pt);


#ifdef PARANOID
 // Check spatial dimension
 if (Dim!=2)
  {
   //Issue a warning
   throw OomphLibError(
    "This element will almost certainly not work in non-2D problems, though it should be easy enough to upgrade... Volunteers?\n",
    OOMPH_CURRENT_FUNCTION,
    OOMPH_EXCEPTION_LOCATION);
  }
#endif

}



//===========================================================================
/// Compute the element's residual vector and the Jacobian matrix.
//===========================================================================
template<class ELEMENT>
void StefanBoltzmannUnsteadyHeatFluxElement<ELEMENT>::
fill_in_generic_residual_contribution_solar_ust_heat_flux(
 Vector<double> &residuals, DenseMatrix<double> &jacobian,
 unsigned flag)
{
 //Find out how many nodes there are
 const unsigned n_node = nnode();

  //Set up memory for the shape and test functions
 Shape psif(n_node), testf(n_node);
 
 //Set the value of n_intpt
 const unsigned n_intpt = integral_pt()->nweight();
 
 //Set the Vector to hold local coordinates
 Vector<double> s(Dim-1);
 
 //Integer to store the local equation numbers
 int local_eqn=0;

 // Locally cache the index at which the variable is stored
 const unsigned u_index_ust_heat = U_index_ust_heat;
 
 // Interpolated u
 double interpolated_u=0;
 
 //Loop over the integration points
 //--------------------------------
 for(unsigned ipt=0;ipt<n_intpt;ipt++)
  {

   //Assign values of s
   for(unsigned i=0;i<(Dim-1);i++)
    {
     s[i] = integral_pt()->knot(ipt,i);
    }

   //Get the integral weight
   double w = integral_pt()->weight(ipt);
   
   //Find the shape and test functions and return the Jacobian
   //of the mapping
   double J = shape_and_test(s,psif,testf);
   
   //Premultiply the weights and the Jacobian
   double W = w*J;
   
   // Get outer unit normal
   Vector<double> n(Dim);
   outer_unit_normal(s,n);

   //Need to find position to feed into flux function
   Vector<double> interpolated_x(Dim);
   
   //Initialise to zero
   for(unsigned i=0;i<Dim;i++)
    {
     interpolated_x[i] = 0.0;
    }
   
   //Calculate temperature position
   interpolated_u=0.0;
   for(unsigned l=0;l<n_node;l++)
    {
     //Calculate the value at the nodes
     double u_value = raw_nodal_value(l,u_index_ust_heat);
     interpolated_u += u_value*psif[l];
     
     //Loop over directions
     for(unsigned i=0;i<Dim;i++)
      {
       interpolated_x[i] += nodal_position(l,i)*psif[l];
      }
    }
   
   // Outgoing Stefan Boltzmann radiation
   double outgoing_sb_radiation=
    this->sigma()*pow((interpolated_u+this->theta_0()),4);

   // Incoming Stefan Boltzmann radiation
   double incoming_sb_radiation=incoming_stefan_boltzmann_radiation
    (ipt,interpolated_x,n);

   // Net flux
   double flux=incoming_sb_radiation-outgoing_sb_radiation;

   //Loop over the test functions
   for(unsigned l=0;l<n_node;l++)
    {
     local_eqn = nodal_local_eqn(l,u_index_ust_heat);
     /*IF it's not a boundary condition*/
     if(local_eqn >= 0)
      {
       // Add the prescribed flux terms NOTE THAT THERE'S NO BETA
       // IN HERE THE ABOVE BALANCES THE BETA * DU/DN THAT APPEARS
       // IN THE WEAK FORM OF THE EQUATIONS!
       residuals[local_eqn] -= flux*testf[l]*W;
       
       // No Jacobian -- computed by FD anyway!
       if (flag==1)
        {
         // hierher may speed it up a lot..
         throw OomphLibError(
          "Analytical Jacobian not yet implemented... Volunteers?\n",
          OOMPH_CURRENT_FUNCTION,
          OOMPH_EXCEPTION_LOCATION);
        }

      }
    }
  }
}

//////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////


//=======================================================================
/// Namespace containing helper functions for Stefan Boltzmann radiation
//=======================================================================
namespace StefanBoltzmannHelper
{
 
 /// Bin to store pointers to finite elements in
 Vector<Vector<std::set<FiniteElement*> > > Element_in_bin;
 
 /// Max/min bin coords
 Vector<double> Max_coord(2,-DBL_MAX);
 Vector<double> Min_coord(2, DBL_MAX);
 
 /// Increments in bin
 Vector<double> Dx(2,0.0);
 
 /// Number of bins in x direction
 unsigned Nx_bin=1000;
 
 /// Number of bins in y direction
 unsigned Ny_bin=1000;
 
 /// \short Number of sampling points in element to form segments with which
 /// we check intersection with ray
 unsigned Nsample=10;
 
 
 //======================================================================
 /// \short Helper function to setup or use bin that is used to
 /// locate intersections of rays with boundaries.
 ///
 /// Args:  -- Two vectors, ray_vertex[0] and ray_vertex[1] which define
 ///           the end points of a ray.
 ///        -- Boolean populate_bin:
 //            If true:  populate the bin structure represented by
 ///                     Element_in_bin by associating all bins
 ///                     that are intersected by the ray with the element
 ///                     pointed to by el_pt.
 ///           If false: Return vector of bin indices that are intersected
 ///                     by the ray (retrived from previously set up bin
 ///                     structure)
 ///        -- Output stream outfile; if open, we write the intersected bins
 ///           to that file but only if populate_bin=false. Only used for
 ///           debugging...
 //======================================================================
 void bin_helper(const Vector<Vector<double> >& ray_vertex,
                 const bool& populate_bin,
                 Vector<std::pair<unsigned,unsigned> >& intersected_bin,
                 FiniteElement* el_pt,
                 ofstream& outfile)
 {
  
  // Actually plot
  bool plot_it=false;
  if (outfile.is_open())
   {
    if (populate_bin)
     {
      //Issue a warning
      OomphLibWarning(
       "Not outputting while bin is being populated...\n",
       OOMPH_CURRENT_FUNCTION,
       OOMPH_EXCEPTION_LOCATION);
     }
    else
     {
      plot_it=true;
     }
   }
  
  // Step along ray in increasing y direction
  Vector<double> lower_ray_vertex=ray_vertex[0];
  Vector<double> upper_ray_vertex=ray_vertex[1];
  if (ray_vertex[1][1]<ray_vertex[0][1])
   {
    lower_ray_vertex=ray_vertex[1];
    upper_ray_vertex=ray_vertex[0];
   }
  
  // Output
  if (plot_it)
   {
    outfile
     << "ZONE T=\"ray\"\n"
     <<ray_vertex[0][0] << " " << ray_vertex[0][1] << "\n"
     <<ray_vertex[1][0] << " " << ray_vertex[1][1] << "\n";
   }
  
  // Add bin that contains the start point of the ray
  unsigned ix_start=unsigned((lower_ray_vertex[0]-Min_coord[0])/
                             (Max_coord[0]-Min_coord[0])*
                             double(Nx_bin));
  unsigned iy_start=unsigned((lower_ray_vertex[1]-Min_coord[1])/
                             (Max_coord[1]-Min_coord[1])*
                             double(Ny_bin));
  if (populate_bin)
   {
    Element_in_bin[ix_start][iy_start].insert(el_pt);
   }
  else
   {
    intersected_bin.push_back(std::make_pair(ix_start,iy_start));
   }
  
  // Vertical ray?
  if (lower_ray_vertex[0]==upper_ray_vertex[0])
   {
    // Add all the bins above the initial one until end point
    unsigned iy_end=unsigned((upper_ray_vertex[1]-Min_coord[1])/
                             (Max_coord[1]-Min_coord[1])*
                             double(Ny_bin));
    for (unsigned i=iy_start+1;i<=iy_end;i++)
     {
      if (populate_bin)
       {
        Element_in_bin[ix_start][i].insert(el_pt);
       }
      else
       {
        intersected_bin.push_back(std::make_pair(ix_start,i));
       }
     }
   }
  /* // horizonal ray? */
  /* else (lower_ray_vertex[1]==upper_ray_vertex[1]) */
  /*       { */

  /*   // Add all the bins above the initial one until end point */
  /*   unsigned i_end=unsigned((upper_ray_vertex[1]-Min_coord[1])/ */
  /*                            (Max_coord[1]-Min_coord[1])* */
  /*                            double(Ny_bin)); */
  /*   for (unsigned i=iy_start+1;i<=iy_end;i++) */
  /*    { */
  /*     if (populate_bin) */
  /*      { */
  /*       Element_in_bin[ix_start][i].insert(el_pt); */
  /*      } */
  /*     else */
  /*      { */
  /*       intersected_bin.push_back(std::make_pair(ix_start,i)); */
  /*      } */
  /*    } */
  /*       } */
  // Non-vertical ray
  else
   {
    // Get the (finite) slope
    double slope=
     (upper_ray_vertex[1]-lower_ray_vertex[1])/
     (upper_ray_vertex[0]-lower_ray_vertex[0]);
    
    // Current bin level
    unsigned iy=iy_start;
    
    // Upper and lower bounds of current bin level
    double y_this_bin_min=Min_coord[1]+double(iy  )*Dx[1];
    double y_this_bin_max=Min_coord[1]+double(iy+1)*Dx[1];
    
    // Keep going until we've moved through all the
    // bins beyond the y-level of the ray's end point
    int unit_offset=1;
    while (y_this_bin_min<upper_ray_vertex[1])
     {
      // Work out x-coordinate of intersection of ray with
      // other boundary of its current y-bin level
      double x_intersect=Max_coord[0];
      if (lower_ray_vertex[0]>upper_ray_vertex[0])
       {
        x_intersect=Min_coord[0];
       }
      if (slope!=0.0)
       {
        x_intersect=lower_ray_vertex[0]+
         (y_this_bin_max-lower_ray_vertex[1])/slope;
       }
      
      // Cut it off if it goes outside the bin structure
      if (x_intersect>Max_coord[0]) x_intersect=Max_coord[0] ;
      if (x_intersect<Min_coord[0]) x_intersect=Min_coord[0] ;
      
      // What's the x-bin index of that point
      unsigned ix_intersect=unsigned((x_intersect-Min_coord[0])/
                                     (Max_coord[0]-Min_coord[0])*
                                     double(Nx_bin));

      // limits for x bins:
      unsigned i_lo=ix_start;
      unsigned i_hi=ix_intersect;

      // Swap if going to the left and apply 
      // unit offset. Equal to one initially because the first
      // bin has already been filled; in subsequent rows of
      // bins, we add all of them.
      if (i_lo>i_hi)
       {
        i_lo=ix_intersect;
        i_hi=ix_start-unit_offset;
       }
      else
       {
        i_lo+=unit_offset;
       }
      unit_offset=0;      

      // ...but don't fall off the end... 
      if (i_hi==Nx_bin) i_hi-=1;

      // Now add all the bins at this y-level
      for (unsigned i=i_lo;i<=i_hi;i++)
       {
        // .. but don't go beyond the end of the ray
        bool add_it=true;
        if (slope>0.0)
         {
          double x_left_end_bin =Min_coord[0]+double(i  )*Dx[0];
          if (x_left_end_bin>upper_ray_vertex[0])
           {
            add_it=false;
           }
         }
        else if (slope<0.0)
         {
          double x_right_end_bin=Min_coord[0]+double(i+1)*Dx[0];
          if (x_right_end_bin<upper_ray_vertex[0])
           {
            add_it=false;
           }
         }
        else
         {
          double x_left_end_bin =Min_coord[0]+double(i  )*Dx[0];
          double x_right_end_bin=Min_coord[0]+double(i+1)*Dx[0];
          if (x_left_end_bin>max(upper_ray_vertex[0],lower_ray_vertex[0]))
           {
            add_it=false;
           }
          else if (x_right_end_bin<min(upper_ray_vertex[0],lower_ray_vertex[0]))
           {
            add_it=false;
           }
         }

        if (add_it)
         {
          if (populate_bin)
           {
            Element_in_bin[i][iy].insert(el_pt);
           }
          else
           {
            intersected_bin.push_back(std::make_pair(i,iy));
           }
         }
       }
        
      // Now update the counters: x bin level starts at the
      // point of intersection with the next level...
      ix_start=ix_intersect;
        
      // ...upper and lower boundary moves one level up
      y_this_bin_min+=Dx[1];
      y_this_bin_max+=Dx[1];
        
      // ...and bump up the level itself
      iy++;
     }
   }
    
  // Plot the intersected bins?
  if (plot_it)
   {
    unsigned nbin=intersected_bin.size();
    for (unsigned i=0;i<nbin;i++)
     {
      unsigned ix=intersected_bin[i].first;
      unsigned iy=intersected_bin[i].second;
        
      double x_lo=Min_coord[0]+double(ix)*Dx[0];
      double x_hi=x_lo+Dx[0];
      double y_lo=Min_coord[1]+double(iy)*Dx[1];
      double y_hi=y_lo+Dx[1];
        
      outfile << "ZONE\n"
              << x_lo << " " << y_lo << "\n"
              << x_hi << " " << y_lo << "\n"
              << x_hi << " " << y_hi << "\n"
              << x_lo << " " << y_hi << "\n"
              << x_lo << " " << y_lo << "\n";
     }
   }
 }
 
 
 //=================================================================
 // Doc populated bins
 //=================================================================
 void doc_bins(ofstream& bin_file)
 {
  // Loop over bins
  for (unsigned ix=0;ix<Nx_bin;ix++)
   {
    for (unsigned iy=0;iy<Ny_bin;iy++)
     {
      // Anybody at home?
      if (Element_in_bin[ix][iy].size()!=0)
       {
        double x_lo=Min_coord[0]+double(ix)*Dx[0];
        double x_hi=x_lo+Dx[0];
        double y_lo=Min_coord[1]+double(iy)*Dx[1];
        double y_hi=y_lo+Dx[1];
          
        bin_file << "ZONE I=2, J=2\n"
                 << x_lo << " " << y_lo << "\n"
                 << x_hi << " " << y_lo << "\n"
                 << x_lo << " " << y_hi << "\n"
                 << x_hi << " " << y_hi << "\n";

       }
     }
   }
 }



 //=================================================================
 // Doc sample points of Stefan Boltzmann elements
 //=================================================================
 void doc_sample_points(ofstream& outfile, 
                        const Vector<FiniteElement*>& sb_face_element_pt)
 {    
  // Vector for  coordinates of sample point
  Vector<double> sample_point(2);
  Vector<double> s(1);

  // Loop over all face elements
  unsigned nel=sb_face_element_pt.size();
  for (unsigned e=0;e<nel;e++)
   {
    StefanBoltzmannRadiationBase* el_pt=
     dynamic_cast<StefanBoltzmannRadiationBase*>(
      sb_face_element_pt[e]);
#ifdef PARANOID 
    if (el_pt==0)
     {
      std::stringstream error_message;
      error_message << "Failed to cast possible intersecting element "
                    << e
                    << " to  StefanBoltzmannRadiationBase";
      throw OomphLibError(
       error_message.str(),
       OOMPH_CURRENT_FUNCTION,
       OOMPH_EXCEPTION_LOCATION);
     }
#endif
      
    // Loop over sampling points
    for (unsigned j_sample=0;j_sample<Nsample;j_sample++)
     {
      // Get vector of local coordinates of plot point j
      // as second vertex
      el_pt->get_s_plot(j_sample,Nsample,s);
        
      // Get coordinate of vertex
      el_pt->interpolated_x(s,sample_point);
        
      outfile << sample_point[0] << " " << sample_point[1] << "\n";
     }
   }
 }


 //=======================================================================
 /// Setup mutual visibility for Stefan Boltzmann radiation for all
 /// face elements (derived from StefanBoltzmannRadiationBase)
 /// contained in vector.
 //=======================================================================
 void setup_stefan_boltzmann_visibility(const Vector<FiniteElement*>&
                                        sb_face_element_pt)
 {
  // Output file for debugging
  const bool plot_it=false;
  ofstream some_file;
  char filename[100];

  // Loop over all face elements to wipe previous information
  unsigned nel=sb_face_element_pt.size();
  for (unsigned e_illuminated=0;e_illuminated<nel;e_illuminated++)
   {
    StefanBoltzmannRadiationBase* illuminated_el_pt=
     dynamic_cast<StefanBoltzmannRadiationBase*>(
      sb_face_element_pt[e_illuminated]);
#ifdef PARANOID
    if (illuminated_el_pt==0)
     {
      std::stringstream error_message;
      error_message << "Failed to cast illuminated element "
                    << e_illuminated
                    << " to  StefanBoltzmannRadiationBase";
      throw OomphLibError(
       error_message.str(),
       OOMPH_CURRENT_FUNCTION,
       OOMPH_EXCEPTION_LOCATION);
     }
#endif
     
    // Forget any previous information
    illuminated_el_pt->wipe_stefan_boltzmann_illumination_info();
   }


  double t_start=TimingHelpers::timer();

  // Vector to illuminated/ing Gauss points
  Vector<double> r_illuminated(2);
  Vector<double> s_illuminated(1);
  Vector<double> unit_normal_illuminated(2);
  Vector<double> r_illuminating(2);
  Vector<double> s_illuminating(1);
  Vector<double> unit_normal_illuminating(2);

  // Setup bin structure
  const bool use_bins=true;
  if (use_bins)
   {
    double t_start_bin=TimingHelpers::timer();

    // Each bin stores FiniteElements that have any sample point in it
    Element_in_bin.clear();
    Element_in_bin.resize(Nx_bin);
    for (unsigned i=0;i<Nx_bin;i++)
     {
      Element_in_bin[i].resize(Ny_bin);
     }
     
    // Initial sweep: Get max/min coords
    //----------------------------------

    // Loop over all face elements
    unsigned nel=sb_face_element_pt.size();
    for (unsigned e_illuminated=0;e_illuminated<nel;e_illuminated++)
     {
      StefanBoltzmannRadiationBase* illuminated_el_pt=
       dynamic_cast<StefanBoltzmannRadiationBase*>(
        sb_face_element_pt[e_illuminated]);
#ifdef PARANOID
      if (illuminated_el_pt==0)
       {
        std::stringstream error_message;
        error_message << "Failed to cast illuminated element "
                      << e_illuminated
                      << " to  StefanBoltzmannRadiationBase";
        throw OomphLibError(
         error_message.str(),
         OOMPH_CURRENT_FUNCTION,
         OOMPH_EXCEPTION_LOCATION);
       }
#endif
       
      // Loop over iluminated integration points
      unsigned nint=illuminated_el_pt->integral_pt()->nweight();
      for (unsigned ipt_illuminated=0;ipt_illuminated<nint;ipt_illuminated++)
       {
        // Local coordinate of integration point
        s_illuminated[0]=
         illuminated_el_pt->integral_pt()->knot(ipt_illuminated,0);
         
        // No recycling of shape fcts -- may as well call interpolated_x
        // directly
        illuminated_el_pt->interpolated_x(s_illuminated,r_illuminated);
         
        for (unsigned i=0;i<2;i++)
         {
          if (r_illuminated[i]>Max_coord[i]) Max_coord[i]=r_illuminated[i];
          if (r_illuminated[i]<Min_coord[i]) Min_coord[i]=r_illuminated[i];
         }
       }
     }

    // Allow for offset
    double percentage_offset=5.0;
    for (unsigned i=0;i<2;i++)
     {
      double dx=Max_coord[i]-Min_coord[i];
      Max_coord[i]=Max_coord[i]+percentage_offset/100.0*dx;
      Min_coord[i]=Min_coord[i]-percentage_offset/100.0*dx;
     }

    // Update increments
    Dx[0]=(Max_coord[0]-Min_coord[0])/double(Nx_bin);
    Dx[1]=(Max_coord[1]-Min_coord[1])/double(Ny_bin);
     

    const bool test_horizontal_and_vertical_rays=false;
    if (test_horizontal_and_vertical_rays)
     {
      
      // Test for left to right horizontal ray
      {
       // Populate bin by associating all bins intersected by
       // ray from one to the other sample vertex with the
       // element (note that the ray can span multiple bins!)
       Vector<std::pair<unsigned,unsigned> > dummy_intersected_bin;
       bool populate_bin=true;
       ofstream dummy_file;
       Vector<Vector<double> > sample_vertex(2);
       sample_vertex[0].resize(2);
       sample_vertex[1].resize(2);
       sample_vertex[0][0]=-0.9;
       sample_vertex[0][1]=0.9;
       sample_vertex[1][0]=0.9;
       sample_vertex[1][1]=0.9;
       
       StefanBoltzmannRadiationBase* el_pt=
        dynamic_cast<StefanBoltzmannRadiationBase*>(
         sb_face_element_pt[0]);
       
       bin_helper(sample_vertex,
                  populate_bin,
                  dummy_intersected_bin,
                  el_pt,
                  dummy_file);
      }
      
      
      
      
      // Test for right to left horizontal ray
      {
       // Populate bin by associating all bins intersected by
       // ray from one to the other sample vertex with the
       // element (note that the ray can span multiple bins!)
       Vector<std::pair<unsigned,unsigned> > dummy_intersected_bin;
       bool populate_bin=true;
       ofstream dummy_file;
       Vector<Vector<double> > sample_vertex(2);
       sample_vertex[0].resize(2);
       sample_vertex[1].resize(2);
       sample_vertex[0][0]= 0.9;
       sample_vertex[0][1]=-0.9;
       sample_vertex[1][0]=-0.9;
       sample_vertex[1][1]=-0.9;
       
       StefanBoltzmannRadiationBase* el_pt=
        dynamic_cast<StefanBoltzmannRadiationBase*>(
         sb_face_element_pt[0]);
       
       bin_helper(sample_vertex,
                  populate_bin,
                  dummy_intersected_bin,
                  el_pt,
                  dummy_file);
      }
      
      
      // Test for bottom to top vertical ray
      {
       // Populate bin by associating all bins intersected by
       // ray from one to the other sample vertex with the
       // element (note that the ray can span multiple bins!)
       Vector<std::pair<unsigned,unsigned> > dummy_intersected_bin;
       bool populate_bin=true;
       ofstream dummy_file;
       Vector<Vector<double> > sample_vertex(2);
       sample_vertex[0].resize(2);
       sample_vertex[1].resize(2);
       sample_vertex[0][0]=-0.7;
       sample_vertex[0][1]=-0.9;
       sample_vertex[1][0]=-0.7;
       sample_vertex[1][1]= 0.9;
       
       StefanBoltzmannRadiationBase* el_pt=
        dynamic_cast<StefanBoltzmannRadiationBase*>(
         sb_face_element_pt[0]);
       
       bin_helper(sample_vertex,
                  populate_bin,
                  dummy_intersected_bin,
                  el_pt,
                  dummy_file);
      }
      
      
      // Test for to to bottom vertical ray
      {
       // Populate bin by associating all bins intersected by
       // ray from one to the other sample vertex with the
       // element (note that the ray can span multiple bins!)
       Vector<std::pair<unsigned,unsigned> > dummy_intersected_bin;
       bool populate_bin=true;
       ofstream dummy_file;
       Vector<Vector<double> > sample_vertex(2);
       sample_vertex[0].resize(2);
       sample_vertex[1].resize(2);
       sample_vertex[0][0]= 0.7;
       sample_vertex[0][1]= 0.9;
       sample_vertex[1][0]= 0.7;
       sample_vertex[1][1]=-0.9;
       
       StefanBoltzmannRadiationBase* el_pt=
        dynamic_cast<StefanBoltzmannRadiationBase*>(
         sb_face_element_pt[0]);
       
       bin_helper(sample_vertex,
                  populate_bin,
                  dummy_intersected_bin,
                  el_pt,
                  dummy_file);
      }
      
     } // end of test for horizontal and vertical rays

    // Setup bin for checking intersections with rays
    //-----------------------------------------------
     
    // Loop over all face elements
    nel=sb_face_element_pt.size();
    for (unsigned e=0;e<nel;e++)
     {
      StefanBoltzmannRadiationBase* el_pt=
       dynamic_cast<StefanBoltzmannRadiationBase*>(
        sb_face_element_pt[e]);
#ifdef PARANOID
      if (el_pt==0)
       {
        std::stringstream error_message;
        error_message << "Failed to cast possible intersecting element "
                      << e
                      << " to  StefanBoltzmannRadiationBase";
        throw OomphLibError(
         error_message.str(),
         OOMPH_CURRENT_FUNCTION,
         OOMPH_EXCEPTION_LOCATION);
       }
#endif

      // Loop over ALL sampling points along element
      Vector<Vector<double> > sample_vertex(2);
      sample_vertex[0].resize(2);
      sample_vertex[1].resize(2);
       
      // Get vector of local coordinates of plot point j
      // as first vertex
      Vector<double> s(1);
      unsigned j_sample=0;
      el_pt->get_s_plot(j_sample,Nsample,s);
       
      // Get coordinate of first vertex
      el_pt->interpolated_x(s,sample_vertex[0]);
       
      // Loop over remaining sampling points
      for (unsigned j_sample=1;j_sample<Nsample;j_sample++)
       {
        // Get vector of local coordinates of plot point j
        // as second vertex
        el_pt->get_s_plot(j_sample,Nsample,s);
         
        // Get coordinate of vertex
        el_pt->interpolated_x(s,sample_vertex[1]);
        
        // Populate bin by associating all bins intersected by
        // ray from one to the other sample vertex with the
        // element (note that the ray can span multiple bins!)
        Vector<std::pair<unsigned,unsigned> > dummy_intersected_bin;
        bool populate_bin=true;
        ofstream dummy_file;
        bin_helper(sample_vertex,
                   populate_bin,
                   dummy_intersected_bin,
                   el_pt,
                   dummy_file);
         
        // Shift along
        sample_vertex[0]=sample_vertex[1];
       }
     }
     
    double t_end_bin=TimingHelpers::timer();
    oomph_info << "Time for setting up bin: "
               << t_end_bin-t_start_bin << std::endl;
   
    // Number of elements
    nel=sb_face_element_pt.size();

    // Assume all elements have the same number of integration points
    unsigned nintpt_all=sb_face_element_pt[0]->integral_pt()->nweight();

    // Exploit symmetry during setup
    const bool exploit_symmetry=true;

    // Helper lookup scheme to exploit symmetry of interaction:
    // If integration point i_ed in element e_ed is illuminatED by
    // integration point i_ing in element e_ing (which is the
    // illuminatING one!) then the reverse is true too
    Vector<Vector<Vector<Vector<unsigned> > > > aux;
    if (exploit_symmetry)
     {
      nintpt_all=sb_face_element_pt[0]->integral_pt()->nweight();
      aux.resize(nel);
      for (unsigned e=0;e<nel;e++)
       {
        aux[e].resize(nintpt_all);
        for (unsigned ipt=0;ipt<nintpt_all;ipt++)
         {
          aux[e][ipt].resize(nel);
         }
       }
     }
  
    // Loop over all face elements -- viewed as illuminated ones
    for (unsigned e_illuminated=0;e_illuminated<nel;e_illuminated++)
     {
      StefanBoltzmannRadiationBase* illuminated_el_pt=
       dynamic_cast<StefanBoltzmannRadiationBase*>(
        sb_face_element_pt[e_illuminated]);

#ifdef PARANOID
      if (illuminated_el_pt==0)
       {
        std::stringstream error_message;
        error_message << "Failed to cast illuminated element "
                      << e_illuminated
                      << " to  StefanBoltzmannRadiationBase";
        throw OomphLibError(
         error_message.str(),
         OOMPH_CURRENT_FUNCTION,
         OOMPH_EXCEPTION_LOCATION);
       }
#endif
     
      // Recast to FaceElement
      FaceElement* illuminated_face_el_pt=
       dynamic_cast<FaceElement*>(illuminated_el_pt);
     
      // Loop over iluminated integration points
      unsigned nint=illuminated_el_pt->integral_pt()->nweight();
      for (unsigned ipt_illuminated=0;ipt_illuminated<nint;ipt_illuminated++)
       {
        // Local coordinate of integration point
        s_illuminated[0]=
         illuminated_el_pt->integral_pt()->knot(ipt_illuminated,0);
       
        // No recycling of shape fcts -- may as well call interpolated_x
        // directly
        illuminated_el_pt->interpolated_x(s_illuminated,r_illuminated);
       
        // Get outer unit normal
        illuminated_face_el_pt->outer_unit_normal(s_illuminated,
                                                  unit_normal_illuminated);
       
        // Now loop over all other elements (the iluminating ones)
        // Note: this includes the current one because its integration
        // points may illuminate each other!
        unsigned e_lo=0;
        if (exploit_symmetry) e_lo=e_illuminated;
        for (unsigned e_illuminating=e_lo;e_illuminating<nel;e_illuminating++)
         {
          StefanBoltzmannRadiationBase* illuminating_el_pt=
           dynamic_cast<StefanBoltzmannRadiationBase*>(
            sb_face_element_pt[e_illuminating]);

#ifdef PARANOID
          if (illuminating_el_pt==0)
           {
            std::stringstream error_message;
            error_message << "Failed to cast illuminating element "
                          << e_illuminating
                          << " to  StefanBoltzmannRadiationBase";
            throw OomphLibError(
             error_message.str(),
             OOMPH_CURRENT_FUNCTION,
             OOMPH_EXCEPTION_LOCATION);
           }
#endif
         
          // Recast to FaceElement
          FaceElement* illuminating_face_el_pt=
           dynamic_cast<FaceElement*>(illuminating_el_pt);
         
          // Storage to accumulate indices of integration points in
          // illuminating face element that is visible from
          // current integration point
          Vector<unsigned> illuminating_integration_point_index;
         
          // Loop over iluminating integration points
          unsigned nint=illuminating_el_pt->integral_pt()->nweight();
          for (unsigned ipt_illuminating=0;ipt_illuminating<nint;
               ipt_illuminating++)
           {
            // Local coordinate of integration point
            s_illuminating[0]=
             illuminating_el_pt->integral_pt()->knot(ipt_illuminating,0);
           
            // No recycling of shape fcts -- may as well call interpolated_x
            // directly
            illuminating_el_pt->interpolated_x(s_illuminating,r_illuminating);
           
            // Get outer unit normal
            illuminating_face_el_pt->outer_unit_normal(s_illuminating,
                                                       unit_normal_illuminating);
           
            // Get vector from illuminating point to illuminated point
            Vector<double> ray(2);
            ray[0]=r_illuminated[0]-r_illuminating[0];
            ray[1]=r_illuminated[1]-r_illuminating[1];
           

            Vector<Vector<double> > ray_vertex(2);
            ray_vertex[0].resize(2);
            ray_vertex[1].resize(2);
            ray_vertex[0][0]=r_illuminated[0];
            ray_vertex[0][1]=r_illuminated[1];
            ray_vertex[1][0]=r_illuminating[0];
            ray_vertex[1][1]=r_illuminating[1];

            // Do we radiate away from the positive face of the
            // illuminating point?
            double dot_illuminating=
             (unit_normal_illuminating[0]*ray[0]+
              unit_normal_illuminating[1]*ray[1]);
            if (dot_illuminating>0.0)
             {
             
              // Do we radiate onto from the positive face of the
              // illuminated point?
              double dot_illuminated=
               (unit_normal_illuminated[0]*ray[0]+
                unit_normal_illuminated[1]*ray[1]);
              if (dot_illuminated<0.0)
               {

                // Does the ray (a finite-length segment) from
                // radiating to radiated point intersect any other elements?
                              
                // Vector of pairs of bin coordinates that
                // intersect ray
                Vector<std::pair<unsigned,unsigned> > intersected_bin;
                if (use_bins)
                 {
                  if (plot_it)
                   {
                    sprintf(filename,"RESLT/latest_ray.dat");
                    some_file.open(filename);
                   }

                  // Find bins that are intersected by ray
                  Vector<std::pair<unsigned,unsigned> > intersected_bin;
                  bool populate_bin=false;
                  FiniteElement* dummy_el_pt=0;
                  bin_helper(ray_vertex,
                             populate_bin,
                             intersected_bin,
                             dummy_el_pt,
                             some_file);
                 
                  // End plot
                  if (plot_it)
                   {
                    some_file.close();
                    pause("done latest ray");
                   }

                  // Storage for vertices of possible intersection with ray
                  Vector<Vector<double> > segment_vertex(2);
                  segment_vertex[0].resize(2);
                  segment_vertex[1].resize(2);

                  // Search through all elements in bins along ray
                  bool have_intersection=false;
                  unsigned nbin=intersected_bin.size();
                  for (unsigned b=0;b<nbin;b++)
                   {
                    // Get bin indices
                    unsigned i=intersected_bin[b].first;
                    unsigned j=intersected_bin[b].second;

                    // Loop over elements in that bin
                    for (std::set<FiniteElement*>::iterator it=
                          Element_in_bin[i][j].begin();
                         it!=Element_in_bin[i][j].end();it++)
                     {
                      // Get possibly blocking element
                      StefanBoltzmannRadiationBase* el_pt=
                       dynamic_cast<StefanBoltzmannRadiationBase*>(*it);
                     
#ifdef PARANOID
                      if (illuminated_el_pt==0)
                       {
                        std::stringstream error_message;
                        error_message
                         << "Failed to cast possibly blocking element "
                         << " to  StefanBoltzmannRadiationBase";
                        throw OomphLibError(
                         error_message.str(),
                         OOMPH_CURRENT_FUNCTION,
                         OOMPH_EXCEPTION_LOCATION);
                       }
#endif
                      // Skip intersections with illuming/illuminated element
                      if ((el_pt!=illuminated_el_pt)&&
                          (el_pt!=illuminating_el_pt))
                       {
                        // Loop over sampling points along element, only
                        // up to Nsample-1 because we're forming segment
                        // with current and next sampling point.
                        for (unsigned j_sample=0;j_sample<Nsample-1;j_sample++)
                         {
                          // Get cector of local coordinates of plot point j
                          // as first vertex
                          Vector<double> s(1);
                          el_pt->get_s_plot(j_sample,Nsample,s);
                         
                          // Get coordinate of first vertex
                          el_pt->interpolated_x(s,segment_vertex[0]);
                         
                          // Get cector of local coordinates of plot point j+1
                          // as second vertex
                          el_pt->get_s_plot(j_sample+1,Nsample,s);
                         
                          // Get coordinate of second vertex
                          el_pt->interpolated_x(s,segment_vertex[1]);
                         
                          // Check intersection
                          bool intersection=IntersectionChecker::intersects(
                           segment_vertex,ray_vertex);
                         
                          // Bail out
                          if (intersection)
                           {
                            have_intersection=true;
                            break;
                           }
                         } // end of loop over sampling points
                       } // endif for self-intersection
                      if (have_intersection) break;
                     } // end of loop over elements in bin
                    if (have_intersection) break;
                   }// End of loop over bins that contain ray
                 
                 
                  // No intersection
                  if (!have_intersection)
                   {
                    // Visible, so add integration point
                    illuminating_integration_point_index.
                     push_back(ipt_illuminating);
                   }
                 }
                // No bins: Brute force search loop
                else
                 {
                  // Intersection for star-shaped (non-convex) polygon
                  // can only be detected in O(n^2) operations.
                  Vector<Vector<double> > segment_vertex(2);
                  segment_vertex[0].resize(2);
                  segment_vertex[1].resize(2);
                 
                  // Loop over all segments to test for intersection
                  bool have_intersection=false;
                  for (unsigned e_intersect=0;e_intersect<nel;
                       e_intersect++)
                   {
                   
                    // Skip intersection with illuminating/ed elements
                    if (! ( (e_intersect==e_illuminated) ||
                            (e_intersect==e_illuminating) ) )
                     {
                     
                      // Loop over sampling points along element
                      for (unsigned j=0;j<Nsample-1;j++)
                       {
                        // Get cector of local coordinates of plot point j
                        // as first vertex
                        Vector<double> s(1);
                        sb_face_element_pt[e_intersect]->
                         get_s_plot(j,Nsample,s);
                       
                        // Get coordinate of first vertex
                        sb_face_element_pt[e_intersect]->
                         interpolated_x(s,segment_vertex[0]);
                       
                        // Get cector of local coordinates of plot point j+1
                        // as second vertex
                        sb_face_element_pt[e_intersect]->
                         get_s_plot(j+1,Nsample,s);
                       
                        // Get coordinate of second vertex
                        sb_face_element_pt[e_intersect]->
                         interpolated_x(s,segment_vertex[1]);
                       
                        // Check intersection
                        bool intersection=IntersectionChecker::intersects(
                         segment_vertex,ray_vertex);
                       
                        if (intersection)
                         {
                          have_intersection=true;
                          break;
                         }
                       }
                     }
                    if (have_intersection)
                     {
                      break;
                     }
                   }
                 
                  // No intersection
                  if (!have_intersection)
                   {
                    // Visible, so add integration point
                    illuminating_integration_point_index.
                     push_back(ipt_illuminating);
                   }

                 } // end if for brute force (rather than bin-based) search loop

               }
             }
           }
         
          // Done all possibly illuminating integration points in
          // current possibly illuminating element
          unsigned npt=illuminating_integration_point_index.size();
          if (npt>0)
           {
            // Add info
            illuminated_el_pt->add_stefan_boltzmann_illumination_info(
             ipt_illuminated,illuminating_el_pt,
             illuminating_integration_point_index);

            // Set up reverse scheme
            if (exploit_symmetry)
             {
              for (unsigned i_ing=0;i_ing<npt;i_ing++)
               {
                aux[e_illuminating]
                 [illuminating_integration_point_index[i_ing]]
                 [e_illuminated].push_back(ipt_illuminated);
               }
             }
           }
         }
       }
     }


    // Now do other half of dependencies
    //----------------------------------
    if (exploit_symmetry)
     {
      // Loop over all face elements -- viewed as illuminated ones
      for (unsigned e_illuminated=0;e_illuminated<nel;e_illuminated++)
       {
        StefanBoltzmannRadiationBase* illuminated_el_pt=
         dynamic_cast<StefanBoltzmannRadiationBase*>(
          sb_face_element_pt[e_illuminated]);

#ifdef PARANOID
        if (illuminated_el_pt==0)
         {
          std::stringstream error_message;
          error_message << "Failed to cast illuminated element "
                        << e_illuminated
                        << " to  StefanBoltzmannRadiationBase";
          throw OomphLibError(
           error_message.str(),
           OOMPH_CURRENT_FUNCTION,
           OOMPH_EXCEPTION_LOCATION);
         }
#endif

        // Loop over iluminated integration points
        unsigned nint=illuminated_el_pt->integral_pt()->nweight();
        for (unsigned ipt_illuminated=0;ipt_illuminated<nint;ipt_illuminated++)
         {
          // Now loop over all other elements (the iluminating ones)
          for (unsigned e_illuminating=0;
               e_illuminating<e_illuminated;e_illuminating++)
           {
            StefanBoltzmannRadiationBase* illuminating_el_pt=
             dynamic_cast<StefanBoltzmannRadiationBase*>(
              sb_face_element_pt[e_illuminating]);
           
#ifdef PARANOID
            if (illuminating_el_pt==0)
             {
              std::stringstream error_message;
              error_message << "Failed to cast illuminating element "
                            << e_illuminating
                            << " to  StefanBoltzmannRadiationBase";
              throw OomphLibError(
               error_message.str(),
               OOMPH_CURRENT_FUNCTION,
               OOMPH_EXCEPTION_LOCATION);
             }
#endif
            // Get illuminating integration points
            Vector<unsigned> illuminating_integration_point_index=
             aux[e_illuminated][ipt_illuminated][e_illuminating];
            unsigned npt=illuminating_integration_point_index.size();
            if (npt>0)
             {
              // Add info
              illuminated_el_pt->add_stefan_boltzmann_illumination_info(
               ipt_illuminated,illuminating_el_pt,
               illuminating_integration_point_index);
             }
           }
         }
       }
     }

    double t_end=TimingHelpers::timer();
    oomph_info << "Time for setting up mutual Stefan Boltzmann radiation: "
               << t_end-t_start << std::endl;
   }

 }

}
}



#endif
