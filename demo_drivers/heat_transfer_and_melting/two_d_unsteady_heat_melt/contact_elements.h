//LIC// ====================================================================
//LIC// This file forms part of oomph-lib, the object-oriented, 
//LIC// multi-physics finite-element library, available 
//LIC// at http://www.oomph-lib.org.
//LIC// 
//LIC//           Version 0.90. August 3, 2009.
//LIC// 
//LIC// Copyright (C) 2006-2009 Matthias Heil and Andrew Hazel
//LIC// 
//LIC// This library is free software; you can redistribute it and/or
//LIC// modify it under the terms of the GNU Lesser General Public
//LIC// License as published by the Free Software Foundation; either
//LIC// version 2.1 of the License, or (at your option) any later version.
//LIC// 
//LIC// This library is distributed in the hope that it will be useful,
//LIC// but WITHOUT ANY WARRANTY; without even the implied warranty of
//LIC// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//LIC// Lesser General Public License for more details.
//LIC// 
//LIC// You should have received a copy of the GNU Lesser General Public
//LIC// License along with this library; if not, write to the Free Software
//LIC// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
//LIC// 02110-1301  USA.
//LIC// 
//LIC// The authors may be contacted at oomph-lib@maths.man.ac.uk.
//LIC// 
//LIC//====================================================================
// Header file for elements that enforce solid contact

#ifndef OOMPH_CONTACT_ELEMENTS_HEADER
#define OOMPH_CONTACT_ELEMENTS_HEADER

// Config header generated by autoconfig
#ifdef HAVE_CONFIG_H
#include <oomph-lib-config.h>
#endif

//Standard libray headers
#include <cmath>

// oomph-lib includes
#include "generic.h" // ../generic/Qelements.h"

namespace oomph
{
 

//=========================================================
///\short Class for hierher
//=========================================================
 template <unsigned DIM, unsigned NPTS_1D>
  class PiecewiseGauss : public Gauss<DIM,NPTS_1D>
  {
    private:
   
   /// Store for the lower and upper limits of integration and the range
   double Lower, Upper, Range;
   
    public:
   
   /// \short Constructor: Pass in lower and upper limits of 1D coordinate
   /// over which we're integrating
   PiecewiseGauss(const double& lower, const double& upper) : 
   Lower(lower), Upper(upper)
    {
     //Set the range of integration
     Range = upper - lower;
    }

   /// Broken copy constructor
   PiecewiseGauss(const PiecewiseGauss& dummy) 
    { 
     BrokenCopy::broken_copy("PiecewiseGauss");
    } 
   
   /// Broken assignment operator
   void operator=(const PiecewiseGauss&) 
    {
     BrokenCopy::broken_assign("PiecewiseGauss");
    }
   
   
   /// Return the number of integration points of the scheme. 
   virtual unsigned nweight() const
   {
    return 3*Gauss<DIM,NPTS_1D>::nweight();
   }
   
   /// Return the rescaled knot values s[j] at integration point i
   double knot(const unsigned &i, const unsigned &j) const
   {
    if (i<Gauss<DIM,NPTS_1D>::nweight())
     {
      double range=0.25*Range;
      double lower=Lower+0.0;
      //double upper=Lower+0.25*Range;
      unsigned ii=i;
      return (lower+(0.5*(1.0+Gauss<DIM,NPTS_1D>::knot(ii,j))*range));
     }
    else if (i<2*Gauss<DIM,NPTS_1D>::nweight())
     {
      double range=0.5*Range;
      double lower=Lower+0.25*Range;
      //double upper=Lower+0.75*Range;
      unsigned ii=i-Gauss<DIM,NPTS_1D>::nweight();
      return (lower+(0.5*(1.0+Gauss<DIM,NPTS_1D>::knot(ii,j))*range));
     }
    else
     {
      double range=0.25*Range;
      double lower=Lower+0.75*Range;
      //double upper=Upper;
      unsigned ii=i-2*Gauss<DIM,NPTS_1D>::nweight();
      return (lower+(0.5*(1.0+Gauss<DIM,NPTS_1D>::knot(ii,j))*range));
     }
   }
   
   /// Return the rescaled weight at integration point i
   double weight(const unsigned &i) const
   {
    if (i<Gauss<DIM,NPTS_1D>::nweight())
      {
       double range=0.25*Range;
       unsigned ii=i;
       return Gauss<DIM,NPTS_1D>::weight(ii)*
        pow(0.5*range,static_cast<int>(DIM));
      }
    else if (i<2*Gauss<DIM,NPTS_1D>::nweight())
     {
      double range=0.5*Range;
      unsigned ii=i-Gauss<DIM,NPTS_1D>::nweight();
      return Gauss<DIM,NPTS_1D>::weight(ii)*
       pow(0.5*range,static_cast<int>(DIM));
     }
     
    else
     {
      double range=0.25*Range;
      unsigned ii=i-2*Gauss<DIM,NPTS_1D>::nweight();
      return Gauss<DIM,NPTS_1D>::weight(ii)*
       pow(0.5*range,static_cast<int>(DIM));
     }
   }
   
};



////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////


//======================================================================
/// \short Base class for penetrator. Given a point x, a specific penetrator
/// must be able to specify how far this point penetrates the penetrator,
/// using whatever logic seems appropriate. We also insist on
/// implementing a position function that, for a given point, x,
/// returns a "corresponding" point, r, on the surface of the penetrator.
//======================================================================
class Penetrator 
 {

   public:

  /// Constructor
  Penetrator(){};
 
  /// \short Get penetration for given point x with outer unit normal n
  virtual double penetration(const Vector<double>& x,
                             const Vector<double>& n) const =0;

  /// \short Get position to surface, r, for given point x. Specific 
  /// implementation of penetetrator has do decide how to relate
  /// these two points.
  virtual void position(const Vector<double>& x, Vector<double>& r) const=0;

  /// \short Vector of pairs identifying values (via a pair of pointer to 
  /// Data object and index within it) that correspond to the Data values 
  /// that are determined by the horizontal/vertical/... equilibrium of force 
  /// equations. Empty by default, indicating that the penetrator is in a 
  /// prescribed position (i.e. a position that is not determined as part
  /// of the solution!)
  virtual Vector<std::pair<Data*,unsigned> > equilibrium_data()
   {
    Vector<std::pair<Data*,unsigned> > dummy;
    return dummy;
   }

 };


////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////


//======================================================================
/// \short Penetrator -- here implemented as a circle
//======================================================================
class CircularPenetrator : public virtual Penetrator
 {

   public:

  /// Constructor: Pass pointer to centre and radius
  CircularPenetrator(Vector<double>* r_c_pt, const double& r)
   {
    Centre_pt=r_c_pt;
    Radius=r;
   }

// hierher
  /* /// Get centre of penetrator (origin for cylindrical polar coordinate system) */
  /* Vector<double>& centre() */
  /*  { */
  /*   return (*Centre_pt); */
  /*  } */
 
  /// \short Get penetration for given point x.
  double penetration(const Vector<double>& x,
                     const Vector<double>& n) const
  {

   // Vector from potential contact point to centre of penetrator
   Vector<double> l(2);
   l[0]=(*Centre_pt)[0]-x[0];
   l[1]=(*Centre_pt)[1]-x[1];
   
   // Distance from potential contact point to centre of penetrator
   double ll=sqrt(l[0]*l[0]+l[1]*l[1]);

   // Projection of vector from potential contact point to centre of penetrator
   // onto outer unit normal on potential contact point
   double project=n[0]*l[0]+n[1]*l[1];
   double project_squared=project*project;

   // Final term in square root
   double b_squared=ll*ll-Radius*Radius;

   // Is square root negative? In this case we have no intersection
   // and we return penetration as -DBL_MAX
   if (project_squared<b_squared)
    {
     return -DBL_MAX;
    }
   else
    {
     double sqr=sqrt(project_squared-b_squared);
     return -std::min(project-sqr,project+sqr);
    }
  }
 


  /// \short Get position to surface, r, for given point x.
  /// Here we assume they both have the same polar angle
  void position(const Vector<double>& x, Vector<double>& r) const
  {
   double phi=atan2(x[1]-(*Centre_pt)[1],x[0]-(*Centre_pt)[0]);
   r[0]=(*Centre_pt)[0]+Radius*cos(phi);
   r[1]=(*Centre_pt)[1]+Radius*sin(phi);
  }
  
   private:
  
  /// \short Pointer to centre of penetrator (origin for cylindrical polar
  /// coordinate system)
  Vector<double>* Centre_pt;

  /// Radius of penetrator
  double Radius;

 };



////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////



//====================================================================
/// Namespace with helper function for polygons
//====================================================================
namespace PolygonHelper
{

 /// \short Check if point in inside polygon.
 /// Reference: http://paulbourke.net/geometry/insidepoly/
 bool point_is_in_polygon(const Vector<double>& point,
                          const Vector<Vector<double> >& polygon_vertex)
 {

  // Total number of vertices
  unsigned nvertex=polygon_vertex.size();

// hierher #ifdef PARANOID
  
  // Make sure the polygon closes exactly:
  double d0=polygon_vertex[nvertex-1][0]-polygon_vertex[0][0];
  double d1=polygon_vertex[nvertex-1][1]-polygon_vertex[0][1];
  if (sqrt(d0*d0+d1*d1)>0.0)
   {
    std::stringstream junk;
    junk << "First and last point of polygon don't coincide!\n"
         << "First point at: " 
         << polygon_vertex[0][0] << " " 
         << polygon_vertex[0][1] << "\n"
         << "Last point at: " 
         << polygon_vertex[nvertex-1][0] << " " 
         << polygon_vertex[nvertex-1][1] << "\n";
    throw OomphLibError(
     junk.str(),
     OOMPH_CURRENT_FUNCTION,
     OOMPH_EXCEPTION_LOCATION);
   }

// #endif

  // Counter for number of intersections
  unsigned intersect_counter=0;
  
  //Get first vertex
  Vector<double> p1=polygon_vertex[0];
  for (unsigned i=1;i<=nvertex;i++)
   {
    // Get second vertex by wrap-around
    Vector<double> p2 = polygon_vertex[i%nvertex];
    
    if (point[1] > std::min(p1[1],p2[1]))
     {
      if (point[1] <= std::max(p1[1],p2[1]))
       {
        if (point[0] <= std::max(p1[0],p2[0]))
         {
          if (p1[1] != p2[1])
           {
            double xintersect =
             (point[1]-p1[1])*(p2[0]-p1[0])/
             (p2[1]-p1[1])+p1[0];
            if ( (p1[0] == p2[0]) ||
                 (point[0] <= xintersect) )
             {
              intersect_counter++;
             }
           }
         }
       }
     }
    p1 = p2;
   }
  
  // Even number of intersections: outside
  if (intersect_counter%2==0)
   {
    return false;
   }
  return true;
 }


}

/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////


// hierher kill

/* //====================================================================== */
/* /// \short Polygonal penetrator  */
/* //====================================================================== */
/* class PolygonalPenetrator : public virtual Penetrator */
/*  { */

/*    public: */

/*   /// Constructor: Specify number of vertices on circular arc */
/*   PolygonalPenetrator(const unsigned& n_vertex) */
/*    { */

/*     double y_c=0.005; */
/*     double radius=1.005; */

/*     double phi_0=asin(y_c/radius); */
/*     double phi_range=MathematicalConstants::Pi-2.0*phi_0; */

/*     Vertex.resize(n_vertex+5); */
/*     for (unsigned j=0;j<n_vertex;j++) */
/*      { */
/*       double phi=phi_0+phi_range*double(j)/double(n_vertex-1); */
/*       Vertex[j].resize(2); */
/*       Vertex[j][0]=-radius*cos(phi); */
/*       Vertex[j][1]=y_c-radius*sin(phi); */
/*      } */

/*     unsigned j=n_vertex; */
/*     Vertex[j].resize(2); */
/*     Vertex[j][0]=2.0; */
/*     Vertex[j][1]=0.0; */

/*     j=n_vertex+1; */
/*     Vertex[j].resize(2); */
/*     Vertex[j][0]= 2.0; */
/*     Vertex[j][1]=-2.0; */

/*     j=n_vertex+2; */
/*     Vertex[j].resize(2); */
/*     Vertex[j][0]=-2.0; */
/*     Vertex[j][1]=-2.0; */

/*     j=n_vertex+3; */
/*     Vertex[j].resize(2); */
/*     Vertex[j][0]=-2.0; */
/*     Vertex[j][1]= 0.0; */

/*     // Make sure the polygon closes exactly: */
/*     Vertex[n_vertex+4].resize(2); */
/*     Vertex[n_vertex+4][0]=Vertex[0][0]; */
/*     Vertex[n_vertex+4][1]=Vertex[0][1]; */
/*    } */

 
/*   /// \short Get penetration for given point x. */
/*   double penetration(const Vector<double>& x, const Vector<double>& n) const */
/*   { */
   
/*    oomph_info << "hierher n not used!" << std::endl; */

/*    // Initialise min distance from any of the line segments */
/*    double dist_min=DBL_MAX; */

/*    // Storage for tangent */
/*    Vector<double> t(2); */

/*    // Loop over all segments */
/*    unsigned nvertex=Vertex.size(); */
/*    for (unsigned j=0;j<(nvertex-1);j++) */
/*     { */
/*      // Get tangent */
/*      t[0]=Vertex[j+1][0]-Vertex[j][0]; */
/*      t[1]=Vertex[j+1][1]-Vertex[j][1]; */
/*      double inv_length=1.0/sqrt(t[0]*t[0]+t[1]*t[1]); */
/*      t[0]*=inv_length; */
/*      t[1]*=inv_length; */
     
/*      // Length of segment */
/*      double length=1.0/inv_length; */
     
/*      // Get projected length along */
/*      double s= */
/*       (x[0]-Vertex[j][0])*t[0]+ */
/*       (x[1]-Vertex[j][1])*t[1]; */
     

/*      // Get distance */
/*      double dist=0.0; */

/*      // Left vertex is closest */
/*      if (s<=0.0) */
/*       { */
/*        double d0=(x[0]-Vertex[j][0]); */
/*        double d1=(x[1]-Vertex[j][1]); */
/*        dist=sqrt(d0*d0+d1*d1); */
/*       } */
/*      // Right vertex is closest */
/*      else if (s>=length) */
/*       { */
/*        double d0=(x[0]-Vertex[j+1][0]); */
/*        double d1=(x[1]-Vertex[j+1][1]); */
/*        dist=sqrt(d0*d0+d1*d1); */
/*       } */
/*      else */
/*       { */
/*        // What's the distance? Note: n_x=-t_y; n_y=t_x. */
/*        dist=std::fabs((x[0]-Vertex[j][0])*(-t[1])+ */
/*                       (x[1]-Vertex[j][1])*( t[0])); */
/*       } */
     
/*      if (dist<dist_min) dist_min=dist; */
/*     } */

/*    // Is point inside the polygon?  */
/*    if (PolygonHelper::point_is_in_polygon(x,Vertex)) */
/*     { */
/*      return dist_min; */
/*     } */
/*    return -dist_min; */
/*   } */


 
/*   /// \short Get position to surface, r, for given point x. Here we */
/*   /// assume they both have the same x coordinate */
/*   void position(const Vector<double>& x, Vector<double>& r) const */
/*   { */
/*    oomph_info << "not done yet\n"; */
/*    abort(); */
/*   } */
 
/*    private: */
  
/*   /// \short Vector of vector to vertex coordinates */
/*   Vector<Vector<double> > Vertex; */

/*  }; */

/* //////////////////////////////////////////////////////////////////////// */
/* //////////////////////////////////////////////////////////////////////// */
/* //////////////////////////////////////////////////////////////////////// */



/* //====================================================================== */
/* /// \short Penetrator: A parabolic wall */
/* //====================================================================== */
/* class ParabolicWallPenetrator : public virtual Penetrator */
/*  { */

/*    public: */

/*   /// Constructor: Pass pointer to y coordinate at centre and "parabola" */
/*   /// coefficient: y=y_wall+C_wall x^2 */
/*   ParabolicWallPenetrator(double* y_wall_pt, double* c_wall_pt) */
/*    { */
/*     Y_wall_pt=y_wall_pt; */
/*     C_wall_pt=c_wall_pt; */
/*    } */

 
/*   /// \short Get penetration for given point x. */
/*   double penetration(const Vector<double>& x, const Vector<double>& n) const */
/*   { */
/*    oomph_info << "hierher n not used!" << std::endl; */

/*    // Actual penetration */
/*    double penetration=(*Y_wall_pt)+(*C_wall_pt)*x[0]*x[0]-x[1]; */
/*    return penetration; */
/*   } */
 
/*   /// \short Get position to surface, r, for given point x. Here we */
/*   /// assume they both have the same x coordinate */
/*   void position(const Vector<double>& x, Vector<double>& r) const */
/*   { */
/*    r[0]=x[0]; */
/*    r[1]=(*Y_wall_pt)+(*C_wall_pt)*x[0]*x[0]; */
/*   } */
 
/*    private: */
  
/*   /// \short Pointer to y position of penetrator */
/*   double* Y_wall_pt; */


/*   /// \short Pointer to parabola coefficient */
/*   double* C_wall_pt; */

/*  }; */

/* //////////////////////////////////////////////////////////////////////// */
/* //////////////////////////////////////////////////////////////////////// */
/* //////////////////////////////////////////////////////////////////////// */


/* //====================================================================== */
/* /// \short Penetrator: A flat wall */
/* //====================================================================== */
/* class FlatWallPenetrator : public virtual Penetrator */
/*  { */

/*    public: */

/*   /// Constructor: Pass pointer to y coordinate */
/*   FlatWallPenetrator(double* y_wall_pt) */
/*    { */
/*     Y_wall_pt=y_wall_pt; */
/*    } */

/*   /// Get height of penetrator */
/*   double& y_wall() */
/*    { */
/*     return (*Y_wall_pt); */
/*    } */
 
/*   /// \short Get penetration for given point x. */
/*   double penetration(const Vector<double>& x, const Vector<double>& n) const */
/*   { */
/*    oomph_info << "hierher n not used!" << std::endl; */

/*    // Actual penetration */
/*    double penetration=(*Y_wall_pt)-x[1]; */
/*    return penetration; */
/*   } */
 
/*   /// \short Get position to surface, r, for given point x. Here  */
/*   /// we assume they both have the same x coordinate */
/*   void position(const Vector<double>& x, Vector<double>& r) const */
/*   { */
/*    r[0]=x[0]; */
/*    r[1]=(*Y_wall_pt); */
/*   } */
 
/*    private: */
  
/*   /// \short Pointer to y position of penetrator */
/*   double* Y_wall_pt; */

/*  }; */

/* //////////////////////////////////////////////////////////////////////// */
/* //////////////////////////////////////////////////////////////////////// */
/* //////////////////////////////////////////////////////////////////////// */


/* //====================================================================== */
/* /// \short Penetrator -- here implemented as an ellipse; we use cylindrical */
/* /// polars centred at center of penetrator. */
/* //====================================================================== */
/* class OuterEllipticalPenetrator : public virtual Penetrator */
/*  { */

/*    public: */

/*   /// Constructor: Pass pointer to centre and radius */
/*   OuterEllipticalPenetrator(Vector<double>* r_c_pt,  */
/*                             const double& a, */
/*                             const double& b) */
/*    { */
/*     Centre_pt=r_c_pt; */
/*     A=a; */
/*     B=b; */
/*    } */

/*   /// Get centre of penetrator (origin for cylindrical polar coordinate system) */
/*   Vector<double>& centre() */
/*    { */
/*     return (*Centre_pt); */
/*    } */
 
/*   /// \short Get penetration for given point x. */
/*   double penetration(const Vector<double>& x, const Vector<double>& n) const */
/*   { */
/*    oomph_info << "hierher n not used!" << std::endl; */

/*    double phi=atan2((x[1]-(*Centre_pt)[1])/B,(x[0]-(*Centre_pt)[0])/A); */
/*    double radius_p=sqrt(A*cos(phi)*A*cos(phi)+ */
/*                         B*sin(phi)*B*sin(phi)); */

/*    double radius_x=sqrt((x[0]-(*Centre_pt)[0])*(x[0]-(*Centre_pt)[0])+ */
/*                         (x[1]-(*Centre_pt)[1])*(x[1]-(*Centre_pt)[1])); */
   
/*    // Actual penetration (outer!) */
/*    double penetration=radius_x-radius_p; */
   
/*    return penetration; */
/*   } */
 


/*   /// \short Get position to surface, r, for given point x. Here we  */
/*   /// assume they both have the same polar angle */
/*   void position(const Vector<double>& x, Vector<double>& r) const */
/*   { */
/*    double phi=atan2((x[1]-(*Centre_pt)[1])/B,(x[0]-(*Centre_pt)[0])/A); */
/*    r[0]=(*Centre_pt)[0]+A*cos(phi); */
/*    r[1]=(*Centre_pt)[1]+B*sin(phi); */
/*   } */
 
/*    private: */

/*   /// \short Pointer to centre of penetrator (origin for cylindrical polar */
/*   /// coordinate system) */
/*   Vector<double>* Centre_pt; */

/*   /// X-half axis */
/*   double A; */

/*   /// Y-half axis */
/*   double B; */

/*  }; */

/* //////////////////////////////////////////////////////////////////////// */
/* //////////////////////////////////////////////////////////////////////// */
/* //////////////////////////////////////////////////////////////////////// */


/* //====================================================================== */
/* /// \short Penetrator -- flat wall with elliptical hollow bit (up to specified */
/* /// width) */
/* //====================================================================== */
/* class EllipticalHollowPenetrator : public virtual Penetrator */
/*  { */

/*    public: */

/*   /// Constructor: Pass pointer to centre, half width and half axes */
/*   EllipticalHollowPenetrator(Vector<double>* r_c_pt,  */
/*                              double* a_pt, */
/*                              double* b_pt) */
/*    { */
/*     Centre_pt=r_c_pt; */
/*     A_pt=a_pt; */
/*     B_pt=b_pt; */
/*    } */

/*   /// Get centre of penetrator (origin for cylindrical polar coordinate system) */
/*   Vector<double>& centre() */
/*    { */
/*     return (*Centre_pt); */
/*    } */
 
/*   /// x-half axis */
/*   double& a() */
/*    { */
/*     return *A_pt; */
/*    } */

/*   /// y-half axis */
/*   double& b() */
/*    { */
/*     return *B_pt; */
/*    } */
 
/*   /// \short Get penetration for given point x. */
/*   double penetration(const Vector<double>& x,  */
/*                      const Vector<double>& n) const */
/*   { */
/*    oomph_info << "hierher n not used!" << std::endl; */

/*    // Get position on penetrator */
/*    Vector<double> r(2); */
/*    position(x,r); */
/*    double radius_p=sqrt((r[0]-(*Centre_pt)[0])*(r[0]-(*Centre_pt)[0])+ */
/*                         (r[1]-(*Centre_pt)[1])*(r[1]-(*Centre_pt)[1])); */

/*    double radius_x=sqrt((x[0]-(*Centre_pt)[0])*(x[0]-(*Centre_pt)[0])+ */
/*                         (x[1]-(*Centre_pt)[1])*(x[1]-(*Centre_pt)[1])); */
   
/*    // Actual penetration (outer!) */
/*    double penetration=radius_x-radius_p; */
   
/*    return penetration; */
/*   } */
 


/*   /// \short Get position to surface, r, for given point x.  */
/*   /// Here we assume they both have the same x coordinate */
/*   void position(const Vector<double>& x, Vector<double>& r) const */
/*   { */
/*    bool outside=false; */
/*    if (std::fabs(x[0]-(*Centre_pt)[0])>(*A_pt)) */
/*     { */
/*      outside=true; */
/*     } */
/*    else */
/*     { */
/*      double phi=acos((x[0]-(*Centre_pt)[0])/(*A_pt)); */
/*      r[0]=(*Centre_pt)[0]+(*A_pt)*cos(phi); */
/*      r[1]=(*Centre_pt)[1]-(*B_pt)*sin(phi); */
/*     } */
/*    if (outside||(std::fabs(r[0]-(*Centre_pt)[0])>(*A_pt))) */
/*     { */
/*      double phi_max=acos((*A_pt)/(*A_pt)); */
/*      if (x[0]>0.0) */
/*       { */
/*        r[0]=(*Centre_pt)[0]+(*A_pt)*cos(phi_max)+(x[0]-(*A_pt)); */
/*       } */
/*      else */
/*       { */
/*        r[0]=(*Centre_pt)[0]-((*A_pt)*cos(phi_max)+(-x[0]-(*A_pt))); */
/*       } */
/*      r[1]=(*Centre_pt)[1]-(*B_pt)*sin(phi_max); */
/*     } */
/*   } */
 

/*   /// \short Get position to surface of ellipse, r, for given point x.   */
/*   /// We assume they both have the same x coordinate */
/*   void ellipse_position(const Vector<double>& x, Vector<double>& r) const */
/*   { */
/*    double phi=acos((x[0]-(*Centre_pt)[0])/(*A_pt)); */
/*                    r[0]=(*Centre_pt)[0]+(*A_pt)*cos(phi); */
/*    if ((x[1]-(*Centre_pt)[1])>0) */
/*     { */
/*      r[1]=((*Centre_pt)[1]+(*B_pt)*sin(phi)); */
/*     } */
/*    else */
/*     { */
/*      r[1]=-((*Centre_pt)[1]+(*B_pt)*sin(phi)); */
/*     } */
/*   } */
 
/*    private: */

/*   /// \short Pointer to centre of penetrator (origin for cylindrical polar */
/*   /// coordinate system) */
/*   Vector<double>* Centre_pt; */

/*   /// X-half axis */
/*   double* A_pt; */

/*   /// Y-half axis */
/*   double* B_pt; */

/*  }; */


/* //////////////////////////////////////////////////////////////////////// */
/* //////////////////////////////////////////////////////////////////////// */
/* //////////////////////////////////////////////////////////////////////// */


/* //====================================================================== */
/* /// \short Penetrator -- here implemented as a circle */
/* //====================================================================== */
/* class CircularPenetrator : public virtual Penetrator */
/*  { */

/*    public: */

/*   /// Constructor: Pass pointer to centre and radius */
/*   CircularPenetrator(Vector<double>* r_c_pt, const double& r) */
/*    { */
/*     Centre_pt=r_c_pt; */
/*     Radius=r; */
/*    } */

/*   /// Get centre of penetrator (origin for cylindrical polar coordinate system) */
/*   Vector<double>& centre() */
/*    { */
/*     return (*Centre_pt); */
/*    } */
 
/*   /// \short Get penetration for given point x. */
/*   double penetration(const Vector<double>& x,  */
/*                      const Vector<double>& n) const */
/*   { */
/*    oomph_info << "hierher n not used!" << std::endl; */

/*    // Actual penetration */
/*    double penetration=Radius- */
/*     sqrt((x[0]-(*Centre_pt)[0])*(x[0]-(*Centre_pt)[0])+ */
/*          (x[1]-(*Centre_pt)[1])*(x[1]-(*Centre_pt)[1])); */

/*    return penetration; */
/*   } */
 


/*   /// \short Get position to surface, r, for given point x.  */
/*   /// Here we assume they both have the same polar angle */
/*   void position(const Vector<double>& x, Vector<double>& r) const */
/*   { */
/*    double phi=atan2(x[1]-(*Centre_pt)[1],x[0]-(*Centre_pt)[0]); */
/*    r[0]=(*Centre_pt)[0]+Radius*cos(phi); */
/*    r[1]=(*Centre_pt)[1]+Radius*sin(phi); */
/*   } */
  
/*    private: */
  
/*   /// \short Pointer to centre of penetrator (origin for cylindrical polar */
/*   /// coordinate system) */
/*   Vector<double>* Centre_pt; */

/*   /// Radius of penetrator */
/*   double Radius; */

/*  }; */

// hierher end kill

////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////

//======================================================================
/// Template-free base class for contact elements
//======================================================================
class ContactElementBase
{

  public:

 /// Resulting contact force
 virtual void resulting_contact_force(Vector<double> &contact_force)=0;

};


////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////



//======================================================================
/// A class for elements that impose contact boundary conditions
/// either enforcing non-penetration (but "without stick"; default) or 
/// permament contact (in which case contact force can be
/// positive or negative. Uses Lagrange-multiplier-like pressure
/// to enforce contact/non-penetration. Almost certainly works only with
/// 2D Penetrator at the moment.
//======================================================================
 template <class ELEMENT>
  class SurfaceContactElement : public virtual FaceGeometry<ELEMENT>, 
 public virtual SolidFaceElement, public virtual ContactElementBase
  {
 
    public:
 
   /// \short Constructor, which takes a "bulk" element and the 
   /// value of the index and its limit
    SurfaceContactElement(FiniteElement* const &element_pt, 
                          const int &face_index,
                          const unsigned &id=0,
                          const bool& called_from_refineable_constructor=
                          false) : 
   FaceGeometry<ELEMENT>(), FaceElement()
    { 
   
     // By default we only to proper non-penetration (without "stick", i.e.
     // we don't allow negative contact pressures) 
     Enable_stick=false;

     // Initialise pointer to penetrator
     Penetrator_pt=0;

     //Attach the geometrical information to the element. N.B. This function
     //also assigns nbulk_value from the required_nvalue of the bulk element
     element_pt->build_face_element(face_index,this);
 

#ifdef PARANOID
     {
      //Check that the bulk element is not a refineable 3d element
      if (!called_from_refineable_constructor)
       {
        if(element_pt->dim()==3)
         {
          //Is it refineable
          RefineableElement* ref_el_pt=
           dynamic_cast<RefineableElement*>(element_pt);
          if(ref_el_pt!=0)
           {
            if (this->has_hanging_nodes())
             {
              throw OomphLibError(
               "This face element will not work correctly if nodes are hanging.\nUse the refineable version instead. ",
               OOMPH_CURRENT_FUNCTION,
               OOMPH_EXCEPTION_LOCATION);
             }
           }
         }
       }
     }
#endif

     //  Store the ID of the FaceElement -- this is used to distinguish
     // it from any others
     Contact_id=id;
   
     // We need one additional value for each FaceElement node:
     // the normal traction (Lagrange multiplier) to be 
     // exerted onto the solid
     unsigned n_nod=nnode();
     Vector<unsigned> n_additional_values(n_nod,1);
   
     // Now add storage for Lagrange multipliers and set the map containing 
     // the position of the first entry of this face element's 
     // additional values.
     add_additional_values(n_additional_values,id);
   
#ifdef PARANOID
     // Check spatial dimension
     if (element_pt->dim()!=2)
      {
       //Issue a warning
       throw OomphLibError(
        "This element will almost certainly not work in non-2D problems, though it should be easy enough to upgrade... Volunteers?\n",
        OOMPH_CURRENT_FUNCTION,
        OOMPH_EXCEPTION_LOCATION);
      }
#endif

     // Change integration scheme
     set_integration_scheme(new PiecewiseGauss<1,3>(s_min(),s_max()));
    }
   
   
   /// \short Default constructor. 
    SurfaceContactElement() :  FaceGeometry<ELEMENT>(), FaceElement() { }

   /// \short Enforce permanent contact with penetrator, allowing
   /// for negative contact pressures.
   void enable_stick()
   {
    Enable_stick=true;
   }

   /// \short Allow only proper non-penetration (without "stick", i.e.
   /// we don't allow negative contact pressures) 
   void disable_stick()
   {
    Enable_stick=false;
   }

   /// \short Do we allow only proper non-penetration (without "stick", i.e.
   /// no negative contact pressures)?
   void is_stick_enabled()
   {
    return Enable_stick;
   }

   /// Reset penetration for all nodes
   void reset_penetration()
   {
    unsigned nnod=nnode();
    for (unsigned j=0;j<nnod;j++)
     {
      Node* nod_pt=node_pt(j);
      Vector<double> x(2);
      x[0]=nod_pt->x(0);
      x[1]=nod_pt->x(1);

      // Get outer unit normal
      Vector<double> s(2);
      local_coordinate_of_node(j,s);
      Vector<double> unit_normal(2);
      outer_unit_normal(s,unit_normal);

      // Get position on penetrator
      Vector<double> r_p(2);
      Penetrator_pt->position(x,r_p);
      
      // Get penetration
      double d=Penetrator_pt->penetration(x,unit_normal);
      
      // Reset
      bool do_it=false;
      
      // Permanent contact: reset always
      if (Enable_stick)
       {
        do_it=true;
       }
      // Only non-penetration: reset only if node penetrates
      else
       {
        if (d>0.0)
         { 
          do_it=true;
         }
       }
      if (do_it)
       {
        nod_pt->x(0)=r_p[0];
        nod_pt->x(1)=r_p[1];
       }
     }
   }

   /// Doc penetration for all nodes; return max.
   double doc_penetration()
   {
    double max_pen=0.0;
    unsigned nnod=nnode();
    for (unsigned j=0;j<nnod;j++)
     {
      Node* nod_pt=node_pt(j);
      Vector<double> x(2);
      x[0]=nod_pt->x(0);
      x[1]=nod_pt->x(1);

      // Get outer unit normal
      Vector<double> s(2);
      local_coordinate_of_node(j,s);
      Vector<double> unit_normal(2);
      outer_unit_normal(s,unit_normal);

      double pen=penetration(x,unit_normal);
      if (pen>max_pen) max_pen=pen;
     }
    return max_pen;
   }

   /// Return the residuals
   void fill_in_contribution_to_residuals(Vector<double> &residuals)
   {
    fill_in_contribution_to_residuals_surface_contact(residuals);
   }

 
   // hierher FD the lot for now
   // /// Fill in contribution from Jacobian
   // void fill_in_contribution_to_jacobian(Vector<double> &residuals,
   //                                       DenseMatrix<double> &jacobian)
   //  {
   //   //Call the residuals
   //   fill_in_contribution_to_residuals_surface_contact(residuals);

   //   //Call the generic FD jacobian calculation
   //   FaceGeometry<ELEMENT>::fill_in_jacobian_from_solid_position_by_fd(jacobian);
   
   //   //Derivs w.r.t. to any external data (e.g. during displacement control)
   //   this->fill_in_jacobian_from_external_by_fd(residuals,jacobian);
   //   }


   /// \short Pointer to penetrator
   Penetrator* penetrator_pt() const
    {
     return Penetrator_pt;
    }
 
   /// \short Set pointer to penetrator
   void set_penetrator_pt(Penetrator* penetrator_pt)
    {
     Penetrator_pt=penetrator_pt;
     Vector<std::pair<Data*,unsigned> > 
      eq_data(Penetrator_pt->equilibrium_data());
     unsigned n=eq_data.size();
     Penetrator_eq_data_data_index.resize(n,-1);
     Penetrator_eq_data_index.resize(n,-1);
     Penetrator_eq_data_type.resize(n,-1);
     for (unsigned i=0;i<n;i++)
      {
       if (eq_data[i].first!=0)
        {
         bool is_duplicate=false;
         unsigned nnod=nnode();
         for (unsigned j=0;j<nnod;j++)
          {
           if (eq_data[i].first==node_pt(j))
            {
             Penetrator_eq_data_type[i]=Nodal_data;
             Penetrator_eq_data_data_index[i]=j;
             Penetrator_eq_data_index[i]=eq_data[i].second;
             is_duplicate=true;
             break;
            }
           if (eq_data[i].first==
               dynamic_cast<SolidNode*>(node_pt(j))->variable_position_pt())
            {
             Penetrator_eq_data_type[i]=Nodal_position_data;
             Penetrator_eq_data_data_index[i]=j;
             Penetrator_eq_data_index[i]=eq_data[i].second;
             is_duplicate=true;
             break;
            }
          }
         
         if (!is_duplicate)
          {
           Penetrator_eq_data_type[i]=External_data;
           Penetrator_eq_data_data_index[i]=
            this->add_external_data(eq_data[i].first);
           Penetrator_eq_data_index[i]=eq_data[i].second;
          }
        }
      }
    }
 

   /// \short Output function
   void output(std::ostream &outfile)
   {
    unsigned n_plot=5;
    output(outfile,n_plot);
   }

   /// \short Output function
   void output(std::ostream &outfile, const unsigned &n_plot)
   {

    unsigned n_dim = this->nodal_dimension();
  
    Vector<double> x(n_dim);
    Vector<double> xi(n_dim);
    Vector<double> s(n_dim-1);
    Vector<double> r_pen(n_dim);
    Vector<double> unit_normal(n_dim);
 
    // Tecplot header info
    outfile << this->tecplot_zone_string(n_plot);
  
    // Loop over plot points
    unsigned num_plot_points=this->nplot_points(n_plot);
    for (unsigned iplot=0;iplot<num_plot_points;iplot++)
     {
      // Get local coordinates of plot point
      this->get_s_plot(iplot,n_plot,s);
    
      // Get Eulerian and Lagrangian coordinates and outer unit normal
      this->interpolated_x(s,x);
      this->interpolated_xi(s,xi);
      this->outer_unit_normal(s,unit_normal);   

      // Get penetration
      double d=penetration(x,unit_normal);
    
      //Output the x,y,..
      for(unsigned i=0;i<n_dim;i++) 
       {outfile << x[i] << " ";}

      // Penetration
      outfile << std::max(d,-100.0) << " ";

      // Lagrange multiplier-like pressure
      double p=get_interpolated_lagrange_p(s);
      outfile << p << " ";
      

      // Plot Lagrange multiplier like pressure
      outfile << -unit_normal[0]*p << " ";
      outfile << -unit_normal[1]*p << " ";

      // Plot vector from current point to boundary of penetrator
      //Penetrator_pt->position(x,r_pen);
      double d_tmp=d;
      if (d_tmp==-DBL_MAX) d_tmp=0.0;
      outfile << -d_tmp*unit_normal[0] << " "; 
      outfile << -d_tmp*unit_normal[1] << " "; 

      // Output normal
      for(unsigned i=0;i<n_dim;i++) 
       {outfile << unit_normal[i] << " ";} 
    

      //Output the displacements
      for(unsigned i=0;i<n_dim;i++) 
       {outfile << x[i]-xi[i] << " ";}

      outfile << std::endl;
     }
   
    // Write tecplot footer (e.g. FE connectivity lists)
    this->write_tecplot_zone_footer(outfile,n_plot);
  
   }
 
   /// \short C_style output function
   void output(FILE* file_pt)
   {FiniteElement::output(file_pt);}

   /// \short C-style output function
   void output(FILE* file_pt, const unsigned &n_plot)
   {FiniteElement::output(file_pt,n_plot);}


   /// Shape fct for lagrange multiplier
   void shape_p(const Vector<double>& s, Shape &psi) const
   {
    bool use_isoparametric=false;
    if (use_isoparametric)
     {
      FaceGeometry<ELEMENT>::shape(s,psi);
     }
    else
     {
      const double smin=s_min();
      const double smax=s_max();
      const double sl=smin+0.25*(smax-smin);
      const double sr=smin+0.75*(smax-smin);
      if (s[0]<=sl)
       {
        psi[0]=1.0;
        psi[1]=0.0;
        psi[2]=0.0;
       }
      else if (s[0]<=sr)
       {
        psi[0]=0.0;
        psi[1]=1.0;
        psi[2]=0.0;
       }
      else 
       {
        psi[0]=0.0;
        psi[1]=0.0;
        psi[2]=1.0;
       }
     }
   }

   /// Resulting contact force
   void resulting_contact_force(Vector<double> &contact_force); 
   
    protected:
 
 
   /// \short Get interpolated pressure (essentially a Lagrange multiplier
   /// that enforces the imposed boundary motion to ensure 
   /// non-penetration or contact)
   double get_interpolated_lagrange_p(const Vector<double>& s)
   {
    // Initialise pressure
    double p=0;
   
    //Find out how many nodes there are
    unsigned n_node = nnode();
   
    //Set up memory for the shape functions
    Shape psi(n_node);
   
    // Evaluate shape function
    shape_p(s,psi);

    // Build up Lagrange multiplier (pressure)
    for (unsigned j=0;j<n_node;j++)
     {
      // Cast to a boundary node
      BoundaryNodeBase *bnod_pt = 
       dynamic_cast<BoundaryNodeBase*>(node_pt(j));
     
      // Get the index of the first nodal value associated with
      // this FaceElement
      unsigned first_index=
       bnod_pt->index_of_first_value_assigned_by_face_element(Contact_id);
     
      // Pressure (Lagrange multiplier) is the first (and only) additional
      // value created by this face element
      p+=node_pt(j)->value(first_index)*psi[j];
     }
    return p;
   }
   
   /// \short Helper function that actually calculates the residuals
   // This small level of indirection is required to avoid calling
   // fill_in_contribution_to_residuals in fill_in_contribution_to_jacobian
   // which causes all kinds of pain if overloading later on
   void fill_in_contribution_to_residuals_surface_contact(Vector<double>&
                                                          residuals);
 
   /// Work out penetration of point 
   double penetration(const Vector<double>& x, const Vector<double>& n) const
   {
    return Penetrator_pt->penetration(x,n);
   }

   /// Pointer to penetrator
   Penetrator* Penetrator_pt;

   /// \short ID of the contact constraint (used for the identification of
   /// the nodal value that corresponds to the pressure-like
   /// Lagrange multipliers.
   unsigned Contact_id;

   /// \short Do we allow only proper non-penetration (without "stick", i.e.
   /// no negative contact pressures)?
   bool Enable_stick;


   /// Enumeration for type of penetrator data
   enum{Nodal_data, 
        Nodal_position_data, 
        External_data};

   /// \short Vector containing the type of Data (labeled by the 
   /// class' private enumeration) that is determined (via pseudo-hijacking)
   /// from the Penetrator's i-th equilibrium of forces equation. -1 if
   /// this relevant equilibrium equation is not employed to determine
   /// an unknown that's associated with the current element.
   Vector<int> Penetrator_eq_data_type;

   /// \short Vector containing the index of the Data object (e.g. the
   /// node number in the current element) that stores the unknown 
   /// that is determined from the Penetrator's 
   /// i-th equilibrium of forces equation. -1 if the relevant 
   /// equilibrium equation is not employed to determine
   /// an unknown that's associated with the current element.
   Vector<int> Penetrator_eq_data_index;

   /// \short Vector containing the index of the value in the Data 
   /// object (e.g. the node number in the current element) that 
   /// stores the unknown that is determined from the Penetrator's 
   /// i-th equilibrium of forces equation. -1 if the relevant 
   /// equilibrium equation is not employed to determine
   /// an unknown that's associated with the current element.
   Vector<int> Penetrator_eq_data_data_index;


  }; 


///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////

 
//=====================================================================
/// Return the residuals for the SurfaceContactElement equations
//=====================================================================
 template<class ELEMENT>
  void SurfaceContactElement<ELEMENT>::
  fill_in_contribution_to_residuals_surface_contact(Vector<double> &residuals)
  {

   // Spatial dimension of problem
   unsigned n_dim = this->nodal_dimension();
   
   // Contribution to contact force
   Vector<double> contact_force(n_dim,0.0);
 
   // Create vector of local residuals (start assembling contributions
   // from zero -- necessary so we can over-write pseudo-hijacked
   // contributions at the end.
   unsigned n_dof=ndof();
   Vector<double> local_residuals(n_dof,0.0);

   // Penalty-like method? [Only for test; not actively used; keep around
   //--------------------- 'cos it may be useful...]
   const bool penalty=false;
   if (penalty)
    {
     oomph_info << "This is almost certainly broken by now...\n";
     abort();

     //Find out how many nodes there are
     unsigned n_node = nnode();
   
     //Find out how many positional dofs there are
     unsigned n_position_type = this->nnodal_position_type();
   
     //Integer to hold the local equation number
     int local_eqn=0;
   
     //Set up memory for the shape functions
     //Note that in this case, the number of lagrangian coordinates is always
     //equal to the dimension of the nodes
     Shape psi(n_node,n_position_type);
     DShape dpsids(n_node,n_position_type,n_dim-1); 
   
     //Set the value of n_intpt
     unsigned n_intpt = integral_pt()->nweight();
   
     //Loop over the integration points
     for(unsigned ipt=0;ipt<n_intpt;ipt++)
      {
       //Get the integral weight
       double w = integral_pt()->weight(ipt);
     
       //Only need to call the local derivatives
       dshape_local_at_knot(ipt,psi,dpsids);
     
       //Calculate the Eulerian and Lagrangian coordinates 
       Vector<double> interpolated_x(n_dim,0.0);
     
       //Also calculate the surface Vectors (derivatives wrt local coordinates)
       DenseMatrix<double> interpolated_A(n_dim-1,n_dim,0.0);   
     
       //Calculate displacements and derivatives
       for(unsigned l=0;l<n_node;l++) 
        {
         //Loop over positional dofs
         for(unsigned k=0;k<n_position_type;k++)
          {
           //Loop over displacement components (deformed position)
           for(unsigned i=0;i<n_dim;i++)
            {
             //Calculate the Eulerian and Lagrangian positions
             interpolated_x[i] += 
              nodal_position_gen(l,bulk_position_type(k),i)*psi(l,k);
                      
             //Loop over LOCAL derivative directions, to calculate the tangent(s)
             for(unsigned j=0;j<n_dim-1;j++)
              {
               interpolated_A(j,i) += 
                nodal_position_gen(l,bulk_position_type(k),i)*dpsids(l,k,j);
              }
            }
          }
        }
     
       //Now find the local deformed metric tensor from the tangent Vectors
       DenseMatrix<double> A(n_dim-1);
       for(unsigned i=0;i<n_dim-1;i++)
        {
         for(unsigned j=0;j<n_dim-1;j++)
          {
           //Initialise surface metric tensor to zero
           A(i,j) = 0.0;
           //Take the dot product
           for(unsigned k=0;k<n_dim;k++)
            { 
             A(i,j) += interpolated_A(i,k)*interpolated_A(j,k);
            }
          }
        }
     
       //Get the outer unit normal
       Vector<double> interpolated_normal(n_dim);
       outer_unit_normal(ipt,interpolated_normal);
     
       //Find the determinant of the metric tensor
       double Adet =0.0;
       switch(n_dim)
        {
        case 2:
         Adet = A(0,0);
         break;
        case 3:
         Adet = A(0,0)*A(1,1) - A(0,1)*A(1,0);
         break;
        default:
         throw OomphLibError(
          "Wrong dimension in SurfaceContactElement",
          "SurfaceContactElement::fill_in_contribution_to_residuals()",
          OOMPH_EXCEPTION_LOCATION);
        }
     
       //Premultiply the weights and the square-root of the determinant of 
       //the metric tensor
       double W = w*sqrt(Adet);
     
       //Now calculate the load from the penalty method
       Vector<double> traction(n_dim,0.0);

       // Get penetration
       double pen=penetration(interpolated_x,interpolated_normal);

       double stiff=1.0e2;
       if (pen>0.0)
        {
         traction[0]=-stiff*pen*interpolated_normal[0];
         traction[1]=-stiff*pen*interpolated_normal[1];
        }

       //=====LOAD TERMS  FROM PRINCIPLE OF VIRTUAL DISPLACEMENTS========
       
       //Loop over the test functions, nodes of the element
       for(unsigned l=0;l<n_node;l++)
        {
         //Loop of types of dofs
         for(unsigned k=0;k<n_position_type;k++)
          {
           //Loop over the displacement components
           for(unsigned i=0;i<n_dim;i++)
            {
             local_eqn = this->position_local_eqn(l,bulk_position_type(k),i);
             /*IF it's not a boundary condition*/
             if(local_eqn >= 0)
              {
               //Add the loading terms to the residuals
               local_residuals[local_eqn] -= traction[i]*psi(l,k)*W;
              }
            }
          } //End of if not boundary condition
        } //End of loop over shape functions
      } //End of loop over integration points

    }
   // Proper Lagrange multipliers
   //----------------------------
   else
    {

     //Find out how many nodes there are
     unsigned n_node = nnode();
   
     //Find out how many positional dofs there are
     unsigned n_position_type = this->nnodal_position_type();
      
     //Integer to hold the local equation number
     int local_eqn=0;
   
     //Set up memory for the shape functions
     //Note that in this case, the number of lagrangian coordinates is always
     //equal to the dimension of the nodes
     Shape psi(n_node,n_position_type);
     DShape dpsids(n_node,n_position_type,n_dim-1); 

     // Separate shape functions for Lagrange multiplier
     Shape psi_p(n_node);
     Vector<double> s(n_dim-1);

     // Contribution to integrated pressure
     Vector<double> pressure_integral(n_node,0.0);
     
     // Contribution to weighted penetration integral
     Vector<double> penetration_integral(n_node,0.0);
     
     //Set the value of n_intpt
     unsigned n_intpt = integral_pt()->nweight();
   
     //Loop over the integration points
     for(unsigned ipt=0;ipt<n_intpt;ipt++)
      {
       //Get the integral weight
       double w = integral_pt()->weight(ipt);
     
       //Only need to call the local derivatives
       dshape_local_at_knot(ipt,psi,dpsids);
     
       // Separate shape function for Lagrange multiplier
       for(unsigned i=0;i<n_dim-1;i++)
        {
         s[i] = integral_pt()->knot(ipt,i);
        }
       shape_p(s,psi_p);

       // Interpolated Lagrange multiplier (pressure acting on solid
       // to enforce melting)
       double interpolated_lambda_p=0.0;
        
       //Calculate the Eulerian and Lagrangian coordinates 
       Vector<double> interpolated_x(n_dim,0.0);
     
       //Also calculate the surface Vectors (derivatives wrt local coordinates)
       DenseMatrix<double> interpolated_A(n_dim-1,n_dim,0.0);   
     
       //Calculate displacements and derivatives
       for(unsigned l=0;l<n_node;l++) 
        {

         // Cast to a boundary node
         BoundaryNodeBase *bnod_pt = 
          dynamic_cast<BoundaryNodeBase*>(node_pt(l));
       
         // Get the index of the nodal value associated with
         // this FaceElement
         unsigned first_index=
          bnod_pt->index_of_first_value_assigned_by_face_element(Contact_id);
       
         // Add to Lagrange multiplier (acting as pressure on solid
         // to enforce motion to ensure non-penetration)
         interpolated_lambda_p+=node_pt(l)->value(first_index)*psi_p[l];
       
         //Loop over positional dofs
         for(unsigned k=0;k<n_position_type;k++)
          {
           //Loop over displacement components (deformed position)
           for(unsigned i=0;i<n_dim;i++)
            {
             //Calculate the Eulerian and Lagrangian positions
             interpolated_x[i] += 
              nodal_position_gen(l,bulk_position_type(k),i)*psi(l,k);
                      
             //Loop over LOCAL derivative directions, to calculate the tangent(s)
             for(unsigned j=0;j<n_dim-1;j++)
              {
               interpolated_A(j,i) += 
                nodal_position_gen(l,bulk_position_type(k),i)*dpsids(l,k,j);
              }
            }
          }
        }
     
       //Now find the local deformed metric tensor from the tangent Vectors
       DenseMatrix<double> A(n_dim-1);
       for(unsigned i=0;i<n_dim-1;i++)
        {
         for(unsigned j=0;j<n_dim-1;j++)
          {
           //Initialise surface metric tensor to zero
           A(i,j) = 0.0;
           //Take the dot product
           for(unsigned k=0;k<n_dim;k++)
            { 
             A(i,j) += interpolated_A(i,k)*interpolated_A(j,k);
            }
          }
        }
     
       //Get the outer unit normal
       Vector<double> interpolated_normal(n_dim);
       outer_unit_normal(ipt,interpolated_normal);
     
       //Find the determinant of the metric tensor
       double Adet =0.0;
       switch(n_dim)
        {
        case 2:
         Adet = A(0,0);
         break;
        case 3:
         Adet = A(0,0)*A(1,1) - A(0,1)*A(1,0);
         break;
        default:
         throw OomphLibError(
          "Wrong dimension in SurfaceContactElement",
          "SurfaceContactElement::fill_in_contribution_to_residuals()",
          OOMPH_EXCEPTION_LOCATION);
        }
     
       //Premultiply the weights and the square-root of the determinant of 
       //the metric tensor
       double W = w*sqrt(Adet);
     
       // Calculate the "load" -- Lagrange multiplier acts as traction to
       // to enforce required surface displacement
       Vector<double> traction(n_dim);
       for (unsigned i=0;i<n_dim;i++)
        {
         traction[i]=-interpolated_lambda_p*interpolated_normal[i];
        }


       // Accumulate contribution to total contact force
       for(unsigned i=0;i<n_dim;i++)
        {
         contact_force[i]+=traction[i]*W;
        }
     
       //=====LOAD TERMS  FROM PRINCIPLE OF VIRTUAL DISPLACEMENTS========
       
       //Loop over the test functions, nodes of the element
       for(unsigned l=0;l<n_node;l++)
        {
         //Loop of types of dofs
         for(unsigned k=0;k<n_position_type;k++)
          {
           //Loop over the displacement components
           for(unsigned i=0;i<n_dim;i++)
            {
             local_eqn = this->position_local_eqn(l,bulk_position_type(k),i);
             /*IF it's not a boundary condition*/
             if(local_eqn >= 0)
              {
               //Add the loading terms to the residuals
               local_residuals[local_eqn] -= traction[i]*psi(l,k)*W;
              }
            }
          } //End of if not boundary condition
        } //End of loop over shape functions

       //=====CONTRIBUTION TO CONTACT PRESSURE/LAGRANGE MULTIPLIER EQNS ========

       // Get local penetration
       double d=penetration(interpolated_x,interpolated_normal);
       
       //Loop over the nodes
       for(unsigned l=0;l<n_node;l++)
        {
         // Contribution to integrated pressure
         pressure_integral[l]+=interpolated_lambda_p*psi_p[l]*W;
         
         // Contribution to weighted penetration integral
         penetration_integral[l]+=d*psi_p[l]*W;
        }


      } //End of loop over integration points


     // Collocation for contact pressure/Lagrange multiplier:
     //------------------------------------------------------
   
     // Storage for nodal coordinate
     Vector<double> x(n_dim);
   
     //Loop over the nodes
     for(unsigned l=0;l<n_node;l++)
      {
       // get the node pt
       Node* nod_pt = node_pt(l);
   
       // Cast to a boundary node
       BoundaryNodeBase *bnod_pt =
        dynamic_cast<BoundaryNodeBase*>(nod_pt);
   
       // Get the index of the first nodal value associated with
       // this FaceElement
       unsigned first_index=
        bnod_pt->index_of_first_value_assigned_by_face_element(Contact_id);

       // Equation for Lagrange multiplier
       local_eqn = nodal_local_eqn(l,first_index);
    
       /*IF it's not a boundary condition*/
       if(local_eqn >= 0)
        {

         // Enforcement by collocation
         bool do_collocation=false;
         if (do_collocation)
          {
           // Nodal position
           x[0]=nod_pt->x(0);
           x[1]=nod_pt->x(1);
           
           // Get outer unit normal
           Vector<double> s(2);
           local_coordinate_of_node(l,s);
           Vector<double> unit_normal(2);
           outer_unit_normal(s,unit_normal);

           // Get penetration
           double d=penetration(x,unit_normal);
           
           // Get value of contact pressure
           double contact_pressure=nod_pt->value(first_index);
           
           // Contact/non-penetration residual
           if (Enable_stick)
            {
             // Enforce contact
             local_residuals[local_eqn]-=d;
            }
           else
            {
             // Piecewise linear variation for non-penetration constraint
             if (-d>contact_pressure)
              {
               local_residuals[local_eqn]+=contact_pressure;
              }
             else
              {
               local_residuals[local_eqn]-=d;
              }
            }
          }
         // Weighted penetration constraint
         else
          {
           // Use weighted/integrated quantities
           double d=penetration_integral[l];
           double contact_pressure=pressure_integral[l];

           // Contact/non-penetration residual
           if (Enable_stick)
            {
             // Enforce contact
             local_residuals[local_eqn]-=d;
            }
           else
            {
             // Piecewise linear variation for non-penetration constraint
             if (-d>contact_pressure)
              {
               local_residuals[local_eqn]+=contact_pressure;
              }
             else
              {
               local_residuals[local_eqn]-=d;
              }

            }
                     
          }

        }
      }
    }

   // Now deal with the penetrator equilibrium equations (if any!)
   unsigned n=Penetrator_eq_data_type.size();
   for (unsigned i=0;i<n;i++)
    {
     if (Penetrator_eq_data_type[i]>=0)
      {
       switch(unsigned(Penetrator_eq_data_type[i]))
        {
         
        case External_data:
        {
         int local_eqn=external_local_eqn(
          Penetrator_eq_data_data_index[i],
          Penetrator_eq_data_index[i]);
         if (local_eqn>=0)
          {
           local_residuals[local_eqn]=contact_force[i];
          }
        }
        break;
        
        case Nodal_position_data:
        {
         // position type (dummy -- hierher paranoid check)
         unsigned k=0;
         int local_eqn=position_local_eqn(
          Penetrator_eq_data_data_index[i],k,
          Penetrator_eq_data_index[i]);
         if (local_eqn>=0)
          {
           local_residuals[local_eqn]=contact_force[i];
          }
        }
        break;
        
        
        case Nodal_data:
        {
         int local_eqn=nodal_local_eqn(
          Penetrator_eq_data_data_index[i],
          Penetrator_eq_data_index[i]);
         if (local_eqn>=0)
          {
           local_residuals[local_eqn]+=contact_force[i];
          }
        }
        break;
        
        default:


         std::stringstream junk;
         junk << "Never get here: "
              << "unsigned(Penetrator_eq_data_type[i]) = "
              << unsigned(Penetrator_eq_data_type[i]);
          throw OomphLibError(
          junk.str(),
          OOMPH_CURRENT_FUNCTION,
          OOMPH_EXCEPTION_LOCATION);

        }
      }  
    }

   // Now add local contribution to existing entries
   for (unsigned j=0;j<n_dof;j++)
    {
     residuals[j]+=local_residuals[j];
    }

  }




//=====================================================================
/// Resulting contact force
//=====================================================================
 template<class ELEMENT>
  void SurfaceContactElement<ELEMENT>::resulting_contact_force(
   Vector<double> &contact_force) 
  {
   //Find out how many nodes there are
   unsigned n_node = nnode();
   
   //Find out how many positional dofs there are
   unsigned n_position_type = this->nnodal_position_type();
   
   //Find out the dimension of the node
   unsigned n_dim = this->nodal_dimension();

   // Initialise
   for (unsigned i=0;i<n_dim;i++)
    {
     contact_force[i]=0.0;
    }

   //Set up memory for the shape functions
   //Note that in this case, the number of lagrangian coordinates is always
   //equal to the dimension of the nodes
   Shape psi(n_node,n_position_type);
   DShape dpsids(n_node,n_position_type,n_dim-1); 
   
   // Separate shape functions for Lagrange multiplier
   Shape psi_p(n_node);
   Vector<double> s(n_dim-1);
   
   //Set the value of n_intpt
   unsigned n_intpt = integral_pt()->nweight();
   
   //Loop over the integration points
   for(unsigned ipt=0;ipt<n_intpt;ipt++)
    {
     //Get the integral weight
     double w = integral_pt()->weight(ipt);
     
     //Only need to call the local derivatives
     dshape_local_at_knot(ipt,psi,dpsids);
     
     // Separate shape function for Lagrange multiplier
     for(unsigned i=0;i<n_dim-1;i++)
      {
       s[i] = integral_pt()->knot(ipt,i);
      }
     shape_p(s,psi_p);
     
     // Interpolated Lagrange multiplier (pressure acting on solid
     // to enforce melting)
     double interpolated_lambda_p=0.0;
     
     //Calculate the Eulerian and Lagrangian coordinates 
     Vector<double> interpolated_x(n_dim,0.0);
     
     //Also calculate the surface Vectors (derivatives wrt local coordinates)
     DenseMatrix<double> interpolated_A(n_dim-1,n_dim,0.0);   
     
     //Calculate displacements and derivatives
     for(unsigned l=0;l<n_node;l++) 
      {
       // Cast to a boundary node
       BoundaryNodeBase *bnod_pt = 
        dynamic_cast<BoundaryNodeBase*>(node_pt(l));
       
       // Get the index of the nodal value associated with
       // this FaceElement
       unsigned first_index=
        bnod_pt->index_of_first_value_assigned_by_face_element(Contact_id);
       
       // Add to Lagrange multiplier (acting as pressure on solid
       // to enforce motion to ensure non-penetration)
       interpolated_lambda_p+=node_pt(l)->value(first_index)*psi_p[l];
       
       //Loop over positional dofs
       for(unsigned k=0;k<n_position_type;k++)
        {
         //Loop over displacement components (deformed position)
         for(unsigned i=0;i<n_dim;i++)
          {
           //Calculate the Eulerian and Lagrangian positions
           interpolated_x[i] += 
            nodal_position_gen(l,bulk_position_type(k),i)*psi(l,k);
           
           //Loop over LOCAL derivative directions, to calculate the tangent(s)
           for(unsigned j=0;j<n_dim-1;j++)
            {
             interpolated_A(j,i) += 
              nodal_position_gen(l,bulk_position_type(k),i)*dpsids(l,k,j);
            }
          }
        }
      }
     
     //Now find the local deformed metric tensor from the tangent Vectors
     DenseMatrix<double> A(n_dim-1);
     for(unsigned i=0;i<n_dim-1;i++)
      {
       for(unsigned j=0;j<n_dim-1;j++)
        {
         //Initialise surface metric tensor to zero
         A(i,j) = 0.0;
         //Take the dot product
         for(unsigned k=0;k<n_dim;k++)
          { 
           A(i,j) += interpolated_A(i,k)*interpolated_A(j,k);
          }
        }
      }
     
     //Get the outer unit normal
     Vector<double> interpolated_normal(n_dim);
     outer_unit_normal(ipt,interpolated_normal);
     
     //Find the determinant of the metric tensor
     double Adet =0.0;
     switch(n_dim)
      {
      case 2:
       Adet = A(0,0);
       break;
      case 3:
       Adet = A(0,0)*A(1,1) - A(0,1)*A(1,0);
       break;
      default:
       throw OomphLibError(
        "Wrong dimension in SurfaceContactElement",
        "SurfaceContactElement::contact_force()",
        OOMPH_EXCEPTION_LOCATION);
      }
     
     //Premultiply the weights and the square-root of the determinant of 
     //the metric tensor
     double W = w*sqrt(Adet);
     
     // Calculate the "load" -- Lagrange multiplier acts as traction to
     // to enforce required surface displacement
     Vector<double> traction(n_dim);
     for (unsigned i=0;i<n_dim;i++)
      {
       traction[i]=-interpolated_lambda_p*interpolated_normal[i];
      }
     
     // Add to resulting force
     for (unsigned i=0;i<n_dim;i++)
      {
       contact_force[i]+=traction[i]*W;
      }
    }
 
  }



////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////


}


#endif
