//LIC// ====================================================================
//LIC// This file forms part of oomph-lib, the object-oriented, 
//LIC// multi-physics finite-element library, available 
//LIC// at http://www.oomph-lib.org.
//LIC// 
//LIC//           Version 0.90. August 3, 2009.
//LIC// 
//LIC// Copyright (C) 2006-2009 Matthias Heil and Andrew Hazel
//LIC// 
//LIC// This library is free software; you can redistribute it and/or
//LIC// modify it under the terms of the GNU Lesser General Public
//LIC// License as published by the Free Software Foundation; either
//LIC// version 2.1 of the License, or (at your option) any later version.
//LIC// 
//LIC// This library is distributed in the hope that it will be useful,
//LIC// but WITHOUT ANY WARRANTY; without even the implied warranty of
//LIC// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//LIC// Lesser General Public License for more details.
//LIC// 
//LIC// You should have received a copy of the GNU Lesser General Public
//LIC// License along with this library; if not, write to the Free Software
//LIC// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
//LIC// 02110-1301  USA.
//LIC// 
//LIC// The authors may be contacted at oomph-lib@maths.man.ac.uk.
//LIC// 
//LIC//====================================================================
// Header file for elements that enforce solid contact for linear elasticity

#ifndef OOMPH_LINEAR_CONTACT_ELEMENTS_HEADER
#define OOMPH_LINEAR_CONTACT_ELEMENTS_HEADER

// Config header generated by autoconfig
#ifdef HAVE_CONFIG_H
#include <oomph-lib-config.h>
#endif

//Standard libray headers
#include <cmath>

// oomph-lib includes
#include "generic.h" // ../generic/Qelements.h"
#include "linear_elasticity.h" // ../generic/Qelements.h"

namespace oomph
{
 

////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////



//======================================================================
/// A class for elements that impose contact boundary conditions
/// in linear elasticity problems
/// either enforcing non-penetration (but "without stick"; default) or 
/// permament contact (in which case contact force can be
/// positive or negative. Uses Lagrange-multiplier-like pressure
/// to enforce contact/non-penetration. Almost certainly works only with
/// 2D Penetrator at the moment.
//======================================================================
 template <class ELEMENT>
  class LinearElasticitySurfaceContactElement : 
public virtual FaceGeometry<ELEMENT>, 
 public virtual SolidFaceElement, public virtual ContactElementBase
  {
 
    public:
 
   /// \short Constructor, which takes a "bulk" element and the 
   /// value of the index and its limit
    LinearElasticitySurfaceContactElement(
     FiniteElement* const &element_pt, 
     const int &face_index,
     const unsigned &id=0,
     const bool& called_from_refineable_constructor=
     false) : 
   FaceGeometry<ELEMENT>(), FaceElement()
    { 
     
     // By default we only to proper non-penetration (without "stick", i.e.
     // we don't allow negative contact pressures) 
     Enable_stick=false;

     // Initialise pointer to penetrator
     Penetrator_pt=0;

     //Attach the geometrical information to the element. N.B. This function
     //also assigns nbulk_value from the required_nvalue of the bulk element
     element_pt->build_face_element(face_index,this);
     
     
#ifdef PARANOID
     {
      //Check that the bulk element is not a refineable 3d element
      if (!called_from_refineable_constructor)
       {
        if(element_pt->dim()==3)
         {
          //Is it refineable
          RefineableElement* ref_el_pt=
           dynamic_cast<RefineableElement*>(element_pt);
          if(ref_el_pt!=0)
           {
            if (this->has_hanging_nodes())
             {
              throw OomphLibError(
               "This face element will not work correctly if nodes are hanging.\nUse the refineable version instead. ",
               OOMPH_CURRENT_FUNCTION,
               OOMPH_EXCEPTION_LOCATION);
             }
           }
         }
       }
     }
#endif
     
     //  Store the ID of the FaceElement -- this is used to distinguish
     // it from any others
     Contact_id=id;
     
     // We need one additional value for each FaceElement node:
     // the normal traction (Lagrange multiplier) to be 
     // exerted onto the solid
     unsigned n_nod=nnode();
     Vector<unsigned> n_additional_values(n_nod,1);
     
     // Now add storage for Lagrange multipliers and set the map containing 
     // the position of the first entry of this face element's 
     // additional values.
     add_additional_values(n_additional_values,id);
     
#ifdef PARANOID
     // Check spatial dimension
     if (element_pt->dim()!=2)
      {
       //Issue a warning
       throw OomphLibError(
        "This element will almost certainly not work in non-2D problems, though it should be easy enough to upgrade... Volunteers?\n",
        OOMPH_CURRENT_FUNCTION,
        OOMPH_EXCEPTION_LOCATION);
      }
#endif
     
     // Change integration scheme
     set_integration_scheme(new PiecewiseGauss<1,3>(s_min(),s_max()));

     //Find the dimension of the problem
     unsigned n_dim = element_pt->nodal_dimension();
     
     //Find the index at which the displacemenet unknowns are stored
     ELEMENT* cast_element_pt = dynamic_cast<ELEMENT*>(element_pt);
     this->U_index_linear_elasticity_traction.resize(n_dim);
     for(unsigned i=0;i<n_dim;i++)
      {
       this->U_index_linear_elasticity_traction[i] = 
        cast_element_pt->u_index_linear_elasticity(i);
      }
    }
  
   
   /// \short Default constructor. 
    LinearElasticitySurfaceContactElement() :  FaceGeometry<ELEMENT>(), 
    FaceElement() { }
   
   /// \short Enforce permanent contact with penetrator, allowing
   /// for negative contact pressures.
   void enable_stick()
   {
    Enable_stick=true;
   }

   /// \short Allow only proper non-penetration (without "stick", i.e.
   /// we don't allow negative contact pressures) 
   void disable_stick()
   {
    Enable_stick=false;
   }

   /// \short Do we allow only proper non-penetration (without "stick", i.e.
   /// no negative contact pressures)?
   void is_stick_enabled()
   {
    return Enable_stick;
   }

   // hierher kill -- also in nonlinear version
   /* /// Reset penetration for all nodes */
   /* void reset_penetration() */
   /* { */
   /*  unsigned nnod=nnode(); */
   /*  for (unsigned j=0;j<nnod;j++) */
   /*   { */
   /*    Node* nod_pt=node_pt(j); */
   /*    Vector<double> x(2); */
   /*    x[0]=nod_pt->x(0); */
   /*    x[1]=nod_pt->x(1); */

   /*    // Get outer unit normal */
   /*    Vector<double> s(2); */
   /*    local_coordinate_of_node(j,s); */
   /*    Vector<double> unit_normal(2); */
   /*    outer_unit_normal(s,unit_normal); */

   /*    // Get position on penetrator */
   /*    Vector<double> r_p(2); */
   /*    Penetrator_pt->position(x,r_p); */
      
   /*    // Get penetration */
   /*    double d=Penetrator_pt->penetration(x,unit_normal); */
      
   /*    // Reset */
   /*    bool do_it=false; */
      
   /*    // Permanent contact: reset always */
   /*    if (Enable_stick) */
   /*     { */
   /*      do_it=true; */
   /*     } */
   /*    // Only non-penetration: reset only if node penetrates */
   /*    else */
   /*     { */
   /*      if (d>0.0) */
   /*       {  */
   /*        do_it=true; */
   /*       } */
   /*     } */
   /*    if (do_it) */
   /*     { */
   /*      nod_pt->x(0)=r_p[0]; */
   /*      nod_pt->x(1)=r_p[1]; */
   /*     } */
   /*   } */
   /* } */

   /* /// Doc penetration for all nodes; return max. */
   /* double doc_penetration() */
   /* { */
   /*  double max_pen=0.0; */
   /*  unsigned nnod=nnode(); */
   /*  for (unsigned j=0;j<nnod;j++) */
   /*   { */
   /*    Node* nod_pt=node_pt(j); */
   /*    Vector<double> x(2); */
   /*    x[0]=nod_pt->x(0); */
   /*    x[1]=nod_pt->x(1); */

   /*    // Get outer unit normal */
   /*    Vector<double> s(2); */
   /*    local_coordinate_of_node(j,s); */
   /*    Vector<double> unit_normal(2); */
   /*    outer_unit_normal(s,unit_normal); */

   /*    double pen=penetration(x,unit_normal); */
   /*    if (pen>max_pen) max_pen=pen; */
   /*   } */
   /*  return max_pen; */
   /* } */
   // hierher end kill -- also in other one!

   /// Return the residuals
   void fill_in_contribution_to_residuals(Vector<double> &residuals)
   {
    fill_in_contribution_to_residuals_linear_elasticity_surface_contact(
     residuals);
   }

 
   // hierher FD the lot for now
   // /// Fill in contribution from Jacobian
   // void fill_in_contribution_to_jacobian(Vector<double> &residuals,
   //                                       DenseMatrix<double> &jacobian)
   //  {
   //   //Call the residuals
   //   fill_in_contribution_to_residuals_surface_contact(residuals);

   //   //Call the generic FD jacobian calculation
   //   FaceGeometry<ELEMENT>::fill_in_jacobian_from_solid_position_by_fd(jacobian);
   
   //   //Derivs w.r.t. to any external data (e.g. during displacement control)
   //   this->fill_in_jacobian_from_external_by_fd(residuals,jacobian);
   //   }


   /// \short Pointer to penetrator
   Penetrator* penetrator_pt() const
    {
     return Penetrator_pt;
    }
 
   /// \short Set pointer to penetrator
   void set_penetrator_pt(Penetrator* penetrator_pt)
    {
     Penetrator_pt=penetrator_pt;
     Vector<std::pair<Data*,unsigned> > 
      eq_data(Penetrator_pt->equilibrium_data());
     unsigned n=eq_data.size();
     Penetrator_eq_data_data_index.resize(n,-1);
     Penetrator_eq_data_index.resize(n,-1);
     Penetrator_eq_data_type.resize(n,-1);
     for (unsigned i=0;i<n;i++)
      {
       if (eq_data[i].first!=0)
        {
         bool is_duplicate=false;
         unsigned nnod=nnode();
         for (unsigned j=0;j<nnod;j++)
          {
           if (eq_data[i].first==node_pt(j))
            {
             Penetrator_eq_data_type[i]=Nodal_data;
             Penetrator_eq_data_data_index[i]=j;
             Penetrator_eq_data_index[i]=eq_data[i].second;
             is_duplicate=true;
             break;
            }
           if (eq_data[i].first==
               dynamic_cast<SolidNode*>(node_pt(j))->variable_position_pt())
            {
             Penetrator_eq_data_type[i]=Nodal_position_data;
             Penetrator_eq_data_data_index[i]=j;
             Penetrator_eq_data_index[i]=eq_data[i].second;
             is_duplicate=true;
             break;
            }
          }
         
         if (!is_duplicate)
          {
           Penetrator_eq_data_type[i]=External_data;
           Penetrator_eq_data_data_index[i]=
            this->add_external_data(eq_data[i].first);
           Penetrator_eq_data_index[i]=eq_data[i].second;
          }
        }
      }
    }
 

   /// \short Output function
   void output(std::ostream &outfile)
   {
    unsigned n_plot=5;
    output(outfile,n_plot);
   }

   /// \short Output function
   void output(std::ostream &outfile, const unsigned &n_plot)
   {

    unsigned n_dim = this->nodal_dimension();
  
    Vector<double> x(n_dim);
    Vector<double> disp(n_dim);
    Vector<double> x_def(n_dim);
    Vector<double> s(n_dim-1);
    Vector<double> r_pen(n_dim);
    Vector<double> unit_normal(n_dim);
 
    // Tecplot header info
    outfile << this->tecplot_zone_string(n_plot);
  
    // Loop over plot points
    unsigned num_plot_points=this->nplot_points(n_plot);
    for (unsigned iplot=0;iplot<num_plot_points;iplot++)
     {
      // Get local coordinates of plot point
      this->get_s_plot(iplot,n_plot,s);
    
      // Get coordinates and outer unit normal
      this->interpolated_x(s,x);
      this->outer_unit_normal(s,unit_normal);   

      // Displacement
      this->interpolated_u_linear_elasticity(s,disp);

      // Deformed position
      for(unsigned i=0;i<n_dim;i++) 
       {
        x_def[i]=x[i]+disp[i];
       }

      // Get penetration based on deformed position
      double d=penetration(x_def,unit_normal);
    
      //Output the x,y,..
      for(unsigned i=0;i<n_dim;i++) 
       {outfile << x[i] << " ";} // col 1,2

      // Penetration
      outfile << std::max(d,-100.0) << " "; // col 3

      // Lagrange multiplier-like pressure
      double p=get_interpolated_lagrange_p(s);
      outfile << p << " "; // col 4
      

      // Plot Lagrange multiplier like pressure
      outfile << -unit_normal[0]*p << " "; // col 5
      outfile << -unit_normal[1]*p << " "; // col 6

      // Plot vector from current point to boundary of penetrator
      //Penetrator_pt->position(x,r_pen);
      double d_tmp=d;
      if (d_tmp==-DBL_MAX) d_tmp=0.0;
      outfile << -d_tmp*unit_normal[0] << " ";  // col 7
      outfile << -d_tmp*unit_normal[1] << " ";  // col 8

      // Output normal
      for(unsigned i=0;i<n_dim;i++) 
       {outfile << unit_normal[i] << " ";} // col 9, 10
    
      //Output the displacements
      for(unsigned i=0;i<n_dim;i++)
       {
        outfile << disp[i] << " "; // col 11, 12
       }

      //Output the deformed position
      for(unsigned i=0;i<n_dim;i++)
       {
        outfile << x_def[i] << " "; // col 13, 14
       }
      outfile << std::endl;
     }
   
    // Write tecplot footer (e.g. FE connectivity lists)
    this->write_tecplot_zone_footer(outfile,n_plot);
  
   }
 
   /// \short C_style output function
   void output(FILE* file_pt)
   {FiniteElement::output(file_pt);}

   /// \short C-style output function
   void output(FILE* file_pt, const unsigned &n_plot)
   {FiniteElement::output(file_pt,n_plot);}


   /// Shape fct for lagrange multiplier
   void shape_p(const Vector<double>& s, Shape &psi) const
   {
    bool use_isoparametric=false;
    if (use_isoparametric)
     {
      FaceGeometry<ELEMENT>::shape(s,psi);
     }
    else
     {
      const double smin=s_min();
      const double smax=s_max();
      const double sl=smin+0.25*(smax-smin);
      const double sr=smin+0.75*(smax-smin);
      if (s[0]<=sl)
       {
        psi[0]=1.0;
        psi[1]=0.0;
        psi[2]=0.0;
       }
      else if (s[0]<=sr)
       {
        psi[0]=0.0;
        psi[1]=1.0;
        psi[2]=0.0;
       }
      else 
       {
        psi[0]=0.0;
        psi[1]=0.0;
        psi[2]=1.0;
       }
     }
   }

   /// Resulting contact force
   void resulting_contact_force(Vector<double> &contact_force);
   
    protected:
   
   
   /// Compute vector of FE interpolated displacement u at local coordinate s
   void interpolated_u_linear_elasticity(const Vector<double> &s,
                                         Vector<double>& disp) const
   {
    //Find the dimension of the problem
    unsigned n_dim = this->nodal_dimension();
    
    //Find number of nodes
    unsigned n_node = nnode();
    
    //Local shape function
    Shape psi(n_node);
    
    //Find values of shape function
    shape(s,psi);
    
    // Get displacements
    for (unsigned i=0;i<n_dim;i++)
     {
      //Index at which the nodal value is stored
      unsigned u_nodal_index = this->U_index_linear_elasticity_traction[i];
      
      //Initialise value of u
      disp[i] = 0.0;
      
      //Loop over the local nodes and sum
      for(unsigned l=0;l<n_node;l++) 
       {
        disp[i] += nodal_value(l,u_nodal_index)*psi[l];
       }
     }
    // hierher paranoid check via bulk
   }
  

   
   
   
   /// \short Get interpolated pressure (essentially a Lagrange multiplier
   /// that enforces the imposed boundary motion to ensure 
   /// non-penetration or contact)
   double get_interpolated_lagrange_p(const Vector<double>& s)
   {
    // Initialise pressure
    double p=0;
    
    //Find out how many nodes there are
    unsigned n_node = nnode();
    
    //Set up memory for the shape functions
    Shape psi(n_node);
    
    // Evaluate shape function
    shape_p(s,psi);
 
 // Build up Lagrange multiplier (pressure)
 for (unsigned j=0;j<n_node;j++)
  {
   // Cast to a boundary node
   BoundaryNodeBase *bnod_pt = 
    dynamic_cast<BoundaryNodeBase*>(node_pt(j));
   
   // Get the index of the first nodal value associated with
   // this FaceElement
   unsigned first_index=
    bnod_pt->index_of_first_value_assigned_by_face_element(Contact_id);
   
   // Pressure (Lagrange multiplier) is the first (and only) additional
   // value created by this face element
   p+=node_pt(j)->value(first_index)*psi[j];
  }
 return p;
}

   /// \short Helper function that actually calculates the residuals
   // This small level of indirection is required to avoid calling
   // fill_in_contribution_to_residuals in fill_in_contribution_to_jacobian
   // which causes all kinds of pain if overloading later on
   void fill_in_contribution_to_residuals_linear_elasticity_surface_contact(
    Vector<double>& residuals);
 
   /// Work out penetration of point 
   double penetration(const Vector<double>& x, const Vector<double>& n) const
   {
    return Penetrator_pt->penetration(x,n);
   }

   /// Pointer to penetrator
   Penetrator* Penetrator_pt;

   /// \short ID of the contact constraint (used for the identification of
   /// the nodal value that corresponds to the pressure-like
   /// Lagrange multipliers.
   unsigned Contact_id;

   /// \short Do we allow only proper non-penetration (without "stick", i.e.
   /// no negative contact pressures)?
   bool Enable_stick;


   /// Enumeration for type of penetrator data
   enum{Nodal_data, 
        Nodal_position_data, 
        External_data};

   /// \short Vector containing the type of Data (labeled by the 
   /// class' private enumeration) that is determined (via pseudo-hijacking)
   /// from the Penetrator's i-th equilibrium of forces equation. -1 if
   /// this relevant equilibrium equation is not employed to determine
   /// an unknown that's associated with the current element.
   Vector<int> Penetrator_eq_data_type;

   /// \short Vector containing the index of the Data object (e.g. the
   /// node number in the current element) that stores the unknown 
   /// that is determined from the Penetrator's 
   /// i-th equilibrium of forces equation. -1 if the relevant 
   /// equilibrium equation is not employed to determine
   /// an unknown that's associated with the current element.
   Vector<int> Penetrator_eq_data_index;

   /// \short Vector containing the index of the value in the Data 
   /// object (e.g. the node number in the current element) that 
   /// stores the unknown that is determined from the Penetrator's 
   /// i-th equilibrium of forces equation. -1 if the relevant 
   /// equilibrium equation is not employed to determine
   /// an unknown that's associated with the current element.
   Vector<int> Penetrator_eq_data_data_index;

   /// Index at which the i-th displacement component is stored
   Vector<unsigned> U_index_linear_elasticity_traction;
   

  }; 


///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////

 
//=====================================================================
/// Return the residuals for the LinearElasticitySurfaceContactElement
/// equations
//=====================================================================
 template<class ELEMENT>
  void LinearElasticitySurfaceContactElement<ELEMENT>::
  fill_in_contribution_to_residuals_linear_elasticity_surface_contact(
   Vector<double> &residuals)
  {

   // Spatial dimension of problem
   unsigned n_dim = this->nodal_dimension();
   
   // Contribution to contact force
   Vector<double> contact_force(n_dim,0.0);
 
   // Create vector of local residuals (start assembling contributions
   // from zero -- necessary so we can over-write pseudo-hijacked
   // contributions at the end.
   unsigned n_dof=ndof();
   Vector<double> local_residuals(n_dof,0.0);

   // Penalty-like method? [Only for test; not actively used; keep around
   //--------------------- 'cos it may be useful...]
   const bool penalty=false;
   if (penalty)
    {
     oomph_info << "This is almost certainly broken by now...\n";
     abort();

     /* //Find out how many nodes there are */
     /* unsigned n_node = nnode(); */
   
     /* //Find out how many positional dofs there are */
     /* unsigned n_position_type = this->nnodal_position_type(); */
   
     /* //Integer to hold the local equation number */
     /* int local_eqn=0; */
   
     /* //Set up memory for the shape functions */
     /* //Note that in this case, the number of lagrangian coordinates is always */
     /* //equal to the dimension of the nodes */
     /* Shape psi(n_node,n_position_type); */
     /* DShape dpsids(n_node,n_position_type,n_dim-1);  */
   
     /* //Set the value of n_intpt */
     /* unsigned n_intpt = integral_pt()->nweight(); */
   
     /* //Loop over the integration points */
     /* for(unsigned ipt=0;ipt<n_intpt;ipt++) */
     /*  { */
     /*   //Get the integral weight */
     /*   double w = integral_pt()->weight(ipt); */
     
     /*   //Only need to call the local derivatives */
     /*   dshape_local_at_knot(ipt,psi,dpsids); */
     
     /*   //Calculate the Eulerian and Lagrangian coordinates  */
     /*   Vector<double> interpolated_x(n_dim,0.0); */
     
     /*   //Also calculate the surface Vectors (derivatives wrt local coordinates) */
     /*   DenseMatrix<double> interpolated_A(n_dim-1,n_dim,0.0);    */
     
     /*   //Calculate displacements and derivatives */
     /*   for(unsigned l=0;l<n_node;l++)  */
     /*    { */
     /*     //Loop over positional dofs */
     /*     for(unsigned k=0;k<n_position_type;k++) */
     /*      { */
     /*       //Loop over displacement components (deformed position) */
     /*       for(unsigned i=0;i<n_dim;i++) */
     /*        { */
     /*         //Calculate the Eulerian and Lagrangian positions */
     /*         interpolated_x[i] +=  */
     /*          nodal_position_gen(l,bulk_position_type(k),i)*psi(l,k); */
                      
     /*         //Loop over LOCAL derivative directions, to calculate the tangent(s) */
     /*         for(unsigned j=0;j<n_dim-1;j++) */
     /*          { */
     /*           interpolated_A(j,i) +=  */
     /*            nodal_position_gen(l,bulk_position_type(k),i)*dpsids(l,k,j); */
     /*          } */
     /*        } */
     /*      } */
     /*    } */
     
     /*   //Now find the local deformed metric tensor from the tangent Vectors */
     /*   DenseMatrix<double> A(n_dim-1); */
     /*   for(unsigned i=0;i<n_dim-1;i++) */
     /*    { */
     /*     for(unsigned j=0;j<n_dim-1;j++) */
     /*      { */
     /*       //Initialise surface metric tensor to zero */
     /*       A(i,j) = 0.0; */
     /*       //Take the dot product */
     /*       for(unsigned k=0;k<n_dim;k++) */
     /*        {  */
     /*         A(i,j) += interpolated_A(i,k)*interpolated_A(j,k); */
     /*        } */
     /*      } */
     /*    } */
     
     /*   //Get the outer unit normal */
     /*   Vector<double> interpolated_normal(n_dim); */
     /*   outer_unit_normal(ipt,interpolated_normal); */
     
     /*   //Find the determinant of the metric tensor */
     /*   double Adet =0.0; */
     /*   switch(n_dim) */
     /*    { */
     /*    case 2: */
     /*     Adet = A(0,0); */
     /*     break; */
     /*    case 3: */
     /*     Adet = A(0,0)*A(1,1) - A(0,1)*A(1,0); */
     /*     break; */
     /*    default: */
     /*     throw OomphLibError( */
     /*      "Wrong dimension in SurfaceContactElement", */
     /*      "SurfaceContactElement::fill_in_contribution_to_residuals()", */
     /*      OOMPH_EXCEPTION_LOCATION); */
     /*    } */
     
     /*   //Premultiply the weights and the square-root of the determinant of  */
     /*   //the metric tensor */
     /*   double W = w*sqrt(Adet); */
     
     /*   //Now calculate the load from the penalty method */
     /*   Vector<double> traction(n_dim,0.0); */

     /*   // Get penetration */
     /*   double pen=penetration(x_def,interpolated_normal); */

     /*   double stiff=1.0e2; */
     /*   if (pen>0.0) */
     /*    { */
     /*     traction[0]=-stiff*pen*interpolated_normal[0]; */
     /*     traction[1]=-stiff*pen*interpolated_normal[1]; */
     /*    } */

     /*   //=====LOAD TERMS  FROM PRINCIPLE OF VIRTUAL DISPLACEMENTS======== */
       
     /*   //Loop over the test functions, nodes of the element */
     /*   for(unsigned l=0;l<n_node;l++) */
     /*    { */
     /*     //Loop of types of dofs */
     /*     for(unsigned k=0;k<n_position_type;k++) */
     /*      { */
     /*       //Loop over the displacement components */
     /*       for(unsigned i=0;i<n_dim;i++) */
     /*        { */
     /*         local_eqn = this->position_local_eqn(l,bulk_position_type(k),i); */
     /*         /\*IF it's not a boundary condition*\/ */
     /*         if(local_eqn >= 0) */
     /*          { */
     /*           //Add the loading terms to the residuals */
     /*           local_residuals[local_eqn] -= traction[i]*psi(l,k)*W; */
     /*          } */
     /*        } */
     /*      } //End of if not boundary condition */
     /*    } //End of loop over shape functions */
     /*  } //End of loop over integration points */

    }
   // Proper Lagrange multipliers
   //----------------------------
   else
    {

     //Find out how many nodes there are
     unsigned n_node = nnode();
   
     //Integer to hold the local equation number
     int local_eqn=0;
   
     //Set up memory for the shape functions
     Shape psi(n_node);
     DShape dpsids(n_node,n_dim-1);

     // Separate shape functions for Lagrange multiplier
     Shape psi_p(n_node);
     Vector<double> s(n_dim-1);

     // Contribution to integrated pressure
     Vector<double> pressure_integral(n_node,0.0);
     
     // Contribution to weighted penetration integral
     Vector<double> penetration_integral(n_node,0.0);
     
     // Deformed position
     Vector<double> x_def(n_dim,0.0);

     //Set the value of n_intpt
     unsigned n_intpt = integral_pt()->nweight();
   
     //Loop over the integration points
     for(unsigned ipt=0;ipt<n_intpt;ipt++)
      {
       //Get the integral weight
       double w = integral_pt()->weight(ipt);
     
       //Only need to call the local derivatives
       dshape_local_at_knot(ipt,psi,dpsids);
     
       // Separate shape function for Lagrange multiplier
       for(unsigned i=0;i<n_dim-1;i++)
        {
         s[i] = integral_pt()->knot(ipt,i);
        }
       shape_p(s,psi_p);

       // Interpolated Lagrange multiplier (pressure acting on solid
       // to enforce melting)
       double interpolated_lambda_p=0.0;
        
       // Displacement
       Vector<double> disp(n_dim,0.0);
     
       //Calculate the coordinates 
       Vector<double> interpolated_x(n_dim,0.0);
     
       //Also calculate the surface Vectors (derivatives wrt local coordinates)
       DenseMatrix<double> interpolated_A(n_dim-1,n_dim,0.0);   
     
       //Calculate displacements and derivatives
       for(unsigned l=0;l<n_node;l++) 
        {
         // Cast to a boundary node
         BoundaryNodeBase *bnod_pt = 
          dynamic_cast<BoundaryNodeBase*>(node_pt(l));
       
         // Get the index of the nodal value associated with
         // this FaceElement
         unsigned first_index=
          bnod_pt->index_of_first_value_assigned_by_face_element(Contact_id);
       
         // Add to Lagrange multiplier (acting as pressure on solid
         // to enforce motion to ensure non-penetration)
         interpolated_lambda_p+=node_pt(l)->value(first_index)*psi_p[l];
         
         //Loop over displacement components
         for(unsigned i=0;i<n_dim;i++)
          {
           //Calculate the positions
           interpolated_x[i]+=nodal_position(l,i)*psi(l);
           
           //Index at which the displacement nodal value is stored
           unsigned u_nodal_index=this->U_index_linear_elasticity_traction[i];
           disp[i] += nodal_value(l,u_nodal_index)*psi(l);

           // Loop over LOCAL derivative directions, to calculate the 
           // tangent(s)
           for(unsigned j=0;j<n_dim-1;j++)
            {
             interpolated_A(j,i)+=nodal_position(l,i)*dpsids(l,j);
            }
          }
        }
     
       //Now find the local deformed metric tensor from the tangent Vectors
       DenseMatrix<double> A(n_dim-1);
       for(unsigned i=0;i<n_dim-1;i++)
        {
         for(unsigned j=0;j<n_dim-1;j++)
          {
           //Initialise surface metric tensor to zero
           A(i,j) = 0.0;
           //Take the dot product
           for(unsigned k=0;k<n_dim;k++)
            { 
             A(i,j) += interpolated_A(i,k)*interpolated_A(j,k);
            }
          }
        }
     
       //Get the outer unit normal
       Vector<double> interpolated_normal(n_dim);
       outer_unit_normal(ipt,interpolated_normal);
     
       //Find the determinant of the metric tensor
       double Adet =0.0;
       switch(n_dim)
        {
        case 2:
         Adet = A(0,0);
         break;
        case 3:
         Adet = A(0,0)*A(1,1) - A(0,1)*A(1,0);
         break;
        default:
         throw OomphLibError(
          "Wrong dimension in SurfaceContactElement",
          "LinearElasticitySurfaceContactElement::fill_in_contribution_to_residuals()",
          OOMPH_EXCEPTION_LOCATION);
        }
     
       //Premultiply the weights and the square-root of the determinant of 
       //the metric tensor
       double W = w*sqrt(Adet);
     
       // Calculate the "load" -- Lagrange multiplier acts as traction to
       // to enforce required surface displacement and the
       // deformed position
       Vector<double> traction(n_dim);
       for (unsigned i=0;i<n_dim;i++)
        {
         traction[i]=-interpolated_lambda_p*interpolated_normal[i];
         x_def[i]=interpolated_x[i]+disp[i];
        }


       // Accumulate contribution to total contact force
       for(unsigned i=0;i<n_dim;i++)
        {
         contact_force[i]+=traction[i]*W;
        }
     
       //=====LOAD TERMS  FROM PRINCIPLE OF VIRTUAL DISPLACEMENTS========
       
       //Loop over the test functions, nodes of the element
       for(unsigned l=0;l<n_node;l++)
        {
         //Loop over the displacement components
         for(unsigned i=0;i<n_dim;i++)
          {
           local_eqn = this->nodal_local_eqn(l,i);
           /*IF it's not a boundary condition*/
           if(local_eqn >= 0)
            {
             //Add the loading terms to the residuals
             local_residuals[local_eqn] -= traction[i]*psi(l)*W;
            } //End of if not boundary condition
          }
        } //End of loop over shape functions
       
       //=====CONTRIBUTION TO CONTACT PRESSURE/LAGRANGE MULTIPLIER EQNS ========

       // Get local penetration
       double d=penetration(x_def,interpolated_normal);
       
       //Loop over the nodes
       for(unsigned l=0;l<n_node;l++)
        {
         // Contribution to integrated pressure
         pressure_integral[l]+=interpolated_lambda_p*psi_p[l]*W;
         
         // Contribution to weighted penetration integral
         penetration_integral[l]+=d*psi_p[l]*W;
        }

      } //End of loop over integration points


     // Collocation for contact pressure/Lagrange multiplier:
     //------------------------------------------------------
   
     // Storage for nodal coordinate
     Vector<double> x(n_dim);
     
     //Loop over the nodes
     for(unsigned l=0;l<n_node;l++)
      {
       // get the node pt
       Node* nod_pt = node_pt(l);
       
       // Cast to a boundary node
       BoundaryNodeBase *bnod_pt =
        dynamic_cast<BoundaryNodeBase*>(nod_pt);
       
       // Get the index of the first nodal value associated with
       // this FaceElement
       unsigned first_index=
        bnod_pt->index_of_first_value_assigned_by_face_element(Contact_id);
       
       // Equation for Lagrange multiplier
       local_eqn = nodal_local_eqn(l,first_index);
       
       /*IF it's not a boundary condition*/
       if(local_eqn >= 0)
        {
         // Enforcement by collocation
         bool do_collocation=false;
         if (do_collocation)
          {
           // Nodal position
           x[0]=nod_pt->x(0);
           x[1]=nod_pt->x(1);
           
           // Get outer unit normal
           Vector<double> s(1);
           local_coordinate_of_node(l,s);
           Vector<double> unit_normal(2);
           outer_unit_normal(s,unit_normal);

           // Displacement
           Vector<double> disp(2);
           this->interpolated_u_linear_elasticity(s,disp);

           // Deformed position
           Vector<double> x_def(2);
           x_def[0]=x[0]+disp[0];
           x_def[1]=x[1]+disp[1];

           // Get penetration
           double d=penetration(x_def,unit_normal);
           
           // Get value of contact pressure
           double contact_pressure=nod_pt->value(first_index);
           
           // Contact/non-penetration residual
           if (Enable_stick)
            {
             // Enforce contact
             local_residuals[local_eqn]-=d;
            }
           else
            {
             // Piecewise linear variation for non-penetration constraint
             if (-d>contact_pressure)
              {
               local_residuals[local_eqn]+=contact_pressure;
              }
             else
              {
               local_residuals[local_eqn]-=d;
              }
            }
          }
         // Weighted penetration constraint
         else
          {
           // Use weighted/integrated quantities
           double d=penetration_integral[l];
           double contact_pressure=pressure_integral[l];

           // Contact/non-penetration residual
           if (Enable_stick)
            {
             // Enforce contact
             local_residuals[local_eqn]-=d;
            }
           else
            {
             // Piecewise linear variation for non-penetration constraint
             if (-d>contact_pressure)
              {
               local_residuals[local_eqn]+=contact_pressure;
              }
             else
              {
               local_residuals[local_eqn]-=d;
              }
            }
          }
        }
      }
    }

   // Now deal with the penetrator equilibrium equations (if any!)
   unsigned n=Penetrator_eq_data_type.size();
   for (unsigned i=0;i<n;i++)
    {
     if (Penetrator_eq_data_type[i]>=0)
      {
       switch(unsigned(Penetrator_eq_data_type[i]))
        {
         
        case External_data:
        {
         int local_eqn=external_local_eqn(
          Penetrator_eq_data_data_index[i],
          Penetrator_eq_data_index[i]);
         if (local_eqn>=0)
          {
           local_residuals[local_eqn]=contact_force[i];
          }
        }
        break;
        
        case Nodal_position_data:
        {
         // position type (dummy -- hierher paranoid check)
         unsigned k=0;
         int local_eqn=position_local_eqn(
          Penetrator_eq_data_data_index[i],k,
          Penetrator_eq_data_index[i]);
         if (local_eqn>=0)
          {
           local_residuals[local_eqn]=contact_force[i];
          }
        }
        break;
        
        
        case Nodal_data:
        {
         int local_eqn=nodal_local_eqn(
          Penetrator_eq_data_data_index[i],
          Penetrator_eq_data_index[i]);
         if (local_eqn>=0)
          {
           local_residuals[local_eqn]+=contact_force[i];
          }
        }
        break;
        
        default:


         std::stringstream junk;
         junk << "Never get here: "
              << "unsigned(Penetrator_eq_data_type[i]) = "
              << unsigned(Penetrator_eq_data_type[i]);
          throw OomphLibError(
          junk.str(),
          OOMPH_CURRENT_FUNCTION,
          OOMPH_EXCEPTION_LOCATION);

        }
      }  
    }

   // Now add local contribution to existing entries
   for (unsigned j=0;j<n_dof;j++)
    {
     residuals[j]+=local_residuals[j];
    }

  }


 
 
//=====================================================================
/// Resulting contact force
//=====================================================================
 template<class ELEMENT>
  void LinearElasticitySurfaceContactElement<ELEMENT>::resulting_contact_force(
   Vector<double> &contact_force)
  {
   //Find out how many nodes there are
   unsigned n_node = nnode();
   
   //Find out the dimension of the node
   unsigned n_dim = this->nodal_dimension();

   // Initialise
   for (unsigned i=0;i<n_dim;i++)
    {
     contact_force[i]=0.0;
    }

   //Set up memory for the shape functions
   Shape psi(n_node);
   DShape dpsids(n_node,n_dim-1);
   
   // Separate shape functions for Lagrange multiplier
   Shape psi_p(n_node);
   Vector<double> s(n_dim-1);
   
   //Set the value of n_intpt
   unsigned n_intpt = integral_pt()->nweight();
   
   //Loop over the integration points
   for(unsigned ipt=0;ipt<n_intpt;ipt++)
    {
     //Get the integral weight
     double w = integral_pt()->weight(ipt);
     
     //Only need to call the local derivatives
     dshape_local_at_knot(ipt,psi,dpsids);
     
     // Separate shape function for Lagrange multiplier
     for(unsigned i=0;i<n_dim-1;i++)
      {
       s[i] = integral_pt()->knot(ipt,i);
      }
     shape_p(s,psi_p);
     
     // Interpolated Lagrange multiplier (pressure acting on solid
     // to enforce melting)
     double interpolated_lambda_p=0.0;
     
     //Calculate the coordinates
     Vector<double> interpolated_x(n_dim,0.0);
     
     // Displacement
     Vector<double> disp(n_dim,0.0);
     
     //Also calculate the surface Vectors (derivatives wrt local coordinates)
     DenseMatrix<double> interpolated_A(n_dim-1,n_dim,0.0);
     
     //Calculate displacements and derivatives
     for(unsigned l=0;l<n_node;l++)
      {
       // Cast to a boundary node
       BoundaryNodeBase *bnod_pt =
        dynamic_cast<BoundaryNodeBase*>(node_pt(l));
       
       // Get the index of the nodal value associated with
       // this FaceElement
       unsigned first_index=
        bnod_pt->index_of_first_value_assigned_by_face_element(Contact_id);
       
       // Add to Lagrange multiplier (acting as pressure on solid
       // to enforce motion to ensure non-penetration)
       interpolated_lambda_p+=node_pt(l)->value(first_index)*psi_p[l];
       
       //Loop over displacement components
       for(unsigned i=0;i<n_dim;i++)
        {
         //Calculate the positions
         interpolated_x[i] += nodal_position(l,i)*psi(l);
         
         //Index at which the displacement nodal value is stored
         unsigned u_nodal_index=this->U_index_linear_elasticity_traction[i];
         disp[i] += nodal_value(l,u_nodal_index)*psi(l);
         
         //Loop over LOCAL derivative directions, to calculate the tangent(s)
         for(unsigned j=0;j<n_dim-1;j++)
          {
           interpolated_A(j,i) += nodal_position(l,i)*dpsids(l,j);
          }
        }
      }
     
     
     //Now find the local deformed metric tensor from the tangent Vectors
     DenseMatrix<double> A(n_dim-1);
     for(unsigned i=0;i<n_dim-1;i++)
      {
       for(unsigned j=0;j<n_dim-1;j++)
        {
         //Initialise surface metric tensor to zero
         A(i,j) = 0.0;
         //Take the dot product
         for(unsigned k=0;k<n_dim;k++)
          {
           A(i,j) += interpolated_A(i,k)*interpolated_A(j,k);
          }
        }
      }
     
     //Get the outer unit normal
     Vector<double> interpolated_normal(n_dim);
     outer_unit_normal(ipt,interpolated_normal);
     
     //Find the determinant of the metric tensor
     double Adet =0.0;
     switch(n_dim)
      {
      case 2:
       Adet = A(0,0);
       break;
      case 3:
       Adet = A(0,0)*A(1,1) - A(0,1)*A(1,0);
       break;
      default:
       throw OomphLibError(
        "Wrong dimension in SurfaceContactElement",
        "SurfaceContactElement::contact_force()",
        OOMPH_EXCEPTION_LOCATION);
      }
     
     //Premultiply the weights and the square-root of the determinant of
     //the metric tensor
     double W = w*sqrt(Adet);
     
     // Calculate the "load" -- Lagrange multiplier acts as traction to
     // to enforce required surface displacement
     Vector<double> traction(n_dim);
     for (unsigned i=0;i<n_dim;i++)
      {
       traction[i]=-interpolated_lambda_p*interpolated_normal[i];
      }
     
     // Add to resulting force
     for (unsigned i=0;i<n_dim;i++)
      {
       contact_force[i]+=traction[i]*W;
      }
    }
 
  }



////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////


}


#endif
