//LIC// ====================================================================
//LIC// This file forms part of oomph-lib, the object-oriented, 
//LIC// multi-physics finite-element library, available 
//LIC// at http://www.oomph-lib.org.
//LIC// 
//LIC//           Version 0.90. August 3, 2009.
//LIC// 
//LIC// Copyright (C) 2006-2009 Matthias Heil and Andrew Hazel
//LIC// 
//LIC// This library is free software; you can redistribute it and/or
//LIC// modify it under the terms of the GNU Lesser General Public
//LIC// License as published by the Free Software Foundation; either
//LIC// version 2.1 of the License, or (at your option) any later version.
//LIC// 
//LIC// This library is distributed in the hope that it will be useful,
//LIC// but WITHOUT ANY WARRANTY; without even the implied warranty of
//LIC// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//LIC// Lesser General Public License for more details.
//LIC// 
//LIC// You should have received a copy of the GNU Lesser General Public
//LIC// License along with this library; if not, write to the Free Software
//LIC// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
//LIC// 02110-1301  USA.
//LIC// 
//LIC// The authors may be contacted at oomph-lib@maths.man.ac.uk.
//LIC// 
//LIC//====================================================================
// Header file for elements that are used to apply Sommerfeld
// boundary conditions to the Helmholtz equations
#ifndef OOMPH_HELMHOLTZ_BC_ELEMENTS_HEADER
#define OOMPH_HELMHOLTZ_BC_ELEMENTS_HEADER


// Config header generated by autoconfig
#ifdef HAVE_CONFIG_H
  #include <oomph-lib-config.h>
#endif


#include "math.h"
#include <complex>

// Get the Bessel functions
#include "oomph_crbond_bessel.h"

// oomph-lib ncludes
// hierher re-enable #include "../generic/Qelements.h"



namespace oomph
{



///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
// Collection of the  Bessel functions used in the Helmholtz problem 
///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////

//====================================================================
/// Namespace to provide Hankel function of the first kind
/// and various orders -- needed for Helmholtz computations.
//====================================================================
namespace Hankel_functions_for_Helmholtz_problem
{
 /// define I for complex
 std::complex<double> I(0.0,1.0);
 
//====================================================================
/// Compute Hankel function of the first kind of order n and 
/// its derivates  at coordinate x.The function returns the vector 
/// then its derivate 
//====================================================================
 void Hankel_first(const int& n,const double& x,
                   Vector< complex<double> >& h, 
                   Vector< complex<double> >& hp)
 {
  // n is the lenght of the vector returned, nm the higher 
  // order computed 
  int  nm = n;
  Vector<double> jn_r(n),yn_r(n),jnp_r(n), ynp_r(n);
  CRBond_Bessel::bessjyna(n,x,nm,&jn_r[0],&yn_r[0],
                          &jnp_r[0],&ynp_r[0]);
  for (unsigned i=0;i<unsigned(n);i++)
   {
    h[i] =(jn_r[i]+(I*yn_r[i]));
    hp[i]=(jnp_r[i]+(I*ynp_r[i]));
   }
 }
 
} //End of namespace



/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////


//======================================================================
/// \short A class for elements that allow the appoxiamtion of the 
/// Summerfeld BC.
/// The element geometry is obtained from the  FaceGeometry<ELEMENT> 
/// policy class.
//======================================================================
template <class ELEMENT>
 class HelmholtzBCElementBase : public virtual FaceGeometry<ELEMENT>, 
 public virtual FaceElement
 {
   public:
  
  /// \short Constructor, takes the pointer to the "bulk" element and the 
  /// index of the face to which the element is attached.
  HelmholtzBCElementBase(FiniteElement* const &bulk_el_pt, 
                         const int& face_index); 
  
  ///\short  Broken empty constructor
  HelmholtzBCElementBase()
   {
    throw OomphLibError(
     "Don't call empty constructor for HelmholtzBCElementBase",
     "HelmholtzBCElementBase::HelmholtzBCElementBase()",
     OOMPH_EXCEPTION_LOCATION);
   }
  
  /// Broken copy constructor
  HelmholtzBCElementBase(const HelmholtzBCElementBase& dummy) 
   { 
    BrokenCopy::broken_copy("HelmholtzBCElementBase");
   } 
  
  /// Broken assignment operator
  void operator=(const HelmholtzBCElementBase&) 
   {
    BrokenCopy::broken_assign("HelmholtzBCElementBase");
   }
  
  /// Pointer to square of wavenumber 
  double*& k_squared_pt()
   { 
    return K_squared_pt;
   }
  
  /// Output function -- forward to broken version in FiniteElement
  /// until somebody decides what exactly they want to plot here...
  void output(std::ostream &outfile) {FiniteElement::output(outfile);}
  
  /// \short Output function -- forward to broken version in FiniteElement
  /// until somebody decides what exactly they want to plot here...
  void output(std::ostream &outfile, const unsigned &n_plot)
  {FiniteElement::output(outfile,n_plot);}
  
  /// C-style output function -- forward to broken version in FiniteElement
  /// until somebody decides what exactly they want to plot here...
  void output(FILE* file_pt) {FiniteElement::output(file_pt);}
  
  /// \short C-style output function -- forward to broken version in 
  /// FiniteElement until somebody decides what exactly they want to plot 
  /// here...
  void output(FILE* file_pt, const unsigned &n_plot)
  {FiniteElement::output(file_pt,n_plot);}

  /// \short Return the index at which the unknown value
  /// is stored.
 virtual inline std::complex<unsigned> u_index_helmholtz() const 
 {return std::complex<unsigned>(U_index_helmholtz.real(),U_index_helmholtz.imag());}
 
 /// \short Return he spatial dimension of the problem
 virtual inline unsigned dim() const 
 {return Dim;}
 
   protected:
 
 /// \short Function to compute the shape and test functions and to return 
 /// the Jacobian of mapping between local and global (Eulerian)
 /// coordinates
 inline double test_only(const Vector<double> &s, Shape &test)
  const
  {
   //Get the shape functions
   shape(s,test);
   
   //Return the value of the jacobian
   return J_eulerian(s);
  }

 /// \short Function to compute the shape, test functions and derivates 
 /// and to return
 /// the Jacobian of mapping between local and global (Eulerian)
 /// coordinates
 inline double d_shape_and_test_local(const Vector<double> &s, Shape &psi, 
                                      Shape &test,
                                      DShape &dpsi_ds,DShape &dtest_ds)
  const
  {
   //Find number of nodes
   unsigned n_node = nnode();
   
   //Get the shape functions
   dshape_local(s,psi,dpsi_ds);

   //Set the test functions to be the same as the shape functions
   for(unsigned i=0;i<n_node;i++) 
    for(unsigned j=0;j<(Dim-1);j++) 
     {
      {
       test[i] = psi[i];
       dtest_ds(i,j)= dpsi_ds(i,j);
      }
     }
   //Return the value of the jacobian
   return J_eulerian(s);
  }
 
 /// \Short The index at which the real and imag part of the unknown is stored 
 /// at the nodes
 std::complex<unsigned> U_index_helmholtz;
 
 ///The spatial dimension of the problem
 unsigned Dim;
 
 /// Pointer to square of wavenumber
 double* K_squared_pt;
 
 
 }; 

//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////


///===================================================
/// Mesh for Helmholtz outer boundary flux element
/// The mesh contains all the informations needed to
/// compute the exact Summerfeld BC
///====================================================
template<class ELEMENT>
class HelmholtzOuterBoundaryMesh : public virtual Mesh
{
  public:
 
 /// Constructor: Specify radius of outer boundary
 HelmholtzOuterBoundaryMesh(const double& outer_radius, 
                            const unsigned nfourier) : 
  Outer_radius(outer_radius), Nfourier(nfourier)
  {}
  
  /// hierher: In PARANOID setting check that the nodal points
  /// all have the required "outer_radius" (within tolerance)
  /// if not throw OOMPH_LIB error
  void check_the_outer_radius ()
  {
   //define the tolerance 
   double eps=pow(10.0,-5);
   //first loop over elements e
   unsigned nel=this->nelement();
   for (unsigned e=0;e<nel;e++)
    {
     // set a pointer to each element   
     HelmholtzBCElementBase<ELEMENT>* el_pt=
      dynamic_cast<HelmholtzBCElementBase<ELEMENT>*>
      (this->element_pt(e));    
     // loop over the nodes
     unsigned n_node=el_pt->nnode();
     for (unsigned n=0;n<n_node;n++)
      {
       // Get pointer to node
       Node* nod_pt=el_pt->node_pt(n);  
       
       // Extract nodal coordinates from node:
       Vector<double> x(2);
       x[0]=nod_pt->x(0);
       x[1]=nod_pt->x(1);
       
       // Evaluate the radial distance 
       double r=sqrt(x[0]*x[0]+x[1]*x[1]); 
       
       if(abs(r-Outer_radius) < eps)
        { throw OomphLibError(
           "There Helmholtz nodes is not atthe right radial distance ",
           " ScatteringProblem<ELEMENT>::ScatteringProblem()",
           OOMPH_EXCEPTION_LOCATION);
         break;
        }
      }
    }
  }
 
  /// \short Compute and store the gamma integral at all integration
  /// points of the constituent elements.
  void setup_gamma();
  
  /// \short Gamma integral evaluated at Gauss points 
  /// for specified element
  Vector<complex<double> >& gamma_at_gauss_point(FiniteElement* el_pt) 
   {                                          
    return Gamma_at_gauss_point[el_pt];
   }
  
  /// \short Derivate of Gamma integral evaluated 
  /// at Gauss points for specified element w.r.t global unknown
  Vector<std::map<unsigned,complex<double> > >
   &d_gamma_at_gauss_point(FiniteElement* el_pt) 
   {                                          
    return D_Gamma_at_gauss_point[el_pt];
   }
  
  /// \short The outer radius  
  double &outer_radius() 
   {                                          
    return Outer_radius ;
   }

/// \short Nbr of Fourier terms used in the  Gamma computation
  unsigned & nfourier () 
   {                                          
    return Nfourier ;
   }
  
  private:
  
  /// Outer radius
  double Outer_radius;
  
/// Nbr of Fourier terms used in the  Gamma computation
  unsigned Nfourier;
  
  
  /// \short Container to store the gamma integral for given Gauss point
  /// and element
  std::map<FiniteElement*,Vector<complex<double> > > Gamma_at_gauss_point;
  
  
  /// \short Container to store the derivate of Gamma integral evaluated 
  /// at Gauss points for specified element w.r.t global unknown
  std::map<FiniteElement*,Vector<std::map<unsigned,complex<double> > > > D_Gamma_at_gauss_point;
  
};


//=============================================================
// Flux element used in the Outer boundary mesh with Feng's
// approximate  BC
//==============================================================  
template<class ELEMENT>
 class HelmholtzAbsorbingBCElement : public  HelmholtzBCElementBase<ELEMENT>
{
 
  public:
 /// hierher:write something
 HelmholtzAbsorbingBCElement (FiniteElement* const &bulk_el_pt, 
                              const int& face_index) : 
  HelmholtzBCElementBase<ELEMENT>(bulk_el_pt,face_index)
  {
   // Initialise pointers
   Outer_radius_pt=0;
   
   // Initialise order of absorbing boundary condition
   ABC_order_pt=0;
  }
  
  /// Pointer to order of absorbing boundary condition
  unsigned*& abc_order_pt()
   {
    return ABC_order_pt;
   }
  
  
  /// Add the element's contribution to its residual vector
  inline void fill_in_contribution_to_residuals(Vector<double> &residuals)
   {
    //Call the generic residuals function with flag set to 0
    //using a dummy matrix argument
    fill_in_generic_residual_contribution_helmholtz_abc(
     residuals,GeneralisedElement::Dummy_matrix,0);
   }
  
  /// \short Add the element's contribution to its residual vector and its 
  /// Jacobian matrix
  inline void fill_in_contribution_to_jacobian(Vector<double> &residuals,
                                               DenseMatrix<double> &jacobian)
   {
    //Call the generic routine with the flag set to 1
    fill_in_generic_residual_contribution_helmholtz_abc(residuals,jacobian,1);
   }
  
  
  /// Get pointer to radius of outer boundary (must be a cirle)
  double*& outer_radius_pt()
   { 
    return Outer_radius_pt;
   }
  
  private:
  
/// \short Compute the element's residual vector and the (
/// Jacobian matrix.
/// Overloaded version, using the abc approximation
  void fill_in_generic_residual_contribution_helmholtz_abc(
   Vector<double> &residuals, DenseMatrix<double> &jacobian, 
   const unsigned& flag)
  {
   //Find out how many nodes there are
   const unsigned n_node = this->nnode();
   
   //Set up memory for the shape and test functions
   Shape psi(n_node), test(n_node);
   DShape dpsi_ds (n_node,this->Dim-1),
    dtest_ds(n_node,this->Dim-1),
    dtest_dS(n_node,this->Dim-1),
    dpsi_dS (n_node,this->Dim-1);
   
   //Set the value of Nintpt
   const unsigned n_intpt = this->integral_pt()->nweight();
   
   //Set the Vector to hold local coordinates
   Vector<double> s(this->Dim-1);
   
   //Integers to hold the local equation and unknown numbers
   int local_eqn_real=0,local_unknown_real=0;
   int local_eqn_imag=0,local_unknown_imag=0;   
   
   // Define the problem parameters
   double R=*Outer_radius_pt;
   double k=sqrt(*(this->K_squared_pt));
   
   //Loop over the integration points
   //--------------------------------
   for(unsigned ipt=0;ipt<n_intpt;ipt++)
    {
     //Assign values of s
     for(unsigned i=0;i<(this->Dim-1);i++)
      {
       s[i] = this->integral_pt()->knot(ipt,i);
      }
     
     //Get the integral weight
     double w = this->integral_pt()->weight(ipt);
     
     //Find the shape test functions and derivates; return the Jacobian
     //of the mapping between local and global (Eulerian)
     // coordinates
     double J = this->d_shape_and_test_local(s,psi,test,dpsi_ds,dtest_ds);
     
     //Premultiply the weights and the Jacobian
     double W = w*J;
     // get the inverse of jacibian
     double inv_J=1/J;     
     

     //Need to find position to feed into flux function, 
     //initialise to zero
     complex<double> interpolated_u(0.0,0.0);
     complex<double> du_dS(0.0,0.0);
     
     //Calculate velocities and derivatives:loop over the nodes
     for(unsigned l=0;l<n_node;l++) 
      {    
       // Loop over real and imag part
       //Get the nodal value of the helmholtz unknown
       double u_value_real = this->raw_nodal_value(
        l,this->U_index_helmholtz.real());
       double u_value_imag = this->raw_nodal_value(
        l,this->U_index_helmholtz.imag());
       
       interpolated_u.real() += u_value_real*psi[l];
       interpolated_u.imag() += u_value_imag*psi[l];
       
       du_dS.real() += u_value_real*dpsi_ds(l,0)*inv_J;   
       du_dS.imag() += u_value_imag*dpsi_ds(l,0)*inv_J;    
       
       // Get the value of dtest_dS
       dtest_dS(l,0)=dtest_ds(l,0)*inv_J;
       // Get the value of dpsif_dS
       dpsi_dS(l,0)=dpsi_ds(l,0)*inv_J;
      }
     
     // use ABC first order approximation
     if (*ABC_order_pt==1)
      {
       //Loop over the test functions
       for(unsigned l=0;l<n_node;l++)
        {
         local_eqn_real = this->nodal_local_eqn
          (l,this->U_index_helmholtz.real());
         local_eqn_imag = this->nodal_local_eqn
          (l,this->U_index_helmholtz.imag());
         
         // first, calculate the contrubution of the real part
         //-----------------------       
         //IF it's not a boundary condition
         if(local_eqn_real >= 0)
          {   
           //Add the first order terms to the residuals
           
           residuals[local_eqn_real] +=
            (k*interpolated_u.imag()+(0.5/R)
             *interpolated_u.real())*test[l]*W;
           
           // Calculate the jacobian
           //-----------------------
           if(flag)
            {
             //Loop over the velocity shape functions again
             for(unsigned l2=0;l2<n_node;l2++)
              {
               local_unknown_real = this->nodal_local_eqn(
                l2,this->U_index_helmholtz.real());
               local_unknown_imag = this->nodal_local_eqn(
                l2,this->U_index_helmholtz.imag());
               
               //If at a non-zero degree of freedom add in the entry
               if(local_unknown_real >= 0)
                {
                 // Add the first order terms contribution
                 jacobian(local_eqn_real,local_unknown_real)
                  +=(0.5/R)*psi[l2]*test[l]*W;
                }
               if(local_unknown_imag >= 0)
                {      
                 // Add the first order terms contribution
                 jacobian(local_eqn_real,local_unknown_imag)
                  +=k*psi[l2]*test[l]*W;
                }       
              }//End of loop over the nodes l2
            } // End of flag
          }  // End of loop over local_eqn_real 
         
         
         // second, calculate the contrubution of the imag part
         //-----------------------       
         //IF it's not a boundary condition
         if(local_eqn_imag >= 0)
          {   
           //Add the first order terms to the residuals   
           residuals[local_eqn_imag] +=
            (-k*interpolated_u.real()+(0.5/R)
             *interpolated_u.imag())*test[l]*W;
           
           // Calculate the jacobian
           //-----------------------
           if(flag)
            {
             //Loop over the velocity shape functions again
             for(unsigned l2=0;l2<n_node;l2++)
              {
               local_unknown_real = this->nodal_local_eqn(
                l2,this->U_index_helmholtz.real());
               local_unknown_imag = this->nodal_local_eqn(
                l2,this->U_index_helmholtz.imag());
               //If at a non-zero degree of freedom add in the entry
               if(local_unknown_real >= 0)
                {
                 // Add the first order terms contribution
                 jacobian(local_eqn_imag,local_unknown_real)
                  +=(-k)*psi[l2]*test[l]*W;
                }
               if(local_unknown_imag >= 0)
                {                      
                 // Add the first order terms contribution
                 jacobian(local_eqn_imag,local_unknown_real)
                  +=(0.5/R)*psi[l2]*test[l]*W; 
                }
              } //End of loop over the nodes l2
            } // End of flag
          } // End of loop over local_eqn_imag
        } //End of loop over the nodes
      }  
     
     //:use second order approximation
     if(*ABC_order_pt==2) 
      {
       //Now add to the appropriate equations:use second order approximation
       //Loop over the test functions
       for(unsigned l=0;l<n_node;l++)
        {
         local_eqn_real = this->nodal_local_eqn
          (l,this->U_index_helmholtz.real());
         local_eqn_imag = this->nodal_local_eqn
          (l,this->U_index_helmholtz.imag());
         
         // first, calculate the real part contrubution 
         //-----------------------    
         //IF it's not a boundary condition
         if(local_eqn_real >= 0)
          {
           //Add the second order terms:compute manually real and imag part
           
           residuals[local_eqn_real] +=
            (k*interpolated_u.imag()+(0.5/R)
             *interpolated_u.real())*test[l]*W
            + ((0.125/(k*R*R))*interpolated_u.imag())*test[l]*W;
           
           residuals[local_eqn_real] +=
            (-0.5/k)*du_dS.imag()*dtest_dS(l,0)*W;
           
           // Calculate the jacobian
           //-----------------------
           if(flag)
            {
             //Loop over the velocity shape functions again
             for(unsigned l2=0;l2<n_node;l2++)
              {     
               local_unknown_real = this->nodal_local_eqn(
                l2,this->U_index_helmholtz.real());
               local_unknown_imag = this->nodal_local_eqn(
                l2,this->U_index_helmholtz.imag());
               //If at a non-zero degree of freedom add in the entry
               if(local_unknown_real >= 0)
                {
                 jacobian(local_eqn_real,local_unknown_real)
                  +=(0.5/R)*psi[l2]*test[l]*W;  
                }
               
               //If at a non-zero degree of freedom add in the entry
               if(local_unknown_imag >= 0)
                {
                 jacobian(local_eqn_real,local_unknown_imag)
                  +=           k   *psi[l2]*test[l]*W
                  +  (0.125/(k*R*R))*psi[l2]*test[l]*W;
                 
                 jacobian(local_eqn_real,local_unknown_imag)
                  +=(-0.5/k)*dpsi_dS(l2,0)*dtest_dS(l,0)*W; 
                }  
              }
            }
          }// end of local_eqn_real
         
         // second, calculate the imag part contrubution 
         //-----------------------  
         //IF it's not a boundary condition
         if(local_eqn_imag >= 0)
          {
           //Add the second order terms contibution to the residual                   
           residuals[local_eqn_imag] +=
            (-k*interpolated_u.real()+(0.5/R)
             *interpolated_u.imag())*test[l]*W
            + ((-0.125/(k*R*R))*interpolated_u.real())*test[l]*W;
           
           residuals[local_eqn_imag] +=
            (0.5/k)*du_dS.real()*dtest_dS(l,0)*W;
           
           // Calculate the jacobian
           //-----------------------
           if(flag)
            {
             //Loop over the velocity shape functions again
             for(unsigned l2=0;l2<n_node;l2++)
              {     
               local_unknown_real = this->nodal_local_eqn(
                l2,this->U_index_helmholtz.real());
               local_unknown_imag = this->nodal_local_eqn(
                l2,this->U_index_helmholtz.imag());
               //If at a non-zero degree of freedom add in the entry
               if(local_unknown_real >= 0)
                {
                 jacobian(local_eqn_imag,local_unknown_real)
                  +=    (-k)     *psi[l2]*test[l]*W
                  -(0.125/(k*R*R))*psi[l2]*test[l]*W;
                 
                 jacobian(local_eqn_imag,local_unknown_real)
                  +=(0.5/k)*dpsi_dS(l2,0)*dtest_dS(l,0)*W;
                }     
               
               //If at a non-zero degree of freedom add in the entry
               if(local_unknown_imag >= 0)
                {
                 jacobian(local_eqn_imag,local_unknown_imag)
                  +=(0.5/R)*psi[l2]*test[l]*W; 
                }   
              }
            }
          }
        }// End of loop over the nodes   
      } 
     
     if(*ABC_order_pt==3)
      {
       //Now add to the appropriate equations:use second order approximation
       //Loop over the test functions
       for(unsigned l=0;l<n_node;l++)
        {
         local_eqn_real = this->nodal_local_eqn
          (l,this->U_index_helmholtz.real());
         local_eqn_imag = this->nodal_local_eqn
          (l,this->U_index_helmholtz.imag());
         
         // first, calculate the real part contrubution 
         //-----------------------    
         //IF it's not a boundary condition
         if(local_eqn_real >= 0)
          {
           //Add the second order terms:compute manually real and imag part
           residuals[local_eqn_real] +=
            ((k*(1+0.125/(k*k*R*R)))*interpolated_u.imag()
             +(0.5/R-0.125/(k*k*R*R*R))*interpolated_u.real())
            *test[l]*W;
           
           residuals[local_eqn_real] +=
            ((-0.5/k)*du_dS.imag()+(0.5/(k*k*R))*du_dS.real()) 
            *dtest_dS(l,0)*W;
           
           // Calculate the jacobian
           //-----------------------
           if(flag)
            {
             //Loop over the velocity shape functions again
             for(unsigned l2=0;l2<n_node;l2++)
              {     
               local_unknown_real = this->nodal_local_eqn(
                l2,this->U_index_helmholtz.real());
               local_unknown_imag = this->nodal_local_eqn(
                l2,this->U_index_helmholtz.imag());
               //If at a non-zero degree of freedom add in the entry
               if(local_unknown_real >= 0)
                {
                 jacobian(local_eqn_real,local_unknown_real)
                  +=(0.5/R-0.125/(k*k*R*R*R))*psi[l2]*test[l]*W;
                 
                 jacobian(local_eqn_real,local_unknown_real)
                  +=(0.5/(k*k*R))*dpsi_dS(l2,0)*dtest_dS(l,0)*W; 
                }
               
               //If at a non-zero degree of freedom add in the entry
               if(local_unknown_imag >= 0)
                {
                 jacobian(local_eqn_real,local_unknown_imag)
                  +=(k*(1+0.125/(k*k*R*R)))*psi[l2]*test[l]*W;
                 
                 jacobian(local_eqn_real,local_unknown_imag)
                  +=(-0.5/k)*dpsi_dS(l2,0)*dtest_dS(l,0)*W;
                }  
              }
            }
          }// end of local_eqn_real
         
         // second, calculate the imag part contrubution 
         //-----------------------  
         //IF it's not a boundary condition
         if(local_eqn_imag >= 0)
          {
           //Add the second order terms contibution to the residual                   
           residuals[local_eqn_imag] +=
            ((-k*(1+0.125/(k*k*R*R)))*interpolated_u.real()
             +(0.5/R-0.125/(k*k*R*R*R))*interpolated_u.imag())
            *test[l]*W;
           
           residuals[local_eqn_imag] +=
            ((0.5/k)*du_dS.real()+(0.5/(k*k*R))*du_dS.imag())
            *dtest_dS(l,0)*W;
           
           // Calculate the jacobian
           //-----------------------
           if(flag)
            {
             //Loop over the velocity shape functions again
             for(unsigned l2=0;l2<n_node;l2++)
              {     
               local_unknown_real = this->nodal_local_eqn(
                l2,this->U_index_helmholtz.real());
               local_unknown_imag = this->nodal_local_eqn(
                l2,this->U_index_helmholtz.imag());
               //If at a non-zero degree of freedom add in the entry
               if(local_unknown_real >= 0)
                {
                 jacobian(local_eqn_imag,local_unknown_real)
                  +=(-k*(1+0.125/(k*k*R*R)))*psi[l2]*test[l]*W;
                 
                 jacobian(local_eqn_imag,local_unknown_real)
                  +=(0.5/k)*dpsi_dS(l2,0)*dtest_dS(l,0)*W;
                }
               //If at a non-zero degree of freedom add in the entry
               if(local_unknown_imag >= 0)
                {
                 jacobian(local_eqn_imag,local_unknown_imag)
                  +=(0.5/R-0.125/(k*k*R*R*R))*psi[l2]*test[l]*W;
                 
                 jacobian(local_eqn_imag,local_unknown_imag)
                  +=(0.5/(k*k*R))*dpsi_dS(l2,0)*dtest_dS(l,0)*W;
                }   
              }
            }
          }
        }// End of loop over the nodes   
      }
    } //End of loop over int_pt
   
  } // End of fill_in_generic_residual_contribution_helmholtz_flux
  
  private:
  
  /// Pointer to radius of outer boundary (must be a circle!)
  double* Outer_radius_pt;
   
  /// Pointer to order of absorbing boundary condition
  unsigned* ABC_order_pt;
  
};

//=============================================================
//  Flux element used in the Outer boundary mesh with the
// Dirichlet to Neumann (DtN)  BC   
//==============================================================  
template<class ELEMENT>
 class HelmholtzDtNBoundaryElement : public  HelmholtzBCElementBase<ELEMENT>
{
 
  public:
 /// hierhier:write something
 HelmholtzDtNBoundaryElement(FiniteElement* const &bulk_el_pt, 
                             const int& face_index) : 
  HelmholtzBCElementBase<ELEMENT>(bulk_el_pt,face_index)
  {}
  
  /// Add the element's contribution to its residual vector
  inline void fill_in_contribution_to_residuals(Vector<double> &residuals)
   {
    //Call the generic residuals function with flag set to 0
    //using a dummy matrix argument
    fill_in_generic_residual_contribution_helmholtz_DtN_bc
     (residuals,GeneralisedElement::Dummy_matrix,0);
   }
  
  /// \short Add the element's contribution to its residual vector and its 
  /// Jacobian matrix
  inline void fill_in_contribution_to_jacobian(Vector<double> &residuals,
                                               DenseMatrix<double> &jacobian)
   {
    //Call the generic routine with the flag set to 1
    fill_in_generic_residual_contribution_helmholtz_DtN_bc
     (residuals,jacobian,1);
   }
  
  /// \short compute the contribution of the element 
  /// to the Gamma and its derivates w.r.t 
  /// to global unknows; the function takes n et phi 
  /// as Input  
  void compute_gamma_contribution(const double& phi,const int& n, 
                                  complex<double>& gamma_con,
                                  std::map<unsigned,complex<double> >& 
                                  d_gamma_con);
  
  /// \short Access function to mesh of all boundary condition elements
  /// (needed to get access to gamma values)
  HelmholtzOuterBoundaryMesh<ELEMENT>* outer_boundary_mesh_pt() const
   {
    return Outer_boundary_mesh_pt;
   }
  
  /// \short Set  mesh of all boundary condition elements
  void set_outer_boundary_mesh_pt
   (HelmholtzOuterBoundaryMesh<ELEMENT>* mesh_pt)
  {
   Outer_boundary_mesh_pt=mesh_pt;
   
   // Create a set of nodes
   std::set<Node*> node_set;
   unsigned nel=mesh_pt->nelement();
   for (unsigned e=0;e<nel;e++)
    {
     FiniteElement* el_pt=mesh_pt->finite_element_pt(e);
     unsigned nnod=el_pt->nnode();
     for (unsigned j=0;j<nnod;j++)
      {
       Node* nod_pt=el_pt->node_pt(j);
       //if (!(nod_pt->is_a_copy()))
       {
        node_set.insert(nod_pt);
       }
/*        else */
/*         { */
/*          cout << "node is copy\n"; */
/*         } */
      }
    }
   
   cout << "Set of all nodes: " << node_set.size() << std::endl;
   
   // Now erase the current element's own nodes
   unsigned nnod=this->nnode();
   for (unsigned j=0;j<nnod;j++)
    {
     node_set.erase(this->node_pt(j)); // hierher
     // If the node is periodic erase its
     // copied_node_pt too 
    }
   
   cout << "Set of all nodes: [2]  " << node_set.size() << std::endl;
   
   // Now declare these nodes to be the element's external Data
   for (std::set<Node*>::iterator it=node_set.begin();
        it!=node_set.end();it++)
    {
     if (!((*it)->is_a_copy()))
      {
       this->add_external_data(*it);
      }
    }
   
   cout << "Number of external data: " << this->nexternal_data() 
        << std::endl;
  }
  
  private:
  
/// \short Compute the element's residual vector  
/// Jacobian matrix.
/// Overloaded version, using the gamma computed in the mesh
  void fill_in_generic_residual_contribution_helmholtz_DtN_bc
   (Vector<double> &residuals, DenseMatrix<double> &jacobian, 
    const unsigned& flag)
  {
   //Find out how many nodes there are
   const unsigned n_node = this->nnode();
   
   //Set up memory for the shape and test functions
   Shape test(n_node);
   
   //Set the value of Nintpt
   const unsigned n_intpt = this->integral_pt()->nweight();
   
   //Set the Vector to hold local coordinates
   Vector<double> s(this->Dim-1);
   
   //Integers to hold the local equation and unknown numbers
   int local_eqn_real=0,local_unknown_real=0,global_eqn_real=0,
    local_eqn_imag=0,local_unknown_imag=0,global_eqn_imag=0;
   int external_global_eqn_real=0, external_unknown_real=0,
    external_global_eqn_imag=0, external_unknown_imag=0;
   
   
   // Get the gamma value for the current integration point
   // from the mesh
   Vector<std::complex<double> > 
    gamma(Outer_boundary_mesh_pt->gamma_at_gauss_point(this));
   
   Vector<std::map<unsigned,complex<double> > >
    d_gamma(Outer_boundary_mesh_pt->d_gamma_at_gauss_point(this));
   
   //Loop over the integration points
   //--------------------------------
   for(unsigned ipt=0;ipt<n_intpt;ipt++)
    {
     //Assign values of s
     for(unsigned i=0;i<(this->Dim-1);i++)
      {
       s[i] = this->integral_pt()->knot(ipt,i);
      }
     
     //Get the integral weight
     double w = this->integral_pt()->weight(ipt);
     
     //Find the shape test functions and derivates; return the Jacobian
     //of the mapping between local and global (Eulerian)
     // coordinates
     double J = this->test_only(s,test);
     //Premultiply the weights and the Jacobian
     double W = w*J;
     
     //Now add to the appropriate equations
     //Loop over the test functions:loop over the nodes
     for(unsigned l=0;l<n_node;l++)
      {
       local_eqn_real = this->nodal_local_eqn
        (l,this->U_index_helmholtz.real());
       local_eqn_imag = this->nodal_local_eqn
        (l,this->U_index_helmholtz.imag());
       
       //IF it's not a boundary condition
       if(local_eqn_real >= 0)
        {
         //Add the gamma contribution in this int_point to the res
         residuals[local_eqn_real] -=gamma[ipt].real()*test[l]*W;
         
         // Calculate the jacobian
         //-----------------------
         if(flag)
          {
           //Loop over the velocity shape functions again
           for(unsigned l2=0;l2<n_node;l2++)
            { 
             // Add the contribution of the local data
             local_unknown_real = this->nodal_local_eqn(
              l2,this->U_index_helmholtz.real());
             global_eqn_real=this->eqn_number(local_unknown_real);
             
             local_unknown_imag = this->nodal_local_eqn(
              l2,this->U_index_helmholtz.imag());
             global_eqn_imag=this->eqn_number(local_unknown_imag);
             
             //If at a non-zero degree of freedom add in the entry
             if(local_unknown_real >= 0)
              {
               // Add the first order terms contribution
               jacobian(local_eqn_real,local_unknown_real)
                -=d_gamma[ipt][global_eqn_real].real()*test[l]*W; 
              }
             if(local_unknown_imag >= 0)
              {
               // Add the first order terms contribution
               jacobian(local_eqn_real,local_unknown_imag)
                -=d_gamma[ipt][global_eqn_imag].real()*test[l]*W; 
              }
            } // End of loop over nodes l2  
           
           // Add the contribution of the external data
           unsigned n_ext_data=this->nexternal_data();
           //Loop over the velocity shape functions again
           for(unsigned l2=0;l2<n_ext_data;l2++)
            { 
             // Add the contribution of the local data
             external_unknown_real = this->external_local_eqn(
              l2,this->U_index_helmholtz.real());
             external_global_eqn_real=this->eqn_number(external_unknown_real);
             
             external_unknown_imag = this->external_local_eqn(
              l2,this->U_index_helmholtz.imag());
             external_global_eqn_imag=this->eqn_number(external_unknown_imag);
             
             //If at a non-zero degree of freedom add in the entry
             if(external_unknown_real >= 0)
              {
               // Add the first order terms contribution
               jacobian(local_eqn_real,external_unknown_real)
                -=d_gamma[ipt][external_global_eqn_real].real()*test[l]*W;
              }
             if(external_unknown_imag >= 0)
              {
               // Add the first order terms contribution
               jacobian(local_eqn_real,external_unknown_imag)
                -=d_gamma[ipt][external_global_eqn_imag].real()*test[l]*W;
              }
            } // End of loop over external data    
          }// End of flag
        }// end of local_eqn_real
       
       if(local_eqn_imag >= 0)
        {
         //Add the gamma contribution in this int_point to the res
         residuals[local_eqn_imag] -=gamma[ipt].imag()*test[l]*W;
         
         // Calculate the jacobian
         //-----------------------
         if(flag)
          {
           //Loop over the velocity shape functions again
           for(unsigned l2=0;l2<n_node;l2++)
            { 
             // Add the contribution of the local data
             local_unknown_real = this->nodal_local_eqn(
              l2,this->U_index_helmholtz.real());
             global_eqn_real=this->eqn_number(local_unknown_real);
             
             local_unknown_imag = this->nodal_local_eqn(
              l2,this->U_index_helmholtz.imag());
             global_eqn_imag=this->eqn_number(local_unknown_imag);
             //If at a non-zero degree of freedom add in the entry
             if(local_unknown_real >= 0)
              {
               // Add the first order terms contribution
               jacobian(local_eqn_imag,local_unknown_real)
                -=d_gamma[ipt][global_eqn_real].imag()*test[l]*W;
              }
             if(local_unknown_imag >= 0)
              {
               // Add the first order terms contribution
               jacobian(local_eqn_imag,local_unknown_imag)
                -=d_gamma[ipt][global_eqn_imag].imag()*test[l]*W; 
              }
            } // End of loop over nodes l2  
           
           // Add the contribution of the external data
           unsigned n_ext_data=this->nexternal_data();
           //Loop over the velocity shape functions again
           for(unsigned l2=0;l2<n_ext_data;l2++)
            { 
             // Add the contribution of the local data
             external_unknown_real = this->external_local_eqn(
              l2,this->U_index_helmholtz.real());
             external_global_eqn_real=this->eqn_number(external_unknown_real);
             
             external_unknown_imag = this->external_local_eqn(
              l2,this->U_index_helmholtz.imag());
             external_global_eqn_imag=this->eqn_number(external_unknown_imag);
             
             //If at a non-zero degree of freedom add in the entry
             if(external_unknown_real >= 0)
              {
               // Add the first order terms contribution
               jacobian(local_eqn_imag,external_unknown_real)
                -=d_gamma[ipt][external_global_eqn_real].imag()*test[l]*W;
              }
             if(external_unknown_imag >= 0)
              {
               // Add the first order terms contribution
               jacobian(local_eqn_imag,external_unknown_imag)
                -=d_gamma[ipt][external_global_eqn_imag].imag()*test[l]*W;
              }
            } // End of loop over external data    
          }// End of flag
        } // end of local_eqn_imag   
      }// end of llop over yhe node
    } //End of loop over int_pt
  } // End of fill_in_generic_residual_contribution_helmholtz_flux
  
  
 
  private:
 
  /// \short Pointer to mesh of all boundary condition elements
  /// (needed to get access to gamma values)
  HelmholtzOuterBoundaryMesh<ELEMENT>* Outer_boundary_mesh_pt;
  
};


////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////





//===========start_compute_gamma_contribution==================
/// \short compute the contribution of the element 
/// to the Gamma and its derivates w.r.t 
/// to global unknows; the function takes n et phi 
/// as Input  
//==============================================================  
template<class ELEMENT>
 void HelmholtzDtNBoundaryElement<ELEMENT>::
 compute_gamma_contribution(
  const double& phi,
  const int& n, 
  complex<double>& gamma_con,
  std::map<unsigned,complex<double> >& d_gamma_con)                           
 {  
  // define the imaginary number
  std::complex<double> I(0.0,1.0);
  
  // Make integraton scheme hierher: how is this chosen?
  GaussLobattoLegendre<1,10>* local_integral_pt=
   new GaussLobattoLegendre<1,10>;
  
  //Find out how many nodes there are
  const unsigned n_node = this->nnode();
  
  //Set up memory for the shape  functions
  Shape psi(n_node); 
  DShape dpsi(n_node,1);
  
  // initialise the variable
  int local_unknown_real=0, local_unknown_imag=0;
  int global_eqn_real=0,global_eqn_imag=0;
  
  //Set the value of n_intpt
  const unsigned n_intpt=local_integral_pt->nweight();
  
 //Set the Vector to hold local coordinates
  Vector<double> s(this->Dim-1);
  
  // Initialise
  gamma_con=std::complex<double>(0.0,0.0);
  d_gamma_con.clear();
  
//Loop over the integration points
  //--------------------------------
  for(unsigned ipt=0;ipt<n_intpt;ipt++)
   {
   //Assign values of s
    for(unsigned i=0;i<(this->Dim-1);i++) 
     {
      s[i]=local_integral_pt->knot(ipt,i);
     }
    
    //Get the integral weight
    double w=local_integral_pt->weight(ipt);
    
    // Get the shape functions
    this->dshape_local(s,psi,dpsi);
    
    // Eulerian coordinates at Gauss point
    Vector<double> interpolated_x(this->Dim,0.0);
    
    // Derivs of Eulerian coordinates w.r.t. local coordinates
    Vector<double> interpolated_dxds(this->Dim);
    complex<double> interpolated_u(0.0,0.0);
    
    // Assemble x and its derivs
    for(unsigned l=0;l<n_node;l++) 
     {
      //Loop over directions
      for(unsigned i=0;i<this->Dim;i++)
       {
        interpolated_x[i]+=this->nodal_position(l,i)*psi[l];
        interpolated_dxds[i]+=this->nodal_position(l,i)*dpsi(l,0);
       }
      
      //Get the nodal value of the helmholtz unknown
      double u_value_real =this->raw_nodal_value(
       l,this->U_index_helmholtz.real());
      double u_value_imag =this->raw_nodal_value(
       l,this->U_index_helmholtz.imag());
      
      interpolated_u.real() += u_value_real*psi(l);         
      interpolated_u.imag() += u_value_imag*psi(l);    
      
     } // End of loop over the nodes
    
    // calculate the integral
    //-----------------------
    // define the variable phi_p
    double phi_p=atan2(interpolated_x[1],interpolated_x[0]);
    
    //define dphi_ds=(-yx'+y'x)/(x^2+y^2)
    double denom =(interpolated_x[0]*interpolated_x[0])+
     (interpolated_x[1]*interpolated_x[1]);
    double nom =-interpolated_dxds[1]*interpolated_x[0]+
     interpolated_dxds[0]*interpolated_x[1];
    double dphi_ds=nom/denom;
    
    // compute the element contribution to gamma
    gamma_con+=(dphi_ds)*w*exp(I*(phi-phi_p)*double(n))*interpolated_u;
    
    // compute the contribution to each node to the map   
    for(unsigned l=0;l<n_node;l++) 
     {
      complex<double> factor=std::complex<double>(1.0,0.0);
      
      // Add the contribution of the real local data
      local_unknown_real = this->nodal_local_eqn(
       l,this->U_index_helmholtz.real());
     global_eqn_real=this->eqn_number(local_unknown_real);
     if (global_eqn_real >= 0)
      {   
       d_gamma_con[global_eqn_real]+=
        (dphi_ds)*w*exp(I*(phi-phi_p)*double(n))*psi(l);
      }
     
     // Add the contribution of the imag local data
     local_unknown_imag = this->nodal_local_eqn(
      l,this->U_index_helmholtz.imag());
     global_eqn_imag=this->eqn_number(local_unknown_imag);
     if (global_eqn_real >= 0)
      {   
       d_gamma_con[global_eqn_imag]+=
        I* (dphi_ds)*w*exp(I*(phi-phi_p)*double(n))*psi(l);
      }
     }// end of loop over the node
   }//End of loop over integration points    
  
  // Kill integration scheme (hierher make pool)
  delete local_integral_pt;
  
 }


// /////////////////////////////////////////////////////////////////////
// /////////////////////////////////////////////////////////////////////
// /////////////////////////////////////////////////////////////////////



///================================================================
/// Compute and store the gamma integral and derivates 
///w.r.t global unknows at all integration  points
/// of the constituent elements
//================================================================
template<class ELEMENT>
 void HelmholtzOuterBoundaryMesh<ELEMENT>::setup_gamma()
 { 
  
  //introduce the Helmholtz parameter:ask the first element:hierhier
  
  // set a pointer to each element   
  HelmholtzDtNBoundaryElement<ELEMENT>* el_pt=
   dynamic_cast<HelmholtzDtNBoundaryElement<ELEMENT>*>
   (this->element_pt(0));    
  
  double k=sqrt(*(el_pt->k_squared_pt()));  
  
  // introduce the parameters of the sum    
  unsigned n_max=this->nfourier()+2; //hierher
  
  Vector<complex<double> > h2_a(n_max), h2p_a(n_max),q(n_max);
  
  Hankel_functions_for_Helmholtz_problem::
   Hankel_first(n_max,Outer_radius*k,h2_a,h2p_a);
  
  for (unsigned i=0;i<Nfourier;i++)
   {
    q[i]=(k/(M_PI*2.0))*(h2p_a[i]/h2_a[i]);  
   } 
  
  //first loop over elements e
  unsigned nel=this->nelement();
  for (unsigned e=0;e<nel;e++)
   {
    // set a pointer to each element   
    HelmholtzDtNBoundaryElement<ELEMENT>* el_pt=
     dynamic_cast<HelmholtzDtNBoundaryElement<ELEMENT>*>
     (this->element_pt(e));    
    
    // Define the value of phi 
    //Set the value of n_intpt
    const unsigned n_intpt =el_pt->integral_pt()->nweight();
    
    // initialise the vector storing the value of gamma
    Vector<complex<double> > gamma_vector(
     n_intpt,std::complex<double>(0.0,0.0));
    Vector<std::map<unsigned,complex<double> > > 
     d_gamma_vector(n_intpt);
    
    //Loop over the integration points
    for(unsigned ipt=0;ipt<n_intpt;ipt++)
     {
      //Allocate and initialise to zero hierher DIM in general    
      Vector<double> x(el_pt->dim(),0.0);
      
      //Set the Vector to hold local coordinates
      Vector<double> s(el_pt->dim()-1,0.0);
      //Assign values of s
      for(unsigned i=0;i<(el_pt->dim()-1);i++) 
      {
       s[i]=el_pt->integral_pt()->knot(ipt,i);
      }
      
      //Get the coordinates of the integration point
      el_pt->interpolated_x(s,x);
      
      double  phi=atan2(x[1],x[0]);
      
      //define the variable      
      complex<double> gamma_con_p(0.0,0.0)
       ,gamma_con_n(0.0,0.0);
      std::map<unsigned,complex<double> > 
       d_gamma_con_p,d_gamma_con_n;
      
      // loop over the sum points n
      for (unsigned nn=0;nn<Nfourier;nn++)
       {
        //Second loop over the element 
        //to evaluate the complete integral
        for (unsigned ee=0;ee<nel;ee++)
         {
          HelmholtzDtNBoundaryElement<ELEMENT>* eel_pt=
           dynamic_cast<HelmholtzDtNBoundaryElement<ELEMENT>*>
           (this->element_pt(ee));
          
          // contribution of the positive term in the sum
          eel_pt->compute_gamma_contribution(
           phi,int(nn),gamma_con_p,d_gamma_con_p) ;
         
         // contribution of the negative term in the sum
         eel_pt->compute_gamma_contribution(
          phi,-int(nn),gamma_con_n,d_gamma_con_n) ;
         
         unsigned n_node=eel_pt->nnode();
         if (nn==0)
          { 
           gamma_vector[ipt]+=q[nn]*gamma_con_p;
           for(unsigned l=0;l<n_node;l++) 
            {
             // Add the contribution of the real local data
             int local_unknown_p_real=
              eel_pt->nodal_local_eqn(
               l,eel_pt->u_index_helmholtz().real());
             
             int global_eqn_p_real=eel_pt->eqn_number(
              local_unknown_p_real);
             if (global_eqn_p_real >= 0)
              {   
               d_gamma_vector[ipt][global_eqn_p_real]+=
                q[nn]*d_gamma_con_p[global_eqn_p_real];
              }
             
             // Add the contribution of the imag local data
             int local_unknown_p_imag=
              eel_pt->nodal_local_eqn(
               l,eel_pt->u_index_helmholtz().imag());

              int global_eqn_p_imag=eel_pt->eqn_number(
               local_unknown_p_imag);
              if (global_eqn_p_imag >= 0)
               {   
                d_gamma_vector[ipt][global_eqn_p_imag]+=
                 q[nn]*d_gamma_con_p[global_eqn_p_imag];
               }
            }// end of loop over the node
          }//End of if
         else 
          { 
           gamma_vector[ipt]+=q[nn]*(gamma_con_p+gamma_con_n);
           for(unsigned l=0;l<n_node;l++) 
            {
             // Add the contribution of the real local data
             int local_unknown_real
              =eel_pt->nodal_local_eqn(
               l,eel_pt->u_index_helmholtz().real());
             int global_eqn_real=eel_pt->eqn_number(local_unknown_real);
             if (global_eqn_real >= 0)
              {          
               d_gamma_vector[ipt][global_eqn_real]+=
                q[nn]*(d_gamma_con_p[global_eqn_real]+
                       d_gamma_con_n[global_eqn_real]);
              }  
             // Add the contribution of the imag local data
             int local_unknown_imag
              =eel_pt->nodal_local_eqn(
               l,eel_pt->u_index_helmholtz().imag());
             int global_eqn_imag=eel_pt->eqn_number(local_unknown_imag);
             if (global_eqn_imag >= 0)
              {          
               d_gamma_vector[ipt][global_eqn_imag]+=
                q[nn]*(d_gamma_con_p[global_eqn_imag]+
                       d_gamma_con_n[global_eqn_imag]);
              }  
            }// end of loop over the node
          }//End of else  
         }// End of second loop over the elements 
       }// End of loop over Fourier terms  
     }// end of loop over integration point
    
    // Store it in map
    Gamma_at_gauss_point[el_pt]=gamma_vector;
    D_Gamma_at_gauss_point[el_pt]=d_gamma_vector;
    
  }// end of first loop over element  
 }

//===========================================================================
/// Constructor, takes the pointer to the "bulk" element, the 
/// index of the fixed local coordinate and its value represented
/// by an integer (+/- 1), indicating that the face is located
/// at the max. or min. value of the "fixed" local coordinate
/// in the bulk element.
//===========================================================================
template<class ELEMENT>
 HelmholtzBCElementBase<ELEMENT>::
 HelmholtzBCElementBase(FiniteElement* const &bulk_el_pt, 
                        const int &face_index) : 
 FaceGeometry<ELEMENT>(), FaceElement()
 { 
#ifdef PARANOID
  {
   //Check that the element is not a refineable 3d element
   ELEMENT* elem_pt = new ELEMENT;
   //If it's three-d
   if(elem_pt->dim()==3)
    {
     //Is it refineable
     if(dynamic_cast<RefineableElement*>(elem_pt))
      {
       //Issue a warning
       OomphLibWarning(
        "This flux element will not" 
        "work correctly if nodes are hanging\n",
        "HelmholtzBCElementBase::Constructor",
        OOMPH_EXCEPTION_LOCATION);
      }
    }
  }
#endif   
  
  // Let the bulk element build the FaceElement, i.e. setup the pointers 
  // to its nodes (by referring to the appropriate nodes in the bulk
  // element), etc.
  bulk_el_pt->build_face_element(face_index,this);
  
  // Initialise pointer to wavenumber
  K_squared_pt=0;
  
  // Extract the dimension of the problem from the dimension of 
  // the first node
  Dim = this->node_pt(0)->ndim();
  
  //Set up U_index_helmholtz. Initialise to zero, which probably won't change
  //in most cases, oh well, the price we pay for generality
   U_index_helmholtz.real()=0;
   U_index_helmholtz.imag()=1;

   //Cast to the appropriate HelmholtzEquation so that we can
   //find the index at which the variable is stored
   //We assume that the dimension of the full problem is the same
   //as the dimension of the node, if this is not the case you will have
   //to write custom elements, sorry
   switch(Dim)
    {
     //One dimensional problem
    case 1:
    {
     HelmholtzEquations<1>* eqn_pt = 
      dynamic_cast<HelmholtzEquations<1>*>(bulk_el_pt);
     //If the cast has failed die
     if(eqn_pt==0)
      {
       std::string error_string =
        "Bulk element must inherit from HelmholtzEquations.";
       error_string += 
        "Nodes are one dimensional, but cannot cast the bulk element to\n";
       error_string += "HelmholtzEquations<1>\n.";
       error_string += 
        "If you desire this functionality, you must implement it yourself\n";
       
       throw OomphLibError(error_string,
                           "HelmholtzFluxElement::HelmholtzFluxElement()",
                           OOMPH_EXCEPTION_LOCATION);
      }
     //Otherwise read out the value
     else
      {  
       //Read the index from the (cast) bulk element
       U_index_helmholtz.real() = eqn_pt->u_index_helmholtz().real();
       U_index_helmholtz.imag() = eqn_pt->u_index_helmholtz().imag();    
      }
    }
    break;
    
    //Two dimensional problem
    case 2:
    {
     HelmholtzEquations<2>* eqn_pt = 
      dynamic_cast<HelmholtzEquations<2>*>(bulk_el_pt);
     //If the cast has failed die
     if(eqn_pt==0)
      {
       std::string error_string =
        "Bulk element must inherit from HelmholtzEquations.";
       error_string += 
        "Nodes are two dimensional, but cannot cast the bulk element to\n";
       error_string += "HelmholtzEquations<2>\n.";
       error_string += 
        "If you desire this functionality, you must implement it yourself\n";
       
       throw OomphLibError(error_string,
                           "HelmholtzFluxElement::HelmholtzFluxElement()",
                           OOMPH_EXCEPTION_LOCATION);
      }
     else
      {
       //Read the index from the (cast) bulk element
       U_index_helmholtz.real() = eqn_pt->u_index_helmholtz().real();
       U_index_helmholtz.imag() = eqn_pt->u_index_helmholtz().imag();    
      }   
    }
    
    break;
    
    //Three dimensional problem
    case 3: 
    {
     HelmholtzEquations<3>* eqn_pt = 
      dynamic_cast<HelmholtzEquations<3>*>(bulk_el_pt);
     //If the cast has failed die
     if(eqn_pt==0)
      {
       std::string error_string =
        "Bulk element must inherit from HelmholtzEquations.";
       error_string += 
        "Nodes are three dimensional, but cannot cast the bulk element to\n";
       error_string += "HelmholtzEquations<3>\n.";
       error_string += 
        "If you desire this functionality, you must implement it yourself\n";
       
       throw OomphLibError(error_string,
                        "HelmholtzFluxElement::HelmholtzFluxElement()",
                           OOMPH_EXCEPTION_LOCATION); 
      }
     else 
      {
       //Read the index from the (cast) bulk element
       U_index_helmholtz.real() = eqn_pt->u_index_helmholtz().real();
       U_index_helmholtz.imag() = eqn_pt->u_index_helmholtz().imag();  
      }
    }
    break;
    
    //Any other case is an error
    default:
     std::ostringstream error_stream; 
     error_stream <<  "Dimension of node is " << Dim 
                  << ". It should be 1,2, or 3!" << std::endl;
     
     throw OomphLibError(error_stream.str(),
                         "HelmholtzFluxElement::HelmholtzFluxElement()",
                         OOMPH_EXCEPTION_LOCATION);
     break;
    }
 }
 

}

#endif

