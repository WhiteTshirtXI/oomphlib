//LIC// ====================================================================
//LIC// This file forms part of oomph-lib, the object-oriented, 
//LIC// multi-physics finite-element library, available 
//LIC// at http://www.oomph-lib.org.
//LIC// 
//LIC//           Version 0.90. August 3, 2009.
//LIC// 
//LIC// Copyright (C) 2006-2009 Matthias Heil and Andrew Hazel
//LIC// 
//LIC// This library is free software; you can redistribute it and/or
//LIC// modify it under the terms of the GNU Lesser General Public
//LIC// License as published by the Free Software Foundation; either
//LIC// version 2.1 of the License, or (at your option) any later version.
//LIC// 
//LIC// This library is distributed in the hope that it will be useful,
//LIC// but WITHOUT ANY WARRANTY; without even the implied warranty of
//LIC// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//LIC// Lesser General Public License for more details.
//LIC// 
//LIC// You should have received a copy of the GNU Lesser General Public
//LIC// License along with this library; if not, write to the Free Software
//LIC// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
//LIC// 02110-1301  USA.
//LIC// 
//LIC// The authors may be contacted at oomph-lib@maths.man.ac.uk.
//LIC// 
//LIC//====================================================================
// Header file with various simple block preconditioners written
// from scratch for "didactic" purposes, not necessarily to
// illustrate any particularly clever maths (though they work!)
 
//Include guards
#ifndef OOMPH_SIMPLE_BLOCK_PRECONDITIONERS
#define OOMPH_SIMPLE_BLOCK_PRECONDITIONERS


// Config header generated by autoconfig
#ifdef HAVE_CONFIG_H
#include <oomph-lib-config.h>
#endif

// oomph-lib includes
#include "generic.h"

namespace oomph
{
  

//=========================start_of_diagonal_class=============================
/// \short Simple proof-of-concept block diagonal preconditioner for
/// demo purposes. There's a much better version in src/generic!
//=============================================================================
 template<typename MATRIX> 
 class Simple : public BlockPreconditioner<MATRIX>
 {
  
 public :
  
  /// Constructor for Simple
  Simple() : BlockPreconditioner<MATRIX>()
   {
   } // end_of_constructor

 
  /// Destructor - delete the diagonal solvers (subsidiary preconditioners)
  ~Simple()
   {
    this->clean_up_my_memory();
   }

  /// clean up the memory
  virtual void clean_up_my_memory();
     
  /// Broken copy constructor
  Simple(const Simple&) 
   { 
    BrokenCopy::broken_copy("Simple");
   } 
 
  /// Broken assignment operator
  void operator=(const Simple&) 
   {
    BrokenCopy::broken_assign("Simple");
   }


  /// \short Setup the preconditioner 
  void setup();
  
  // This is put in to override the default behaviour of name hiding, which
  // "hides", but does not override, base class functions with the same name
  // as aderived class function even if the argument differ to allow for 
  // overloading. This is not a problem when using base class pointers.
  using Preconditioner::setup;

  /// Apply preconditioner to r, i.e. return solution of P z = r
  void preconditioner_solve(const DoubleVector &r, DoubleVector &z);
  
 private :
  
  /// \short Vector of pointers to preconditioners/inexact solvers 
  /// for each diagonal block
  Vector<Preconditioner*> Diagonal_block_preconditioner_pt;

 };

 //=========================start_of_setup_for_simple========================
 /// The setup function.
 //============================================================================
 template<typename MATRIX> 
 void Simple<MATRIX>::setup()
 {
  // clean the memory
  this->clean_up_my_memory();

  // Set up the generic block look up scheme
  this->block_setup();

  // Extract the number of blocks
  unsigned nblock_types = this->nblock_types();

  // Resize the storage for the diagonal blocks
  Diagonal_block_preconditioner_pt.resize(nblock_types);

  // Create the subsidiary preconditioners
  for (unsigned i=0;i<nblock_types;i++)
   {
    Diagonal_block_preconditioner_pt[i] = new SuperLUPreconditioner;
   }

  // Setup preconditioners
  for (unsigned i=0;i<nblock_types;i++)
   {
    // Get block -- this makes a copy of the relevant entries in the
    // full Jacobian (i.e. the matrix of the linear system we're
    // actually trying to solve); we can do with this copy whatever
    // we want...
    CRDoubleMatrix block;
    this->get_block(i,i,block);
    
    // Set up preconditioner (i.e. lu-decompose the block)
    Diagonal_block_preconditioner_pt[i]->setup(&block);
    
    // Done with this block now, so the diagonal block that we extracted
    // above can go out of scope. Its LU decomposition (which is the only 
    // thing we need to apply the preconditoner in the preconditoner_solve(...)
    // function) is retained in the associated sub-preconditioner/(in)exact 
    // solver(SuperLU).
   }
 }
 
 
 //============================================================================
 /// Preconditioner solve for the diagonal preconditioner: 
 /// Apply preconditioner to r and return z, so that P z = r, where
 /// P is the block diagonal matrix constructed from the original 
 /// linear system.
 //============================================================================
 template<typename MATRIX> 
 void Simple<MATRIX>::
 preconditioner_solve(const DoubleVector& r, DoubleVector& z)
 {   
  // Get number of blocks
  unsigned nblock_types = this->nblock_types();

  // Split up rhs vector into sub-vectors, re-arranged to match
  // the matrix blocks
  Vector<DoubleVector> block_r;
  this->get_block_vectors(r,block_r);

  // Solution of block solves
  Vector<DoubleVector> block_z(nblock_types);
  for (unsigned i = 0; i < nblock_types; i++)
   {
    Diagonal_block_preconditioner_pt[i]->preconditioner_solve(block_r[i],
                                                              block_z[i]);
   }
  
  // Copy solution in block vectors block_z back to z
  this->return_block_vectors(block_z,z);
 }

 //=========================start_of_clean_up_for_simple=======================
 /// The clean up function.
 //============================================================================
 template<typename MATRIX> 
 void Simple<MATRIX>::clean_up_my_memory()
 { 
  // Delete diagonal preconditioners (approximate solvers)
  unsigned n_block = Diagonal_block_preconditioner_pt.size();
  for (unsigned i=0;i<n_block;i++)
   {
    if(Diagonal_block_preconditioner_pt[i]!=0)
     {
      delete Diagonal_block_preconditioner_pt[i];
      Diagonal_block_preconditioner_pt[i]=0;
     }
   }
 } // End of clean_up_my_memory function.
 

 ///////////////////////////////////////////////////////////////////////////////
 ///////////////////////////////////////////////////////////////////////////////
 ///////////////////////////////////////////////////////////////////////////////



//=========================start_of_upper_triangular_class=====================
/// \short Upper triangular preconditioner for a system 
/// with any number of dof types.
//=============================================================================
 template<typename MATRIX> 
 class UpperTriangular : public BlockPreconditioner<MATRIX>
 {
 
 public :
 
  /// Constructor.
  UpperTriangular() : BlockPreconditioner<MATRIX>()
   {
   }
 
  /// Destructor - delete the preconditioner matrices
  virtual ~UpperTriangular()
   {
    this->clean_up_my_memory();
   }

  /// clean up the memory
  virtual void clean_up_my_memory();
 
  /// Broken copy constructor
  UpperTriangular(const UpperTriangular&) 
   { 
    BrokenCopy::broken_copy("UpperTriangular");
   } 
  
  /// Broken assignment operator
  void operator=(const UpperTriangular&) 
   {
    BrokenCopy::broken_assign("UpperTriangular");
   }
  
  /// Apply preconditioner to r
  void preconditioner_solve(const DoubleVector &r, DoubleVector &z);
 
  /// \short Setup the preconditioner 
  void setup();

  // This is put in to override the default behaviour of name hiding, which
  // "hides", but does not override, base class functions with the same name
  // as aderived class function even if the argument differ to allow for 
  // overloading. This is not a problem when using base class pointers.
  using Preconditioner::setup;

 private:  

  /// Matrix of matrix vector product operators for the off diagonals
  DenseMatrix<MatrixVectorProduct*> Off_diagonal_matrix_vector_products;

  /// \short Vector of pointers to preconditioners/inexact solvers 
  /// for each diagonal block
  Vector<Preconditioner*> Block_preconditioner_pt;
 };

 //========================start_of_setup_for_upper_triangular_class===========
 /// The setup function.
 //============================================================================
 template<typename MATRIX> 
 void UpperTriangular<MATRIX>::setup()
 {
  // clean the memory
  this->clean_up_my_memory();

  // Set up the block look up schemes
  this->block_setup();


  // number of block types  
  unsigned nblock_types = this->nblock_types();
  std::cout << "nblock:" << nblock_types << std::endl;

  // storage for the off diagonal matrix vector products
  Off_diagonal_matrix_vector_products.resize(nblock_types,nblock_types,0);
  Block_preconditioner_pt.resize(nblock_types);

  // build the preconditioners and matrix vector products
  for(unsigned i = 0; i < nblock_types; i++)
   {
    // Create the subsidiary preconditioners
    Block_preconditioner_pt[i] = new SuperLUPreconditioner;

    {
     // Get block -- this makes a copy of the relevant entries in the
     // full Jacobian (i.e. the matrix of the linear system we're
     // actually trying to solve); we can do with this copy whatever
     // we want...
     CRDoubleMatrix block;
     this->get_block(i,i,block);
    
     // Set up preconditioner (i.e. lu-decompose the block)
     Block_preconditioner_pt[i]->setup(&block);
    
     // Done with this block now, so the diagonal block that we extracted
     // above can go out of scope. Its LU decomposition (which is the only 
     // thing we need to apply the preconditoner in the 
     // preconditoner_solve(...) function) is retained in the associated 
     // sub-preconditioner/(in)exact solver(SuperLU).
    }
     
    // next setup the off diagonal mat vec operators
    for(unsigned j=i+1;j<nblock_types;j++)
     {
      // Get the block
      CRDoubleMatrix block_matrix = this->get_block(i,j);

      // Copy the block into a "multiplier" class. If trilinos is being
      // used this should also be faster than oomph-lib's multiplys.
      Off_diagonal_matrix_vector_products(i,j) = new MatrixVectorProduct();

      this->setup_matrix_vector_product(
       Off_diagonal_matrix_vector_products(i,j),&block_matrix,j);
      // Done with this block now, so the diagonal block that we extracted
      // above can go out of scope. Its LU decomposition (which is the only 
      // thing we need to apply the preconditoner in the 
      // preconditoner_solve(...) function) is retained in the associated 
      // sub-preconditioner/(in)exact solver(SuperLU).
     } // End for loop over j
   } // End for loop over i
 } // End setup(...)


 //=============================================================================
 /// Preconditioner solve for the upper triangular preconditioner: 
 /// Apply preconditioner to r and return z, so that P z = r, where
 /// P is the block diagonal matrix constructed from the original 
 /// linear system.
 //=============================================================================
 template<typename MATRIX> void UpperTriangular<MATRIX>::
 preconditioner_solve(const DoubleVector& r, DoubleVector& z)
 {
  // Get number of blocks
  unsigned n_block = this->nblock_types();

  // vector of vectors for each section of residual vector
  Vector<DoubleVector> block_r;
  
  // rearrange the vector r into the vector of block vectors block_r
  this->get_block_vectors(r,block_r);

  // Vector of vectors for the solution block vectors
  Vector<DoubleVector> block_z(n_block);

  // Required to be an int due to an unsigned being unable to be compared to a
  // negative number (because it would roll over).
  for (int i=n_block-1;i>-1;i--)
   {
    // Back substitute
    for (unsigned j=i+1;j<n_block;j++)
     {
      DoubleVector temp;
      Off_diagonal_matrix_vector_products(i,j)->multiply(block_z[j],temp);
      block_r[i] -= temp;
     } // End for over j

    // Solve on the block
    this->Block_preconditioner_pt[i]->
     preconditioner_solve(block_r[i], block_z[i]);
   } // End for over i

  // Copy solution in block vectors block_r back to z
  this->return_block_vectors(block_z,z);
 }

 //========================start_of_clean_up_for_upper_triangular_class========
 /// The clean up function.
 //============================================================================
 template<typename MATRIX> 
 void UpperTriangular<MATRIX>::clean_up_my_memory()
 {     
  // Delete anything in Off_diagonal_matrix_vector_products
  for(unsigned i=0,ni=Off_diagonal_matrix_vector_products.nrow();i<ni;i++)
   {
    for(unsigned j=0,nj=Off_diagonal_matrix_vector_products.ncol();j<nj;j++)
     {
      if(Off_diagonal_matrix_vector_products(i,j) != 0)
       {    
        delete Off_diagonal_matrix_vector_products(i,j);
        Off_diagonal_matrix_vector_products(i,j) = 0;
       }
     }
   }

  // Delete preconditioners (approximate solvers)
  unsigned n_block = Block_preconditioner_pt.size();
  for (unsigned i=0;i<n_block;i++)
   {
    if(Block_preconditioner_pt[i]!=0)
     {
      delete Block_preconditioner_pt[i];
      Block_preconditioner_pt[i]=0;
     }
   }
 } // End of clean_up_my_memory function.

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

//=======================start_of_two_plus_three_class=========================
/// \short Block diagonal preconditioner for system with 5 dof types
/// assembled into a 2x2 block system, with (0,0) block containing the 
/// first two dof types and the (1,1) block the remaining three dof types.
//=============================================================================
 template<typename MATRIX> 
 class TwoPlusThree : public BlockPreconditioner<MATRIX>
 {
 public :
  
  /// Constructor for TwoPlusThree
  TwoPlusThree() : BlockPreconditioner<MATRIX>(),
                  First_subsidiary_preconditioner_pt(0),
                  Second_subsidiary_preconditioner_pt(0)
   {
   } // end_of_constructor
  
  
  /// Destructor - delete the diagonal solvers (subsidiary preconditioners)
  ~TwoPlusThree()
   {
    this->clean_up_my_memory();
   }
  /// clean up the memory
  virtual void clean_up_my_memory();

  /// Broken copy constructor
  TwoPlusThree
  (const TwoPlusThree&) 
   { 
    BrokenCopy::broken_copy("TwoPlusThree");
   } 
  
  /// Broken assignment operator
  void operator=(const TwoPlusThree&) 
   {
    BrokenCopy::broken_assign("TwoPlusThree");
   }
  
  /// Apply preconditioner to r, i.e. return z such that P z = r
  void preconditioner_solve(const DoubleVector &r, DoubleVector &z);
  
  /// \short Setup the preconditioner 
  virtual void setup();
  
 private :
  
  /// \short Pointer to preconditioners/inexact solver
  /// for (0,0) block
  Preconditioner* First_subsidiary_preconditioner_pt;
  
  /// \short Pointer to preconditioners/inexact solver
  /// for (1,1) block
  Preconditioner* Second_subsidiary_preconditioner_pt;
  
 };

 //====================start_of_setup_for_two_plus_three=======================
 /// The setup function.
 //============================================================================
 template<typename MATRIX> 
 void TwoPlusThree<MATRIX>::setup()
 {
  // Clean up memory.
  this->clean_up_my_memory();

  unsigned n_dof_types = this->ndof_types();
#ifdef PARANOID
  // This preconditioner only works for 5 dof types
  if (n_dof_types!=5)
   {
    std::stringstream tmp;
    tmp << "This preconditioner only works for problems with 5 dof types\n"
        << "Yours has " << n_dof_types;
    throw OomphLibError(tmp.str(),
                        OOMPH_CURRENT_FUNCTION,
                        OOMPH_EXCEPTION_LOCATION);
   }
#endif


  // Combine into two major blocks, one containing dof types 0 and 1, the
  // final one dof types 2-4. In general we want:
  // dof_to_block_map[dof_type] = block type
  Vector<unsigned> dof_to_block_map(n_dof_types);
  dof_to_block_map[0]=0;
  dof_to_block_map[1]=0;
  dof_to_block_map[2]=1;
  dof_to_block_map[3]=1;
  dof_to_block_map[4]=1;
  this->block_setup(dof_to_block_map);

  // Show that it worked ok:
  oomph_info << "Preconditioner has " << this->nblock_types() 
             << " block types\n";
  
  // Create the subsidiary preconditioners
  First_subsidiary_preconditioner_pt= new SuperLUPreconditioner;
  Second_subsidiary_preconditioner_pt= new SuperLUPreconditioner;
  
  // Set diagonal solvers/preconditioners; put in own scope
  // so variable block goes out of scope
  {
   CRDoubleMatrix block;
   this->get_block(0,0,block);
   oomph_info << "Block size of block 0: " << block.nrow() << std::endl;
   
   // Set up preconditioner (i.e. lu-decompose the block)
   First_subsidiary_preconditioner_pt->setup(&block);
  }
  {
   CRDoubleMatrix block;
   this->get_block(1,1,block);
   oomph_info << "Block size of block 1: " << block.nrow() << std::endl;
   
   // Set up preconditioner (i.e. lu-decompose the block)
   Second_subsidiary_preconditioner_pt->setup(&block);
  }
 } // End of setup
 
 
 //=============================================================================
 /// Preconditioner solve for the two plus three diagonal preconditioner: 
 /// Apply preconditoner to r and return z, so that P r = z, where
 /// P is the block diagonal matrix constructed from the original 
 /// linear system.
 //=============================================================================
 template<typename MATRIX> 
 void TwoPlusThree<MATRIX>::
 preconditioner_solve(const DoubleVector& r, DoubleVector& z)
 {   
  // Get number of blocks
  unsigned n_block = this->nblock_types();

  // Split up rhs vector into sub-vectors, arranged to match the matrix blocks.
  Vector<DoubleVector> block_r;
  this->get_block_vectors(r,block_r);

  // Create storage for solution of block solves
  Vector<DoubleVector> block_z(n_block);

  // Solve (0,0) diagonal block system
  First_subsidiary_preconditioner_pt->preconditioner_solve(block_r[0],
                                                           block_z[0]);
  
  // Solve (1,1) diagonal block system
  Second_subsidiary_preconditioner_pt->preconditioner_solve(block_r[1],
                                                            block_z[1]);
  
  // Copy solution in block vectors block_z back to z
  this->return_block_vectors(block_z,z);
 }

  
 //====================start_of_clean_up_for_two_plus_three====================
 /// The clean up function.
 //============================================================================
 template<typename MATRIX> 
 void TwoPlusThree<MATRIX>::clean_up_my_memory()
 {     
  //Clean up subsidiary preconditioners.
  if(First_subsidiary_preconditioner_pt!=0)
   {
    delete First_subsidiary_preconditioner_pt;
    First_subsidiary_preconditioner_pt = 0;
   }
  if(Second_subsidiary_preconditioner_pt!=0)
   {
    delete Second_subsidiary_preconditioner_pt;
    Second_subsidiary_preconditioner_pt = 0;
   }
 } // End of clean_up_my_memory function.

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////


//=================start_of_two_plus_three_upper_triangular_class==============
/// \short Upper two plus three triangular preconditioner for a system with
///  5 dof types.
//=============================================================================
 template<typename MATRIX> 
 class TwoPlusThreeUpperTriangular 
  : public BlockPreconditioner<MATRIX>
 {
 
 public :
 
  /// Constructor.
  TwoPlusThreeUpperTriangular()  :
   BlockPreconditioner<MATRIX>(),
   First_subsidiary_preconditioner_pt(0),
   Second_subsidiary_preconditioner_pt(0)
   {
   }
 
  /// Destructor - delete the preconditioner matrices
  virtual ~TwoPlusThreeUpperTriangular()
   {
    this->clean_up_my_memory();
   }

  /// clean up the memory
  virtual void clean_up_my_memory();
 
  /// Broken copy constructor
  TwoPlusThreeUpperTriangular(const TwoPlusThreeUpperTriangular&) 
   { 
    BrokenCopy::broken_copy("SimpleUpperBloxkTriangularPreconditioner");
   } 
 
  /// Broken assignment operator
  void operator=(const TwoPlusThreeUpperTriangular&) 
   {
    BrokenCopy::broken_assign("TwoPlusThreeUpperTriangular");
   }
 
  /// Apply preconditioner to r
  void preconditioner_solve(const DoubleVector &r, DoubleVector &z);
 
  /// \short Setup the preconditioner 
  void setup();

  // This is put in to override the default behaviour of name hiding, which
  // "hides", but does not override, base class functions with the same name
  // as aderived class function even if the argument differ to allow for 
  // overloading. This is not a problem when using base class pointers.
  using Preconditioner::setup;

 private:  

  /// Matrix of matrix vector product operators for the off diagonals
  DenseMatrix<MatrixVectorProduct*> Off_diagonal_matrix_vector_products;

  /// \short Pointer to preconditioners/inexact solver
  /// for (0,0) block
  Preconditioner* First_subsidiary_preconditioner_pt;
  
  /// \short Pointer to preconditioners/inexact solver
  /// for (1,1) block
  Preconditioner* Second_subsidiary_preconditioner_pt;
 };

 //==============start_of_setup_for_two_plus_three_upper_triangular_class=======
 /// The setup function.
 //============================================================================
 template<typename MATRIX> 
 void TwoPlusThreeUpperTriangular<MATRIX>::setup()
 {
  // clean the memory
  this->clean_up_my_memory();

  // Get number of degrees of freedom.
  unsigned n_dof_types = this->ndof_types();

#ifdef PARANOID
  // This preconditioner only works for 5 dof types
  if (n_dof_types!=5)
   {
    std::stringstream tmp;
    tmp << "This preconditioner only works for problems with 5 dof types\n"
        << "Yours has " << n_dof_types;
    throw OomphLibError(tmp.str(),
                        OOMPH_CURRENT_FUNCTION,
                        OOMPH_EXCEPTION_LOCATION);
   }
#endif

  // Combine into two major blocks, one containing dof types 0 and 1, the
  // final one dof types 2-4. In general we want
  // dof_to_block_map[dof_type] = block_type
  Vector<unsigned> dof_to_block_map(n_dof_types);
  dof_to_block_map[0]=0;
  dof_to_block_map[1]=0;
  dof_to_block_map[2]=1;
  dof_to_block_map[3]=1;
  dof_to_block_map[4]=1;
  this->block_setup(dof_to_block_map);


  // number of block types  
  unsigned nblock_types = this->nblock_types();
  // Show that it worked ok:
  oomph_info << "Preconditioner has " << nblock_types
             << " block types\n";
  
  // Create the subsidiary preconditioners
  First_subsidiary_preconditioner_pt= new SuperLUPreconditioner;
  Second_subsidiary_preconditioner_pt= new SuperLUPreconditioner;

  // storage for the off diagonal matrix vector products
  Off_diagonal_matrix_vector_products.resize(nblock_types,nblock_types,0);


  // Set diagonal solvers/preconditioners; put in own scope
  // so block goes out of scope
  {
   CRDoubleMatrix block;
   this->get_block(0,0,block);
   oomph_info << "Block size of block 0: " << block.nrow() << std::endl;
   
   // Set up preconditioner (i.e. lu-decompose the block)
   First_subsidiary_preconditioner_pt->setup(&block);
  }
  {
   CRDoubleMatrix block;
   this->get_block(1,1,block);
   oomph_info << "Block size of block 1: " << block.nrow() << std::endl;
   
   // Set up preconditioner (i.e. lu-decompose the block)
   Second_subsidiary_preconditioner_pt->setup(&block);
  }

  // next setup the off diagonal mat vec operators
  {
   // Get the block
   CRDoubleMatrix block_matrix = this->get_block(0,1);

   // Copy the block into a "multiplier" class. If trilinos is being
   // used this should also be faster than oomph-lib's multiphys.
   Off_diagonal_matrix_vector_products(0,1) = new MatrixVectorProduct();

   this->setup_matrix_vector_product(
    Off_diagonal_matrix_vector_products(0,1),&block_matrix,1);
  }
 
 }

 //=============================================================================
 /// Preconditioner solve for the two plus three upper block triangular 
 /// preconditioner: 
 /// Apply preconditioner to r and return z, so that P z = r, where
 /// P is the block diagonal matrix constructed from the original 
 /// linear system.
 //=============================================================================
 template<typename MATRIX> 
 void TwoPlusThreeUpperTriangular<MATRIX>::
 preconditioner_solve(const DoubleVector& r, DoubleVector& z)
 {
  // Get number of blocks
  unsigned n_block = this->nblock_types();

  // Split up rhs vector into sub-vectors, rarranged to match the matrix blocks.
  Vector<DoubleVector> block_r;
  this->get_block_vectors(r,block_r);

  // Create storage for solution of block solves
  Vector<DoubleVector> block_z(n_block);

  // Solve (1,1) diagonal block system
  Second_subsidiary_preconditioner_pt->preconditioner_solve(block_r[1],
                                                            block_z[1]);

  // Solve (0,1) off diagonal.
  // Substitute
  DoubleVector temp;
  Off_diagonal_matrix_vector_products(0,1)->multiply(block_z[1],temp);
  block_r[0] -= temp;   

  // Solve (0,0) diagonal block system
  First_subsidiary_preconditioner_pt->preconditioner_solve(block_r[0],
                                                           block_z[0]); 

  // Copy solution in block vectors block_z back to z
  this->return_block_vectors(block_z,z);
 }


 //===========start_of_clean_up_for_two_plus_three_upper_triangular_class======
 /// The clean up function.
 //============================================================================
 template<typename MATRIX> 
 void TwoPlusThreeUpperTriangular<MATRIX>::clean_up_my_memory()
 {     
  // Delete anything in Off_diagonal_matrix_vector_products
  for(unsigned i=0,ni=Off_diagonal_matrix_vector_products.nrow();i<ni;i++)
   {
    for(unsigned j=0,nj=Off_diagonal_matrix_vector_products.ncol();j<nj;j++)
     {
      if(Off_diagonal_matrix_vector_products(i,j) != 0)
       {
        delete Off_diagonal_matrix_vector_products(i,j);
        Off_diagonal_matrix_vector_products(i,j) = 0;
       }
     }
   }
  //Clean up subsidiary preconditioners.
  if(First_subsidiary_preconditioner_pt!=0)
   {
    delete First_subsidiary_preconditioner_pt;
    First_subsidiary_preconditioner_pt = 0;
   }
  if(Second_subsidiary_preconditioner_pt!=0)
   {
    delete Second_subsidiary_preconditioner_pt;
    Second_subsidiary_preconditioner_pt = 0;
   }
 } // End of clean_up_my_memory function.

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

//=========start_of_two_plus_three_upper_triangular_with_sub_class=============
/// \short Upper block triangular with subsidiary preconditioner for a system 
/// with 5 dof types.
//=============================================================================
 template<typename MATRIX> 
 class TwoPlusThreeUpperTriangularWithOneLevelSubsidiary 
  : public BlockPreconditioner<MATRIX>
 {
 
 public :
 
  /// Constructor.
  TwoPlusThreeUpperTriangularWithOneLevelSubsidiary() :
   BlockPreconditioner<MATRIX>(),
   First_subsidiary_preconditioner_pt(0),
   Second_subsidiary_preconditioner_pt(0)
   {
   }
 
  /// Destructor - delete the preconditioner matrices
  virtual ~TwoPlusThreeUpperTriangularWithOneLevelSubsidiary()
   {
    this->clean_up_my_memory();
   }

  /// clean up the memory
  virtual void clean_up_my_memory();
 
  /// Broken copy constructor
  TwoPlusThreeUpperTriangularWithOneLevelSubsidiary
  (const TwoPlusThreeUpperTriangularWithOneLevelSubsidiary&) 
   { 
    BrokenCopy::broken_copy("SimpleUpperBlockTriangularPreconditioner");
   } 
 
  /// Broken assignment operator
  void operator=(const 
                 TwoPlusThreeUpperTriangularWithOneLevelSubsidiary&) 
   {
    BrokenCopy::broken_assign(
     "TwoPlusThreeUpperTriangularWithOneLevelSubsidiary");
   }
 
  /// Apply preconditioner to r
  void preconditioner_solve(const DoubleVector &r, DoubleVector &z);
 
  /// \short Setup the preconditioner 
  void setup();

  // This is put in to override the default behaviour of name hiding, which
  // "hides", but does not override, base class functions with the same name
  // as aderived class function even if the argument differ to allow for 
  // overloading. This is not a problem when using base class pointers.
  using Preconditioner::setup;

 private:  

  /// Matrix of matrix vector product operators for the off diagonals
  DenseMatrix<MatrixVectorProduct*> Off_diagonal_matrix_vector_products;

  /// \short Pointer to preconditioners/inexact solver
  /// for (0,0) block
  Preconditioner* First_subsidiary_preconditioner_pt;
  
  /// \short Pointer to preconditioners/inexact solver
  /// for (1,1) block
  Preconditioner* Second_subsidiary_preconditioner_pt;
 };

 //=======start_of_setup_for_two_plus_three_upper_triangular_with_sub_class====
 /// The setup function.
 //============================================================================
 template<typename MATRIX> 
 void TwoPlusThreeUpperTriangularWithOneLevelSubsidiary<MATRIX>::setup()
 {
  // clean the memory
  this->clean_up_my_memory();

  // number of block types  
  unsigned n_dof_types = this->ndof_types();

#ifdef PARANOID
  // This preconditioner only works for 5 dof types
  if (n_dof_types!=5)
   {
    std::stringstream tmp;
    tmp << "This preconditioner only works for problems with 5 dof types\n"
        << "Yours has " << n_dof_types;
    throw OomphLibError(tmp.str(),
                        OOMPH_CURRENT_FUNCTION,
                        OOMPH_EXCEPTION_LOCATION);
   }
#endif


  // Combine into two major blocks, one containing dof types 0 and 1, the
  // final one dof types 2-4. In general we want
  // dof_to_block_map[dof_type] = block type
  Vector<unsigned> dof_to_block_map(n_dof_types);
  dof_to_block_map[0]=0;
  dof_to_block_map[1]=0;
  dof_to_block_map[2]=1;
  dof_to_block_map[3]=1;
  dof_to_block_map[4]=1;
  this->block_setup(dof_to_block_map);

  // Show that it worked ok:
  unsigned nblock_types = this->nblock_types();
  oomph_info << "Preconditioner has " << this->nblock_types() 
             << " block types\n";
  
  // Create the subsidiary preconditioners.
  {
   // First subsidiary precond is a block diagonal preconditioner itself.
   // Put in owns cope so block_prec_pt goes out of scope.
   UpperTriangular<CRDoubleMatrix>* block_prec_pt=
    new UpperTriangular<CRDoubleMatrix>;
   First_subsidiary_preconditioner_pt=block_prec_pt;

   // Turn first_sub into a subsidiary preconditioner, declaring which
   // of the five dof types in the present (master) preconditioner
   // correspond to the dof types in the subsidiary block preconditioner
   unsigned n_sub_dof_types=2;
   Vector<unsigned> dof_map(n_sub_dof_types);
   dof_map[0]=0;
   dof_map[1]=1;
   block_prec_pt->turn_into_subsidiary_block_preconditioner(this,dof_map);    
   // Perform setup
   block_prec_pt->setup(this->matrix_pt());
  }

  // Second subsidiary precond is a block diagonal preconditioner itself
  UpperTriangular<CRDoubleMatrix>* block_prec_pt=
   new UpperTriangular<CRDoubleMatrix>;
  Second_subsidiary_preconditioner_pt=block_prec_pt;

  // Turn second_sub into a subsidiary preconditioner, declaring which
  // of the five dof types in the present (master) preconditioner
  // correspond to the dof types in the subsidiary block preconditioner
  unsigned n_sub_dof_types=3;
  Vector<unsigned> dof_map(n_sub_dof_types);
  dof_map[0]=2;
  dof_map[1]=3;
  dof_map[2]=4;
  block_prec_pt->turn_into_subsidiary_block_preconditioner(this,dof_map);    
  // Perform setup
  block_prec_pt->setup(this->matrix_pt());

  // storage for the off diagonal matrix vector products
  Off_diagonal_matrix_vector_products.resize(nblock_types,nblock_types,0);
  // next setup the off diagonal mat vec operators
  {
   // Get the block
   CRDoubleMatrix block_matrix = this->get_block(0,1);

   // Copy the block into a "multiplier" class. If trilinos is being
   // used this should also be faster than oomph-lib's multiphys.
   Off_diagonal_matrix_vector_products(0,1) = new MatrixVectorProduct();

   this->setup_matrix_vector_product(
    Off_diagonal_matrix_vector_products(0,1),&block_matrix,1);
  }
 
 }

 //=============================================================================
 /// Preconditioner solve for the one plus four upper triangular with 
 /// subsisdiary  preconditioner: 
 /// Apply preconditioner to r and return z, so that P z = r, where
 /// P is the block diagonal matrix constructed from the original 
 /// linear system.
 //=============================================================================
 template<typename MATRIX> 
 void TwoPlusThreeUpperTriangularWithOneLevelSubsidiary<MATRIX>::
 preconditioner_solve(const DoubleVector& r, DoubleVector& z)
 {
  // Solve (1,1) diagonal block system
  // Now apply the subsidiary block preconditioner that acts on the
  // "bottom right" 3x3 sub-system (only!). The subsidiary preconditioner 
  // will extract the relevant (3x1) "sub-vectors" from the "big" (5x1)
  // vector big_r and treat it as the rhs, r, of P z = r
  // where P is 3x3 block diagonal. Once the system is solved,
  // the result is automatically put back into the appropriate places 
  // of the "big" (5x1) vector z:
  Second_subsidiary_preconditioner_pt->preconditioner_solve(r,z);
    
  // Get number of blocks
  unsigned n_block = this->nblock_types();

  // Split up rhs vector into sub-vectors, re-arranged to match
  // the matrix blocks
  Vector<DoubleVector> block_r;
  this->get_block_vectors(r,block_r);

  // Create storage for solution of block solves
  Vector<DoubleVector> block_z(n_block);

  // Solve (0,1) off diagonal.
  // Substitute
  this->get_block_vectors(z,block_z);
  DoubleVector temp;
  Off_diagonal_matrix_vector_products(0,1)->multiply(block_z[1],temp);
  block_r[0] -= temp;   

  // Block solve for first diagonal block. Since the associated subsidiary 
  // preconditioner is a block preconditioner itself, it will extract 
  // the required (2x1) block rhs from a "big" (5x1) rhs vector, big_r.
  // Therefore we first put the actual (2x1) rhs vector block_r[0] into the
  // "big" (5x1) vector big_r. 
  DoubleVector big_r(z.distribution_pt());
  this->return_block_vector(0,block_r[0],big_r);
     
  // Now apply the subsidiary block preconditioner that acts on the
  // "upper left" 2x2 sub-system (only!). The subsidiary preconditioner 
  // will extract the relevant (2x1) "sub-vectors" from the "big" (5x1)
  // vector big_r and treat it as the rhs, r, of P z = r
  // where P is 2x2 block diagonal. Once the system is solved,
  // the result is automatically put back into the appropriate places 
  // of the "big" (5x1) vector z:
  First_subsidiary_preconditioner_pt->preconditioner_solve(big_r,z);
 }

 //====start_of_clean_up_for_two_plus_three_upper_triangular_with_sub_class=====
 /// The clean up function.
 //============================================================================
 template<typename MATRIX> 
 void TwoPlusThreeUpperTriangularWithOneLevelSubsidiary<MATRIX>::
 clean_up_my_memory()
 {     
  // Delete anything in Off_diagonal_matrix_vector_products
  for(unsigned i=0,ni=Off_diagonal_matrix_vector_products.nrow();i<ni;i++)
   {
    for(unsigned j=0,nj=Off_diagonal_matrix_vector_products.ncol();j<nj;j++)
     {
      if(Off_diagonal_matrix_vector_products(i,j) != 0)
       {
        delete Off_diagonal_matrix_vector_products(i,j);
        Off_diagonal_matrix_vector_products(i,j) = 0;
       }
     }
   }
  //Clean up subsidiary preconditioners.
  if(First_subsidiary_preconditioner_pt!=0)
   {
    delete First_subsidiary_preconditioner_pt;
    First_subsidiary_preconditioner_pt = 0;
   }
  if(Second_subsidiary_preconditioner_pt!=0)
   {
    delete Second_subsidiary_preconditioner_pt;
    Second_subsidiary_preconditioner_pt = 0;
   }
 } // End of clean_up_my_memory function.

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

//====================start_of_two_plus_one_class=============================
/// \short Block diagonal preconditioner for system with 3 dof types
/// assembled into a 2x2 block system, with (0,0) block containing
/// the first two dof types, the (1,1) block containing the last one.
/// Both blocks are solved by subsidiary diagonal block preconditioners, so
/// the overall behaviour is equivalent to a solve with a 3x3 upper triangular
/// preconditioner.
//=============================================================================
 template<typename MATRIX> 
 class TwoPlusOneUpperTriangularPreconditioner : 
  public BlockPreconditioner<MATRIX>
 {
  
 public :
  
  /// Constructor for TwoPlusOneUpperTriangularPreconditioner
  TwoPlusOneUpperTriangularPreconditioner() : 
   BlockPreconditioner<MATRIX>(),
   First_subsidiary_preconditioner_pt(0),
   Second_subsidiary_preconditioner_pt(0),
   Off_diagonal_matrix_vector_product_pt(0)
   {
   } // end_of_constructor
  
  
  /// Destructor - delete the diagonal solvers (subsidiary preconditioners)
  ~TwoPlusOneUpperTriangularPreconditioner()
   {
    this->clean_up_my_memory();
   }

  virtual void clean_up_my_memory();
     
  /// Broken copy constructor
  TwoPlusOneUpperTriangularPreconditioner
  (const TwoPlusOneUpperTriangularPreconditioner&) 
   { 
    BrokenCopy::broken_copy("TwoPlusOneUpperTriangularPreconditioner");
   } 
  
  /// Broken assignment operator
  void operator=(const TwoPlusOneUpperTriangularPreconditioner&) 
   {
    BrokenCopy::broken_assign("TwoPlusOneUpperTriangularPreconditioner");
   }
  
  /// Apply preconditioner to r, i.e. return z such that P z = r
  void preconditioner_solve(const DoubleVector &r, DoubleVector &z);
  
  /// \short Setup the preconditioner 
  void setup();

  // This is put in to override the default behaviour of name hiding, which
  // "hides", but does not override, base class functions with the same name
  // as aderived class function even if the argument differ to allow for 
  // overloading. This is not a problem when using base class pointers.
  using Preconditioner::setup;


 private :
  
  /// \short Pointer to preconditioners/inexact solver
  /// for (0,0) block
  Preconditioner* First_subsidiary_preconditioner_pt;
  
  /// \short Pointer to preconditioners/inexact solver
  /// for (1,1) block
  Preconditioner* Second_subsidiary_preconditioner_pt;
  
  /// Matrix vector product operators for the off diagonals.
  MatrixVectorProduct* Off_diagonal_matrix_vector_product_pt;
 };

 //================start_of_setup_for_two_plus_one_preconditioner=============
 /// The setup function.
 //===========================================================================
 template<typename MATRIX> 
 void TwoPlusOneUpperTriangularPreconditioner<MATRIX>::setup()
 {
  // Clean up memory.
  this->clean_up_my_memory();


#ifdef PARANOID
  // This preconditioner only works for 3 dof types
  unsigned n_dof_types = this->ndof_types();
  if (n_dof_types!=3)
   {
    std::stringstream tmp;
    tmp << "This preconditioner only works for problems with 3 dof types\n"
        << "Yours has " << n_dof_types;
    throw OomphLibError(tmp.str(),
                        OOMPH_CURRENT_FUNCTION,
                        OOMPH_EXCEPTION_LOCATION);
   }
#endif

  // Combine into two major blocks, one containing dofs 0 and 1, the
  // final one dof, 2.

  Vector<unsigned> dof_to_block_map(3);
  dof_to_block_map[0]=0;
  dof_to_block_map[1]=0;
  dof_to_block_map[2]=1;
  this->block_setup(dof_to_block_map);

  // Create the subsidiary preconditioners
  //--------------------------------------
  {
   // Limit scope of variables such as block_prec_pt
   // First one:
   UpperTriangular<CRDoubleMatrix>* block_prec_pt=
    new UpperTriangular<CRDoubleMatrix>;
   First_subsidiary_preconditioner_pt=block_prec_pt;
  
   // Turn it into a subsidiary preconditioner, declaring which
   // of the three dof types in the present (master) preconditioner
   // correspond to the dof types in the subsidiary block preconditioner
   unsigned n_sub_dof_types=2;

   Vector<unsigned> dof_map(n_sub_dof_types);
   dof_map[0] = 0;
   dof_map[1] = 1;
   block_prec_pt->turn_into_subsidiary_block_preconditioner(this,dof_map);
  
   // Perform setup
   block_prec_pt->setup(this->matrix_pt());
  }

  // Second one:
  UpperTriangular<CRDoubleMatrix>* block_prec_pt=
   new UpperTriangular<CRDoubleMatrix>;
  Second_subsidiary_preconditioner_pt=block_prec_pt;
  
  // Turn it into a subsidiary preconditioner, declaring which
  // of the three dof types in the present (master) preconditioner
  // correspond to the dof types in the subsidiary block preconditioner i.e.
  // arguments: dof_map[doc_in_subdiary]=dof_in_present
  unsigned n_sub_dof_types=1;

  Vector<unsigned> dof_map(n_sub_dof_types);
  dof_map[0] = 2;
  block_prec_pt->turn_into_subsidiary_block_preconditioner(this,dof_map);
  
  // Perform setup
  block_prec_pt->setup(this->matrix_pt()); 


  // Set up off diagonal matrix vector product operator.
  // Get the block
  CRDoubleMatrix block_matrix = this->get_block(0,1);
  Off_diagonal_matrix_vector_product_pt = new MatrixVectorProduct();
  this->setup_matrix_vector_product(
   Off_diagonal_matrix_vector_product_pt,&block_matrix,1);
 }
 
 
 //=============================================================================
 /// Preconditioner solve for the two plus one diagonal preconditioner: 
 /// Apply preconditoner to r and return z, so that P z = r, where
 /// P is the block diagonal matrix constructed from the original 
 /// linear system.
 //=============================================================================
 template<typename MATRIX> 
 void TwoPlusOneUpperTriangularPreconditioner<MATRIX>::
 preconditioner_solve(const DoubleVector& r, DoubleVector& z)
 {   
  // Solve (1,1) diagonal block system
  // Now apply the subsidiary block preconditioner that acts on the
  // "bottom right" 1x1 sub-system (only!). The subsidiary preconditioner 
  // will extract the relevant (1x1) "sub-vectors" from the "big" (3x1)
  // vector big_r and treat it as the rhs, r, of P z = r
  // where P is 1x1 block diagonal. Once the system is solved,
  // the result is automatically put back into the appropriate places 
  // of the "big" (3x1) vector z:
  Second_subsidiary_preconditioner_pt->preconditioner_solve(r,z);

  // Solve (0,1) off diagonal.
  // Substitute
  DoubleVector temp;
  DoubleVector z_1;
  this->get_block_vector(1,z,z_1);
  Off_diagonal_matrix_vector_product_pt->multiply(z_1,temp);

  // Get r_0 from the RHS and modify it accordingly.
  DoubleVector r_0;
  this->get_block_vector(0,r,r_0);
  r_0 -= temp;   

  
  // Block solve for first diagonal block. Since the associated subsidiary 
  // preconditioner is a block preconditioner itself, it will extract 
  // the required (2x1) block rhs from a "big" (3x1) rhs vector, big_r.
  // Therefore we first put the actual (2x1) rhs vector r_0 into the
  // "big" (3x1) vector big_r. 
  DoubleVector big_r(z.distribution_pt());
  this->return_block_vector(0,r_0,big_r);
    
  // Now apply the subsidiary block preconditioner that acts on the
  // "top left" 2x2 sub-system (only!). The subsidiary preconditioner 
  // will extract the relevant (2x1) "sub-vectors" from the "big" (3x1)
  // vector big_r and treat it as the rhs, r, of P z = r
  // where P is 2x2 block diagonal. Once the system is solved,
  // the result is automatically put back into the appropriate places 
  // of the "big" (3x1) vector z:
  First_subsidiary_preconditioner_pt->preconditioner_solve(big_r,z);
 }

 //================start_of_clean_up_for_two_plus_one_preconditioner==========
 /// The clean up function.
 //===========================================================================
 template<typename MATRIX> 
 void TwoPlusOneUpperTriangularPreconditioner<MATRIX>::clean_up_my_memory()
 {     
  // Delete diagonal preconditioners (approximate solvers)
  if(First_subsidiary_preconditioner_pt!=0)
   {
    delete First_subsidiary_preconditioner_pt;
    First_subsidiary_preconditioner_pt = 0;
   }
  if(Second_subsidiary_preconditioner_pt!=0)
   {
    delete Second_subsidiary_preconditioner_pt;
    Second_subsidiary_preconditioner_pt = 0;
   }
  if(Off_diagonal_matrix_vector_product_pt!=0)
   {
    delete  Off_diagonal_matrix_vector_product_pt;
    Off_diagonal_matrix_vector_product_pt = 0;
   }
 } // End of clean_up_my_memory function.

 ///////////////////////////////////////////////////////////////////////////////
 ///////////////////////////////////////////////////////////////////////////////
 ///////////////////////////////////////////////////////////////////////////////

//=========start_of_two_plus_three_upper_triangular_with_two_sub_class=========
/// \short Upper block triangular with a two level subsidiary preconditioner 
/// for a system with 5 dof types.
//=============================================================================
 template<typename MATRIX> 
 class TwoPlusThreeUpperTriangularWithTwoLevelSubsidiary 
  : public BlockPreconditioner<MATRIX>
 {
 
 public :
 
  /// Constructor.
  TwoPlusThreeUpperTriangularWithTwoLevelSubsidiary() :
   BlockPreconditioner<MATRIX>(),
   Off_diagonal_matrix_vector_products(0),
   First_subsidiary_preconditioner_pt(0),
   Second_subsidiary_preconditioner_pt(0)
   {
   }
 
  /// Destructor - delete the preconditioner matrices
  virtual ~TwoPlusThreeUpperTriangularWithTwoLevelSubsidiary()
   {
    this->clean_up_my_memory();
   }

  /// clean up the memory
  virtual void clean_up_my_memory();
 
  /// Broken copy constructor
  TwoPlusThreeUpperTriangularWithTwoLevelSubsidiary
  (const TwoPlusThreeUpperTriangularWithTwoLevelSubsidiary&) 
   { 
    BrokenCopy::broken_copy("SimpleUpperBlockTriangularPreconditioner");
   } 
 
  /// Broken assignment operator
  void operator=(const 
                 TwoPlusThreeUpperTriangularWithTwoLevelSubsidiary&) 
   {
    BrokenCopy::broken_assign(
     "TwoPlusThreeUpperTriangularWithTwoLevelSubsidiary");
   }
 
  /// Apply preconditioner to r
  void preconditioner_solve(const DoubleVector &r, DoubleVector &z);
 
  /// \short Setup the preconditioner 
  void setup();

  // This is put in to override the default behaviour of name hiding, which
  // "hides", but does not override, base class functions with the same name
  // as aderived class function even if the argument differ to allow for 
  // overloading. This is not a problem when using base class pointers.
  using Preconditioner::setup;

 private:  

  /// Matrix of matrix vector product operators for the off diagonals
  DenseMatrix<MatrixVectorProduct*> Off_diagonal_matrix_vector_products;

  /// \short Pointer to preconditioners/inexact solver
  /// for (0,0) block
  Preconditioner* First_subsidiary_preconditioner_pt;
  
  /// \short Pointer to preconditioners/inexact solver
  /// for (1,1) block
  Preconditioner* Second_subsidiary_preconditioner_pt;
 };

 //===start_of_setup_for_two_plus_three_upper_triangular_with_two_sub_class=====
 /// The setup function.
 //============================================================================
 template<typename MATRIX> 
 void TwoPlusThreeUpperTriangularWithTwoLevelSubsidiary<MATRIX>::setup()
 {
  // clean the memory
  this->clean_up_my_memory();

  // number of block types  
  unsigned n_dof_types = this->ndof_types();

#ifdef PARANOID
  // This preconditioner only works for 5 dof types
  if (n_dof_types!=5)
   {
    std::stringstream tmp;
    tmp << "This preconditioner only works for problems with 5 dof types\n"
        << "Yours has " << n_dof_types;
    throw OomphLibError(tmp.str(),
                        OOMPH_CURRENT_FUNCTION,
                        OOMPH_EXCEPTION_LOCATION);
   }
#endif


  // Combine into two major blocks, one containing dof types 0 and 1, the
  // final one dof types 2-4. In general we want
  // dof_to_block_map[dof_type] = block type
  Vector<unsigned> dof_to_block_map(n_dof_types);
  dof_to_block_map[0]=0;
  dof_to_block_map[1]=0;
  dof_to_block_map[2]=1;
  dof_to_block_map[3]=1;
  dof_to_block_map[4]=1;
  this->block_setup(dof_to_block_map);

  // Show that it worked ok:
  unsigned nblock_types = this->nblock_types();
  oomph_info << "Preconditioner has " << this->nblock_types() 
             << " block types\n";
  
  // Create the subsidiary preconditioners.
  {
   // First subsidiary precond is a block diagonal preconditioner itself.
   // Put in owns cope so block_prec_pt goes out of scope.
   UpperTriangular<CRDoubleMatrix>* block_prec_pt=
    new UpperTriangular<CRDoubleMatrix>;
   First_subsidiary_preconditioner_pt=block_prec_pt;

   // Turn first_sub into a subsidiary preconditioner, declaring which
   // of the five dof types in the present (master) preconditioner
   // correspond to the dof types in the subsidiary block preconditioner
   unsigned n_sub_dof_types=2;
   Vector<unsigned> dof_map(n_sub_dof_types);
   dof_map[0]=0;
   dof_map[1]=1;
   block_prec_pt->turn_into_subsidiary_block_preconditioner(this,dof_map);    
   // Perform setup
   block_prec_pt->setup(this->matrix_pt());
  }

  // Second subsidiary precond is a block diagonal preconditioner itself
  TwoPlusOneUpperTriangularPreconditioner<CRDoubleMatrix>* block_prec_pt=
   new TwoPlusOneUpperTriangularPreconditioner<CRDoubleMatrix>;
  Second_subsidiary_preconditioner_pt=block_prec_pt;

  // Turn second_sub into a subsidiary preconditioner, declaring which
  // of the five dof types in the present (master) preconditioner
  // correspond to the dof types in the subsidiary block preconditioner
  unsigned n_sub_dof_types=3;
  Vector<unsigned> dof_map(n_sub_dof_types);
  dof_map[0]=2;
  dof_map[1]=3;
  dof_map[2]=4;
  block_prec_pt->turn_into_subsidiary_block_preconditioner(this,dof_map);    
  // Perform setup
  block_prec_pt->setup(this->matrix_pt());

  // storage for the off diagonal matrix vector products
  Off_diagonal_matrix_vector_products.resize(nblock_types,nblock_types,0);
  // next setup the off diagonal mat vec operators
  {
   // Get the block
   CRDoubleMatrix block_matrix = this->get_block(0,1);

   // Copy the block into a "multiplier" class. If trilinos is being
   // used this should also be faster than oomph-lib's multiphys.
   Off_diagonal_matrix_vector_products(0,1) = new MatrixVectorProduct();

   this->setup_matrix_vector_product(
    Off_diagonal_matrix_vector_products(0,1),&block_matrix,1);
  }
 
 }

 //=============================================================================
 /// Preconditioner solve for the one plus four upper triangular with 
 /// subsisdiary  preconditioner: 
 /// Apply preconditioner to r and return z, so that P z = r, where
 /// P is the block diagonal matrix constructed from the original 
 /// linear system.
 //=============================================================================
 template<typename MATRIX> 
 void TwoPlusThreeUpperTriangularWithTwoLevelSubsidiary<MATRIX>::
 preconditioner_solve(const DoubleVector& r, DoubleVector& z)
 {
  // Solve (1,1) diagonal block system
  // Now apply the subsidiary block preconditioner that acts on the
  // "bottom right" 3x3 sub-system (only!). The subsidiary preconditioner 
  // will extract the relevant (3x1) "sub-vectors" from the "big" (5x1)
  // vector big_r and treat it as the rhs, r, of P z = r
  // where P is 3x3 block diagonal. Once the system is solved,
  // the result is automatically put back into the appropriate places 
  // of the "big" (5x1) vector z:
  Second_subsidiary_preconditioner_pt->preconditioner_solve(r,z);
    
  // Get number of blocks
  unsigned n_block = this->nblock_types();

  // Split up rhs vector into sub-vectors, re-arranged to match
  // the matrix blocks
  Vector<DoubleVector> block_r;
  this->get_block_vectors(r,block_r);

  // Create storage for solution of block solves
  Vector<DoubleVector> block_z(n_block);

  // Solve (0,1) off diagonal.
  // Substitute
  this->get_block_vectors(z,block_z);
  DoubleVector temp;
  Off_diagonal_matrix_vector_products(0,1)->multiply(block_z[1],temp);
  block_r[0] -= temp;   

  // Block solve for first diagonal block. Since the associated subsidiary 
  // preconditioner is a block preconditioner itself, it will extract 
  // the required (2x1) block rhs from a "big" (5x1) rhs vector, big_r.
  // Therefore we first put the actual (2x1) rhs vector block_r[0] into the
  // "big" (5x1) vector big_r. 
  DoubleVector big_r(z.distribution_pt());
  this->return_block_vector(0,block_r[0],big_r);
     
  // Now apply the subsidiary block preconditioner that acts on the
  // "upper left" 2x2 sub-system (only!). The subsidiary preconditioner 
  // will extract the relevant (2x1) "sub-vectors" from the "big" (5x1)
  // vector big_r and treat it as the rhs, r, of P z = r
  // where P is 2x2 block diagonal. Once the system is solved,
  // the result is automatically put back into the appropriate places 
  // of the "big" (5x1) vector z:
  First_subsidiary_preconditioner_pt->preconditioner_solve(big_r,z);
 }

 //====start_of_clean_up_for_two_plus_three_upper_triangular_with_sub_class=====
 /// The clean up function.
 //============================================================================
 template<typename MATRIX> 
 void TwoPlusThreeUpperTriangularWithTwoLevelSubsidiary<MATRIX>::
 clean_up_my_memory()
 {     
  // Delete anything in Off_diagonal_matrix_vector_products
  for(unsigned i=0,ni=Off_diagonal_matrix_vector_products.nrow();i<ni;i++)
   {
    for(unsigned j=0,nj=Off_diagonal_matrix_vector_products.ncol();j<nj;j++)
     {
      if(Off_diagonal_matrix_vector_products(i,j) != 0)
       {
        delete Off_diagonal_matrix_vector_products(i,j);
        Off_diagonal_matrix_vector_products(i,j) = 0;
       }
     }
   }
  //Clean up subsidiary preconditioners.
  if(First_subsidiary_preconditioner_pt!=0)
   {
    delete First_subsidiary_preconditioner_pt;
    First_subsidiary_preconditioner_pt = 0;
   }
  if(Second_subsidiary_preconditioner_pt!=0)
   {
    delete Second_subsidiary_preconditioner_pt;
    Second_subsidiary_preconditioner_pt = 0;
   }
 } // End of clean_up_my_memory function.

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

//=============start_of_two_plus_three_upper_triangular_with_replace_class=====
/// \short Block diagonal preconditioner for system with 5 dof types
/// assembled into a 2x2 block system, with (0,0) block containing
/// the first two dof types, the (1,1) block the remaining dof types.
/// The blocks are solved by upper block triangular preconditioners.
/// However, the overall system is modified by replacing all off-diagonal 
/// blocks by zero matrices, so the preconditioner again behaves like a 5x5
/// block diagonal preconditioner.
//=============================================================================
 template<typename MATRIX> 
 class TwoPlusThreeUpperTriangularWithReplace : 
  public BlockPreconditioner<MATRIX>
 {
  
 public :
  
  /// Constructor for TwoPlusThreeUpperTriangularWithReplace
  TwoPlusThreeUpperTriangularWithReplace() : 
   BlockPreconditioner<MATRIX>(),
   First_subsidiary_preconditioner_pt(0),
   Second_subsidiary_preconditioner_pt(0)
   {
   } // end_of_constructor
  
  
  /// Destructor - delete the diagonal solvers (subsidiary preconditioners)
  ~TwoPlusThreeUpperTriangularWithReplace()
   {
    this->clean_up_my_memory();
   }

  /// Clean up the memory
  virtual void clean_up_my_memory();

  /// Broken copy constructor
  TwoPlusThreeUpperTriangularWithReplace
  (const TwoPlusThreeUpperTriangularWithReplace&) 
   { 
    BrokenCopy::
     broken_copy("TwoPlusThreeUpperTriangularWithReplace");
   } 
  
  /// Broken assignment operator
  void operator=(const TwoPlusThreeUpperTriangularWithReplace&) 
   {
    BrokenCopy::
     broken_assign("TwoPlusThreeUpperTriangularWithReplace");
   }
  
  /// Apply preconditioner to r, i.e. return z such that P z = r
  void preconditioner_solve(const DoubleVector &r, DoubleVector &z);
  
  /// \short Setup the preconditioner 
  virtual void setup();
  
 private :
  /// \short Pointer to preconditioners/inexact solver
  /// for (0,0) block
  Preconditioner* First_subsidiary_preconditioner_pt;
  
  /// \short Pointer to preconditioners/inexact solver
  /// for (1,1) block
  Preconditioner* Second_subsidiary_preconditioner_pt;

  /// Matrix of matrix vector product operators for the off diagonals.
  DenseMatrix<MatrixVectorProduct*> Off_diagonal_matrix_vector_products;

  // Matrix of pointers to replacement matrx blocks
  DenseMatrix<CRDoubleMatrix*> Replacement_matrix_pt;
  
 };
 
 //==start_of_setup_for_two_plus_three_upper_triangular_with_replace===========
 /// The setup function.
 //============================================================================
 template<typename MATRIX> 
 void TwoPlusThreeUpperTriangularWithReplace<MATRIX>::setup()
 {
  // Clean up memory.
  this->clean_up_my_memory();

  unsigned n_dof_types = this->ndof_types();
#ifdef PARANOID
  // This preconditioner only works for 5 dof types
  if (n_dof_types!=5)
   {
    std::stringstream tmp;
    tmp << "This preconditioner only works for problems with 5 dof types\n"
        << "Yours has " << n_dof_types;
    throw OomphLibError(tmp.str(),
                        OOMPH_CURRENT_FUNCTION,
                        OOMPH_EXCEPTION_LOCATION);
   }
#endif
   
  // Call block setup. There is no argument as the replacement only works
  // with an identity mapping, which is the default. In order to deal with
  // the off diagonals, which is required to be a single block concatenation
  // is used.
  this->block_setup();

  // Storage for the off diagonal matrix vector products.
  Replacement_matrix_pt.resize(n_dof_types,n_dof_types,0);

  // Copy dofs and null any off diagonals.
  for(unsigned i=0;i<5;i++)
   {
    for(unsigned j=0;j<5;j++)
     {
      if(i!=j)
       {
        // Get the block's (row!) distribution.
        LinearAlgebraDistribution* block_dist_pt=
         this->block_distribution_pt(i);
         
        // Number of rows in block matrix (i,j).
        unsigned long block_nrow = block_dist_pt->nrow_local();

        // Number of columns in block matrix (i,j) is the same as the number
        // of rows in block matrix (j,i).
        // We use the actual nrow, not the local one here as this block may
        // need to be gotten from another processor.
        unsigned long block_ncol = this->block_distribution_pt(j)->nrow();

        // Storage for replacement matrices:
        // Values
        Vector<double> replacement_value(0);
        // Column index
        Vector<int> replacement_column_index(0);
        // Row start
        Vector<int> replacement_row_start;

        // Need one row start per row, and one for the nnz, all of which are 0.
        replacement_row_start.resize(block_nrow+1,0);

        Replacement_matrix_pt(i,j)=
         new CRDoubleMatrix(block_dist_pt, block_ncol, replacement_value,
                            replacement_column_index, replacement_row_start);

        // Replace.
        this->set_replacement_dof_block(i,j,Replacement_matrix_pt(i,j));

       }
     }// end for loop of j
   }// end for loop of i
  
  // First subsidiary precond setup, put in own block to limit scope.
  {
   // Second subsidiary precond is a block diagonal preconditioner itself
   UpperTriangular<CRDoubleMatrix>* block_prec_pt=
    new UpperTriangular<CRDoubleMatrix>;
   First_subsidiary_preconditioner_pt=block_prec_pt;
  
   // Turn it into a subsidiary preconditioner, declaring which
   // of the five dof types in the present (master) preconditioner
   // correspond to the dof types in the subsidiary block preconditioner
   unsigned n_sub_dof_types=2;
   Vector<unsigned> dof_map(n_sub_dof_types);
   dof_map[0]=0;
   dof_map[1]=1;
   block_prec_pt->turn_into_subsidiary_block_preconditioner(this,dof_map);
    // Perform setup
   block_prec_pt->setup(this->matrix_pt());
  }

  // Second subsidiary precond is a block diagonal preconditioner itself
  UpperTriangular<CRDoubleMatrix>* block_prec_pt=
   new UpperTriangular<CRDoubleMatrix>;
  Second_subsidiary_preconditioner_pt=block_prec_pt;
  
  // number of block types  
  unsigned nblock_types = 2;
  // Storage for the off diagonal matrix vector products.
  Off_diagonal_matrix_vector_products.resize(nblock_types,nblock_types,0);

  // Turn it into a subsidiary preconditioner, declaring which
  // of the five dof types in the present (master) preconditioner
  // correspond to the dof types in the subsidiary block preconditioner
  unsigned n_sub_dof_types=3;
  Vector<unsigned> dof_map(n_sub_dof_types);
  dof_map[0]=2;
  dof_map[1]=3;
  dof_map[2]=4;
  block_prec_pt->turn_into_subsidiary_block_preconditioner(this,dof_map);
  
  // Perform setup
  block_prec_pt->setup(this->matrix_pt());

  // Next setup the off diagonal mat vec operators:

  // Data type indicating which blocks from the preconditioner matrix we want
  VectorMatrix<BlockSelector> required_block(2,3);
  for(unsigned i=0;i<2;i++)
   {
    for(unsigned j=0;j<3;j++)
     {
      required_block[i][j].select_block(i,j+2,true);   
     }// End for over j (x)
   }// End for loop over i (y)
  
   
  // Get the block
  CRDoubleMatrix block_matrix = this->get_concatenated_block(required_block);

  // Copy the block into a "multiplier" class. If trilinos is being
  // used this should also be faster than oomph-lib's multiphys.
  Off_diagonal_matrix_vector_products(0,1) = new MatrixVectorProduct();

  this->setup_matrix_vector_product(
   Off_diagonal_matrix_vector_products(0,1),&block_matrix,dof_map);
   
 }

 
 //=============================================================================
 /// Preconditioner solve for the two plus three upper triangular with 
 /// replacement preconditioner: 
 /// Apply preconditoner to r and return z, so that P r = z, where
 /// P is the block diagonal matrix constructed from the original 
 /// linear system.
 //=============================================================================
 template<typename MATRIX> 
 void TwoPlusThreeUpperTriangularWithReplace<MATRIX>::
 preconditioner_solve(const DoubleVector& r, DoubleVector& z)
 {   
  // Now apply the subsidiary block preconditioner that acts on the
  // "bottom right" 3x3 sub-system (only!). The subsidiary preconditioner 
  // will extract the relevant (3x1) "sub-vectors" from the "big" (5x1)
  // vector big_r and treat it as the rhs, r, of P z = r
  // where P is 3x3 block diagonal.
  Second_subsidiary_preconditioner_pt->preconditioner_solve(r,z);
   
  // Split up rhs vector into sub-vectors, re-arranged to match
  // the matrix blocks
  DoubleVector r_0;
  unsigned block0_size=2;
  Vector<unsigned> block0_vec_number(block0_size);
  for(unsigned i=0;i<block0_size;i++)
   {
    block0_vec_number[i]=i;
   }
  this->get_concatenated_block_vector(block0_vec_number,r,r_0);
     
  DoubleVector z_1;
  unsigned block1_size=3;
  Vector<unsigned> block1_vec_number(block1_size);
  for(unsigned i=0;i<block1_size;i++)
   {
    block1_vec_number[i]=i+2;
   }
  this->get_concatenated_block_vector(block1_vec_number,z,z_1);

  // Multiply by (0,1) off diagonal.
  DoubleVector temp;
  Off_diagonal_matrix_vector_products(0,1)->multiply(z_1,temp);
  r_0 -= temp;

  // Block solve for first diagonal block. Since the associated subsidiary 
  // preconditioner is a block preconditioner itself, it will extract 
  // the required (2x1) block rhs from a "big" (5x1) rhs vector, big_r.
  // Therefore we first put the actual (2x1) rhs vector block_r[0] into the
  // "big" (5x1) vector big_r. 
  DoubleVector big_r(z.distribution_pt());
  this->return_concatenated_block_vector(block0_vec_number,r_0,big_r);
    
  // Now apply the subsidiary block preconditioner that acts on the
  // "top left" 2x2 sub-system (only!). The subsidiary preconditioner 
  // will extract the relevant (2x1) "sub-vectors" from the "big" (5x1)
  // vector big_r and treat it as the rhs, r, of P z = r
  // where P is 2x2 block diagonal. Once the system is solved,
  // the result is automatically put back into the appropriate places 
  // of the "big" (5x1) vector z:
  First_subsidiary_preconditioner_pt->preconditioner_solve(big_r,z);
  
 }

 //==start_of_clean_up_for_two_plus_three_upper_triangular_with_replace========
 /// The clean up function.
 //============================================================================
 template<typename MATRIX> 
 void TwoPlusThreeUpperTriangularWithReplace<MATRIX>:: 
 clean_up_my_memory()
 {     
  // Clean up subsidiary preconditioners.
  if(First_subsidiary_preconditioner_pt!=0)
   {
    delete First_subsidiary_preconditioner_pt;
    First_subsidiary_preconditioner_pt = 0;
   }
  if(Second_subsidiary_preconditioner_pt!=0)
   {
    delete Second_subsidiary_preconditioner_pt;
    Second_subsidiary_preconditioner_pt = 0;
   }

  // Clean up the replacement matricies.
  for(unsigned i=0,ni=Replacement_matrix_pt.nrow();i<ni;i++)
   {
    for(unsigned j=0,nj=Replacement_matrix_pt.ncol();j<nj;j++)
     {
      if(Replacement_matrix_pt(i,j)!=0)
       {
        delete Replacement_matrix_pt(i,j);
        Replacement_matrix_pt(i,j)=0;
       }
     } // End loop over j.
   } // End loop over i.
    
  // Clean up the off diag matrix products.
  for(unsigned i=0,ni=Off_diagonal_matrix_vector_products.nrow();i<ni;i++)
   {
    for(unsigned j=0,nj=Off_diagonal_matrix_vector_products.ncol();j<nj;j++)
     {
      if(Off_diagonal_matrix_vector_products(i,j) != 0)
       {
        delete Off_diagonal_matrix_vector_products(i,j);
        Off_diagonal_matrix_vector_products(i,j) = 0;
       }
     }
   }
 } // End of clean_up_my_memory function.

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

//====================start_of_one_plus_one_class=============================
/// \short Block diagonal preconditioner for system with 2 dof types
/// assembled into a 2x2 block system, with (0,0) block containing
/// the first dof types, the (1,1) block containing the last one.
/// Both blocks are solved by subsidiary upper triangular block 
/// preconditioners.
/// This class is no longer used anywhere.
//=============================================================================
 template<typename MATRIX> 
 class OnePlusOneUpperTriangularPreconditioner : 
  public BlockPreconditioner<MATRIX>
 {
  
 public :
  
  /// Constructor for OnePlusOneUpperTriangularPreconditioner
  OnePlusOneUpperTriangularPreconditioner() : 
   BlockPreconditioner<MATRIX>(),
   First_subsidiary_preconditioner_pt(0),
   Second_subsidiary_preconditioner_pt(0),
   Off_diagonal_matrix_vector_product_pt(0)
   {
   } // end_of_constructor
  
  
  /// Destructor - delete the diagonal solvers (subsidiary preconditioners)
  ~OnePlusOneUpperTriangularPreconditioner()
   {
    this->clean_up_my_memory();
   }

  virtual void clean_up_my_memory();
     
  /// Broken copy constructor
  OnePlusOneUpperTriangularPreconditioner
  (const OnePlusOneUpperTriangularPreconditioner&) 
   { 
    BrokenCopy::broken_copy("OnePlusOneUpperTriangularPreconditioner");
   } 
  
  /// Broken assignment operator
  void operator=(const OnePlusOneUpperTriangularPreconditioner&) 
   {
    BrokenCopy::broken_assign("OnePlusOneUpperTriangularPreconditioner");
   }
  
  /// Apply preconditioner to r, i.e. return z such that P z = r
  void preconditioner_solve(const DoubleVector &r, DoubleVector &z);
  
  /// \short Setup the preconditioner 
  void setup();

  // This is put in to override the default behaviour of name hiding, which
  // "hides", but does not override, base class functions with the same name
  // as aderived class function even if the argument differ to allow for 
  // overloading. This is not a problem when using base class pointers.
  using Preconditioner::setup;


 private :
  
  /// \short Pointer to preconditioners/inexact solver
  /// for (0,0) block
  Preconditioner* First_subsidiary_preconditioner_pt;
  
  /// \short Pointer to preconditioners/inexact solver
  /// for (1,1) block
  Preconditioner* Second_subsidiary_preconditioner_pt;
  
  /// Matrix vector product operators for the off diagonals.
  MatrixVectorProduct* Off_diagonal_matrix_vector_product_pt;
 };

 //================start_of_setup_for_two_plus_one_preconditioner=============
 /// The setup function.
 //===========================================================================
 template<typename MATRIX> 
 void OnePlusOneUpperTriangularPreconditioner<MATRIX>::setup()
 {
  // Clean up memory.
  this->clean_up_my_memory();

  unsigned n_dof_types = this->ndof_types();
#ifdef PARANOID
  // This preconditioner only works for 2 dof types
  if (n_dof_types!=2)
   {
    std::stringstream tmp;
    tmp << "This preconditioner only works for problems with 2 dof types\n"
        << "Yours has " << n_dof_types;
    throw OomphLibError(tmp.str(),
                        OOMPH_CURRENT_FUNCTION,
                        OOMPH_EXCEPTION_LOCATION);
   }
#endif

  // The dof types are the same as the desired blocking.
  this->block_setup();

  // Create the subsidiary preconditioners
  //--------------------------------------
  {
   // Limit scope of variables such as block_prec_pt
   // First one:
   UpperTriangular<CRDoubleMatrix>* block_prec_pt=
    new UpperTriangular<CRDoubleMatrix>;
   First_subsidiary_preconditioner_pt=block_prec_pt;
  
   // Turn it into a subsidiary preconditioner, declaring which
   // of the three dof types in the present (master) preconditioner
   // correspond to the dof types in the subsidiary block preconditioner
   unsigned n_sub_dof_types=1;

   Vector<unsigned> dof_map(n_sub_dof_types);
   dof_map[0] = 0;
   block_prec_pt->turn_into_subsidiary_block_preconditioner(this,dof_map);
  
   // Perform setup
   block_prec_pt->setup(this->matrix_pt());
  }

  // Second one:
  UpperTriangular<CRDoubleMatrix>* block_prec_pt=
   new UpperTriangular<CRDoubleMatrix>;
  Second_subsidiary_preconditioner_pt=block_prec_pt;
  
  // Turn it into a subsidiary preconditioner, declaring which
  // of the three dof types in the present (master) preconditioner
  // correspond to the dof types in the subsidiary block preconditioner i.e.
  // arguments: dof_map[doc_in_subdiary]=dof_in_present
  unsigned n_sub_dof_types=1;

  Vector<unsigned> dof_map(n_sub_dof_types);
  dof_map[0] = 1;
  block_prec_pt->turn_into_subsidiary_block_preconditioner(this,dof_map);
  
  // Perform setup
  block_prec_pt->setup(this->matrix_pt()); 


  // Set up off diagonal matrix vector product operator.
  // Get the block
  CRDoubleMatrix block_matrix = this->get_block(0,1);
  Off_diagonal_matrix_vector_product_pt = new MatrixVectorProduct();
  this->setup_matrix_vector_product(
   Off_diagonal_matrix_vector_product_pt,&block_matrix,1);
 }
 
 
 //=============================================================================
 /// Preconditioner solve for the two plus one diagonal preconditioner: 
 /// Apply preconditoner to r and return z, so that P z = r, where
 /// P is the block diagonal matrix constructed from the original 
 /// linear system.
 //=============================================================================
 template<typename MATRIX> 
 void OnePlusOneUpperTriangularPreconditioner<MATRIX>::
 preconditioner_solve(const DoubleVector& r, DoubleVector& z)
 {   
  // Solve (1,1) diagonal block system
  // Now apply the subsidiary block preconditioner that acts on the
  // "bottom right" 1x1 sub-system (only!). The subsidiary preconditioner 
  // will extract the relevant (1x1) "sub-vectors" from the "big" (2x1)
  // vector big_r and treat it as the rhs, r, of P z = r
  // where P is 1x1 block diagonal. Once the system is solved,
  // the result is automatically put back into the appropriate places 
  // of the "big" (2x1) vector z:
  Second_subsidiary_preconditioner_pt->preconditioner_solve(r,z);

  // Solve (0,1) off diagonal.
  // Substitute
  DoubleVector temp;
  DoubleVector z_1;
  this->get_block_vector(1,z,z_1);
  Off_diagonal_matrix_vector_product_pt->multiply(z_1,temp);

  // Get r_0 from the RHS and modify it accordingly.
  DoubleVector r_0;
  this->get_block_vector(0,r,r_0);
  r_0 -= temp;   

  
  // Block solve for first diagonal block. Since the associated subsidiary 
  // preconditioner is a block preconditioner itself, it will extract 
  // the required (1x1) block rhs from a "big" (2x1) rhs vector, big_r.
  // Therefore we first put the actual (1x1) rhs vector r_0 into the
  // "big" (2x1) vector big_r. 
  DoubleVector big_r(z.distribution_pt());
  this->return_block_vector(0,r_0,big_r);
    
  // Now apply the subsidiary block preconditioner that acts on the
  // "top left" 1x1 sub-system (only!). The subsidiary preconditioner 
  // will extract the relevant (1x1) "sub-vectors" from the "big" (2x1)
  // vector big_r and treat it as the rhs, r, of P z = r
  // where P is 1x1 block diagonal. Once the system is solved,
  // the result is automatically put back into the appropriate places 
  // of the "big" (2x1) vector z:
  First_subsidiary_preconditioner_pt->preconditioner_solve(big_r,z);
 }

 //================start_of_clean_up_for_two_plus_one_preconditioner==========
 /// The clean up function.
 //===========================================================================
 template<typename MATRIX> 
 void OnePlusOneUpperTriangularPreconditioner<MATRIX>::clean_up_my_memory()
 {     
  // Delete diagonal preconditioners (approximate solvers)
  if(First_subsidiary_preconditioner_pt!=0)
   {
    delete First_subsidiary_preconditioner_pt;
    First_subsidiary_preconditioner_pt = 0;
   }
  if(Second_subsidiary_preconditioner_pt!=0)
   {
    delete Second_subsidiary_preconditioner_pt;
    Second_subsidiary_preconditioner_pt = 0;
   }
  if(Off_diagonal_matrix_vector_product_pt!=0)
   {
    delete  Off_diagonal_matrix_vector_product_pt;
    Off_diagonal_matrix_vector_product_pt = 0;
   }
 } // End of clean_up_my_memory function.

 ///////////////////////////////////////////////////////////////////////////////
 ///////////////////////////////////////////////////////////////////////////////
 ///////////////////////////////////////////////////////////////////////////////

//==================start_of_coarse_two_plus_two_plus_one_class================
/// \short Block diagonal preconditioner for system with 5 dof types
/// assembled into a 2x2 block system, with (0,0) block containing
/// the first two dof types, the (1,1) block containing the remaining,
/// (1,1) block is itself solved by a (2x2) block preconditioner!
//=============================================================================
 template<typename MATRIX> 
 class CoarseTwoPlusTwoPlusOne : 
  public BlockPreconditioner<MATRIX>
 {
  
 public :
  
  /// Constructor for CoarseTwoPlusTwoPlusOne
  CoarseTwoPlusTwoPlusOne() : 
   BlockPreconditioner<MATRIX>(),
   First_subsidiary_preconditioner_pt(0),
   Second_subsidiary_preconditioner_pt(0)
   {
   } // end_of_constructor
  
  
  /// Destructor - delete the diagonal solvers (subsidiary preconditioners)
  ~CoarseTwoPlusTwoPlusOne()
   {
    this->clean_up_my_memory();
   }    
  
  /// clean up the memory
  virtual void clean_up_my_memory();

  /// Broken copy constructor
  CoarseTwoPlusTwoPlusOne
  (const CoarseTwoPlusTwoPlusOne&) 
   { 
    BrokenCopy::broken_copy(
     "CoarseTwoPlusTwoPlusOne");
   } 
  
  /// Broken assignment operator
  void operator=(const 
                 CoarseTwoPlusTwoPlusOne&) 
   {
    BrokenCopy::broken_assign(
     "CoarseTwoPlusTwoPlusOne");
   }
  
  /// Apply preconditioner to r, i.e. return z such that P z = r
  void preconditioner_solve(const DoubleVector &r, DoubleVector &z);
  
  /// \short Setup the preconditioner 
  virtual void setup();
  
 private :
  
  /// \short Pointer to preconditioners/inexact solver
  /// for (0,0) block
  Preconditioner* First_subsidiary_preconditioner_pt;
  
  /// \short Pointer to preconditioners/inexact solver
  /// for (1,1) block
  Preconditioner* Second_subsidiary_preconditioner_pt;

  // Matrix of pointers to replacement matrx blocks
  DenseMatrix<CRDoubleMatrix*> Replacement_matrix_pt;

  /// Matrix of matrix vector product operators for the off diagonals.
  DenseMatrix<MatrixVectorProduct*> Off_diagonal_matrix_vector_products;
 };

 //===============start_of_setup_for_coarse_two_plus_two_plus_one=============
 /// The setup function.
 //===========================================================================
 template<typename MATRIX> 
 void CoarseTwoPlusTwoPlusOne<MATRIX>::setup()
 {
  // Clean up memory
  this->clean_up_my_memory();


#ifdef PARANOID

  // This preconditioner only works for 5 dof types
  unsigned n_dof_types = this->ndof_types();
  if (n_dof_types!=5)
   {
    std::stringstream tmp;
    tmp << "This preconditioner only works for problems with 5 dof types\n"
        << "Yours has " << n_dof_types;
    throw OomphLibError(tmp.str(),
                        OOMPH_CURRENT_FUNCTION,
                        OOMPH_EXCEPTION_LOCATION);
   }
#endif

  // Setup block.
  this->block_setup();

  // Replacement.
  Replacement_matrix_pt.resize(5,5,0);
  for(unsigned i=0;i<5;i++)
   {
    for(unsigned j=0;j<5;j++)
     {
      if(i!=j)
       {
        // Get the block's (row!) distribution.
        LinearAlgebraDistribution* block_dist_pt=
         this->block_distribution_pt(i);
         
        // Number of rows in block matrix (i,j).
        unsigned long block_nrow = block_dist_pt->nrow_local();

        // Number of columns in block matrix (i,j) is the same as the number
        // of rows in block matrix (j,i).
        // We use the actual nrow, not the local one here as this block may
        // need to be gotten from another processor.
        unsigned long block_ncol = this->block_distribution_pt(j)->nrow();

        // Storage for replacement matrices:
        // Values
        Vector<double> replacement_value(0);
        // Column index
        Vector<int> replacement_column_index(0);
        // Row start
        Vector<int> replacement_row_start;

        // Need one row start per row, and one for the nnz, all of which are 0.
        replacement_row_start.resize(block_nrow+1,0);

        Replacement_matrix_pt(i,j)=
         new CRDoubleMatrix(block_dist_pt, block_ncol, replacement_value,
                            replacement_column_index, replacement_row_start);

        // Replace.
        this->set_replacement_dof_block(i,j,Replacement_matrix_pt(i,j));
       }// End of if
     }// End of j loop.
   }// End of i loop.

  // Create the subsidiary preconditioners
  //--------------------------------------

  {
   // First subsidiary precond is a block diagonal preconditioner itself.
   // Put in owns cope so block_prec_pt goes out of scope.
   UpperTriangular<CRDoubleMatrix>* block_prec_pt=
    new UpperTriangular<CRDoubleMatrix>;
   First_subsidiary_preconditioner_pt=block_prec_pt;

   // Turn first_sub into a subsidiary preconditioner, declaring which
   // of the five dof types in the present (master) preconditioner
   // correspond to the dof types in the subsidiary block preconditioner
   unsigned n_sub_dof_types=2;
   Vector<unsigned> dof_map(n_sub_dof_types);
   dof_map[0]=0;
   dof_map[1]=1;
   block_prec_pt->turn_into_subsidiary_block_preconditioner(this,dof_map);    
   // Perform setup
   block_prec_pt->setup(this->matrix_pt());
  }

  // Second subsidiary precond is a block diagonal preconditioner itself
  UpperTriangular<CRDoubleMatrix>* block_prec_pt=
   new UpperTriangular<CRDoubleMatrix>;
  Second_subsidiary_preconditioner_pt=block_prec_pt;
  unsigned n_sub_dof_types=2;
  Vector<Vector<unsigned> > doftype_coarsen_map_coarse(n_sub_dof_types);
  doftype_coarsen_map_coarse[0].resize(2);
  doftype_coarsen_map_coarse[1].resize(1);
  doftype_coarsen_map_coarse[0][0]=0;
  doftype_coarsen_map_coarse[0][1]=1;
  doftype_coarsen_map_coarse[1][0]=2;

  Vector<unsigned> doftype_in_master_coarse(3);
  doftype_in_master_coarse[0]=2;
  doftype_in_master_coarse[1]=3;
  doftype_in_master_coarse[2]=4;
   
  block_prec_pt->
   turn_into_subsidiary_block_preconditioner(this,doftype_in_master_coarse,
                                             doftype_coarsen_map_coarse);
  // Perform setup
  block_prec_pt->setup(this->matrix_pt());

  // Set up off diagonal
  // number of block types  
  unsigned nblock_types = 2;
  // Storage for the off diagonal matrix vector products.
  Off_diagonal_matrix_vector_products.resize(nblock_types,nblock_types,0);
  // Data type indicating which blocks from the preconditioner matrix we want
  VectorMatrix<BlockSelector> required_block(2,3);
  for(unsigned i=0;i<3;i++)
   {
    for(unsigned j=0;j<2;j++)
     {
      required_block[j][i].select_block(j,i+2,true);   
     }// End for over j (y)
   }// End for loop over i (x)
  
   
  // Get the block
  CRDoubleMatrix block_matrix = this->get_concatenated_block(required_block);

  // Copy the block into a "multiplier" class. If trilinos is being
  // used this should also be faster than oomph-lib's multiphys.
  Off_diagonal_matrix_vector_products(0,1) = new MatrixVectorProduct();

  n_sub_dof_types=3;
  Vector<unsigned> dof_map(n_sub_dof_types);
  dof_map[0]=2;
  dof_map[1]=3;
  dof_map[2]=4;
  block_prec_pt->turn_into_subsidiary_block_preconditioner(this,dof_map);

  this->setup_matrix_vector_product(
   Off_diagonal_matrix_vector_products(0,1),&block_matrix,dof_map);
 }// End of setup
 
 
 //=============================================================================
 /// Preconditioner solve for the coarse one plus two plus two with subsidiary 
 /// and replacement preconditioner: 
 /// Apply preconditoner to r and return z, so that P z = r, where
 /// P is the block diagonal matrix constructed from the original 
 /// linear system.
 //=============================================================================
 template<typename MATRIX> 
 void CoarseTwoPlusTwoPlusOne<MATRIX>::
 preconditioner_solve(const DoubleVector& r, DoubleVector& z)
 {   
  // Now apply the subsidiary block preconditioner that acts on the
  // "bottom right" 3x3 sub-system (only!). The subsidiary preconditioner 
  // will extract the relevant (4x1) "sub-vectors" from the "big" (5x1)
  // vector big_r and treat it as the rhs, r, of P z = r
  // where P is 3x3 block diagonal.
  Second_subsidiary_preconditioner_pt->preconditioner_solve(r,z);
   
  // Split up rhs vector into sub-vectors, re-arranged to match
  // the matrix blocks
  DoubleVector r_0;
  unsigned block0_size=2;
  Vector<unsigned> block0_vec_number(block0_size);
  for(unsigned i=0;i<block0_size;i++)
   {
    block0_vec_number[i]=i;
   }
  this->get_concatenated_block_vector(block0_vec_number,r,r_0);
     
  DoubleVector z_1;
  unsigned block1_size=3;
  Vector<unsigned> block1_vec_number(block1_size);
  for(unsigned i=0;i<block1_size;i++)
   {
    block1_vec_number[i]=i+2;
   }
  this->get_concatenated_block_vector(block1_vec_number,z,z_1);

  // Multiply by (0,1) off diagonal.
  DoubleVector temp;
  Off_diagonal_matrix_vector_products(0,1)->multiply(z_1,temp);
  r_0 -= temp;

  // Block solve for first diagonal block. Since the associated subsidiary 
  // preconditioner is a block preconditioner itself, it will extract 
  // the required (2x1) block rhs from a "big" (4x1) rhs vector, big_r.
  // Therefore we first put the actual (2x1) rhs vector block_r[0] into the
  // "big" (4x1) vector big_r. 
  DoubleVector big_r(z.distribution_pt());
  this->return_concatenated_block_vector(block0_vec_number,r_0,big_r);
    
  // Now apply the subsidiary block preconditioner that acts on the
  // "top left" 2x2 sub-system (only!). The subsidiary preconditioner 
  // will extract the relevant (2x1) "sub-vectors" from the "big" (4x1)
  // vector big_r and treat it as the rhs, r, of P z = r
  // where P is 2x2 block diagonal. Once the system is solved,
  // the result is automatically put back into the appropriate places 
  // of the "big" (4x1) vector z:
  First_subsidiary_preconditioner_pt->preconditioner_solve(big_r,z);
 }// End of solve
 
 //=============start_of_clean_up_for_coarse_one_plus_two_plus_two===========
/// The clean up function.
//===========================================================================
 template<typename MATRIX> 
 void CoarseTwoPlusTwoPlusOne<MATRIX>::
 clean_up_my_memory()
 {     
  // Delete diagonal preconditioners (approximate solvers)
  if(First_subsidiary_preconditioner_pt!=0)
   {
    delete First_subsidiary_preconditioner_pt;
    First_subsidiary_preconditioner_pt = 0;
   }
  if(Second_subsidiary_preconditioner_pt!=0)
   {
    delete Second_subsidiary_preconditioner_pt;
    Second_subsidiary_preconditioner_pt = 0;
   }

  // Clean up the replacement matricies.
  for(unsigned i=0,ni=Replacement_matrix_pt.nrow();i<ni;i++)
   {
    for(unsigned j=0,nj=Replacement_matrix_pt.ncol();j<nj;j++)
     {
      if(Replacement_matrix_pt(i,j)!=0)
       {
        delete Replacement_matrix_pt(i,j);
        Replacement_matrix_pt(i,j)=0;
       }
     } // End loop over j.
   } // End loop over i.

  // Delete anything in Off_diagonal_matrix_vector_products
  for(unsigned i=0,ni=Off_diagonal_matrix_vector_products.nrow();i<ni;i++)
   {
    for(unsigned j=0,nj=Off_diagonal_matrix_vector_products.ncol();j<nj;j++)
     {
      if(Off_diagonal_matrix_vector_products(i,j) != 0)
       {    
        delete Off_diagonal_matrix_vector_products(i,j);
        Off_diagonal_matrix_vector_products(i,j) = 0;
       }
     }// End of loop over rows.
   }// End of loop over columns.

 } // End of clean_up_my_memory function.

 ///////////////////////////////////////////////////////////////////////////////
 ///////////////////////////////////////////////////////////////////////////////
 ///////////////////////////////////////////////////////////////////////////////
}
#endif
