\mainpage Example problem: The Helmholtz equation -- scattering problems


This document discusses the finite-element-based solution of the 
Helmholtz equation which describes time-harmonic wave propagation 
problems. We start by  reviewing the relevant theory and then 
present the solution of a simple model problem -- scattering of a
planar wave from a circular cylinder.


<CENTER>
<TABLE BORDER=1, WIDTH=500px>
<TR>
<TD bgcolor="cornsilk">
<CENTER>
<B>Ackowledgement:</B>
</CENTER>
This tutorial and the associated driver codes were developed jointly
with Tarak Kharrat (EnstaParisTech, Paris).
\n\n
</TD>
</TR>
</TABLE>
</CENTER>

<HR>
<HR>

\section theory Theory: The Helmholtz equation for time-harmonic scattering problems

The Helmholtz equation governs time-harmonic solutions of problems
governed by the linear wave equation
\f[
\nabla^2 U(x,y,t) = \frac{1}{c^2} \frac{\partial^2 U}{\partial t^2},
 \ \ \ \ \ \ \ \ \ \ \ \ @E[lin_wave]@
\f]
where \f$ c \f$ is the wavespeed. Assuming that \f$ U(x,y,t) \f$
is time-harmonic, with frequency \f$ \omega \f$, we write the real
function \f$ U(x,y,t) \f$ as
\f[
U(x,y,t) =\Re (u(x,y) \ e^{-i \omega t})
\f]
where \f$ u(x,y) \f$ is a complex-valued function. This transforms 
(@R[lin_wave]@) into the Helmholtz equation
\f[
\nabla^2 u(x,y,t) + k^2 u = 0
 \ \ \ \ \ \ \ \ \ \ \ \ @E[helmholtz]@
\f]
where 
\f[
k = \frac{\omega}{c}
 \ \ \ \ \ \ \ \ \ \ \ \ @E[wavenumber]@
\f]
is the wave number. Like other elliptic PDEs the Helmholtz equations
admits Dirichlet, Neumann (flux) and Robin boundary conditions.

Here we shall consider the specific example of the scattering 
of an acoustic wave from a sound-hard obstacle ("the scatterer"). 


@I w 0.6\textwidth scattering "Scattering of an incoming wave from a sound-hard obstacle -- the scatterer. "


We define \f$ \Phi(x,y,t) \f$ as the displacement potential 
so that the time-dependent displacement of a fluid particle in
the acoustic medium is given by
\f[
{\bf u} = \nabla \Phi.
\f]
It is easy to show that \f$ \Phi \f$ satisfies the linear wave
equation (@R[lin_wave]@) with wave speed \f$ c = \sqrt{B/\rho}\f$, where
\f$ B \f$ and \f$ \rho \f$ are the bulk modulus and density of the
acoustic medium, respectively.

Since the surface \f$ \partial D_{bound}\f$ of the scatterer is
impenetrable, the normal displacement of the fluid has to vanish
on  \f$ \partial D_{bound}\f$  and the boundary condition for the 
displacement potential becomes
\f[
\left. \frac{\partial \Phi}{\partial n}\right|_{\partial D_{bound}} = 0.
\ \ \ \ \ \ \ \ \ \ \ \ \  @E[non_pen_bc]@
\f]
Assuming that the incoming wave (already satisfying (@R[lin_wave]@))
is described by a (known) displacement potential
\f[
\Phi_{inc}(x,y,t) = \phi_{inc}(x,y) \  e^{-i \omega t}
\f]
we write the total potential as
\f[
\Phi(x,y,t) = \left( \phi_{inc}(x,y) + u(x,y) \right) \ e^{-i \omega t}
\f]
where \f$ u(x,y) \  e^{-i \omega t} \f$ represents the displacement potential 
associated with the scattered field which satsifies (@R[helmholtz]@). 
The boundary condition (@R[non_pen_bc]@) then becomes a Neumann 
(flux) boundary condition for the scattered field,
\f[
\left. \frac{\partial u}{\partial n}\right|_{\partial D_{bound}} =
- \left. \frac{\partial \phi_{inc}}{\partial n}\right|_{\partial D_{bound}}.
\ \ \ \ \ \ \ \ \ \ \ \ \  @E[non_pen_bc_for_scattered]@
\f]
The scattered field is also subject to the 
<a href="http://en.wikipedia.org/wiki/Sommerfeld_radiation_condition">
Sommerfeld radiation condition</a> which in 2D has the form
\f[
\lim_{r\to \infty} \sqrt{r} \left(\frac{\partial u}{\partial r} - iku
\right) =0. 
\f]
This condition ensures that scattering only produces outgoing not incoming
waves from infinity and guarantee that the problem has a unique
solution and,more generally, that the problem is well-posed.

Assuming that the incident wave has the following expansion
\f[
 \left  u^{inc}(r, \theta)  
\right= \sum_{n=-\infty}^{+\infty} i^n  J_n(kr) e^{in\theta} 
\f]
where \f$ J_n \f$ denotes the Bessel function of the first kind
of order m. The exact solution is then given by the series
\f[
 \left u^{ex}(r,\theta) 
\right= -\sum_{n=-\infty}^{+\infty} i^n \frac
{H^{'}_{n}(ka)}{J^{'}_{n}(ka)}  H_n(kr) e^{in\theta} 
\f]
where \f$ H_n \f$ denotes the Hankel function of the first kind
of order n and the prime denotes differentiation with respect to argument.

In order to developp numerical methods to solve the above problem,
it's necessary to truncate the infinite exterior. Successful
reformulation of the exterior problem into a problem on a
bounded domain hinges on the selection of an appropriate artificial
boundary condition on the truncationsurface to replace the Sommerfeld 
radiation condition.

Different kind of truncation surfaces can be considered,but, for
simple domain (such as circle in our case) the natural choice is to consider
a circular truncation surface  for wich the exact {\emDirichlet-to-Neumann}
boundary condition is known. On the other hand, some approximation of 
the Sommerfeld radiation condition was also developed and can be implemented.

\section bc Boundary conditions for a finite domain

This document discusses two kinds of 'adaptation' of the the
Sommerfeld radiation condition. The first one, the exact 
{\emDirichlet-to-Neumann} (DtN) boundary condition can be implemented
for simple truncation surfaces (such as circles).This accuracy of the 
DtN boundary condition is not ralated to the size
of the artificial truncation domain (which is the weak point of the
ABCs). However, the exact condition is given in an infinite series 
which must necessarily be truncated in any actual computation, 
and doing so introduces error.
In addition, the exact boundary is non-local which, upon
discretization by a  Finite-element, results in the filling of dense 
blocks in an otherwise sparse system of linear equations.

In this problem, we restrict our attention to local approximate
boundary conditions (ABCs) that preserve the sparsity and symmetry of
the problem. In particular, we consider the conditions suggested by Feng.


<HR>
<HR>

\subsection DtN The exact Dirichlet-to-Neumann boundary conditions (DtN)

The equivalent Sommerfeld radiation condition is giving by the
following expression ( evaluated on the fictitious circular boundary 
\f$ \Gamma  \f$ that encloses the scatterer).
\f[
 \left \frac {\partial u}{\partial \rho}|_{\rho=a} + \gamma (u)
\right  =0.   
\f]
where 
\f[
 \left \gamma (u)
\right =- \frac {k}{2 \pi} \sum_{n=-\infty}^{+\infty} \frac {H_n^{(1)^{'}}(ka)}{H_n^{(1)}(ka)} \quad 
\int_0^{2\pi}u(a,\varphi^{'}) e^{in(\varphi-\varphi^{'})} \,d\varphi^{'}  
\f]
in which \f$ H_n^{(1)} \f$ denotes the \textit nth-order \em
Hankel  functions of the first kind and \textit 'a'  is the radius of 
\f$ \Gamma \f$ .

The accuracy of the DtN boundary condition is not ralated to the size
of the artificial truncation domain (the value of the outer radius) 

<HR>
<HR>

\subsection ABCs The Approximate boundary conditions (ABCs)

Feng derived his conditions by truncating an asymptotic expansion 
of the exact Direchlet-to-Neumann(DtN) map. His first order is given by
\f[
 \left \frac {\partial u}{\partial n}-iku
\right =0   \ \ \  on\ \Gamma  
\f] 
His second order is
\f[
 \left \frac {\partial u}{\partial n}-[ik-\frac
 {1}{2R}+\frac{i}{8kR^{2}}(1+4 \frac {\partial^{2}}{\partial
 \theta^{2}})]u
\right =0   \  \ \ \   on\ \Gamma  
\f]
Feng's third order is 
\f[
 \left \frac {\partial u}{\partial n}-[ik-\frac
 {1}{2R}+\frac{1}{8k^{2}R^{2}}(ik+ \frac {1}{R})(1+4 \frac
 {\partial^{2}}{\partial \theta^{2}})]u
\right =0   \  \ \ \   on\ \Gamma  
\f]
 
These two kinds of 'new-infinte' boundary conditions are related to
two differents kind of elements (populating the outer_boundary mesh)
and are implemented in
 <a
 href="../../../helmholtz/scattering/html/helmholtz__bc__elements_8h-source.html">
Helmholtz_bc_elements</a> 

\section impl Implementation

We shall now discuss the solution of the above problem with
\c oomph-lib.


<HR>
<HR>

\subsection namespace The global namespace

As usual, we define the problem parameters in a global namespace.
The key parameter is the wave number squared (key parameter of the
Helmholtz equation). The other parameters are provided to allow users
to swith between Dtn and Feng's boundary conditions and to define the
domain specifities.

\dontinclude scattering.cc
\skipline start_of_namespace
\until std::complex<double> I(0.0,1.0);  


The function \c get_exact_u
returns the exact solution for the scattering problem.
We will use this function for the validation of our results.

\dontinclude scattering.cc
\skipline  void get_exact_u
\until  }// end of get_exact_u
  
Next we define the expression of the prescribed flux applied on the
inner boundary. The function \c  prescribed_incoming_flux evaluates
the derivate of the incident wave w.r.t the normal direction (the
radial direction) 

\dontinclude scattering.cc
\skipline void prescribed_incoming_flu
\until // end of namespace

<HR>
<HR>

\subsection main The driver code
The driver code is very similar to the \c oomph-lib's poisson ones: We
run a couple of test to check that the problem is solved in different
cases (adaptivity, DtN bc or ABCs, ABcs orders....),we set up the
problem, create a label for its output. Following this, we solve the 
problem  and document the solution.

\dontinclude scattering.cc
\skipline start_of_main
\until } //end of main

 
<HR>
<HR>

\subsection class The problem class

The problem class is very similar to the <a href="http://oomph-lib.maths.man.ac.uk/doc/poisson/two_d_poisson_flux_bc_adapt/html/index.html">
Adaptive solution of the 2D Poisson equation with flux boundary conditions</a> 
implementation: The only difference is the provision of the function 
\c actions_before_newton_convergence_check which guarantee that
the informations needed by the HelmholtzDtNBoundaryElement are
updated in each iteration (in the computation of \f$ \gamma(u) \f$)
 . Another difference  is that we 
store  pointers to the three separate Mesh objects as private member
data ( Bulk_mesh_pt, Helmholtz_outer_boundary_mesh_pt,
Helmholtz_inner_boundary_mesh_pt), 
and duplicate the previous functions \c create_flux_elements(...) 
and \c set_prescribed_incoming_flux_pt() in two different function 
to take en account the specifities of the
elements in the inner and in the outer boundary.

\dontinclude scattering.cc
\skipline start_of_problem_class
\until }; // end of problem class


<HR>
<HR>

\subsection constr The problem constructor

We start by building \c the bulk_mesh, and store a pointer to this 
mesh in the private data member: Bulk_mesh_pt=
      new RefineableTwoDAnnularMesh<ELEMENT>(periodic,
                                          azimuthal_fraction,n_theta,n_r,a,h);
\dontinclude scattering.cc
\skipline start_of_constructo
\until  azimuthal_fraction,n_theta,n_r,a,h);

Next we create the spatial error estimator and pass it to the bulk mesh. 

\dontinclude scattering.cc
\skipline  // Create/set error estimator
\until  Z2ErrorEstimator;

After that, we construct two (empty) Meshes and store a pointer to its 
in the private data member:

\dontinclude scattering.cc
\skipline  // Pointer to mesh containing the Helmholtz outer boundary condition
\until  new Mesh; 

we use the functions \c create_flux_elements(...) and \c
create_outer_bc_elements (...) to construct the required flux elements
for the elements on the inner and outer boundary of the bulk mesh and 
add them to a separate mesh.

\dontinclude scattering.cc
\skipline // Create prescribed 
\until outer_boundary_mesh_pt);

We have now created all the required elements and can access them
directly via the data members: Bulk_mesh_pt, Helmholtz_outer_boundary_mesh_pt,
 Helmholtz_inner_boundary_mesh_pt. 
However, many of oomph-lib's generic procedures require ordered
access to all of the Problem's elements, nodes, etc. For instance, 
Problem::newton_solve(...) computes the entries in the global Jacobian
matrix by adding the contributions from all elements in all
(sub-)meshes. Ordered access to the Problem's elements, nodes, etc is
generally obtained via the Problem's (single!) global Mesh object, 
which is accessible via Problem::mesh_pt(). The Problem base class
also provides a private data member Problem::Sub_mesh_pt (a vector of
type Vector<Mesh*>) 
which stores the (pointers to the) Problem's sub-meshes. 
We must add the pointers to our two sub-meshes to the problem,

\dontinclude scattering.cc
\skipline // Add the several  sub
\until inner_boundary_mesh_pt);

and use the function Problem::build_global_mesh() to combine the 
Problem's sub-meshes into a single, global Mesh that is accessible 
via Problem::mesh_pt():

\dontinclude scattering.cc
\skipline // Rebuild 
\until _global_mesh();


The rest of the constructor is (almost) identical to that in the 
 the <a href="http://oomph-lib.maths.man.ac.uk/doc/poisson/two_d_poisson_flux_bc_adapt/html/index.html">
Adaptive solution of the 2D Poisson equation with flux boundary
 conditions</a> .
We pass the useful data to the elements, 
and set up the equation numbering scheme:

\dontinclude scattering.cc
\skipline  // Complete the build
\until } // end of constructor


<HR>
<HR>

\subsection before_adapt Actions before adapt
The mesh adaptation is driven by the error estimates in the bulk
elements and only performed for that mesh. The flux elements must 
therefore be removed from the inner and outer boundary_meshes 
before adaptation. We do this by calling the function 
\c delete_flux_elements(...), and then rebuilding the 
Problem's global mesh.

\dontinclude scattering.cc
\skipline start_of_actions_before_adapt
\until }// end of actions_before_adapt


<HR>
<HR>

\subsection after_adapt Actions after adapt
After the (bulk-)mesh has been adapted, the flux elements must 
be re-attached. This is done by calling the functions
\c create_flux_elements(...) and \c create_outer_bc_elements,
followed by a rebuild of the Problem's global mesh. Finally, 
we set the pointer to the prescribed incoming flux function 
for each flux element in the inner boundary and pointer to the outer 
boundary which contains the flux informations for the second 
type of elements.

\dontinclude scattering.cc
\skipline start_of_actions_after_adapt
\until }// end of actions_after_adapt


<HR>
<HR>

\subsection delete Delete flux elements
This function loops over all the flux elements (i.e. those in the
boundary mesh) and deletes them and their storage.

\dontinclude scattering.cc
\skipline start_of_delete
\until } // end of delete_outer_face_elements


\subsection create_flux Creating the flux elements
The functions \c create_flux_elements(...) and 
\c create_outer_bc_elements(...) are quiet similar but we are obliged 
to provide two separate functions because the elements are added to
different meshes and don't have the same type ( HelmholtzFluxElemen
in the inner boundary and HelmholtzAbsorbingBCElemen or
HelmholtzDtNBoundaryElement in the outer boundary).
This function is described in  the <a href="http://oomph-lib.maths.man.ac.uk/doc/poisson/two_d_poisson_flux_bc/html/index.html">
A two-dimensional Poisson problem with flux boundary conditions</a> .

\dontinclude scattering.cc
\skipline start_of_create_outer
\until } // end of create_outer


\subsection doc Post-processing
The post-processing, implemented in doc_solution(...) is now
completely straightforward. Since the HelmholtzFluxElements,
HelmholtzDtNBoundaryElemen  and HelmholtzAbsorbingBCElement  
only apply boundary conditions, they do not have to be included 
in the plotting or error checking routines,
 so we perform these only for the elements in the bulk mesh.

\dontinclude scattering.cc
\skipline start_of_doc
\until } // end of doc


\section comm_ex Comments and Exercises



\section sources Source files for this tutorial
- The source files for this tutorial are located in the directory:\n\n
  <CENTER>
  <A HREF="../../../../demo_drivers/helmholtz/scattering">
  demo_drivers/helmholtz/scattering/
  </A>
  </CENTER>\n
- The driver code is: \n\n
  <CENTER>
  <A HREF="../../../../demo_drivers/helmholtz/scattering/scattering.cc">
  demo_drivers//scattering/scattering.cc
  </A>
  </CENTER>
.

