\mainpage Example problem: The Helmholtz equation -- scattering problems


In this document we discuss the finite-element-based solution of the 
Helmholtz equation which describes time-harmonic wave propagation 
problems. We start by  reviewing the relevant theory and then 
present the solution of a simple model problem -- scattering of a
planar wave from a circular cylinder.


<CENTER>
<TABLE BORDER=1, WIDTH=500px>
<TR>
<TD bgcolor="cornsilk">
<CENTER>
<B>Ackowledgement:</B>
\n\n
This tutorial and the associated driver codes were developed jointly
with Tarak Kharrat (EnstaParisTech, Paris).
</CENTER>
\n
</TD>
</TR>
</TABLE>
</CENTER>

<HR>
<HR>

\section theory Theory: The Helmholtz equation for time-harmonic scattering problems

The Helmholtz equation governs time-harmonic solutions of problems
governed by the linear wave equation
\f[
\nabla^2 U(x,y,t) = \frac{1}{c^2} \frac{\partial^2 U}{\partial t^2},
 \ \ \ \ \ \ \ \ \ \ \ \ @E[lin_wave]@
\f]
where \f$ c \f$ is the wavespeed. Assuming that \f$ U(x,y,t) \f$
is time-harmonic, with frequency \f$ \omega \f$, we write the real
function \f$ U(x,y,t) \f$ as
\f[
U(x,y,t) =\Re (u(x,y) \ e^{-i \omega t})
\f]
where \f$ u(x,y) \f$ is a complex-valued function. This transforms 
(@R[lin_wave]@) into the Helmholtz equation
\f[
\nabla^2 u(x,y,t) + k^2 u = 0
 \ \ \ \ \ \ \ \ \ \ \ \ @E[helmholtz]@
\f]
where 
\f[
k = \frac{\omega}{c}
 \ \ \ \ \ \ \ \ \ \ \ \ @E[wavenumber]@
\f]
is the wave number. Like other elliptic PDEs the Helmholtz equations
admits Dirichlet, Neumann (flux) and Robin boundary conditions.

If the equation is solved in an infinite domain (e.g in scattering
problems) the solution must satisfy the so-called
<a href="http://en.wikipedia.org/wiki/Sommerfeld_radiation_condition">
Sommerfeld radiation condition</a> which in 2D has the form
\f[
\lim_{r\to \infty} \sqrt{r} \left(\frac{\partial u}{\partial r} - iku
\right) =0. 
\f]
Mathematically, this conditions is required to ensure the uniqueness
of the solution (and hence the well-posedness of the problem).
In a physical context, such as a scattering problem, the condition 
ensures that scattering of an incoming wave only produces outgoing not 
incoming waves from infinity.

<HR>
<HR>

\section discr Discretisation by finite elements
The discretisation of the Helmholtz equation itself requires a trivial
modification of \c oomph-lib's Poisson elements -- we simply add
the term  \f$ k^2 u \f$ to the residual. Since most practical applications
of the Helmholtz equation involve complex-valued solutions, we provide 
separate storage for the real and imaginary parts of the solution -- 
each \c Node therefore stores two unknowns values. By default,
the real and imaginary parts are stored as values 0 and 1,
respecively; see \ref numbering for details.

The application of Dirichlet and Neumann boundary conditions is equally
straightforward and follows the pattern employed for the solution
of the Poisson equation: 
- Dirichlet conditions are imposed by pinning the relevant nodal
  values and setting them to the appropriate prescribed values. 
  \n\n
- Neumann (flux) boundary conditions are imposed via 
  \c FaceElements (here the \c ***HelmholtzFluxElements***). 
   <a href="../../../poisson/two_d_poisson_flux_bc/html/index.html">
  As usual</a> we attach these to the faces of the "bulk" elements
  that are subject to the Neumann boundary conditions.
.

The imposition of the Sommerfeld radiation condition for problems in
infinite domains is slightly more complicated. In the following 
discussion we will restrict ourselves to two dimensions and assume 
that the infinite domain is truncated at a circular artificial
boundary \f$ \Gamma \f$ of radius \f$ R. \f$ [This assumption is also 
made in the implementation of \c oomph-lib's \c FaceElements
that allow the (approximate) imposition of the Sommerfeld radiation
condition. The existing elements can easily be modified to other 
situations but this has not been done yet -- any volunteers?]
All methods exploit the fact that the relevant solution of the 
Helmholtz equation can be written in polar coordinates as
\f[
u(r,\varphi) = \sum_{n=-\infty}^{+\infty} A_n \ H_n^{(1)}(k\varphi)  
\ e^{i n \varphi}, \ \ \ \ \ \ \ @E[polar_soln]@
\f]
where the \f$A_n \f$ are suitable coefficients and
\f$ H_n^{(1)}(\varphi) \f$ is the \f$ n \f$-th-order 
Hankel function of the first kind.


<HR>

\subsection ABCs The Approximate/absorbing boundary conditions (ABCs)
It is possible to derive approximate versions of the Sommerfeld
radiation condition in which the normal derivative of the
solution on the artificial boundary is related to its
value, and its tangential derivatives. Such boundary
conditions (sometimes referred to as approximate or absorbing 
boundary conditions -- ABCs) are typically dervied from asymptotic expansions
of the solution at large distances from the origin and become
more accurate the larger the radius \f$ R \f$ of the artificial boundary
\f$ \Gamma \f$ is. Higher accuracy can therefore only be achieved 
by increasing the size of the computational domain, with an 
associated increase in computational cost.

 \c oomph-lib provides an implementation of the following three 
boundary conditions (all taken from the paper ****, in which the authors
compare the accuracy of these and many other approximate boundary
conditions).

- <b>Feng's first order ABC:</b>
\f[
 \frac {\partial u}{\partial n}-iku
\right =0   \mbox{\ \ \  \ \  on\ }\Gamma  
\f] 
- <b>Feng's second order ABC:</b>
\f[
 \frac{\partial u}{\partial n}-\bigg[ik-\frac
 {1}{2R}+\frac{i}{8kR^{2}}\bigg(1+4 \frac {\partial^{2}}{\partial
 \varphi^{2}}\bigg)\bigg]u
\right =0  \mbox{\ \ \  \ \  on\ }\Gamma  
\f]
- <b>Feng's third order ABC:</b>
\f[
 \frac {\partial u}{\partial n}-\bigg[ik-\frac
 {1}{2R}+\frac{1}{8k^{2}R^{2}}\bigg(ik+ \frac {1}{R}\bigg)
 \bigg(1+4 \frac {\partial^{2}}{\partial \varphi^{2}}\bigg)\bigg]u
\right =0   \mbox{\ \ \  \ \  on\ }\Gamma  
\f]
.
All three boundary conditions are implemented in the class
\c HelmholtzAbsorbingBCElement, a \c FaceElement that is
templated by the type of the "bulk" Helmholtz element. 
The order of the approximation can be set via the member function
\c HelmholtzAbsorbingBCElement::abc_order(). All three boundary
conditons are local (relating the function to its normal derivative)
and do therefore not change the sparsity of the resulting finite
element equations.

<HR>

\subsection DtN The Dirichlet-to-Neumann mapping (DtN)
Using (@R[polar_soln]@), it is easy to show (see, e.g., 
**** pp. ***) that the normal (radial) derivative,
\f$ \partial u / \partial n =  \partial u / \partial r, \f$
on the artifical boundary \f$ \Gamma \f$ is given by
\f[
 \frac {\partial u}{\partial r}\bigg|_{r=R} =
 \frac {\partial u}{\partial n}\bigg|_{r=R} =
 \gamma (u) \ \ \ \ \ \ \ @E[gamma_bc]@   
\f]
where 
\f[
\gamma (u) = \frac {k}{2 \pi} \sum_{n=-\infty}^{+\infty} 
\frac {H_n^{(1)^{'}}(kR)}{H_n^{(1)}(kR)} \quad 
\int_0^{2\pi}u(R,\varphi^{'}) \ e^{in(\varphi-\varphi^{'})}
\,d\varphi^{'}.  
 \ \ \ \ \ \ \ @E[gamma]@   
\f]
Equation (@R[gamma_bc]@) again provides a condition on the
normal derivative of the solution along the artificial boundary 
and is implemented in the \c HelmholtzDtNBoundaryElement class, 
a \c FaceElement, templated by the type of the "bulk" Helmholtz 
element. Since \f$ \gamma \f$ depends on the solution everywhere 
along the artificial boundary (see (@R[gamma]@)), the application of the 
boundary condition (@R[gamma_bc]@) introduces a non-local coupling
between all the degrees of freedom along the artificial boundary.
This is handled by classifying the unknowns that affect \f$ \gamma \f$ 
but are not associated with the element's own nodes as external \c Data. 

To facilitate the setup of the interaction between the 
\c HelmholtzDtNBoundaryElements, \c oomph-lib provides the
class \c HelmholtzDtNMesh which provides storage for 
(the pointers to) the  \c HelmholtzDtNBoundaryElements 
that discretise the artificial boundary. The 
member function \c HelmholtzDtNMesh::setup_gamma() pre-computes the 
\f$ \gamma \f$ values required for the imposition of (@R[gamma_bc]@).
The radius \f$ R \f$ of the artificial boundary and the (finite) number of
(Fourier) terms used in the sum in (@R[gamma]@) are specified
as arguments to the constructor of the \c HelmholtzDtNMesh.
\n\n 
<b>NOTE:</b> Since \f$ gamma \f$  depends on the solution, 
it must be recomputed whenever the unknowns are updated during
the Newton iteration. This is best done by adding a call to
\c HelmholtzDtNMesh::setup_gamma() to 
\c Problem::actions_before_newton_convergence_check().
[If Helmholtz's equation is solved in isolation (or within
a coupled, but linear problem), Newton's method will converge 
in one iteration. In such cases the unnecessary recomputation of 
\f$ gamma \f$ after the one-and-only Newton iteration can be 
suppressed by setting \c Problem::Problem_is_nonlinear to 
\c false. ****]

<HR>
<HR>

\section scattering A specific example: Scattering of an acoustic wave from a sound-hard obstacle
We will now demonstrate the methodology for a specific example:
the scattering of sound waves in an acoustic medium 
of density \f$ \rho  \f$ and bulk modulus \f$ \rho \f$.
Assume that an incoming sound wave impacts a rigid, impermeable
obstacle as shown in this sketch,

@I w 0.6\textwidth scattering "Scattering of an incoming wave from a sound-hard obstacle -- the scatterer. "

we wish to find the scattered wave field that emanates from the body.

For this purpose we denote the time-dependent displacement
of the fluid particle in the acoustic medium by 
\f$ {\bf u}(x,y,t) \f$ and introduce a displacement
potential \f$ \Phi(x,y,t) \f$ such that
\f[
{\bf u} = \nabla \Phi.
\f]
It is easy to show that \f$ \Phi \f$ satisfies the linear wave
equation (@R[lin_wave]@) with wave speed \f$ c = \sqrt{B/\rho}\f$.

Since the surface \f$ \partial D_{bound}\f$ of the scatterer is
impenetrable, the normal displacement of the fluid has to vanish
on  \f$ \partial D_{bound}\f$  and the boundary condition for the 
displacement potential becomes
\f[
\left. \frac{\partial \Phi}{\partial n}\right|_{\partial D_{bound}} = 0.
\ \ \ \ \ \ \ \ \ \ \ \ \  @E[non_pen_bc]@
\f]
Assuming that the incoming wave (already satisfying (@R[lin_wave]@))
is described by a (known) displacement potential of the form
\f[
\Phi_{inc}(x,y,t) = \phi_{inc}(x,y) \  e^{-i \omega t},
\f]
we write the total potential as
\f[
\Phi(x,y,t) = \bigg( \phi_{inc}(x,y) + u(x,y) \bigg) \ e^{-i \omega t},
\f]
where \f$ u(x,y) \  e^{-i \omega t} \f$ represents the displacement potential 
associated with the scattered field which must satsify (@R[helmholtz]@). 
The boundary condition (@R[non_pen_bc]@) then becomes a Neumann 
(flux) boundary condition for the scattered field,
\f[
\left. \frac{\partial u}{\partial n}\right|_{\partial D_{bound}} =
- \left. \frac{\partial \phi_{inc}}{\partial n}\right|_{\partial D_{bound}}.
\ \ \ \ \ \ \ \ \ \ \ \ \  @E[non_pen_bc_for_scattered]@
\f]


For the special case of the incoming wave being a planar wave,
propagating along the x-axis, the incoming field can be written as
\f[
 \left  \phi^{inc}(r, \varphi)  
\right= \sum_{n=-\infty}^{+\infty} i^n  J_n(kr) e^{in\varphi} 
\f]
where \f$ J_n \f$ is the Bessel function of the first kind
of order \f$ n \f$. The exact solution is then given by the series
\f[
 \left u^{ex}(r,\varphi) 
\right= -\sum_{n=-\infty}^{+\infty} i^n \frac
{H^{'}_{n}(ka)}{J^{'}_{n}(ka)}  H_n(kr) e^{in\varphi} 
\f]
where \f$ H_n \f$ denotes the Hankel function of the first kind
of order \f$ n \f$ and the prime denotes differentiation with respect 
to argument.

<HR>
<HR>

\section results Results
The figure below shows an animation of the displacement potential
\f$ \Re(u(x,y,t)) \f$ for scattering from a unit disk (\f$ a=1 \f$) 
for a wavenumber of \f$ k=1 \f$ over one period of the oscillation. 
The simulation was performed in an annular computational domain, 
bounded by the outer surface the unit disk) and an artificial 
outer boundary of radius \f$ R=1.5. \f$ The Sommerfeld radiation
condition was imposed with the DtN mapping and the simulation
was performed with spatial adaptivity (note the non-uniform 
refinement).

The "carpet plot" compares the exact (green) and computed (red)
solutions for the dislacement potential. The colours in the contour 
plot at the bottom of the figure provide an alternative
visualisation of the magnitude of the scattered field. 


<HR>
<HR>

\section num_soln The numerical solution

\subsection namespace The global namespace

As usual, we define the problem parameters in a global namespace.
The main physical parameter is the (square of the) wave number 
\f$ k^2 \f$. The remaining parameters  
to swith between Dtn and Feng's boundary conditions and to define the
domain specifities.

\dontinclude scattering.cc
\skipline start_of_namespace
\until std::complex<double> I(0.0,1.0);  


The function \c get_exact_u
returns the exact solution for the scattering problem.
We will use this function for the validation of our results.

\dontinclude scattering.cc
\skipline  void get_exact_u
\until  }// end of get_exact_u
  
Next we define the expression of the prescribed flux applied on the
inner boundary. The function \c  prescribed_incoming_flux evaluates
the derivate of the incident wave w.r.t the normal direction (the
radial direction) 

\dontinclude scattering.cc
\skipline void prescribed_incoming_flu
\until // end of namespace

<HR>
<HR>

\subsection main The driver code
The driver code is very similar to the \c oomph-lib's poisson ones: We
run a couple of test to check that the problem is solved in different
cases (adaptivity, DtN bc or ABCs, ABcs orders....),we set up the
problem, create a label for its output. Following this, we solve the 
problem  and document the solution.

\dontinclude scattering.cc
\skipline start_of_main
\until } //end of main

 
<HR>
<HR>

\subsection class The problem class

The problem class is very similar to the <a href="http://oomph-lib.maths.man.ac.uk/doc/poisson/two_d_poisson_flux_bc_adapt/html/index.html">
Adaptive solution of the 2D Poisson equation with flux boundary conditions</a> 
implementation: The only difference is the provision of the function 
\c actions_before_newton_convergence_check which guarantee that
the informations needed by the HelmholtzDtNBoundaryElement are
updated in each iteration (in the computation of \f$ \gamma(u) \f$)
 . Another difference  is that we 
store  pointers to the three separate Mesh objects as private member
data ( Bulk_mesh_pt, Helmholtz_outer_boundary_mesh_pt,
Helmholtz_inner_boundary_mesh_pt), 
and duplicate the previous functions \c create_flux_elements(...) 
and \c set_prescribed_incoming_flux_pt() in two different function 
to take en account the specifities of the
elements in the inner and in the outer boundary.

\dontinclude scattering.cc
\skipline start_of_problem_class
\until }; // end of problem class


<HR>
<HR>

\subsection constr The problem constructor

We start by building \c the bulk_mesh, and store a pointer to this 
mesh in the private data member: Bulk_mesh_pt=
      new RefineableTwoDAnnularMesh<ELEMENT>(periodic,
                                          azimuthal_fraction,n_theta,n_r,a,h);
\dontinclude scattering.cc
\skipline start_of_constructo
\until  azimuthal_fraction,n_theta,n_r,a,h);

Next we create the spatial error estimator and pass it to the bulk mesh. 

\dontinclude scattering.cc
\skipline  // Create/set error estimator
\until  Z2ErrorEstimator;

After that, we construct two (empty) Meshes and store a pointer to its 
in the private data member:

\dontinclude scattering.cc
\skipline  // Pointer to mesh containing the Helmholtz outer boundary condition
\until  new Mesh; 

we use the functions \c create_flux_elements(...) and \c
create_outer_bc_elements (...) to construct the required flux elements
for the elements on the inner and outer boundary of the bulk mesh and 
add them to a separate mesh.

\dontinclude scattering.cc
\skipline // Create prescribed 
\until outer_boundary_mesh_pt);

We have now created all the required elements and can access them
directly via the data members: Bulk_mesh_pt, Helmholtz_outer_boundary_mesh_pt,
 Helmholtz_inner_boundary_mesh_pt. 
However, many of oomph-lib's generic procedures require ordered
access to all of the Problem's elements, nodes, etc. For instance, 
Problem::newton_solve(...) computes the entries in the global Jacobian
matrix by adding the contributions from all elements in all
(sub-)meshes. Ordered access to the Problem's elements, nodes, etc is
generally obtained via the Problem's (single!) global Mesh object, 
which is accessible via Problem::mesh_pt(). The Problem base class
also provides a private data member Problem::Sub_mesh_pt (a vector of
type Vector<Mesh*>) 
which stores the (pointers to the) Problem's sub-meshes. 
We must add the pointers to our two sub-meshes to the problem,

\dontinclude scattering.cc
\skipline // Add the several  sub
\until inner_boundary_mesh_pt);

and use the function Problem::build_global_mesh() to combine the 
Problem's sub-meshes into a single, global Mesh that is accessible 
via Problem::mesh_pt():

\dontinclude scattering.cc
\skipline // Rebuild 
\until _global_mesh();


The rest of the constructor is (almost) identical to that in the 
 the <a href="http://oomph-lib.maths.man.ac.uk/doc/poisson/two_d_poisson_flux_bc_adapt/html/index.html">
Adaptive solution of the 2D Poisson equation with flux boundary
 conditions</a> .
We pass the useful data to the elements, 
and set up the equation numbering scheme:

\dontinclude scattering.cc
\skipline  // Complete the build
\until } // end of constructor


<HR>
<HR>

\subsection before_adapt Actions before adapt
The mesh adaptation is driven by the error estimates in the bulk
elements and only performed for that mesh. The flux elements must 
therefore be removed from the inner and outer boundary_meshes 
before adaptation. We do this by calling the function 
\c delete_flux_elements(...), and then rebuilding the 
Problem's global mesh.

\dontinclude scattering.cc
\skipline start_of_actions_before_adapt
\until }// end of actions_before_adapt


<HR>
<HR>

\subsection after_adapt Actions after adapt
After the (bulk-)mesh has been adapted, the flux elements must 
be re-attached. This is done by calling the functions
\c create_flux_elements(...) and \c create_outer_bc_elements,
followed by a rebuild of the Problem's global mesh. Finally, 
we set the pointer to the prescribed incoming flux function 
for each flux element in the inner boundary and pointer to the outer 
boundary which contains the flux informations for the second 
type of elements.

\dontinclude scattering.cc
\skipline start_of_actions_after_adapt
\until }// end of actions_after_adapt


<HR>
<HR>

\subsection delete Delete flux elements
This function loops over all the flux elements (i.e. those in the
boundary mesh) and deletes them and their storage.

\dontinclude scattering.cc
\skipline start_of_delete
\until } // end of delete_outer_face_elements


\subsection create_flux Creating the flux elements
The functions \c create_flux_elements(...) and 
\c create_outer_bc_elements(...) are quiet similar but we are obliged 
to provide two separate functions because the elements are added to
different meshes and don't have the same type ( HelmholtzFluxElemen
in the inner boundary and HelmholtzAbsorbingBCElemen or
HelmholtzDtNBoundaryElement in the outer boundary).
This function is described in  the <a href="http://oomph-lib.maths.man.ac.uk/doc/poisson/two_d_poisson_flux_bc/html/index.html">
A two-dimensional Poisson problem with flux boundary conditions</a> .

\dontinclude scattering.cc
\skipline start_of_create_outer
\until } // end of create_outer


\subsection doc Post-processing
The post-processing, implemented in doc_solution(...) is now
completely straightforward. Since the HelmholtzFluxElements,
HelmholtzDtNBoundaryElemen  and HelmholtzAbsorbingBCElement  
only apply boundary conditions, they do not have to be included 
in the plotting or error checking routines,
 so we perform these only for the elements in the bulk mesh.

\dontinclude scattering.cc
\skipline start_of_doc
\until } // end of doc


\section comm_ex Comments and Exercises
\subsection numbering The enumeration of the unknowns
bla


\section sources Source files for this tutorial
- The source files for this tutorial are located in the directory:\n\n
  <CENTER>
  <A HREF="../../../../demo_drivers/helmholtz/scattering">
  demo_drivers/helmholtz/scattering/
  </A>
  </CENTER>\n
- The driver code is: \n\n
  <CENTER>
  <A HREF="../../../../demo_drivers/helmholtz/scattering/scattering.cc">
  demo_drivers//scattering/scattering.cc
  </A>
  </CENTER>
.

