\mainpage Demo problem: Steady finite-Reynolds-number flow through an elastic iliac bifurcation   
This tutorial demonstrates how to simulate physiological
fluid-structure interaction problems, based on the medical imaging
data, processed with the <a href="http://www.vmtk.org/Main/HomePage">Vascular 
Modeling Toolkit.</a> 

 We combine two single-physics problems, namely
- <a href="../../../solid/vmtk_solid/html/index.html">
  The inflation of a blood vessel</a>
  \n\n
- <a href="../../../navier_stokes/vmtk_fluid/html/index.html">
  Finite-Reynolds number flow through a rigid iliac bifurcation</a>
.
to study the steady flow through an elastic iliac bifurcation.
(Please refer to \c oomph-lib's 
<a href="../../../meshes/mesh_from_vmtk/html/index.html">VMTK
tutorial</a> to find out how to generate \c oomph-lib meshes
from medical images.)

The tutorial also provides a detailed discussion of the mechanism by which
\c FaceElements introduce additional unknowns into a problem. 
This is important in the problem considered here because we
employ two different types of \c FaceElements, both of which
introduce additional unknowns. When dealing with nodes that
are attached to both types of \c FaceElements we must therefore be able 
to determine which nodal values are associated with which \c FaceElement.
Section \ref face below shows how this is done.


<CENTER>
<TABLE BORDER=1, WIDTH=500px>
<TR>
<TD bgcolor="cornsilk">
\n\n
<CENTER>
<B>Ackowledgement:</B>
</CENTER>
\n\n
This tutorial and the associated driver codes were developed jointly
with Amine Massit (ENSTA, Paris).
\n\n
</TD>
</TR>
</TABLE>
</CENTER>


<hr>
<hr>
  

\section prob The problem (and some results)
The animations below show the deformation of an iliac bifurcation
that conveys viscous fluid and deforms in response to the traction 
that the fluid exerts onto it. As in the previous examples
where we considered the constituent single-physics 
<a href="../../../navier_stokes/vmtk_fluid/html/index.html">
fluid</a> and <a href="../../../solid/vmtk_solid/html/index.html">
solid</a> problems, the meshes are obviously very coarse and the
boundary conditions are far from "physiologically realistic":
We keep the upstream and downstream "ends" of the vessel
wall in a fixed position and drive the (steady!) flow by applying
a constant pressure drop between the in- and outflow cross sections.
The different frames shown in the animation show results
for different wall stiffnesses, using the same setup as in
<a href="../../unstructured_three_d_fsi/html/index.html">another
tutorial.</a> 

We stress that the computations presented here serve as
quick-to-compute proof of concept and refer to the section 
\ref comm_ex  at the end of this tutorial for a discussion 
on how to make the simulation more "realistic". 

@I w 0.75\textwidth elastic_iliac_solid "The flow-induced deformation of an iliac bifurcation. The animation shows the effect of variations in the wall stiffness. The arrows show the magnitude of the fluid traction on the wall. "

@I w 0.75\textwidth elastic_iliac_fluid "Steady finite-Reynolds number flow through an elastic iliac bifucation (velocity vectors and pressure contours). The animation shows the effect of variations in the wall stiffness. "


The driver code used for this computation is very similar to the one
discussed in <a href="../../unstructured_three_d_fsi/html/index.html">another
tutorial</a> where we used a much simpler geometry in which the
three branches of the bifurcation had rectangular cross-sections. 
Before discussing the changes to the driver code in section
\ref driver_code below, we provide a more detailed discussion
of the way in which \c FaceElements introduce additional unknowns into 
a problem. Feel free to skip the next section if you're not keen on theory.

 

<HR>
<HR>

\section face How FaceElements introduce additional unknowns into a problem

\c FaceElements are used widely throughout \c oomph-lib to apply 
Neumann/flux-type boundary conditions on the faces of
higher-dimensional "bulk" elements. Examples include:
- <a href="../../../poisson/two_d_poisson_flux_bc2/html/index.html">
  The application of a flux bounday condition in a Poisson problem</a> 
  \n\n
- The application of traction boundary conditions in 
  <a href="../../../navier_stokes/rayleigh_traction_channel/html/index.html">
  fluid</a> and 
  <a href="../../../solid/airy_cantilever/html/index.html">solid</a>
  mechanics problems
  \n\n
- <a href="../../../young_laplace/contact_angle/html/index.html">The
  application of contact-angle boundary condition for the
  Young-Laplace equation</a>
- etc.
.
In all the examples listed above, the boundary conditions simply
add a contribution to the elements' residuals but they do not
introduce any additional unknowns into the problem.

\c FaceElements may also be used to apply boundary conditions
via Lagrange multipliers. An example for this given in the tutorial
that discusses
- <a href="../../../solid/prescribed_displ_lagr_mult/html/index.html">
   The application of displacement boundary conditions for solid
   mechanics problems</a>
.
In such problems, the Lagrange multipliers must be determined
as part of the solution, and storage for associated discrete
unknowns must be created at the nodes of the \c FaceElements.

 To explain the relevant details of the implementation we consider a 
simple 2D Navier-Stokes problem that is discretised using nine-node Taylor-Hood
elements (in which each vertex node stores two discrete velocities and
one pressure, while the other nodes only store two velocity degrees of
freedom). We assume that boundaries 0 and 1 are subject to 
boundary conditions that are imposed via \c FaceElements, and that
each boundary condition introduces its own Lagrange multipliers field<b>s</b>. 
[Yes, the plural is correct. As an example, consider the case of 
imposing displacement constraints in a 2D solid mechanics problem via 
Lagrange multipliers. In this approach 
the imposition of the boundary condition requires \e two Lagrange 
multipliers along each constrained boundary. Physically, the Lagrange
multipliers represent the two components of surface traction required to 
deform the boundary into the required shape; see 
<a href="../../../solid/prescribed_displ_lagr_mult/html/index.html">
the relevant solid mechanics problem</a> for details.]

The sketch below shows the discretisation of the domain, with the black 
circles representing the nodes. The enlargement of the top right
corner also shows the discrete unknowns (nodal velocities and
pressures) stored at each node following the creation of the 
"bulk" Navier-Stokes elements.



@I w 0.75\textwidth multiple_face_elements1 "Sketch of a problem that is subject to flux-type boundary conditions along boundaries 0 and 1. The sketch illustrates the degrees of freedom at each node before any FaceElements are attached.  "


The next figure shows the nodal degrees of freedom after the \c
FaceElements on boundary 0 (shown in red) have been attached. The
\c FaceElements share the existing nodes of the underlying
"bulk" elements and automatically create storage for any additional
nodal unknowns. Here we provide storage for two discrete Lagrange multipliers, 
\f$ \Lambda_x \f$ and \f$ \Lambda_y. \f$ As long as only a single
\c FaceElement is attached to a node, the function
\code
unsigned FaceElement::nbulk_value(const unsigned& j)
\endcode
can be used to determine the number of nodal values at the \c
FaceElement's \c j -th node that were created by the underlying 
"bulk" element \e before the \c FaceElement was attached. 
This makes it easy to identify the additional nodal values associated 
with the \c FaceElement in order to apply boundary conditons, etc.
The methodology is illustrated in the application of boundary 
conditions for the Lagrange multipliers in the 
<a href="../../../solid/prescribed_displ_lagr_mult/html/index.html#bcs_for_lagrange_multipliers">
the solid mechanics problem referred to earlier.</a>
 



@I w 0.75\textwidth multiple_face_elements2 "Sketch illustrating the degrees of freedom at each node after FaceElements have been attached to boundary 0.  "



The next figure shows the degrees of freedom after the \c
FaceElements on boundary 1 (shown in green) have been attached too.
These \c FaceElements must create storage for their own
two Lagrange multipliers, \f$ \lambda_x \f$ and 
\f$ \lambda_y \f$, such that at the corner node (which is attached
to both types of \c FaceElements) we have four additional degrees of freedom.



@I w 0.75\textwidth multiple_face_elements3 "Sketch illustrating the degrees of freedom at each node after all FaceElements have been attached.  "

 
The identification of the additional degrees of freedom via a simple
offset from the degrees of freedom created by the "bulk" element
is now longer possible. We therefore provide an alternative
mechanism to access the relevant information from the nodes
themselves via the function
\code
unsigned BoundaryNodeBase::index_of_first_value_assigned_by_face_element()
\endcode
which does exactly what it says. If only a single type of \c
FaceElement is attached to a (boundary) node, the unsigned that is returned
by this function is exactly the same as the unsigned that is returned
by the corresponding call to \c FaceElement::nbulk_value(...). 
To cater for the case where multiple \c FaceElements are 
attached to the same node, the above function can take an ID
(which defaults to zero) that identifies which type of
\c FaceElement we are dealing with, so the full interface is, in fact,
\code
unsigned BoundaryNodeBase::index_of_first_value_assigned_by_face_element(const unsigned& id=0)
\endcode
The ID is established by the constructor of the specific 
\c FaceElement when the number of values at the nodes is 
adjusted to accomodate the additional values required by the
\c FaceElement. 


To illustrate this, the code extract shown below provides a 
(partial) listing of the constructor of 
the \c ImposeDisplacementByLagrangeMultiplierElement
that was used in the 
<a href="../../../solid/prescribed_displ_lagr_mult/html/index.html">
the solid mechanics problem referred to earlier</a>. The constructor
has the usual two arguments that specify the pointer to the "bulk"
element, and the index of the face that the \c FaceElement is to 
be attached to. The final (optional) argument allows the specification
of the ID referred to above. We store the ID in a private 
the element's private member data.
 
\dontinclude solid_traction_elements.h
\skipline Constructor takes a "bulk"
\until FaceElement()
\skipline {
\until Id=


[We omit a few lines of code that are irrelevant for the
present discussion]. Next we specify the number of additional
values required at each of the element's nodes and store them
in a vector. For a \c dim -dimensional bulk element, we need \c dim 
additional values at each node to store the Lagrange multipliers. 

\skipline Dimension of the bulk
\until n_additional_values

Finally, we pass this vector, together with ID that identifies the
type of the \c FaceElement to the function
\c  FaceElement::add_additional_values(...):

\until }

This function creates the additional storage at each node and
updates the node's internal lookup scheme that provides access to the
first value associated with the specified ID.


The fact that the ID is specified as an optional argument means that
the user does not have to provide a dummy ID in cases where
none is required, i.e. in problems involving just a single type 
of \c FaceElement, as in
<a href="../../../solid/prescribed_displ_lagr_mult/html/index.html">
the solid mechanics problem referred to earlier.</a>
If a problem does involve multiple \c FaceElements, the 
user will be aware of this when writing the driver code and
can then provide distinct IDs as and when required. This is illustrated
in section \ref ***hierher*** below.



<HR>
<HR>

\section driver The driver code

** hierher Andrew your stuff goes here... ***



<HR>
<HR>

\section comm_ex Comments and Exercises

\subsection realism Making the simulation more "realistic"
The simulation shown at the beginning of this tutorial is 
obviously very crude and suffers from (at least) the sum of the 
shortcomings that we identified in the tutorials for the constituent 
single-physics 
<a href="../../../navier_stokes/vmtk_fluid/html/index.html#realism">fluid</a>
and <a href="../../../solid/vmtk_solid/html/index.html#finer"> solid</a>
problems. You should consider repeating the computation using finer
meshes (consult \c oomph-lib's 
<a href="../../../meshes/mesh_from_vmtk/html/index.html">VMTK
tutorial</a> for details) and explore the use of "flow extensions" 
which allow the (inevitably artificial) boundary conditions to be applied 
further from the region of interest. Adding time-dependence to the
problem, e.g. by subjecting the flow to a periodic fluctuation
in the applied pressure drop would be another interesting
exercise.

 
<HR>
<HR>

\section sources Source files for this tutorial
- The source files for this tutorial are located in the directory:\n\n
<CENTER>
<A HREF="../../../../demo_drivers/interaction/vmtk_fsi/">
demo_drivers/interaction/vmtk_fsi/
</A>
</CENTER>\n
- The driver code is: \n\n
<CENTER>
<A HREF="../../../../demo_drivers/interaction/vmtk_fsi/vmtk_fsi.cc">
demo_drivers/interaction/vmtk_fsi/vmtk_fsi.cc
</A>
</CENTER>
.
