\mainpage Refineable Boussinesq Convection using a multi-domain approach: Combining (Refineable) Navier--Stokes and Advection-Diffusion domains

We consider a <a href="../../b_convection/html/index.html"> 
previously-described, </a>
 two-dimensional Boussinesq convection problem in
which an incompressible, Newtonian fluid is heated from below.

When two or more physical processes interact within the same spatial
domain there are three different approaches to setting up the
interaction within \c oomph-lib. One approach is to write a completely
new interaction Element. The second approach described in 
<a  href="../../b_convection/html/index.html"> the non-refineable  </a> and 
<a href="../../refine_b_convect/html/index.html">refineable </a> 
single-domain versions of the present problem is to create a combined
 multi-physics element using inheritance from two, or more, existing
 elements. In both these cases, the physical processes interact within an 
element and this is termed a \b multi-field approach.

In this example we describe the third approach to multi-physics
problems, in which 
 we solve the problem using two different elements on two different
 domains, each occupying the same physical space. One domain is used for 
 the solution of the Navier--Stokes equations and the other for 
 the solution of the advection-diffusion 
equation. Rather than interacting locally within elements, the
different physical processes interact directly between the two domaians. 
One benefit of such a \b multi-domain approach, compared to a \b
multi-field approach, is that different error estimators can be 
used on each domain and there is no longer a need to construct 
a combined multi-physics error estimator. Moreover, the domains do not
have to follow the same refinement pattern, which can be
advantageous if the different physical processes act over different
spatial scales.  The figure below shows that in
this instance the Navier--Stokes mesh (panel (a)) requires much more
refinement than the advection-diffusion mesh (panel (b)).

@I w 0.75\textwidth two_domains "Steady Convection Rolls: (a) contours of x-velocity and corresponding element boundaries in Navier--Stokes mesh, (b) contours of temperature and corresponding element boundaries in advection-diffusion mesh. "


\section external_elements The ElementWithExternalElement class

 Interaction between different elements in different domains is a
fundamental feature of many multi-physics problems and the generic
features of such interactions are provided by the \c
ElementWithExternalElement class. 
Any element which requires information from an "external" element in 
another "external" mesh, for example
 the \c
FSIWallElement described in the <a
href="../../../interaction/fsi_collapsible_channel/html/index.html">
flow in a collapsible channel problem, </a>
 must inherit from the base class \c
ElementWithExternalElement.  

 In the finite element context, we require the "external" element that
 contributes to the interaction at each integration point of the
 finite element. Typically, the contribution to the interaction is
 provided by a function of the field variables interpolated by the
 external element, so we also require the local coordinate within the
 external element that corresponds to the physical location of the
 integration point. Accordingly,
 \c ElementWithExternalElements can store a pointer to an
  external element and a vector of local coordinates at
 each integration point:
\code
FiniteElement*& external_element_pt(const unsigned& interaction, const
unsigned& ipt);
\endcode
\code
Vector<double>& external_element_local_coord(const unsigned&
interaction, const unsigned& ipt);
\endcode
where the unsigned parameter \c interaction denotes the interaction
index (required in cases where an element has more than one element
with which it interacts, <em> e.g. </em> 
an FSI problem where a solid element is
affected by a fluid load on both its "front" and "back", see the 
<a href="../../../interaction/fsi_channel_with_leaflet/html/index.html">FSI 
channel with leaflet problem</a> for further details).

Any \c Data from the external elements involved in the
interaction must also be specified so that
interaction blocks in the Jacobian matrix can be calculated.
Such data is divided into 
- <em> external field data: </em> fields 
interpolated by the external element that affect the interaction; 
.
- <em> external geometric data: </em> any geometric data that affects
the external element and, therefore, spatial derivatives of its fields. 
.
The rationale for the division is that 
in many cases the field data's contribution to the Jacobian interaction blocks
can be found analytically, whereas the geometric
data is more easily handled by finite differences. 
These external data are specified by two member
functions in the \c ElementWithExternalElement class
\code
  virtual void identify_all_field_data_for_external_interaction(
    Vector<std::set<FiniteElement*> >  const &external_elements_pt,
    std::set<std::pair<Data*,unsigned> > &paired_interaction_data); 
\endcode
\code
   virtual void identify_all_geometric_data_for_external_interaction(
    Vector<std::set<FiniteElement*> >  const &external_elements_pt,
    std::set<Data*> &external_geometric_data_pt);
\endcode   
 which can be overloaded in any specific element. For example, the
 FSIWallElement overloads both these functions so that viscous load
 terms can be neglected if desired.
 The default implementation is that for each interaction the
 \c FiniteElement member functions
\code
 void FiniteElement::identify_field_data_for_interactions(...)
\endcode 
and
\code
void FiniteElement::identify_geometric_data(..)
\endcode
are called for each external element. The default implementation
of the function \c identify_field_data_for_interactions(...) returns all
internal and nodal data, including \c Data located at the master nodes
associated with any hanging nodes. Again, these functions can be
overloaded to improve efficiency in specific interaction elements.

\subsection element_modifications Modifying the Navier--Stokes and Advection--Diffusion elements for use in multi-domain problems

 In the present Boussinesq convection problem, we must write new
 elements so that the Navier-Stokes equations and advection-diffusion
 equations can be coupled between different domains:
\code
template<unsigned DIM>
class RefineableQCrouzeixRaviartElementWithExternalElement : 
 public virtual RefineableQCrouzeixRaviartElement<DIM>,
 public virtual ElementWithExternalElement 

template<unsigned DIM>
class RefineableQAdvectionDiffusionElementWithExternalElement : 
 public virtual RefineableQAdvectionDiffusionElement<DIM,3>,
 public virtual ElementWithExternalElement
\endcode

Within these new elements we overload appropriate functions so  
that the required coupling information is obtained
directly from  the "external" element.  In this instance, therefore, 
we overload \c
get_body_force_nst() and \c get_wind_adv_diff() as follows:

\dontinclude my_boussinesq_elements.h
\skipline start_of_get_body_force_nst
\until end of get_body_force_nst

\skipline start_of_get_wind_adv_diff
\until end of get_wind_adv_diff

Note that the functions are similar to those  
the <a href="../../refine_b_convect/html/index.html">
single-domain version of the problem. </a>  They are exactly the
same if \c source_element_pt is replaced by \c this pointer and
\c external_element_local_coord(...) is replaced by \c s.

In both elements, we specify the number of interactions in the
 element constructors so 
 that storage for the pointers to external
elements and local coordinates can be allocated. In addition, there is
 no external geometric data because neither set of elements moves and
 we call the member function \c ignore_external_geometric_data() to
 avoid the call to \c
 identify_all_geometric_data_for_external_interaction(..) and a wasted
 loop over the elements.

\dontinclude my_boussinesq_elements.h
\skipline Constructor
\until }

\skipline Constructor
\until }

\subsubsection off_diag_jac Computation of the Jacobian matrix

 The easiest, but not the most efficient, method to compute the
 Jacobian matrix is to use finite
differences to assemble the entire matrix, 
but this ignores
the fact that the original elements compute their Jacobians analytically. As
discussed in the <a href="../../b_convection/html/index.html#comments">
comments </a> section of the single-domain version of the problem, we
can re-use the
 underlying element's \c fill_in_contribution_to_jacobian(...) 
function and then finite-difference the off-diagonal blocks of the
Jacobian. The off-diagonal blocks represent the effects of the data
 from the external element on the residuals and can be calculated by
 using the function
\code
ElementWithExternalElement::fill_in_jacobian_from_external_interaction_by_fd(..)
\endcode
which calls two functions
\code
ElementWithExternalElement::fill_in_jacobian_from_external_interaction_field_by_fd(..)
\endcode
and
\code
ElementWithExternalElement::fill_in_jacobian_from_external_interaction_geometric_by_fd(..)
\endcode
can be used to calculate the off-diagonal blocks.
In the present example we would only need to call the finite
difference routine for the external field data because the elements
don't move. 

The procedure for calculating the off-diagonal blocks analytically is
more involved than in the single-domain case and requires:
- the derivatives of the functions called from the external elements
with respect to the external elements' degrees of freedom;
.
and
- knowledge of the local equation numbers corresponding to the
external elements' degrees of freedom.
.

The derivatives of the external elements' 
functions with respect to degrees of freedom
must be provided by the external elements themselves, <em> i.e. </em>
\code
void AdvectionDiffusionEquations<DIM>::
dinterpolated_u_adv_diff_ddata(const Vector<double> &s, 
  Vector<double> &du_ddata,Vector<unsigned> &global_eqn_number)
\endcode
returns the derivatives that correspond to the function
\code
double AdvectionDiffusionEquations<DIM>::
interpolated_u_adv_diff( const Vector<double> &s)
\endcode
and
\code
void NavierStokeEquations<DIM>::
dinterpolated_u_nst_ddata(const Vector<double> &s, const unsigned &i,
Vector<double> &du_ddata, Vector<unsigned> &global_eqn_number)
\endcode
returns the derivatives that correspond to the function
\code
double NavierStokesEquations<DIM>::
interpolated_u_nst(const Vector<double> &s, const unsigned &i)
\endcode

We recommend that all such functions add the same two additional
vector arguments, \c du_ddata and \c global_eqn_number, and, on return,
these vectors should contain the derivatives of the
function with respect to each degree of freedom and the corresponding
global equation number of the degree of freedom, respectively. Thus,
the vectors will both be the same size: the number of degrees of
freedom of the (external) element.

These external element member functions are used to calculate the
derivatives of the body force in the Navier--Stokes element 
with respect to the temperature
(external) degrees of freedom 
and the derivatives of the wind in the 
advection-diffusion element with respect to the velocity (external)
degrees of freedom

\dontinclude my_boussinesq_elements.h
\skipline start_of_get_dbody_force
\until end_of_get_dbody_force

\skipline start_of_get_dwind
\until end_of_get_dwind

The use of these functions means that we have derivatives
and the global equation numbers of the corresponding unknowns.
The equivalent local equation numbers 
can then be found from the global equation
numbers by using the function
\code
int GeneralisedElement::local_eqn_number(const unsigned long &ieqn_global)
\endcode

The analytic computation of the off-diagonal terms 
is now reasonably straightforward, although
it is complicated by the potential presence of hanging nodes, and the
implementations are presented in the functions
\code
RefineableQCrouzeixRaviartElementWithExternalElement::
fill_in_off_diagonal_block_analytic(...)
\endcode
\code
RefineableQAdvectionDiffusionElementWithExternalElement::
fill_in_off_diagonal_block_analytic(...)
\endcode

Once again, there is a dramatic decrease in the assembly time of the
Jacobian matrix when all entries are calculated analytically.

<HR>


\section setting_up_interaction Setting up the interaction

The function
\code
template<class ELEMENT_0,class ELEMENT_1,unsigned EL_DIM_0,unsigned EL_DIM_1>
void Multi_domain_functions::set_sources
 (Problem* problem_pt, 
  Mesh* const &first_mesh_pt, Mesh* const &second_mesh_pt, 
  const unsigned& first_interaction=0, 
  const unsigned& second_interaction=0);
\endcode
should be used to set up the two-way interaction between the mesh of
Navier--Stokes elements and the mesh of advection-diffusion
elements. The function must be called prior to the assignment of
any equation numbers. Thus it is called in the problem constructor
and in \c actions_after_adapt() because the elements involved in the
interaction may change after refinement.

Within this function, each of \c ELEMENT_0 and \c ELEMENT_1 (the
element types within \c first_mesh_pt and \c second_mesh_pt
respectively, which are of dimension \c EL_DIM_0 and \c EL_DIM_1
respectively) must both inherit from the class \c
ElementWithExternalElement described above.  The 
optional interaction parameters may be used if the interaction in
either direction is not the only interaction for either of the domains.

<HR>
<HR>

\section multi_domain_boussinesq Multi-domain Boussinesq problem
<HR>


\subsection driver_code The driver code

The driver code itself is structurally very similar to that of the
single-domain example, indeed the \c main() functions are virtually
identical. The only difference is that the \c
RefineableConvectionProblem takes two template arguments (two
different elements) instead of one (a combined element).

<HR>

\subsection problem_class The problem class

Once again, the problem class is similar to that of the
single-domain example and many of the functions are the same. 
There are now two meshes, however, one for the
fluid elements and one for the advection-diffusion elements

\dontinclude multimesh_ref_b_convection.cc
\skipline Access function to the NST mesh
\until end_of_nst_mesh

\skipline Access function to the AD mesh
\until  end_of_ad_mesh

and after mesh adaptation, the
interaction between the two meshes must be set up again.

\skipline Actions after adapt
\until end_of_actions_after_adapt

<HR>

\subsection constructor The constructor

The constructor is somewhat different from the equivalent
single-domain version mainly because there are two meshes instead of
one. Firstly, we build two coarse meshes with the same number of
elements (\f$ 9 \times 8 \f$, as in the original single-domain problem) and
dimensions for each mesh. Error estimators and error targets are set
separately for each mesh. 

\dontinclude multimesh_ref_b_convection.cc
\skipline start_of_constructor
\until Adv_diff_mesh_pt->min_permitted_error

The boundary constraints are applied to each mesh in turn; firstly on
the Navier--Stokes mesh, where we must also pin a single pressure:

\skipline Set the boundary conditions
\until fix_pressure

We then apply boundary constraints to the advection-diffusion mesh:

\skipline Loop over the boundaries of the AD mesh
\until end of loop over AD mesh boundaries

and complete the build of all elements in each mesh by setting the
pointers to the required physical parameters in each domain:

\skipline Complete the build of all elements
\until end of setup for all AD elements

Finally we combine the submeshes, call the \c actions_after_adapt()
routine to set up the interaction between the two meshes, and
assign the equation numbers.

\skipline combine the submeshes
\until end of constructor

<HR>

\subsection actions_before_newton_solve The function actions_before_newton_solve(...)

In this function we update the problem specifications before a
solution by re-applying the specific values of the Dirichlet boundary
conditions for each mesh, and ensuring that the mass-conserving
imperfection is applied to the velocity boundary conditions on the
Navier--Stokes mesh if required. The boundary conditions are exactly
the same as for the single-domain version of the problem, but they
must be applied differently because there are now two meshes instead
of one.

\dontinclude multimesh_ref_b_convection.cc
\skipline start_actions_before_newton_solve
\until end of actions before solve

<HR>

\subsection doc_solution The function doc_solution(...)

This function outputs all fields to the specified solution file in the
directory pointed to by the \c DocInfo object.  Note: the direct call
to \c mesh_pt() specifies the global mesh, so this function will
output the fields in mesh order: the Navier--Stokes mesh followed by
the advection-diffusion mesh.  To output these fields separately we
could simply call the output function for each mesh.

\dontinclude multimesh_ref_b_convection.cc
\skipline start_of_doc_solution
\until end of doc

<HR>
<hr>
\section comm_and_ex Comments and Exercises
\subsection comments Comments
- The use of two separate meshes with different error estimators means
that, in principle, a more accurate solution can be obtained with
fewer degrees of freedom than using a combined error estimator on a
single mesh. The combined error estimator implemented in the single-domain
version of the problem will cause refinement if either the fluid
error or the advection-diffusion error is above the
specified tolerance. Thus, a fully-converged solution in the
single-domain problem is one in which the estimated error in 
all field variables is below the tolerance, but this may be at the
cost of some over-refinement in one or more of the field variables. In
the present multi-domain approach, if the solution is converged on
both meshes then the estimated error in all field variables is again
below the tolerance. Hence, it is fair, in some sense, to 
compare the results between fully-converged
solutions for the single- and multi-domain problems. As suggested by
the figure above, for this Boussinesq convection problem
we do obtain fully-converged solutions
with fewer degrees of freedom using the multi-domain approach because
the temperature field is over-refined in the single-domain
case. Of course, the multi-domain solution includes the extra overhead
of setting up the interaction, but, in general, this cost is
negligible compared to the solution of the linear systems.
- The general procedures described in this tutorial can be used to
setup any interaction between different types of elements using
multiple meshes. 
- Before any refinements take place the combined Jacobian that is
assembled is exactly the same as that in the single-domain problem and
so the residuals at each Newton step will be exactly the same. You can
verify this by comparing the appropriate output files in the
Validation  directory.
.

<hr>

\subsection exercises Exercises
-# Investigate the difference between the solutions for the
multi-domain and single-domain problems by continuing to refine until
the solutions are fully-converged to a given error tolerance. What is
the difference in total number of degrees of freedom? What is the
difference in solution time? What is the difference between the two
solutions?
-# Investigate double-diffusive convection by adding another
advection-diffusion mesh to the problem that interpolates a
concentration field.
.
<hr>
<hr>
\section sources Source files for this tutorial
-  The source files for this tutorial are located in the directory:\n\n
<CENTER>
<A HREF="../../../../demo_drivers/multi_physics/boussinesq_convection">
demo_drivers/multi_physics/boussinesq_convection
</A>
</CENTER>
 which contains refineable and non-refineable multi-domain
versions of the Boussinesq convection problem.
- The refineable driver code described in this tutorial is:\n\n
<CENTER>
<A HREF="
../../../../
demo_drivers/multi_physics/boussinesq_convection/multimesh_ref_b_convection.cc
">
demo_drivers/multi_physics/boussinesq_convection/multimesh_ref_b_convection.cc
</A>
</CENTER>
- The non-refineable driver code is:\n\n
<CENTER>
<A HREF="
../../../../
demo_drivers/multi_physics/boussinesq_convection/multimesh_boussinesq_convection.cc
">
demo_drivers/multi_physics/boussinesq_convection/multimesh_ref_boussinesq_convection.cc
</A>
</CENTER>
.

