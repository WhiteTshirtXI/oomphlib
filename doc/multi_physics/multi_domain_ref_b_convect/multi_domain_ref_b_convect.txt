\mainpage Refineable Boussinesq Convection using a multi-domain approach: Combining (Refineable) Navier--Stokes and Advection-Diffusion domains

In this tutorial we present an alternative approach to the solution
of multi-physics problems, using what we call a "multi-domain"
approach. We illustrate the methodology 
by re-considering the <a href="../../b_convection/html/index.html"> 
previously-described, </a>
two-dimensional Boussinesq convection problem in
which an incompressible, Newtonian fluid is heated from below.
 
The tutorial is quite long but comprises four relatively self-contained parts. 
Feel free to skip the theory if you want to jump straight in...
\n\n
- <a href="#setting_up"><b>Part I</b></a> provides an overview of \c oomph-lib's
  overall framework for setting up multi-domain interactions.
  \n\n
- <a href="#implement_boussinesq"><b>Part II</b></a> illustrates the general
  procedure for the specific example of a Boussinesq convection problem. We 
  demonstrate how to implement a two-way, multi-domain interaction between 
  the Navier-Stokes equations in which the body force is affected by thermal
  buoyancy effects, and the advection-diffusion equations which determine the
  temperature distribution in response to the "wind" given by the
  Navier-Stokes equations.  
  \n\n
- <a href="#multi_domain_boussinesq"><b>Part III</b></a> discusses the
  driver code that solves the Boussinesq problem, using the elements developed 
  in Part II.
  \n\n
- <a href="#optimise"><b>Part IV</b></a> discusses how to optimise
  multi-domain interactions. 
.

<HR>

\section setting_up Part I: The overall framework for handling multi-domain interactions



When two or more physical processes interact within the same spatial
domain there are three different approaches to setting up the
interaction within \c oomph-lib. One approach is to write a completely
new element that discretises all the PDEs involved in the problem. 
The second approach, described in the tutorials discussing the
<a  href="../../b_convection/html/index.html"> the non-refineable  </a> and 
<a href="../../refine_b_convect/html/index.html">refineable </a> 
solution of the Boussinesq convection problem, is to create a 
combined multi-physics element using inheritance from two, or more, existing
elements. In both these cases, the physical processes and their
associated fields interact within a single element and we refer
to this methodology as a \b multi-field approach.

In this tutorial we describe a third approach to multi-physics
problems, in which we solve the problem using two different elements 
on two different meshes (domains), each occupying the same 
physical space.  Rather than interacting locally 
within elements, the different physical processes interact 
directly between the two domains, so that, in 
the Boussinesq convection problem considered here, each 
advection diffusion element obtains the "wind" from the (separate) 
Navier-Stokes element that occupies the same position, while 
the Navier-Stokes elements obtain the temperature
required for the computation of the buyoancy force from the
corresponding advection diffusion element.


One benefit of this \b multi-domain approach, compared to a \b
multi-field approach, is that different error estimators can be 
used on each domain and there is no longer a need to construct 
a combined multi-physics error estimator; see the 
<a href="../../refine_b_convect/html/index.html">tutorial for the
adaptive solution of the Boussinesq convection problem</a> for more
details on this issue. Moreover, the meshes do not
have to have the same refinement pattern, which can be
advantageous if the different physical processes act over different
spatial scales. The figure below shows that in the Boussinesq 
convection problem the Navier--Stokes mesh (panel (a)) requires much more
refinement than the advection-diffusion mesh (panel (b)).

@I w 0.75\textwidth two_domains "Steady Convection Rolls: (a) contours of x-velocity and corresponding element boundaries in Navier--Stokes mesh, (b) contours of temperature and corresponding element boundaries in advection-diffusion mesh. "


<HR>

\subsection external_elements The ElementWithExternalElement class

 Interaction between different elements in different domains is a
fundamental feature of many multi-physics problems and the generic
functionality to deal with such interactions is provided by the \c
ElementWithExternalElement class.  Any element that requires 
information from an "external element" should therefore inherit from the
base class \c ElementWithExternalElement.  

"External elements" typically provide source-like terms for the
\c ElementWithExternalElement. For instance, in the Boussinesq
convection problem studied here,
the advection diffusion element is the "external element" for
the Navier-Stokes element because it affects the body force
in the Navier-Stokes equations; in a fluid-structure interaction 
problem, the Navier-Stokes elements that are adjacent to the
fluid-loaded elastic wall act as the "external elements" for the
\c FSIWallElement because they determine the traction that the fluid
exerts onto the wall; etc.

 Within a finite-element context, the effect of the "external element" 
onto the \c ElementWithExternalElement typically has to be evaluated
at the integration points of the \c ElementWithExternalElement.
Therefore, the \c ElementWithExternalElement base class provides
storage for a pointer to an "external element" (and the local coordinate
within it) for each integration point. Access to this information
is provided via the member functions


\code
FiniteElement*& ElementWithExternalElement::external_element_pt(
                                const unsigned& interaction, 
                                const unsigned& ipt);
\endcode

and

\code
Vector<double>& ElementWithExternalElement::external_element_local_coord(
                      const unsigned& interaction, 
                      const unsigned& ipt);
\endcode

For a given integration point, \c ipt, within the \c
ElementWithExternalElement, these functions return the pointer to the
"external element" that occupies the same spatial position as the
integration point, and the local coordinate
of that point within the "external element", respectively.
The unsigned parameter \c interaction denotes the interaction
index. It is required to allow for cases in which an element interacts with more
than one "external element". This occurs, for instance, in doubly-diffusive
convection problems ***hierher Andrew link*** , where the body force 
in the Navier-Stokes equations is affected by two separate advection 
diffusion processes; or in FSI problems where a beam or shell element is
affected by a fluid load on both its "front" and "back" (see, e.g., the 
<a href="../../../interaction/fsi_channel_with_leaflet/html/index.html">FSI 
channel with leaflet problem</a>).

\c Data that affects the fields in the "external elements" 
must be specified so that the off-diagonal blocks in the 
\c ElementWithExternalElement's Jacobian matrix (representing the
derivatives of the \c ElementWithExternalElement's residual vector
with respect to the \c Data in the "external elements")
can be calculated. We divide such data into two categories:
- <em> External field data: </em> This is all \c Data that affects the 
fields by which the "external element" interacts with 
\c ElementWithExternalElement.
.
- <em> External geometric data: </em> This is all geometric \c Data that affects
the shape and position of the "external element" and, therefore, spatial 
derivatives of its fields. 
.
The rationale for this division is that in many cases the field 
data's contribution to the interaction blocks in the Jacobian matrix
can be found analytically, whereas the geometric
data is more easily handled by finite differencing.

Both types of external data are determined automatically by two member
functions of the \c ElementWithExternalElement. The first one,

\code
virtual void  ElementWithExternalElement::identify_all_field_data_for_external_interaction(
    Vector<std::set<FiniteElement*> > const &external_elements_pt,
    std::set<std::pair<Data*,unsigned> > &paired_interaction_data); 
\endcode

determines the external field data that affect the (possibly multiple) 
interactions in the \c ElementWithExternalElement. Given the vector 
\c external_elements_pt (within which  <code> external_elements_pt[i] </code>
contains the set of pointers to the "external elements"
involved in the \c ElementWithExternalElement's \c i -th interaction), the 
function returns a set of pairs, each of which comprises a
pointer to a \c Data object and an unsigned that identifies a value
within it. The default implementation of this function includes
\b all field data of \b all "external elements", using calls to

\code
void FiniteElement::identify_field_data_for_interactions(...)
\endcode

for each "external element". Similarly, the function

\code
virtual void  ElementWithExternalElement::identify_all_geometric_data_for_external_interaction(
    Vector<std::set<FiniteElement*> >  const &external_elements_pt,
    std::set<Data*> &external_geometric_data_pt);
\endcode   

returns the set of \b all \c Data that affect the shape or position of any
of the "external elements" specified by the vector \c
external_elements_pt. Again, this function has a default
implementation that determines \b all geometric Data associated
with "external elements" by calling

\code
void FiniteElement::identify_geometric_data(..)
\endcode

for each "external element".

We note that the default implementation of these functions can 
(and, where possible, should) be overloaded to exclude data values
that do not actually contribute to the interaction. For instance,
in the Boussinesq convection problem considered here, the
advection diffusion elements are only affected by the
velocity degrees of freedom in the Navier-Stokes elements but
not by the pressures. Our re-implementation of \c
ElementWithExternalElement::identify_all_field_data_for_external_interaction(...)
in the multi-domain advection-diffusion element for the Boussinesq problem
therefore excludes the pressure degrees of freedom. This is discussed
in more detail in <a href="#optimise"><b>Part IV</b></a>.

<HR>

\subsection off_diag_jac Computation of the Jacobian matrix

Most single-physics elements already provide functions 
to compute their own Jacobians analytically. These functions compute the
derivatives of the element's residual vector with respect to the 
element's "own" degrees of freedom (e.g. the fluid velocity and pressure in a
Navier-Stokes element). The interaction with the "external element"
introduces additional dependencies since the element's residual vector
now also depends on the unknowns associated with the "external
elements". The derivatives of the element's residual
vector with respect to these unknowns must therefore be included into the
computation of the element's Jacobian matrix. 


To maximise code re-use, we follow the approach discussed in 
the <a href="../../b_convection/html/index.html#comments">
comments </a> section of the single-domain version of the problem, 
and re-use the underlying element's \c fill_in_contribution_to_jacobian(...) 
function, while employing finite-differencing to evaluate the derivatives
of the element's residual vector with respect to the unknowns
associated with the "external element". This is done most easily by
using the function

\code
ElementWithExternalElement::fill_in_jacobian_from_external_interaction_by_fd(..)
\endcode

which computes the derivatives of the element's
residual vector with respect to external field and external geometric
data by calls to the two functions

\code
ElementWithExternalElement::fill_in_jacobian_from_external_interaction_field_by_fd(..)
\endcode

and

\code
ElementWithExternalElement::fill_in_jacobian_from_external_interaction_geometric_by_fd(..)
\endcode

If, in a particular problem, it is known that the interaction is not
affected by the position or shape of the "external elements" (i.e. if
the interaction terms do not involve spatial derivatives of the
"external element's" field variables, the unnecessary computation of the 
derivatives with respect to the "external element's" geometric data
may be suppressed using a call to

\code
ElementWithExternalElement::ignore_external_geometric_data();
\endcode

Depending on the complexity of the interaction terms, it may be
worthwhile to provide a function that computes the off-diagonal
blocks analytically. This is discussed in more detail in
<a href="#optimise"><b>Part IV</b></a>.


<HR>

\subsection setting_up_interaction Setting up the interaction

The namespace \c Multi_domain_functions provides numerous helper
functions that facilitate the setup of multi-domain interactions.
Specifically, the function \c Multi_domain_functions::set_sources(...)
can be used to identify the "external elements" in a two-way
interaction between two meshes. The function has the following
interface:

\code
  template<class ELEMENT_0,class ELEMENT_1>     
  void setup_multi_domain_interactions(Problem* problem_pt, 
                                       Mesh* const &first_mesh_pt,
                                       Mesh* const &second_mesh_pt,
                                       const unsigned& first_interaction=0,
                                       const unsigned& second_interaction=0);
\endcode

Here \c first_mesh_pt and \c second_mesh_pt point to the two
interacting meshes whose elements (of type \c ELEMENT_0 and
\c ELEMENT_1, respectively), must be derived
from the \c ElementWithExternalElement class. 
The optional interaction parameters may be used to specify 
which interaction is set up in either mesh. If the parameter is not specified
it defaults to zero, which is appropriate if there if there is
only a single interaction.

The function must be called prior to the assignment of the equation 
numbers, and then again whenever either of the two meshes has changed, 
e.g. after a mesh adaptation.


<HR>
<HR>


\section implement_boussinesq Part II: Implementing multi-domain interaction elements for the Boussinesq convection problem 

We shall now illustrate the general procedures discussed above
by demonstrating how to upgrade existing single-physics
Navier-Stokes and advection diffusion elements to \c ElementWithExternalElements
that can be used for the multi-domain-based solution of the 
Boussinesq convection problem. 

<HR>

\subsection nst Upgrading the Navier-Stokes element to an ElementWithExternalElement 


We employ multiple inheritance to upgrade the existing
\c RefineableQCrouzeixRaviartElement to a 
\c RefineableQCrouzeixRaviartBoussinesqElement
in which the temperature that affects the body force is given by
an "external" advection diffusion element. 

\dontinclude multi_domain_boussinesq_elements.h
\skipline nst_bous_class
\until
{


The constructor calls the constructors of the underlying elements, 
initialises the pointer to the Rayleigh number (stored as private
member data in the class) and sets the number of interactions to one,
indicating that the residuals of the Navier-Stokes element are only
affected by a single type of "external element" -- the advection diffusion
element that determines the temperature distribution. 

\until }

We provide access functions to the Rayleigh number

\until return Ra_pt;}

and, given that we are dealing with a refineable element, 
make sure that the pointer to the Rayleigh number is passed to the
"son" elements when the element is refined.

\until }

The most important step is to overload the function 
that computes the body force in the Navier-Stokes equations so that
it depends on the temperature at the \c ipt -th integration 
point, as computed by the "external element": 

\dontinclude multi_domain_boussinesq_elements.h
\skipline  Overload get_body_force_nst
\until {

The element only involves a single interaction so the interaction 
index is zero:

\until interaction=0

We obtain the pointer to the "external element" and cast it to 
an advection diffusion element:

\until external_element_pt

Following this pointer to the advection diffusion element, we
obtain the temperature by evaluating 
\c AdvectionDiffusionnEquations::interpolated_u_adv_diff(...).

\until interpolated_u_adv_diff(

We can now compute the body force by multiplying the temperature
by the Rayleigh number and the unit vector in the direction of gravity.

\until end overloaded body force


Finally, we have to compute the element's Jacobian matrix. 
The easiest (but also the least efficient) way to do this is to recycle the 
analytical computation of the derivatives of the Navier-Stokes 
residuals with respect to the fluid degrees of
freedom, as implemented in  
\c RefineableQCrouzeixRaviartElement::fill_in_contribution_to_jacobian(...),

\skipline Compute the element's residual vector and 
\until fill_in_contribution_to_jacobian(residuals,jacobian);

and then fill in the derivatives with respect to 
the degrees of freedom associated with the "external
elements" by finite differencing:
 
\until else
 
If this is deemed to be too inefficient, we can provide a function
that computes the required entries in the Jacobian analytically:

\until }


(The driver code illustrates both approaches and employs
the macro  \c USE_FD_FOR_DERIVATIVES_WRT_EXTERNAL_DATA
to choose which one to use.)

That's all, as far as a basic implementation is concerned! We 
refer to <a href="#optimise"><b>Part IV</b></a>  for a discussion of how to
implement the fully-analytical computation of the
Jacobian matrix in the function \c fill_in_off_diagonal_block_analytic(...).


<HR>

<HR>

\subsection ad Upgrading the advection diffusion element to an ElementWithExternalElement 


Upgrading the advection diffusion element to an \c
ElementWithExternalElement in which the wind is given by the
"external" Navier Stokes element follows the same procedure.
We use multiple inheritance to construct the element and
set the number of interactions to one:

\dontinclude multi_domain_boussinesq_elements.h
\skipline ad_bous_class
\until }


We overload the function that computes the "wind" for the advection
diffusion equations so that it is given by the fluid
velocity at the \c ipt -th integration point, as computed by 
the "external element": 

\dontinclude multi_domain_boussinesq_elements.h
\skipline  Overload the wind
\until {

The element only involves a single interaction so the interaction 
index is zero:

\until interaction=0

We obtain the pointer to the "external element" and cast it to 
the Navier-Stokes element:

\until external_element_pt

We follow the pointer to this element and evaluate the "wind"
by evaluating \c NavierStokesEquations::interpolated_u_nst(...)
at the local coordinate that coincides with the position of the
integration point:

\until }  //end of get_wind_adv_diff


Again, the element's Jacobian matrix can be computed by two
different methods, as discussed for the Navier-Stokes elements:

\skipline Compute the element
\until }


That's all!


<HR>
<HR>

\section multi_domain_boussinesq Part III: The driver code for the multi-domain Boussinesq problem


Using the upgraded elements discussed above, 
<A HREF="../../../../demo_drivers/multi_physics/boussinesq_convection/multi_domain_ref_b_convection.cc">the driver code </a>
for the multi-domain-based solution of the Boussinesq convection
problem is very similar to that of the 
<a href="../../refine_b_convect/html/index.html">
single-domain example.</a> Indeed, the \c main() functions are virtually
identical. The only difference is that the \c
RefineableConvectionProblem takes two template arguments (specifying
the two different element types) instead of one (specifying the
type of the single, combined element).

<HR>

\subsection problem_class The problem class

The problem class is similar to that of the
<a href="../../refine_b_convect/html/index.html">single-domain example
</a> and many of the functions are the same. 
There are now two meshes, however, one for the
fluid elements and one for the advection-diffusion elements

\dontinclude multi_domain_ref_b_convection.cc
\skipline Access function to the NST mesh
\until end_of_nst_mesh

\skipline Access function to the AD mesh
\until  end_of_ad_mesh

and after any mesh adaptation, the
interaction between the two meshes must be set up again.

\skipline Actions after adapt
\until end_of_actions_after_adapt

<HR>

\subsection constructor The Problem constructor

The problem constructor is slightly different from the equivalent
single-domain version mainly because there are two meshes instead of
one. Firstly, we build two coarse meshes with the same number of
elements (\f$ 9 \times 8 \f$, as in the original single-domain problem) and
dimensions for each mesh. Error estimators and error targets are set
separately for each mesh. 

\dontinclude multi_domain_ref_b_convection.cc
\skipline start_of_constructor
\until Adv_diff_mesh_pt->min_permitted_error

The boundary constraints are applied to each mesh in turn; firstly on
the Navier--Stokes mesh, where we must also pin a single pressure:

\skipline Set the boundary conditions
\until fix_pressure

We then apply boundary constraints to the advection-diffusion mesh:

\skipline Loop over the boundaries of the AD mesh
\until end of loop over AD mesh boundaries

and complete the build of all elements in each mesh by setting the
pointers to the required physical parameters in each domain.
Since neither of the interaction terms involves spatial derivatives
of the field variables in the "external elements", we can ignore
the derivatives with respect to the external geometric data
when computing the element's Jacobian matrix. This is done
by the calls to \c ElementWithExternalElement::ignore_external_geometric_data();

\skipline Complete the build of all elements
\until end of setup for all AD elements

Finally we combine the submeshes,
set up the interaction between the two meshes, and
assign the equation numbers.

\skipline combine the submeshes
\until end of constructor

<HR>

\subsection actions_before_newton_solve The function actions_before_newton_solve(...)

In this function we update the problem specifications before a
solution by re-applying the specific values of the Dirichlet boundary
conditions for each mesh, and ensuring that the mass-conserving
imperfection is applied to the velocity boundary conditions on the
Navier--Stokes mesh if required. The boundary conditions are exactly
the same as for the  <a href="../../b_convection/html/index.html">
single-domain version of the problem</a>, but they
must be applied differently because there are now two meshes instead
of one.

\dontinclude multi_domain_ref_b_convection.cc
\skipline start_actions_before_newton_solve
\until end of actions before solve

<HR>

\subsection doc_solution The function doc_solution(...)

This function outputs all fields to the specified solution file in the
directory pointed to by the \c DocInfo object.

\dontinclude multi_domain_ref_b_convection.cc
\skipline start_of_doc_solution
\until end of doc


<HR>
<HR>


\section optimise Part IV: Optimising multi-domain interactions
We showed in <a href="#implement_boussinesq"><b>Part II</b></a>
that typically only a small number of functions must be implemented to upgrade
an existing single-physics element to an \c ElementWithExternalElement
that can interact with another element in a different domain. This is
because much of the required functionality is already implemented 
in the \c ElementWithExternalElement base class. While this makes
the implementation of multi-physics interactions very easy, the 
use of general-purpose functions may incur unnecessary computational
cost if they are used in problems in which certain types of
interactions do not occur. It is therefore possible
to overload the relevant functions when implementing a specific 
\c ElementWithExternalElement. Here are some examples.

<HR>

\subsection restricting_field_data Ignoring field data that does not participate in the interaction 

The function
\c ElementWithExternalElement::identify_all_field_data_for_external_interaction(...)
assumes that \b all data values in the external elements affect
the interaction with the \c ElementWithExternalElement. In many
cases this assumption is overly pessimistic (and costly). For
instance in the Boussinesq convection problem only the velocity 
degrees of freedom in the (external) Navier-Stokes element affect
the the advection diffusion equations via the "wind". It is therefore
sensible to exclude the pressure degrees of freedom from the
interaction by re-implementing 
\c identify_all_field_data_for_external_interaction(...) as follows

\dontinclude multi_domain_boussinesq_elements.h
\skipline optimised_identification_of_field_data
\until // done

Similar approaches can be used to ignore selected (weak) interactions 
when computing the element's Jacobian matrix. For instance, 
the \c FSIWallElement is an \c ElementWithExternalElement
for which the adjacent fluid elements that apply the fluid
traction to the FSI boundary act as "external elements". 
In high-Reynolds-number flows, the fluid traction is dominated
by the pressure while shear stresses tend to be small. The \c FSIWallElement
therefore uses the same mechanism as illustrated above to (optionally)
neglect the derivatives of its residuals with respect to the fluid
velocity degrees of freedom. We stress that this does not exclude
the shear stress from the computation -- it simply replaces the
exact Jacobian by an approximate version in which the effect
of the velocity degrees of freedom on the residuals of the \c
FSIWallElement are neglected. This may lead to a slight degradation 
in the convergence rate of the Newton iteration but this may be
more than compensated for by the reduction in the CPU times required to
compute the Jacobian matrix.

<HR>

\subsection restricting_geom_data Ignoring geometric data

If the interaction with the "external element" does not involve
spatial derivatives of the fields represented by the "external element"
or if the mesh containing the "external elements" is fixed, the
external geometric data associated with the "external elements" can
be ignored when computing the \c ElementWithExternalElement's 
Jacobian. This may be achieved by calling

\code
ElementWithExternalElement::ignore_external_geometric_data();
\endcode

<HR>

\subsection analytical_jacobian Computing the off-diagonal blocks in the Jacobian analytically

The setup of the Jacobian matrix can be made much more efficient
by computing the derivatives of the \c ElementWithExternalElements'
residual vector with respect to the field data in the associated
"external elements" analytically. The multi-domain driver codes in 

<CENTER>
<A HREF="../../../../demo_drivers/multi_physics/boussinesq_convection">
demo_drivers/multi_physics/boussinesq_convection
</A>
</CENTER>

demonstrate a possible implementation. The key challenge for the
implementation is that the \c ElementWithExternalElement must label the entries
in its elemental Jacobian matrix by its local equation 
numbers, whereas the "external element" can only compute the
derivative of its fields with respect to its own (differently numbered) 
local degrees of freedom (d.o.f.s). To establish which local d.o.f. in the
"external element" corresponds to a given local d.o.f.
in the \c ElementWithExternalElement we exchange the (unique) global
equation numbers associated with each d.o.f. With this trick, the
computation of the derivatives becomes relatively straightforward.
Mathematically, it involves repeated applications of the chain rule. 
In the cases we considered, the fully-analytical computation of the
elemental Jacobian matrix was about 3 to 4 times faster than 
finite-difference-based computation implemented in the
\c ElementWithExternalElement base class. If this speedup is
worth the additional (human) time required to implement the
analytical computation of the off-diagonal entries depends on 
the application (and you!). If nothing else, the availability of a
finite-difference based routine helps in the validation of any
newly-developed analytical re-implementation. 


<HR>
<HR>

\section comm_and_ex Comments and Exercises
\subsection comments Comments
- The use of two separate meshes with different error estimators means
that, in principle, a more accurate solution can be obtained with
fewer degrees of freedom than using a combined error estimator on a
single mesh. The combined error estimator implemented in the
<a href="../../refine_b_convect/html/index.html">single-domain
version of the problem </a> will cause refinement if either the fluid
error or the advection-diffusion error is above the
specified tolerance. Thus, a fully-converged solution in the
single-domain problem is one in which the estimated error in 
all field variables is below the tolerance, but this may be at the
cost of some over-refinement in one or more of the field variables. In
the present multi-domain approach, if the solution is converged on
both meshes then the estimated error in all field variables is again
below the tolerance. Hence, it is fair, in some sense, to 
compare the results between fully-converged
solutions for the single- and multi-domain problems. As suggested by
the figure above, for the Boussinesq convection problem
considered here we do obtain fully-converged solutions
with fewer degrees of freedom using the multi-domain approach because
the temperature field is over-refined in the single-domain
case. Of course, the multi-domain solution includes the extra overhead
of setting up the interaction, but, in general, this cost is
negligible compared to the solution of the linear systems.
\n\n
- The general procedures described in this tutorial can be used to
set up any interaction between different types of elements using
multiple meshes. 
\n\n
- Before any refinements take place the combined Jacobian that is
assembled is exactly the same as that in the single-domain problem and
so the residuals at each Newton step will be exactly the same. You can
verify this by comparing the appropriate output files in the
\c Validation  directory.
.

<hr>

\subsection exercises Exercises
-# Investigate the difference between the solutions for the
   multi-domain and single-domain problems by continuing to refine until
   the solutions are fully-converged to a given error tolerance. What is
   the difference in total number of degrees of freedom? What is the
   difference in solution time? What is the difference between the two
   solutions?  
   \n\n
-# Investigate double-diffusive convection by adding another
   advection-diffusion mesh to the problem that interpolates a
   concentration field. ***hierher reference to driver code? ***
.
<hr>
<hr>
\section sources Source files for this tutorial
-  The source files for this tutorial are located in the directory:\n\n
<CENTER>
<A HREF="../../../../demo_drivers/multi_physics/boussinesq_convection">
demo_drivers/multi_physics/boussinesq_convection
</A>
</CENTER>
\n\n
 which contains refineable and non-refineable multi-domain
versions of the Boussinesq convection problem.
\n\n
- The full driver code for the problem described in this tutorial is:\n\n
<CENTER>
<A HREF="
../../../../
demo_drivers/multi_physics/boussinesq_convection/multi_domain_ref_b_convection.cc
">
demo_drivers/multi_physics/boussinesq_convection/multi_domain_ref_b_convection.cc
</A>
</CENTER>
\n\n
- The corresponding driver code for the non-refineable version of the
  problem is:\n\n
<CENTER>
<A HREF="
../../../../
demo_drivers/multi_physics/boussinesq_convection/multi_domain_boussinesq_convection.cc
">
demo_drivers/multi_physics/boussinesq_convection/multi_domain_ref_boussinesq_convection.cc
</A>
</CENTER>
.









@@END@@

\subsection element_modifications Modifying the Navier--Stokes and Advection--Diffusion elements for use in multi-domain problems

 In the present Boussinesq convection problem, we must write new
 elements so that the Navier-Stokes equations and advection-diffusion
 equations can be coupled between different domains:
\code
template<unsigned DIM>
class RefineableQCrouzeixRaviartElementWithExternalElement : 
 public virtual RefineableQCrouzeixRaviartElement<DIM>,
 public virtual ElementWithExternalElement 

template<unsigned DIM>
class RefineableQAdvectionDiffusionElementWithExternalElement : 
 public virtual RefineableQAdvectionDiffusionElement<DIM,3>,
 public virtual ElementWithExternalElement
\endcode

Within these new elements we overload appropriate functions so  
that the required coupling information is obtained
directly from  the "external element".  In this instance, therefore, 
we overload \c
get_body_force_nst() and \c get_wind_adv_diff() as follows:

\dontinclude my_boussinesq_elements.h
\skipline start_of_get_body_force_nst
\until end of get_body_force_nst

\skipline start_of_get_wind_adv_diff
\until end of get_wind_adv_diff

Note that the functions are similar to those  
the <a href="../../refine_b_convect/html/index.html">
single-domain version of the problem. </a>  They are exactly the
same if \c source_element_pt is replaced by \c this pointer and
\c external_element_local_coord(...) is replaced by \c s.

In both elements, we specify the number of interactions in the
 element constructors so 
 that storage for the pointers to "external
elements" and local coordinates can be allocated. In addition, there is
 no external geometric data because neither set of elements moves and
 we call the member function \c ignore_external_geometric_data() to
 avoid the call to \c
 identify_all_geometric_data_for_external_interaction(..) and a wasted
 loop over the elements.

\dontinclude my_boussinesq_elements.h
\skipline Constructor
\until }

\skipline Constructor
\until }

\subsubsection off_diag_jac Computation of the Jacobian matrix

 The easiest, but not the most efficient, method to compute the
 Jacobian matrix is to use finite
differences to assemble the entire matrix, 
but this ignores
the fact that the original elements compute their Jacobians analytically. As
discussed in the <a href="../../b_convection/html/index.html#comments">
comments </a> section of the single-domain version of the problem, we
can re-use the
 underlying element's \c fill_in_contribution_to_jacobian(...) 
function and then finite-difference the off-diagonal blocks of the
Jacobian. The off-diagonal blocks represent the effects of the data
from the "external element" on the residuals and can be calculated by
using the function
\code
ElementWithExternalElement::fill_in_jacobian_from_external_interaction_by_fd(..)
\endcode
which calls two functions
\code
ElementWithExternalElement::fill_in_jacobian_from_external_interaction_field_by_fd(..)
\endcode
and
\code
ElementWithExternalElement::fill_in_jacobian_from_external_interaction_geometric_by_fd(..)
\endcode
can be used to calculate the off-diagonal blocks.
In the present example we would only need to call the finite
difference routine for the external field data because the elements
don't move. 

The procedure for calculating the off-diagonal blocks analytically is
more involved than in the single-domain case and requires:
- the derivatives of the functions called from the external elements
with respect to the external elements' degrees of freedom;
.
and
- knowledge of the local equation numbers corresponding to the
external elements' degrees of freedom.
.

The derivatives of the external elements' 
functions with respect to degrees of freedom
must be provided by the external elements themselves, <em> i.e. </em>
\code
void AdvectionDiffusionEquations<DIM>::
dinterpolated_u_adv_diff_ddata(const Vector<double> &s, 
  Vector<double> &du_ddata,Vector<unsigned> &global_eqn_number)
\endcode
returns the derivatives that correspond to the function
\code
double AdvectionDiffusionEquations<DIM>::
interpolated_u_adv_diff( const Vector<double> &s)
\endcode
and
\code
void NavierStokeEquations<DIM>::
dinterpolated_u_nst_ddata(const Vector<double> &s, const unsigned &i,
Vector<double> &du_ddata, Vector<unsigned> &global_eqn_number)
\endcode
returns the derivatives that correspond to the function
\code
double NavierStokesEquations<DIM>::
interpolated_u_nst(const Vector<double> &s, const unsigned &i)
\endcode

We recommend that all such functions add the same two additional
vector arguments, \c du_ddata and \c global_eqn_number, and, on return,
these vectors should contain the derivatives of the
function with respect to each degree of freedom and the corresponding
global equation number of the degree of freedom, respectively. Thus,
the vectors will both be the same size: the number of degrees of
freedom of the (external) element.

These external element member functions are used to calculate the
derivatives of the body force in the Navier--Stokes element 
with respect to the temperature
(external) degrees of freedom 
and the derivatives of the wind in the 
advection-diffusion element with respect to the velocity (external)
degrees of freedom

\dontinclude my_boussinesq_elements.h
\skipline start_of_get_dbody_force
\until end_of_get_dbody_force

\skipline start_of_get_dwind
\until end_of_get_dwind

The use of these functions means that we have derivatives
and the global equation numbers of the corresponding unknowns.
The equivalent local equation numbers 
can then be found from the global equation
numbers by using the function
\code
int GeneralisedElement::local_eqn_number(const unsigned long &ieqn_global)
\endcode

The analytic computation of the off-diagonal terms 
is now reasonably straightforward, although
it is complicated by the potential presence of hanging nodes, and the
implementations are presented in the functions
\code
RefineableQCrouzeixRaviartElementWithExternalElement::
fill_in_off_diagonal_block_analytic(...)
\endcode
\code
RefineableQAdvectionDiffusionElementWithExternalElement::
fill_in_off_diagonal_block_analytic(...)
\endcode

Once again, there is a dramatic decrease in the assembly time of the
Jacobian matrix when all entries are calculated analytically.

<HR>
