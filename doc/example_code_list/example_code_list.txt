\mainpage Example codes and Tutorials

This document provides a complete list of the example codes that are 
distributed with the \c oomph-lib library. For each
code we give a brief description of the problem solved and
provide a link to the detailed documentation. The
codes are listed in order of increasing complexity. The bullet-point
list in the right column lists the new \c oomph-lib features
that are introduced in the example. You may either work
through the examples one-by-one, treating the example codes and their
documentation as chapters in a self-study course, or use the list of 
topics in the right column as a quick reference to example codes
that provide an introduction to a specific feature.

You may also wish to consult the following documents:
- The <A HREF="../../intro/html/index.html">Introduction </A> provides
  a "low tech" review of the theory of finite elements and presents a 
  "top-down" discussion of the method's implementation within \c oomph-lib.
- The document <A HREF="../../the_data_structure/html/index.html">
  The Data Structure </A> provides a "bottom-up" discussion of 
  \c oomph-lib's data structure.
- The <A HREF="../../quick_guide/html/index.html">(Not-So-)Quick
  Guide</A> provides a "quick" introduction on how to create new
  instances of \c oomph-lib's fundamental objects: \c Problems,
  \c Meshes, and \c Elements. 
.

<TABLE>
<TR>
<TD bgcolor="cornsilk">
<CENTER><B>Note:</b></CENTER>
We're still working on the detailed documentation for many
of the demo problems listed below. The fully-documented 
demo problems are accessible via the links. If you
are particularly interested in a specific problem for which the
detailed documentation is incomplete, let us know -- we might be able
to give it a slightly higher priority. We are happy to let you have 
driver codes before the documentation is complete. Such codes
usually need a bit of tidying to make them acceptable for 
"general release", but they are fully functional. In fact, they
are run on a regular basis as part of \c oomph-lib's self-test
routines (activated by typing \c make \c check in the top-level
directory). 
</TD>
</TR>
</TABLE>



<B>Overview:</b>
-# <A HREF="#problems">Example codes for specific problem/equations</A>
  - <A HREF="#poisson">Poisson problems</A>
  - <A HREF="#poisson_adapt">Mesh adaptation illustrated for 
            Poisson problems</A>
  - <A HREF="#adv_diff">The advection-diffusion equation</A>
  - <A HREF="#unsteady_heat">The unsteady heat equation; with an
           introduction to timestepping</A>
  - <A HREF="#wave">The linear wave equation</A>
  - <A HREF="#nst">The Navier-Stokes equations</A>
  - <A HREF="#axisym_nst">The axisymmetric Navier-Stokes equations</A>
  - <A HREF="#free_surface_nst">The free-surface Navier-Stokes equations</A>
  - <A HREF="#solid">Solid mechanics problems</A>
  - <A HREF="#beam">Beam structures</A>
  - <A HREF="#shell">Shell structures</A>
  - <A HREF="#fsi">(Fluid-structure) interaction problems</A>
  - <A HREF="#multi"> Multi-physics problems</A>
  .
-# <A HREF="#meshes">Mesh generation</A>
  - <A HREF="#available_meshes">Structured meshes</A>
  - <A HREF="#third_party_meshes">Unstructured meshes generated via input from
             third-party mesh generators</A>
  .
-# <A HREF="#solvers">Linear solvers and preconditioners</A>
  - <A HREF="#linear_solvers">Direct and iterative 
    linear solvers and general-purpose 
    preconditioners</A>
  - <A HREF="#specific_preconditioners">Problem-specific preconditioners</A>
  .
-# <A HREF="#visualisation">Visualisation</A>
  - <A HREF="#paraview">Visualising oomph-lib's output files with Paraview</A>
  .
.


<HR>
<HR>

<A NAME="problems"><B>Example codes for specific problem/equations</B></A>

<CENTER>
<TABLE>
######################################################################
<TR>
<TD>
<B>Example code</B>
</TD>
<TD>
<B>\c oomph-lib features/conventions illustrated 
by the example code</B>
</TD>
<TD>
<B>Completeness of the documentation</B>
</TD>
</TR>
#####################################################################
######################################################################
<TR>
<TD COLSPAN=3 bgcolor="lightcyan">
<A NAME="poisson"><CENTER><B>Poisson problems</B></CENTER></A>
</TD>
</TR>
######################################################################
<TR>
<TD>
<A HREF="../../poisson/one_d_poisson/html/index.html"><B>
The 1D Poisson equation
</B></A> \n\n
We (re-)solve the problem considered in the 
<A HREF="../../quick_guide/html/index.html">
Quick Guide</A>, this time using existing \c oomph-lib objects:
The \c OneDMesh and finite elements from the \c QPoisson family.
#@I w 0.75\textwidth one_d_fish "Plot of the solution "
</TD>
<TD>
- General post-processing routines. \n\n
- General conventions:
  - Use of public typedefs to specify function pointers.
  - Element constructors should not have any arguments.
  .
.
</TD>
<TD>
<CENTER>complete</CENTER>
</TD>
</TR>
######################################################################
<TR>
<TD>
<A HREF="../../poisson/two_d_poisson/html/index.html"><B>
The 2D Poisson equation.
</B></A> \n\n
We solve a 2D Poisson problem with Dirichlet boundary conditions
and compare the results against an exact solution.
</TD>
<TD>
- How to apply Dirichlet boundary conditions in complex meshes.
- How to use the \c DocInfo object to label output files.
- How does one change the linear solver in the Newton method?
\n\n
- General conventions:
  - \c oomph-lib mesh objects are templated by the element type.
    How does one pre-compile mesh objects?
</TD>
<TD>
<CENTER>complete</CENTER>
</TD>

</TR>
##############################################################
<TR>
<TD>
<A HREF="../../poisson/two_d_poisson_flux_bc/html/index.html"><B>
The 2D Poisson equation with flux boundary conditions (I)
</B></A>\n\n
Another 2D Poisson problem -- this time with Dirichlet and Neumann
boundary conditions.
</TD>
<TD>
- How to apply non-Dirichlet (flux) boundary conditions with \c
  FaceElements. \n\n
- General conventions:
  - What are broken virtual functions and why/when/where are they used?
</TD>
<TD>
<CENTER>complete</CENTER>
</TD>
</TR>
######################################################################
<TR>
<TD>
<A HREF="../../poisson/two_d_poisson_flux_bc2/html/index.html"><B>
The 2D Poisson equation with flux boundary conditions (II)
</B></A> \n\n
An alternative solution for the previous problem, using multiple meshes.
</TD>
<TD>
- How to use multiple meshes. \n\n
- General conventions:
  - In problems with multiple sub-meshes, \c Nodes retain 
    the boundary numbers of the mesh in which they were created.
</TD>
<TD>
<CENTER>complete</CENTER>
</TD>
</TR>
#####################################################################
######################################################################
<TR>
<TD COLSPAN=3 bgcolor="lightcyan">
<A NAME="poisson_adapt"><CENTER><B>Poisson problems with adaptivity</B></CENTER></A>
</TD>
</TR>
######################################################################
<TR>
<TD>
<A HREF="../../poisson/fish_poisson/html/index.html"><B>
Adaptive solution of Poisson's equation in a fish-shaped domain
</B></A> \n\n
We solve a 2D Poisson equation in a nontrivial, fish-shaped domain and 
demonstrate \c oomph-lib's fully-automatic mesh adaptation 
routines.
</TD>
<TD>
- How to perform automatic mesh adaptation. 
- \c oomph-lib's "black-box" adaptive Newton solver.
- \c The functions \c Problem::actions_before_adapt() and 
  \c Problem::actions_after_adapt().
</TD>
<TD>
<CENTER>complete</CENTER>
</TD>
</TR>
######################################################################
<TR>
<TD>
<A HREF="../../poisson/two_d_poisson_adapt/html/index.html"><B>
The 2D Poisson equation revisited -- how to create a refineable mesh
</B></A> \n\n
We revisit an <A HREF="../../poisson/two_d_poisson/html/index.html">
earlier example</A> and demonstrate how easy it is to "upgrade" an
existing mesh to a mesh that can be used with \c oomph-lib's
automatic mesh adaptation routines.
</TD>
<TD>
- "Upgrading" meshes to make them refineable.
- General conventions:
  - Hanging nodes -- the functions \c Node::position(...)
    and \c Node::value(...).
</TD>
<TD>
<CENTER>complete</CENTER>
</TD>
</TR>
######################################################################
<TR>
<TD>
<A HREF="../../poisson/fish_poisson2/html/index.html">
<B>
Poisson's equation in a fish-shaped domain revisited -- mesh
adaptation in deformable domains with curvilinear and/or moving boundaries.
</B>
</A>
 \n\n
We revisit an <A HREF="../../poisson/fish_poisson/html/index.html">
earlier example</A> and demonstrate how to create refineable
meshes for problems with curvilinear and/or moving domain boundaries.
</TD>
<TD>
- How to create refineable meshes for problems with
  curvilinear and/or moving domain boundaries.
- General conventions:
  - The \c GeomObject, \c Domain and \c MacroElement objects.
  - The \c Mesh::node_update() function. 
  - It is good practice to store boundary coordinates for 
    (\c Boundary) \c Nodes that are located on curvilinear domain boundaries. 
</TD>
<TD>
<CENTER>complete</CENTER>
</TD>
</TR>
######################################################################
<TR>
<TD>
<A HREF="../../poisson/two_d_poisson_flux_bc_adapt/html/index.html">
<B>
Adaptive solution of Poisson's equation with flux boundary
conditions. 
</B>
</A>
 \n\n
We revisit an <A HREF="../../poisson/two_d_poisson_flux_bc2/html/index.html">
earlier example</A> and demonstrate how to apply flux boundary
conditions in problems with spatial adaptivity. 
</TD>
<TD>
- How to apply flux boundary conditions in problems with spatial 
  adaptivity.
- General conventions:
  - The \c Mesh::flush_element_and_node_storage() function: "Emptying"
    a mesh without deleting its constituent nodes and elements (they
    might be shared with other meshes!). 
<TD>
<CENTER>complete</CENTER>
</TD>
</TR>
######################################################################
<TR>
<TD>
<A HREF="../../poisson/eighth_sphere_poisson/html/index.html">
<B>
Adaptive solution of a 3D Poisson equations in a spherical domain
</B>
</A>
\n\n
We demonstrate \c oomph-lib's octree-based 3D mesh adaptation
routines.
</TD>
<TD>
- Setting up and solving 3D problems isn't any harder than 
  doing it in 2D. 
- General conventions:
  - The namespace \c CommandLineArgs provides storage for the
    command line arguments to make them accessible throughout the
    code.
  - Plotting mesh boundaries.
</TD>
<TD>
<CENTER>complete</CENTER>
</TD>
</TR>
#####################################################################
######################################################################
<TR>
<TD COLSPAN=3 bgcolor="lightcyan">
<A NAME="adv_diff"><CENTER><B>The advection-diffusion equation</B></CENTER></A>
</TD>
</TR>
######################################################################
<TR>
<TD>
<A HREF="../../advection_diffusion/two_d_adv_diff_adapt/html/index.html">
<B>The 2D advection diffusion equation with spatial adaptivity
</B>
</A>
\n\n
We solve a 2D advection-diffusion equation and illustrate the
characteristic features of solutions at large Peclet number.
</TD>
<TD>
- The adaptive discretisation of the advection diffusion equation.
- How to specify the "wind" and the Peclet number for the 
  advection diffusion equation.
- How to document the progress of \c oomph-lib's "black box" adaptive
  Newton solver.
</TD>
<TD>
<CENTER>complete</CENTER>
</TD>
</TR>
######################################################################
<TR>
<TD>
<A HREF="../../advection_diffusion/two_d_adv_diff_flux_bc/html/index.html">
<B>2D advection diffusion equation with Neumann (flux) boundary conditions.
</B>
</A>
\n\n
We solve a 2D advection-diffusion equation with flux boundary conditions.
</TD>
<TD>
- How to specify Neumann (flux) boundary conditions for the
  advection diffusion equation.
</TD>
<TD>
<CENTER>complete</CENTER>
</TD>
</TR>
######################################################################
<TR>
<TD>
<A HREF="../../advection_diffusion/two_d_adv_diff_SUPG/html/index.html">
<B>The 2D advection diffusion equation revisited: Petrov-Galerkin
methods and SUPG stabilisation.
</B>
</A>
\n\n
We demonstrate how to implement a stabilised Petrov-Galerkin discretisation
of the advection diffusion equation. 
</TD>
<TD>
- Petrov-Galerkin discretisation of the advection-diffusion equation.
- General conventions:
  - The role of shape, basis and test functions.
  - The element building blocks: Geometric elements, equation classes
    and specific elements.
</TD>
<TD>
<CENTER>Driver code and pretty pictures</CENTER>
</TD>
</TR>
#####################################################################
######################################################################
<TR>
<TD COLSPAN=3 bgcolor="lightcyan">
<A NAME="unsteady_heat"><CENTER><B>The unsteady heat equation and 
an introduction to time-stepping</B></CENTER></A>
</TD>
</TR>
######################################################################
<TR>
<TD>
<A HREF="../../unsteady_heat/two_d_unsteady_heat/html/index.html">
<B>
The 2D unsteady heat equation
</B>
</A>
\n\n
We solve the 2D unsteady heat equation and 
demonstrate \c oomph-lib's time-stepping procedures for 
parabolic problems.
</TD>
<TD>
- Solving time-dependent problems with \c Problem::unsteady_newton_solve(...)
- The functions \c Problem::actions_before_implicit_timestep() and
  \c Problem::actions_before_implicit_timestep().
- The BDF timesteppers and how to set up initial conditions 
  for parabolic problems.
- Initialising the "previous" nodal positions for elements that are
  based on an ALE formulation. 
  \n\n
- General conventions:
  - Providing a default \c Steady timestepper for all \c Mesh
    constructors. 
  - Steady and unsteady versions of functions -- position and
    interpretation of the (discrete) time index.
</TD>
<TD>
<CENTER>complete</CENTER>
</TD>
</TR>
######################################################################
<TR>
<TD>
<A HREF="../../unsteady_heat/two_d_unsteady_heat2/html/index.html">
<B>
The 2D unsteady heat equation with restarts
</B>
</A>
\n\n
We demonstrate \c oomph-lib's dump/restart capabilities which
allow time-dependent simulations to be restarted.
</TD>
<TD>
- The functions \c Problem::dump(...) and
  \c Problem::read(...).
- How to customise the generic dump/restart functions.
  \n\n
</TD>
<TD>
<CENTER>complete</CENTER>
</TD>
</TR>
######################################################################
<TR>
<TD>
<A HREF="../../unsteady_heat/two_d_unsteady_heat_t_adapt/html/index.html">
<B>
The 2D unsteady heat equation with adaptive timestepping
</B>
</A>
\n\n
We demonstrate \c oomph-lib's adaptive timestepping capabilities.
</TD>
<TD>
- How to enable temporal adaptivity.
- The function \c Problem::adaptive_unsteady_newton_solve().
- The function \c Problem::global_temporal_error_norm().
- How to choose the target for the global temporal error norm.
</TD>
<TD>
<CENTER>complete</CENTER>
</TD>
</TR>
######################################################################
<TR>
<TD>
<A HREF="../../unsteady_heat/two_d_unsteady_heat_adapt/html/index.html">
<B>
Spatially adaptive solution of the 2D unsteady heat equation with
Neumann (flux) boundary conditions.
</B>
</A>
 \n\n
We solve a 2D unsteady heat equation in a non-trivial domain
with flux boundary conditions and compare the computated results
against the exact solution.
</TD>
<TD>
- Spatial adaptvity in time-dependent problems.
- Choosing the maximum number of spatial adaptations per timestep.
- Using \c Problem::set_initial_condition() to assign initial
  conditions ensures that the initial conditions are re-assigned when
  mesh adaptations are performed while the first timestep is
  computed.
- The functions \c Problem::dump(...) and
  \c Problem::read(...) can handle adaptive meshes. \n\n
</TD>
<TD>
<CENTER>complete</CENTER>
</TD>
</TR>
######################################################################
<TR>
<TD>
<A HREF="../../unsteady_heat/two_d_unsteady_heat_ALE/html/index.html">
<B>
Spatially adaptive solution of the 2D unsteady heat equation in a
moving domain with Neumann (flux) boundary conditions.
</B>
</A>
 \n\n
We demonstrate the  spatially adaptive solution of a 2D
unsteady heat equation in a nontrivial moving domain.
</TD>
<TD>
- The ALE form of the unsteady heat equation and its implementation in
  \c oomph-lib's unsteady heat elements.
- The role of the positional \c TimeStepper and the importance of
  assigning history values for the nodal positions. 
\n\n
- General conventions:
  - The function \c Mesh::node_update() automatically updates 
    the nodal positions in response to the deformation/motion of time-dependent
    \c GeomObjects that define the \c Domain and \c Mesh boundaries.
</TD>
<TD>
<CENTER>complete</CENTER>
</TD>
</TR>
######################################################################
<TR>
<TD>
<A HREF="../../unsteady_heat/two_d_unsteady_heat_2adapt/html/index.html">
<B>
Spatially and temporally adaptive solution of the 2D unsteady heat
equation in a moving domain with flux boundary conditions.
</B>
</A>
 \n\n
We demonstrate the use of combined spatial and temporal adaptivity for the
solution of a 2D unsteady heat equation in a nontrivial moving domain.
</TD>
<TD>
- Adaptive timestepping combined with spatial adaptivity.\n\n
</TD>
<TD>
<CENTER>complete</CENTER>
</TD>
</TR>
#####################################################################
######################################################################
<TR>
<TD COLSPAN=3 bgcolor="lightcyan">
<A NAME="wave"><CENTER><B>The linear wave equation</B></CENTER></A>
</TD>
</TR>
######################################################################
<TR>
<TD>
<A HREF="../../linear_wave/two_d_linear_wave/html/index.html">
<B>The 2D linear wave equation.
</B>
</A>
\n\n
We solve a 2D wave equation and demonstrate \c oomph-lib's 
time-stepping procedures for hyperbolic problems.
</TD>
<TD>
- Timestepping for hyperbolic problems: The Newmark scheme.
- How to set up initial conditions for hyperbolic problems.
- Default settings for the linear wave equation elements. 
- How to apply Neumann (flux) boundary conditions for the
  linear wave equation. 
  \n\n
</TD>
<TD>
<CENTER>complete</CENTER>
</TD>
</TR>
######################################################################
<TR>
<TD>
##<A HREF="../../linear_wave/two_d_lin_wave_adapt/html/index.html">
<B>The spatially-adaptive solution of the 2D linear wave equation
</B>
#</A>
\n\n
We demonstrate that the spatially-adaptive solution of the 
2D wave equation is difficult (in fact, not very sensible)
because any spurious waves that are generated during mesh adaptation
are never damped out. Refineable linear wave elements should therefore
only be used to "manually" refine meshes before the start of the simulation. 
</TD>
<TD>
- How to use refineable linear wave elements
  \n\n
</TD>
<TD>
<CENTER>driver code only</CENTER>
</TD>
</TR>
#####################################################################
######################################################################
<TR>
<TD COLSPAN=3 bgcolor="lightcyan">
<A NAME="nst"><CENTER><B>The Navier-Stokes equations</B></CENTER></A>
</TD>
</TR>
######################################################################
<TR>
<TD>
<A HREF="../../navier_stokes/driven_cavity/html/index.html">
<B>The 2D Navier-Stokes equations: Driven cavity flow
</B>
</A>
\n\n
Probably the most-solved problem in computational fluid dynamics:
Steady driven cavity flow. We illustrate the problem's discretisation
with Taylor-Hood and Crouzeix-Raviart elements.
</TD>
<TD>
- Discretising the steady Navier-Stokes equations: The governing
  equations and their implementation in the stress-divergence and
  simplified forms.
- Non-dimensional parameters and their default values.
- The pressure representation in Taylor-Hood and Crouzeix-Raviart elements.
- Pinning a pressure value in problems with Dirichlet boundary
  conditions for the velocity on all boundaries.      
</TD>
<TD>
<CENTER>complete</CENTER>
</TD>
</TR>
######################################################################
<TR>
<TD>
<A HREF="../../navier_stokes/adaptive_driven_cavity/html/index.html">
<B>The 2D Navier-Stokes equations: Adaptive solution of the 2D driven cavity problem
</B>
</A>
\n\n
We employ \c oomph-lib's mesh adaptation routines 
to refine the mesh in the neighbourhood of the 
pressure singularities. 
</TD>
<TD>
- Treatment of pressure degrees of freedom in Navier-Stokes 
  simulations with adaptive mesh refinement -- pinning "redundant"
  pressure degrees of freedom. \n\n
</TD>
<TD>
<CENTER>complete</CENTER>
</TD>
</TR>
######################################################################
<TR>
<TD>
<A HREF="../../navier_stokes/circular_driven_cavity/html/index.html">
<B>The 2D Navier-Stokes equations: Driven cavity flow in a
quarter-circle domain with mesh adaptation
</B>
</A>
\n\n
We re-solve the driven-cavity problem in a different domain,
demonstrate how to apply body forces and show how to switch
between the stress-divergence and simplified forms of the
Navier-Stokes equations.
</TD>
<TD>
- Adapting the driven cavity problem to different domains.
- How to apply body forces in the Navier-Stokes equations.
- How to switch between the stress-divergence and the simplified
  form of the incompressible Navier-Stokes equations.\n\n
</TD>
<TD>
<CENTER>complete</CENTER>
</TD>
</TR>
######################################################################
<TR>
<TD>
<A HREF="../../navier_stokes/three_d_entry_flow/html/index.html">
<B>Adaptive simulation of 3D finite Reynolds number entry flow into a circular pipe
</B>
</A>
\n\n
We solve the classical problem of entry flow into a 3D tube.
</TD>
<TD>
- Adaptivity for 3D Navier-Stokes problems
- How to determine the numbering scheme for mesh boundaries.
- How to adjust parameters that control the behaviour of
  \c oomph-lib's Newton solver.
- The natural (traction-free) boundary conditions for the
  Navier-Stokes equations.
</TD>
<TD>
<CENTER>complete</CENTER>
</TD>
</TR>
######################################################################
<TR>
<TD>
<A HREF="../../navier_stokes/rayleigh_channel/html/index.html">
<B>A variant of Rayleigh's oscillating plate problem: The unsteady 
2D Navier-Stokes equations  with periodic boundary conditions
</B>
</A>
\n\n
We solve a variant of the classical Rayleigh plate problem to demonstrate
the use of periodic boundary conditions and time-stepping for the
Navier-Stokes equations.
</TD>
<TD>
- Timestepping for the Navier-Stokes equations. 
- How to apply periodic boundary conditions. \n\n
- General conventions:
  - Periodic boundary conditions should be applied in the \c Mesh
    constructor.
  .
.
</TD>
<TD>
<CENTER>complete</CENTER>
</TD>
</TR>
######################################################################
<TR>
<TD>
<A HREF="../../navier_stokes/rayleigh_traction_channel/html/index.html">
<B>Another variant of Rayleigh's oscillating plate problem: The unsteady 
2D Navier-Stokes equations with periodic boundary conditions, driven
by an applied traction.
</B>
</A>
\n\n
We demonstrate how to apply traction boundary conditions for the
Navier-Stokes equations. 
</TD>
<TD>
- How to apply traction boundary conditions for the Navier-Stokes
  equations.
   \n\n
.
</TD>
<TD>
<CENTER>complete</CENTER>
</TD>
</TR>
######################################################################
<TR>
<TD>
<A HREF="../../navier_stokes/osc_ellipse/html/index.html">
<B> 2D finite-Reynolds-number-flow driven by an oscillating ellipse
</B>
</A>
\n\n
We study the 2D finite-Reynolds number flow contained inside an 
oscillating elliptical ring and compare the computed results against
an exact solution (an unsteady stagnation point flow).
</TD>
<TD>
- Solving the Navier-Stokes equations in a moving domain. 
- How to apply no-slip boundary conditions on moving walls, using
  the function
  \C FSI_functions::apply_no_slip_on_moving_wall(...) \n\n
</TD>
<TD>
<CENTER>complete</CENTER>
</TD>
</TR>
######################################################################
<TR>
<TD>
<A HREF="../../navier_stokes/collapsible_channel/html/index.html">
<B> 2D finite-Reynolds-number-flow in a 2D channel with a moving wall
</B>
</A>
\n\n
This is a "warm-up" problem for the classical fluid-structure
interaction problem of 
<A HREF="../../interaction/fsi_collapsible_channel/html/index.html"> 
flow in a 2D collapsible channel</A>. Here we
compute the flow through a 2D channel in which part of one wall is 
replaced by a moving "membrane" whose motion is prescribed. 
</TD>
<TD>
- The adaptive solution of the Navier-Stokes equations in a moving 
  domain with traction boundary conditions.       \n\n
</TD>
<TD>
<CENTER>complete</CENTER>
</TD>
</TR>
######################################################################
<TR>
<TD>
<A HREF="../../navier_stokes/algebraic_collapsible_channel/html/index.html">
<B> 2D finite-Reynolds-number-flow in a 2D channel with a moving wall
revisited: Algebraic Node updates.
</B>
</A>
\n\n
We re-visit the problem studied in the previous example and
demonstrate an alternative node-update procedure, based on
\c oomph-lib's \c AlgebraicNode, \c AlgebraicElement and
\c AlgebraicMesh classes. Algebraic node updates will turn out to be essential
for the efficient implementation of fluid-structure interaction 
problems.
</TD>
<TD>
- How to customise the node-update, using \c oomph-lib's \c AlgebraicNode, 
\c AlgebraicElement and \c AlgebraicMesh classes. 
- Existing \c AlgebraicMeshes are easy to use: Simply "upgrade" the
  required element (of type \c ELEMENT, say) in the templated wrapper class
  \c AlgebraicElement<ELEMENT>.  \n\n
</TD>
<TD>
<CENTER>complete</CENTER>
</TD>
</TR>
######################################################################
<TR>
<TD>
<A HREF="../../navier_stokes/channel_with_leaflet
/html/index.html">
<B> 2D finite-Reynolds-number-flow in a 2D channel that is partially
obstructed by an oscillating leaflet
</B>
</A>
\n\n
This is a "warm-up" problem for 
<A HREF="../../interaction/fsi_channel_with_leaflet/html/index.html"> 
the corresponding fluid-structure interaction problem</A> where
the leaflet deforms in response to the fluid traction. Here we
consider the case where the motion of the leaflet is prescribed.
</TD>
<TD>
- Another example illustrating the use of algebraic and 
  \c MacroElement/Domain-based node update techniques.
</TD>
<TD>
<CENTER>complete</CENTER>
</TD>
</TR>
######################################################################
<TR>
<TD>
<A HREF="../../navier_stokes/turek_flag_non_fsi/html/index.html">
<B> Flow past a cylinder with a waving flag
</B>
</A>
\n\n
This is a "warm-up" problem for 
<A HREF="../../interaction/turek_flag/html/index.html"> 
Turek & Hron's FSI benchmark problem</A> where
the flag deforms in response to the fluid traction. Here we
consider the case where the motion of the flag is prescribed.
</TD>
<TD>
- Another example illustrating the use of algebraic and 
  \c MacroElement/Domain-based node update techniques.
</TD>
<TD>
<CENTER>complete</CENTER>
</TD>
</TR>
######################################################################


#####################################################################
######################################################################
<TR>
<TD COLSPAN=3 bgcolor="lightcyan">
<A NAME="axisym_nst"><CENTER><B>The axisymmetric Navier-Stokes equations</B></CENTER></A>
</TD>
</TR>
######################################################################
<TR>
<TD>
<A HREF="../../axisym_navier_stokes/spin_up/html/index.html">
<B>Spin-up of a viscous fluid -- the spatially adaptive solution of the unsteady axisymmetric Navier-Stokes equations.</B>
</A>
\n\n
A classical fluid mechanics problem: Spin-up of a viscous fluid.
A key feature of the flow is the development of thin Ekman (boundary)
layers during the early stages of the spin-up. We demonstrate how
the use of spatial adaptivity helps to resolve these layers. At 
large times, the flow field approaches a rigid-body rotation -- 
this poses a subtle problem for the spatial adaptivity as its default 
behaviour would cause strong spatially uniform refinement.
#####################################################################
</TD>
<TD>
- The axisymmetric Navier-Stokes equations
- How to prescribe a constant reference value for the normalisation of
  the error in spatially-adaptive computations in which the solution
  approaches a "trivial" solution.
</TD>
<TD>
<CENTER>driver code and pretty pictures</CENTER>
</TD>
</TR>
######################################################################



#####################################################################
######################################################################
<TR>
<TD COLSPAN=3 bgcolor="lightcyan">
<A NAME="free_surface_nst"><CENTER><B>The free-surface Navier-Stokes equations</B></CENTER></A>
</TD>
</TR>
######################################################################
<TR>
<TD>
<A HREF="../../navier_stokes/bretherton/html/index.html">
<B>The Bretherton problem: An air finger propagates into a 2D
fluid-filled channel.</B>
</A>
\n\n
A classical fluid mechanics problem: We study the propagation
of an inviscid (air) finger into a 2D fluid-filled channel and
compare our results against those from Bretherton's theoretical
analysis.
</TD>
<TD>
- ***
- General conventions:
  - ***
</TD>
<TD>
<CENTER>driver code and pretty pictures</CENTER>
</TD>
</TR>
######################################################################
<TR>
<TD>
<A HREF="../../navier_stokes/single_layer/html/index.html">
<B>Free-surface relaxation oscillations of a viscous fluid layer.</B>
</A>
\n\n
We study the oscillations of perturbed fluid layer.
</TD>
<TD>
- ***
- General conventions:
  - ***
</TD>
<TD>
<CENTER>driver code and pretty pictures</CENTER>
</TD>
</TR>
######################################################################
<TR>
<TD>
<A HREF="../../navier_stokes/two_layer_interface/html/index.html">
<B>Relaxation oscillations of an interface between two viscous fluids.</B>
</A>
\n\n
We study the oscillations of two-layer fluid system.
</TD>
<TD>
- ***
- General conventions:
  - ***
</TD>
<TD>
<CENTER>driver code only</CENTER>
</TD>
</TR>
######################################################################
<TR>
<TD>
<A HREF="../../navier_stokes/static_single_layer/html/index.html">
<B>A static free surface bounding a layer of viscous fluid.</B>
</A>
\n\n
A hydrostatics problem: Compute the static free surface that
bounds a layer of viscous fluid -- harder than you might think!
</TD>
<TD>
- ***
- General conventions:
  - ***
</TD>
<TD>
<CENTER>driver code only</CENTER>
</TD>
</TR>
######################################################################
<TR>
<TD>
<A HREF="../../navier_stokes/static_two_layer/html/index.html">
<B>A static interface between two viscous fluids.</B>
</A>
\n\n
A hydrostatics problem: Compute the static interface between two
viscous fluids -- harder than you might think!
</TD>
<TD>
- ***
- General conventions:
  - ***
</TD>
<TD>
<CENTER>driver code only</CENTER>
</TD>
</TR>
#####################################################################
<TR>
<TD>
<A HREF="../../navier_stokes/adaptive_interface/html/index.html">
<B>A steadily-rotating cylinder below a free surface in a finite box.</B>
</A>
\n\n
Compute the free surface position and fluid velocity and pressure
fields about a fixed, steadily-rotating cylinder immersed in a viscous
fluid in a finite box. 
Uses a pseudo-elastic remesh strategy and spatial adaptivity in a 
non-trivial free surface problem.
</TD>
<TD>
- ***
- General conventions:
  - ***
</TD>
<TD>
<CENTER>driver code only</CENTER>
</TD>
</TR>
#####################################################################




######################################################################
######################################################################
<TR>
<TD COLSPAN=3 bgcolor="lightcyan">
<A NAME="solid"><CENTER><B>Solid mechanics problems</B></CENTER></A>
</TD>
</TR>
######################################################################
<TR>
<TD>
<A HREF="../../solid/solid_theory/html/index.html">
<B>Solid mechanics: Theory and implementation
</B>
</A>
\n\n
In this document we discuss the theoretical background and the
practical implementation of \c oomph-lib's solid mechanics
capabilities. 
</TD>
<TD>
- Theory:
 - Solid mechanics problems -- Lagrangian coordinates
 - The geometry
 - Equilibrium and the Principle of Virtual Displacements
 - Constitutive Equations for Purely Elastic Behaviour
 - Non-dimensionalisation
 - 2D problems: Plane strain.
 - Isotropic growth.
 - Specialisation to a cartesian basis and finite element discretisation
 . 
- Implementation:
 - The \c SolidNode class
 - The \c SolidFiniteElement class
 - The \c SolidMesh class
 - The \c SolidTractionElement class
 .
- Timestepping and the generation of initial conditions for solid mechanics problems
.
</TD>
<TD>
<CENTER>complete</CENTER>
</TD>
</TR>
######################################################################
<TR>
<TD>
<A HREF="../../solid/airy_cantilever/html/index.html">
<B>Bending of a cantilever beam
</B>
</A>
\n\n
We study a classical solid mechanics problem:  the bending
of a cantilever beam subject to a uniform pressure loading on its
upper face and/or gravity. We compare the results for zero-gravity
against the (approximate) analytical St. Venant solution for
the stress field. 
</TD>
<TD>
- How to formulate solid mechanics problems.
- How to choose a constitutive equation.
- How to apply traction boundary conditions, using
  \c SolidTractionElements.
</TD>
<TD>
<CENTER>complete</CENTER>
</TD>
</TR>
######################################################################
<TR>
<TD>
<A HREF="../../solid/disk_compression/html/index.html">
<B>Axisymmetric compression of a circular disk
</B>
</A>
\n\n
We study the axisymmetric compression of a circular, elastic disk,
loaded by an external traction and "self-gravity". The results
are compared against the predictions from small-displacement
elasticity. 
</TD>
<TD>
- How to formulate solid mechanics problems.
- How to choose a constitutive equation.
- How to apply traction boundary conditions, using
  \c FaceElements.
- General conventions:
  - ***
</TD>
<TD>
<CENTER>driver code only</CENTER>
</TD>
</TR>
######################################################################
<TR>
<TD>
#<A HREF="../../solid/large_shear/html/index.html">
<B>Large shearing deformations of a hyper-elastic, incompressible
block of material 
</B>
#</A>
\n\n
We solve a classical problem in large-displacement elasticity and
comprare against Green and Zerna's exact solution. 
</TD>
<TD>
- How to use incompressible materials.
- General conventions:
  - ***
</TD>
<TD>
<CENTER>to be written!</CENTER>
</TD>
</TR>
######################################################################
<TR>
<TD>
<A HREF="../../solid/disk_oscillation/html/index.html">
<B>Axisymmetric oscillations of a circular disk
</B>
</A>
\n\n
We study the free axisymmetric oscillations of a circular, 
elastic disk and compare the eigenfrequencies and modes
against the predictions from small-displacement elasticity. 
</TD>
<TD>
- How to assign initial conditions for unsteady solid mechanics problems.
- General conventions:
  - ***
</TD>
<TD>
<CENTER>driver code only</CENTER>
</TD>
</TR>
######################################################################
<TR>
<TD>
<A HREF="../../solid/shock_disk/html/index.html">
<B>Large-amplitude shock waves in a circular disk
</B>
</A>
\n\n
We study the propagation of shock waves in an elastic 2D circular disk.
</TD>
<TD>
- Spatial adaptivity for solid mechanics problems. 
- General conventions:
  - ***
</TD>
<TD>
<CENTER>driver code only</CENTER>
</TD>
</TR>
######################################################################
<TR>
<TD>
<A HREF="../../solid/static_fish/html/index.html">
<B>Boundary-driven deformation of a non-trivial 2D solid domain.
</B>
</A>
\n\n
We study the large deformations of a (fish-shaped) 2D elastic domain,
driven by the prescribed deformation of its boundary. 
</TD>
<TD>
- Imposing displacement boundary conditions in solid mechanics
  problems with curvilinear boundaries.
- General conventions:
  - ***
</TD>
<TD>
<CENTER>driver code and pretty pictures</CENTER>
</TD>
</TR>
#####################################################################
######################################################################
<TR>
<TD COLSPAN=3 bgcolor="lightcyan">
<A NAME="beam"><CENTER><B>Beam structures</B></CENTER></A>
</TD>
</TR>
######################################################################
<TR>
<TD>
<A HREF="../../beam/tensioned_string/html/index.html">
<B>The deformation of a pre-stressed elastic beam, loaded by a pressure load
</B>
</A>
\n\n
We study the lateral deformation of a pre-stressed elastic beam,
using \c oomph-lib's geometrically non-linear Kirchhoff-Love-type
\c HermiteBeamElement and compare the results against an
(approximate) analytical solution. 
</TD>
<TD>
- How to specify the undeformed reference shape for 
  the Kirchhoff-Love-type beam elements.
- How to apply boundary conditions and loads for the 
  \c HermiteBeamElement.
- General conventions:
  - How to change control parameters for the Newton solver.
</TD>
<TD>
<CENTER>complete</CENTER>
</TD>
</TR>
######################################################################
<TR>
<TD>
<A HREF="../../beam/steady_ring/html/index.html">
<B>Large-displacement post-buckling of a pressure-loaded,
thin-walled elastic ring
</B>
</A>
\n\n
We compute the post-buckling deformation of a thin-walled elastic
ring, subjected to a pressure load and compare the
results against results from the literature.
</TD>
<TD>
- How to use \c oomph-lib's \c DisplacementControlElement to apply
  displacement control in solid mechanics problems.\n\n
- General conventions:
  - What should be stored in a \c GeneralisedElement's "external" \c Data?
  - What should be stored in a \c Problem's "global" \c Data?
.
</TD>
<TD>
<CENTER>complete</CENTER>
</TD>
</TR>
######################################################################
<TR>
<TD>
<A HREF="../../beam/unsteady_ring/html/index.html">
<B>Large-amplitude oscillations of a thin-walled elastic ring.
</B>
</A>
\n\n
We compute the free, large-amplitude oscillations of a thin-walled elastic
ring and demonstrate that Newmark's method is energy conserving.
</TD>
<TD>
- How to assign initial conditions for beam structures.
- How to use the dump/restart function for \c HermiteBeamElements.
- Demonstrate that \c Newmark timesteppers can be used with
  variable timesteps. 
- How to retrieve solutions at previous timesteps in computations 
  with \c Newmark timesteppers.
- Changing the default non-dimensionalsation for time. 
- The non-dimensionalisation of the kinetic and potential (strain)
  energies of \c HermiteBeamElements.
</TD>
<TD>
<CENTER>complete</CENTER>
</TD>
</TR>
######################################################################
<TR>
<TD>
<A HREF="../../beam/lin_unsteady_ring/html/index.html">
<B>Small-amplitude oscillations of a thin-walled elastic ring.
</B>
</A>
\n\n
We compute the free, small-amplitude oscillations of a thin-walled elastic
ring, demonstrate that Newmark's method is energy conserving,
and compare the oscillation frequencies and mode shapes against
analytical predictions.
</TD>
<TD>
- How to assign initial conditions for beam structures.
- General conventions:
  - ***
</TD>
<TD>
<CENTER>driver code only</CENTER>
</TD>
</TR>
#####################################################################
######################################################################
<TR>
<TD COLSPAN=3 bgcolor="lightcyan">
<A NAME="shell"><CENTER><B>Shell structures</B></CENTER></A>
</TD>
</TR>
######################################################################
<TR>
<TD>
#<A HREF="../../shell/clamped_shell_buckling/html/index.html">
<B>Large-displacement post-buckling of a clamped, circular cylindrical
shell.
</B>
#</A>
\n\n
We simulate the post-buckling deformation of a pressure-loaded,
clamped, thin-walled elastic shell. 
</TD>
<TD>
- How to specify the undeformed reference configuration with
  \c HermiteShellElement structures.
- Using displacement control for  \c HermiteShellElements.
- General conventions:
  - ***
</TD>
<TD>
<CENTER>driver code only</CENTER>
</TD>
</TR>
#####################################################################
######################################################################
<TR>
<TD COLSPAN=3 bgcolor="lightcyan">
<A NAME="fsi"><CENTER><B>(Fluid-structure) interaction problems</B></CENTER></A>
</TD>
</TR>
######################################################################
<TR>
<TD>
<A HREF="../../interaction/circle_as_element/html/index.html">
<B>
Warm-up problem for free-boundary problems: How to parametrise unknown
boundaries.
</B>
</A>
\n\n
We demonstrate how to "upgrade" a \c GeomObject to a \c
GeneralisedElement so that it can be used to parameterise an unknown 
domain boundary.
</TD>
<TD>
- How to use multiple inheritance to combine \c GeomObjects and \c
  GeneralisedElements. 
- How to "upgrade" a \c GeomObject to a \c
  GeneralisedElement so that it can be used to parameterise an unknown 
  domain boundary.
- What is a \c GeomObject's geometric \c Data?
- What is a \c GeneralisedElement's external and internal \c Data?
</TD>
<TD>
<CENTER>complete</CENTER>
</TD>
</TR>
######################################################################
<TR>
<TD>
<A HREF="../../interaction/macro_element_free_boundary_poisson/html/index.html">
<B>
A toy interaction problem: The solution of a 2D Poisson equation coupled to the deformation of the domain boundary
</B>
</A>
\n\n
We show how to use \c MacroElementNodeUpdateElements and
\c MacroElementNodeUpdateMeshes
to implement sparse node update operations in free-boundary problems. 
We demonstrate their
use in a simple free-boundary problem: The solution of Poisson's
equation, coupled to an equation that determines the position of the
domain boundary.
</TD>
<TD>
- How to use \c MacroElementNodeUpdateElements and
  \c MacroElementNodeUpdateMeshes to implement
  sparse node update operations in free-boundary problems.
- Basic free-boundary problems: Making the domain boundary dependent on
  the solution in the domain.
- General conventions:
  - \c MacroElementNodeUpdateElements and \c MacroElementNodeUpdateMeshes.
</TD>
<TD>
<CENTER>complete</CENTER>
</TD>
</TR>
######################################################################
#<TR>
#<TD>
#<A HREF="../../interaction/algebraic_free_boundary_poisson/html/index.html">
#<B>
#The toy interaction problem re-visited : The solution of a 2D Poisson equation coupled to the deformation of the domain boundary -- this time with \c AlgebraicElements.
#</B>
#</A>
#\n\n
#We show how solve the toy interaction problem considered in the
#<A HREF="../../interaction/macro_element_elastic_poisson/html/index.html">
#previous example</A> with \c AlgebraicElements and
#\c AlgebraicMeshes.
#</TD>
#<TD>
#- How to use \c AlgebraicElements and
#\c AlgebraicMeshes to implement
#  sparse node update operations. 
##- General conventions:
#  -  \c AlgebraicElements and \c AlgebraicMeshes.
#</TD>
#<TD>
#<CENTER>driver code and pretty pictures</CENTER>
#</TD>
#</TR>
######################################################################
<TR>
<TD>
<A HREF="../../interaction/fsi_collapsible_channel/html/index.html">
<B>A classical fluid-structure interaction problem: Finite Reynolds
number flow in a 2D channel with an elastic wall.
</B>
</A>
\n\n
We demonstrate the solution of this classical fluid-structure interaction
problem and demonstrate how easy it is to combine the two
single-physics problems (the 
<A HREF="../../beam/tensioned_string/html/index.html">
deformation of an elastic beam under pressure loading</A> and 
the <A HREF="../../navier_stokes/collapsible_channel/html/index.html">
flow in a 2D channel with a moving wall</A>) to a fully-coupled 
fluid-structure interaction problem.
</TD>
<TD>
- The \c FSIFluidElements and \c FSIWallElement base classes.
- Representing a discretised beam/shell structure as a "compound"
  \c GeomObject: The \c MeshAsGeomObject class.
- Using the function 
  \c FSI_functions::setup_fluid_load_info_for_solid_elements(...)
  to set up the fluid-structure interaction.
- The pros (convenient!) and cons (slow!)  of the 
  \c MacroElement/Domain - based node-update procedures
  in fluid-structure interaction problems.
.
</TD>
<TD>
<CENTER>complete</CENTER>
</TD>
</TR>
######################################################################
<TR>
<TD>
<A HREF="../../interaction/fsi_collapsible_channel_algebraic/html/index.html">
<B>Finite Reynolds number flow in a 2D channel with an elastic wall revisited:
Sparse algebraic node updates
</B>
</A>
\n\n
We revisit the 
<A HREF="../../interaction/fsi_collapsible_channel/html/index.html">
problem of flow in a collapsible channel</A> to 
demonstrate that the sparse algebraic node update procedures
first discussed in an 
<A HREF="../../navier_stokes/algebraic_collapsible_channel/html/index.html">
earlier non-FSI example</A> lead to a much more efficient code.
</TD>
<TD>
- How to "sparsify" the node update with algebraic node update
  procedures.
- The \c GeomObject::locate_zeta(...) function and its default
  implementation.
.
</TD>
<TD>
<CENTER>complete</CENTER>
</TD>
</TR>
######################################################################
<TR>
<TD>
<A HREF="../../interaction/fsi_collapsible_channel_adapt/html/index.html">
<B>Finite Reynolds number flow in a 2D channel with an elastic wall
revisited again: Spatial adaptivity in fluid-structure interaction problems.
</B>
</A>
\n\n
We revisit the 
<A HREF="../../interaction/fsi_collapsible_channel/html/index.html">
problem of flow in a collapsible channel</A> yet again to 
demonstrate the use of spatial adaptivity in fluid-structure
interaction problems.
</TD>
<TD>
- How to use spatial adaptativity in fluid-structure interaction problems.
- The \c Steady<NSTEPS> timestepper: How to assign positional
  history values for newly created nodes.
- Updating the node-update data in refineable \c AlgebraicMeshes.
.
</TD>
<TD>
<CENTER>complete</CENTER>
</TD>
</TR>
######################################################################
<TR>
<TD>
<A HREF="../../interaction/fsi_channel_segregated_solver/html/index.html">
<B>
Segregated solvers for fluid-structure-interaction problems: 
Revisiting the flow in a 2D collapsible channel
</B>
</A>
\n\n
We revisit the 
<a HREF="../../interaction/fsi_collapsible_channel/html/index.html">
problem of flow in a collapsible channel</a> once more to 
demonstrate the use of segregated solvers in fluid-structure
interaction problems.
</TD>
<TD>
- The base SegregatableFSIProblem class
- How to construct and solve a segregated problem from a 
(standard) "monolithic" problem 
.
</TD>
<TD>
<CENTER>complete</CENTER>
</TD>
</TR>
######################################################################
<TR>
<TD>
<A HREF="../../preconditioners/fsi/html/index.html">
<B>
Preconditioning monolithic solvers for fluid-structure-interaction problems: 
Revisiting the flow in a 2D collapsible channel yet again
</B>
</A>
\n\n
We revisit the 
<a HREF="../../interaction/fsi_collapsible_channel/html/index.html">
problem of flow in a collapsible channel</a> yet again to 
demonstrate the use of \c oomph-lib's FSI preconditioner
for the monolithic solution of fluid-structure
interaction problems.
</TD>
<TD>
- How to use \c oomph-lib's \c FSIPreconditioner
.
</TD>
<TD>
<CENTER>complete</CENTER>
</TD>
</TR>
######################################################################
<TR>
<TD>
<A HREF="../../interaction/fsi_channel_with_leaflet/html/index.html">
<B>Flow past a flexible leaflet
</B>
</A>
\n\n
We study the flow in a 2D channel that is partially obstructed 
by an elastic leaflet.
</TD>
<TD>
- FSI problems with fully immersed beam structures (i.e. beams
  that are subjected to the fuid traction on both faces).
- Another application of \c oomph-lib's \c FSIPreconditioner. 
</TD>
<TD>
<CENTER>complete</CENTER>
</TD>
</TR>
######################################################################
<TR>
<TD>
<A HREF="../../interaction/turek_flag/html/index.html">
<B>Turek & Hron's FSI benchmark: Flow past an elastic flag
attached to a cylinder
</B>
</A>
\n\n
We demonstrate how to discretise and solve this benchmark problem with
\c oomph-lib.
</TD>
<TD>
- FSI problems with "proper" 2D solids (rather than beam or shell structures)
- FSI problems with wall inertia.
- Another application of \c oomph-lib's \c FSIPreconditioner. 
</TD>
<TD>
<CENTER>complete</CENTER>
</TD>
</TR>
######################################################################
<TR>
<TD>
<A HREF="../../interaction/osc_ring_macro/html/index.html">
<B>A simple fluid-structure interaction problem: Finite Reynolds
number flow, driven by an oscillating ring.
</B>
</A>
\n\n
This is a very simple fluid-structure interaction problem: We study
the finite-Reynolds number internal flow generated by an 
oscillating ring. The wall motion only has a single degree of freedom:
The ring's average radius, which needs to be adjusted to 
conserve mass. The nodal positions in the fluid domain is updated by \c
MacroElements. [This is a warm-up problem for the full
fluid structure interaction problem discussed in the next example].
We compare the predictions for the flow field against
asymptotic results. 
</TD>
<TD>
- Fluid-structure interaction.
- General conventions:
  - ***
</TD>
<TD>
<CENTER>driver code only</CENTER>
</TD>
</TR>
######################################################################
<TR>
<TD>
<A HREF="../../interaction/osc_ring_algebraic/html/index.html">
<B>A simple fluid-structure interaction problem re-visited: Finite Reynolds
number flow, driven by an oscillating ring -- this time with
algebraic updates for the nodal positions.
</B>
</A>
\n\n
We re-visit the simple fluid-structure interaction problem
considered in the <A HREF="../../interaction/osc_ring_macro/html/index.html">
earlier example</A>.This time we perform the update of the
nodal positions with \c AlgebraicElements.
</TD>
<TD>
- Fluid-structure interaction.
- General conventions:
  - ***
</TD>
<TD>
<CENTER>driver code only</CENTER>
</TD>
</TR>
######################################################################
<TR>
<TD>
<A HREF="../../interaction/fsi_osc_ring/html/index.html">
<B>A real fluid-structure interaction problem: Finite Reynolds
number flow in an oscillating elastic ring.
</B>
</A>
\n\n
Our first "real" fluid-structure interaction problem: We study
the finite-Reynolds number internal flow generated by the motion 
of an oscillating elastic ring and compare the results against
asymptotic predictions. 
</TD>
<TD>
- Fluid-structure interaction.
- General conventions:
  - ***
</TD>
<TD>
<CENTER>driver code only</CENTER>
</TD>
</TR>
######################################################################
######################################################################
<TR>
<TD COLSPAN=3 bgcolor="lightcyan">
<A NAME="multi"><CENTER><B>Multi-physics problems</B></CENTER></A>
</TD>
</TR>
######################################################################
<TR>
<TD>
<A NAME="bous">
<A HREF="../../multi_physics/b_convection/html/index.html">
<B>
Simple multi-physics problem: How to combine exisiting single-physics 
elements into new multi-physics elements.</B>
</A></A>
\n\n
We demonstrate how to "combine" a \c CrouzeixRaviartElements and 
\c QAdvectionDiffusionElements into a single \c BuoyantCrouzeixRaviartElement
that solves the Navier--Stokes equations under the Boussinesq approximation
coupled to an energy equation.
</TD>
<TD>
- How to use multiple inheritance to combine two single-physics elements.
- How to write single-physics elements that can be combined into multi-physics
  elements.
- How to use the \c Problem::steady_newton_solve(...) function to find
  steady solutions of unsteady problems.
</TD>
<TD>
<CENTER>complete</CENTER>
</TD>
</TR>
#######################################################################
<TR>
<TD>
<A HREF="../../multi_physics/refine_b_convect/html/index.html">
<B>
Refineable multi-physics problem: How to combine exisiting refineable 
single-physics elements into new refineable multi-physics elements.</B>
</A>
\n\n
We demonstrate how to "combine" a \c RefineableCrouzeixRaviartElements and 
\c RefineableQAdvectionDiffusionElements 
into a single \c RefineableBuoyantCrouzeixRaviartElement
that solves the Navier--Stokes equations under the Boussinesq approximation
coupled to an energy equation.
</TD>
<TD>
- How to use multiple inheritance to combine two refineable
  single-physics elements.
- How to choose the "Z2 flux" for multi-physics elements that are both
  derived from the \c ElementWithZ2ErrorEstimator class.
</TD>
<TD>
<CENTER>complete</CENTER>
</TD>
</TR>
######################################################################
<TR>
<TD>
<A NAME="thermo">
<A HREF="../../multi_physics/thermo/html/index.html">
<B>
Thermoelasticity: How to combine single-physics elements with solid  
mechanics elements.</B>
</A></A>
\n\n
We demonstrate how to "combine" a \c QUnsteadyHeatElement and 
\c QPVDElement into a single \c QThermalPVDElement
that solves the equations governing elastic deformations coupled to
 uniform thermal expansion. The geometric coupling back to the heat
equation is completely hidden.
</TD>
<TD>
- How to use multiple inheritance to combine a single-phyics element
and a solid element
</TD>
<TD>
<CENTER>driver code and pretty pictures</CENTER>
</TD>
</TR>
######################################################################
</TABLE>  
</CENTER>  
<HR>
<HR>
######################################################################

<A NAME="meshes"><B>Mesh generation</B></A>

<CENTER>
<TABLE>
######################################################################
<TR>
<TD>
<B>Mesh type</B>
</TD>
<TD>
<B>\c oomph-lib features/conventions discussed</B>
</TD>
<TD>
<B>Completeness of the documentation</B>
</TD>
</TR>
#####################################################################
######################################################################
<TR>
<TD>
<CENTER><B>
<A NAME="available_meshes">
<A HREF="../../meshes/mesh_list/html/index.html">
Structured meshes
</A>
</A>
</B></CENTER>
\n\n
We list \c oomph-lib's existing structured
meshes and provide a quick overview of their common features.
</TD>
<TD>
- Reminder of \c oomph-lib's design features that facilitate
  the re-use of meshes.
- What structured meshes are available?
.        
</TD>
<TD>
<CENTER>complete</CENTER>
</TD>
</TR>
######################################################################
<TR>
<TD>
<CENTER><B>
<A NAME="third_party_meshes">
<A HREF="../../meshes/third_party_meshes/html/index.html">
Unstructured meshes generated via input from
           third-party mesh generators
</A>
</A>
</B></CENTER>
\n\n
We describe \c oomph-lib's wrappers to third-party 
(unstructured) mesh generators. 
</TD>
<TD>
- <A HREF="../../meshes/mesh_from_triangle/html/index.html"><B>
  TriangleMesh<ELEMENT>:</B></A> \n A Mesh based on the output from
  <A HREF="http://www.cs.cmu.edu/~jrs">J.R.Shewchuk's</A>
  Delaunay mesh generator  
  <A HREF="http://www.cs.cmu.edu/~quake/triangle.html">
  <TT>Triangle</TT></A> \n\n
- <A HREF="../../meshes/mesh_from_tetgen/html/index.html"><B>
  TetgenMesh<ELEMENT>:</B></A> \n A Mesh based on the output from
  <A HREF="http://www.wias-berlin.de/~si">Hang Si's</A> 
  unstructured tetrahedral mesh generator
  <A HREF="http://tetgen.berlios.de/index.html"><TT>TetGen.</TT></A>
  \n\n
- <A HREF="../../meshes/mesh_from_geompack/html/index.html"><B>
  GeompackQuadMesh<ELEMENT>:</B></A> \n A Mesh based on the output from 
  Barry Joe's mesh generator 
  <A HREF="http://members.allstream.net/~bjoe/index.htm">\c Geompack++, </A>
  available as freeware at 
  <A HREF="http://members.allstream.net/~bjoe/index.htm">
  http://members.allstream.net/~bjoe/index.htm.</A>
</TD>
<TD>
<CENTER>complete</CENTER>
</TD>
</TR>
######################################################################
<TR>
<TD>
<CENTER><B>
<A NAME="xfig_mesh">
<A HREF="../../meshes/mesh_from_xfig/html/index.html">
Mesh generation with <code>xfig</code>
</a>
</B></CENTER>
\n\n
\c oomph-lib's one-and-only GUI: Generating unstructured
triangular meshes using <a href="http://www.xfig.org">xfig</a>
and <a href="http://www.cs.cmu.edu/~quake/triangle.html">Triangle</a>
</TD>
<TD>
- How to generated unstructured
triangular meshes using <a href="http://www.xfig.org">xfig</a>
and <a href="http://www.cs.cmu.edu/~quake/triangle.html">Triangle.</a>
</TD>
<TD>
<CENTER>complete</CENTER>
</TD>
</TR>
######################################################################
######################################################################
</TABLE>
</CENTER>  


#///////////////////////////////////////////////////////////////////////

<hr>
<hr>



<A NAME="solvers"><B>Linear solvers and preconditioners</B></A>

<CENTER>
<TABLE>
#####################################################################
######################################################################
<TR>
<TD COLSPAN=3 bgcolor="lightcyan">
<A NAME="linear_solvers"><CENTER><B>Direct and iterative linear solvers 
and general-purpose preconditioners</B></CENTER></A>
</TD>
</TR>
######################################################################
<TR>
<TD>
<A HREF="../../linear_solvers/html/index.html"><B>
Overview</B></A> \n\n
We provide an overview of <code>oomph-lib's</code> direct and iterative
linear solvers and preconditioners.
</TD>
<TD>
- How to change the linear solver for \c oomph-lib's Newton
  solver.
- How to use \c oomph-lib's \c IterativeLinearSolvers and
  \c Preconditioners.
- How to use \c oomph-lib's wrappers to the third-party 
  iterative linear solvers/preconditioners from the
  \c Hypre and \c Trilinos libraries.
.
</TD>
<TD>
<CENTER>complete</CENTER>
</TD>
</TR>
######################################################################
#####################################################################
######################################################################
<TR>
<TD COLSPAN=3 bgcolor="lightcyan">
<A NAME="specific_preconditioners"><CENTER><B>Problem-specific 
preconditioners</B></CENTER></A>
</TD>
</TR>
######################################################################
<TR>
<TD>
<A HREF="../../preconditioners/lsc_navier_stokes/html/index.html"><B>
<code>oomph-lib</code>'s Least-Squares-Commutator (LSC) 
Navier-Stokes precondtitioner</B></A> \n\n
We discuss <code>oomph-lib</code>'s implementation of 
Elman, Silvester & Wathen's Least-Squares-Commutator (LSC) 
Navier-Stokes precondtitioner.
</TD>
<TD>
- How to use <code>oomph-lib</code>'s Least-Squares-Commutator (LSC) 
Navier-Stokes preconditioner
.
</TD>
<TD>
<CENTER>complete</CENTER>
</TD>
</TR>
######################################################################
<TR>
<TD>
<A HREF="../../preconditioners/fsi/html/index.html"><B>
<code>oomph-lib</code>'s fluid-structure interaction 
preconditioner</B></A> \n\n
We discuss <code>oomph-lib</code>'s preconditioner for the
solution of monolithically-discretised fluid-structure interaction 
problems.
</TD>
<TD>
- How to use <code>oomph-lib</code>'s FSI preconditioner
.
</TD>
<TD>
<CENTER>complete</CENTER>
</TD>
</TR>
######################################################################
</TABLE>
</CENTER>  





#///////////////////////////////////////////////////////////////////////

<hr>
<hr>



<A NAME="visualisation"><B>Visualisation of the results</B></A>

<CENTER>
<TABLE>
#####################################################################
######################################################################
<TR>
<TD COLSPAN=3 bgcolor="lightcyan">
<CENTER><B>Visualisation of the results</B></CENTER>
</TD>
</TR>
######################################################################
<TR>
<TD>
<A NAME="paraview">
<A HREF="../../paraview/html/index.html"><B>
Displaying results with paraview</B></A></a> \n\n
We demonstrate how to use 
<a href="http://www.mechanics.citg.tudelft.nl/~simone/">Angelo 
Simone's</a> conversion scripts that allow the \c oomph-lib's
results to be displayed by 
<a href="http://www.paraview.org/New/index.html">paraview.</a>
</TD>
<TD>
- How to display \c  \c oomph-lib's results with
  <a href="http://www.paraview.org/New/index.html">paraview.</a>
.
</TD>
<TD>
<CENTER>complete</CENTER>
</TD>
</TR>
######################################################################
######################################################################
</TABLE>
</CENTER>  



