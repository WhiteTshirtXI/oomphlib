\mainpage Demo problem: Spin-up of a viscous fluid -- the spatially adaptive solution of the unsteady axisymmetric Navier-Stokes equations

This is our first axisymmetric Navier-Stokes example problem. We
discuss the non-dimensionalisation of the equations and their
implementation in \c oomph-lib, and demonstrate the solution of the
spin-up problem.

<HR>
<HR>

\section equation The axisymmetric Navier-Stokes equations

In dimensional form the axisymmetric Navier-Stokes equations are given by the momentum equations (for the \f$ r^* \f$ , \f$ z^* \f$ and \f$ \theta^* \f$ directions, respectively)

\f[ \rho\left(\frac{\partial u_r^*}{\partial t^*} + {u_r^*}\frac{\partial u_r^*}{\partial r^*} - \frac{{u_{\theta}^*}^2}{r^*} + {u_z^*}\frac{\partial u_r^*}{\partial z^*} \right) = B_r^*\left(r^*,z^*,t^*\right)+ \rho G_r^*+ \frac{1}{r^*} \frac{\partial\left({r^*}\sigma_{rr}^*\right)}{\partial r^*} - \frac{\sigma_{\theta\theta}^*}{r^*} + \frac{\partial\sigma_{rz}^*}{\partial z^*}, \f]

\f[ \rho\left(\frac{\partial u_z^*}{\partial t^*} + {u_r^*}\frac{\partial u_z^*}{\partial r^*} + {u_z^*}\frac{\partial u_z^*}{\partial z^*} \right) = B_z^*\left(r^*,z^*,t^*\right)+\rho G_z^*+ \frac{1}{r^*}\frac{\partial\left({r^*}\sigma_{zr}^*\right)}{\partial r^*} + \frac{\partial\sigma_{zz}^*}{\partial z^*}, \f]

\f[ \rho\left(\frac{\partial u_{\theta}^*}{\partial t^*} + {u_r^*}\frac{\partial u_{\theta}^*}{\partial r^*} + \frac{u_r^* u_{\theta}^*}{r^*} +{u_z^*}\frac{\partial u_{\theta}^*}{\partial z^*} \right)= B_\theta^*\left(r^*,z^*,t^*\right)+ \rho G_\theta^*+ \frac{1}{r^*}\frac{\partial\left({r^*}\sigma_{\theta r}^*\right)}{\partial r^*} + \frac{\sigma_{r\theta}^*}{r^*} + \frac{\partial\sigma_{\theta z}^*}{\partial z^*}, \f]

and the continuity equation

\f[ \frac{1}{r^*}\frac{\partial\left(r^*u_r^*\right)}{\partial r^*} + \frac{\partial u_z^*}{\partial z^*} = Q^*. \f]

The dimensional, symmetric stress tensor is defined as:

\f[ \sigma_{rr}^* = -p^* + 2\mu\frac{\partial u_r^*}{\partial r^*}, \qquad \sigma_{\theta\theta}^* = -p^* +2\mu\frac{u_r^*}{r^*}, \f]

\f[ \sigma_{zz}^* = -p^* + 2\mu\frac{\partial u_z^*}{\partial z^*}, \qquad \sigma_{rz}^* = \mu\left(\frac{\partial u_r^*}{\partial z^*} + \frac{\partial u_z^*}{\partial r^*}\right), \f]

\f[ \sigma_{\theta r}^* = \mu r^*\frac{\partial}{\partial r^*} \left(\frac{u_{\theta}^*}{r^*}\right), \qquad \sigma_{\theta z}^* = \mu\frac{\partial u_{\theta}^*}{\partial z^*}. \f]

Here, the (dimensional) velocity components are denoted by \f$ u_r^*
\f$ , \f$ u_z^* \f$ and \f$ u_{\theta}^* \f$ for the radial, axial and
azimuthal velocities, respectively, and we have split the body force
into two components: A constant vector \f$ \rho \ G_i^* \f$ (where \f$
i = r, z, \theta \f$) which typically represents gravitational forces; and a variable body force, \f$ B_i^*(r^*,z^*,t^*) \f$ . \f$ Q^*(r^*,z^*,t^*) \f$ is a volumetric source term for the continuity equation and is typically equal to zero.

We non-dimensionalise the equations, using problem-specific reference quantities for the velocity, \f$ U \f$ , length, \f$ L \f$ , and time, \f$ T \f$ , and scale the constant body force vector on the gravitational acceleration, \f$ g \f$ , so that

\f[ u_r^* = U\, u_r, \qquad u_z^* = U\, u_z, \qquad u_{\theta}^* = U\, u_{\theta}, \f]

\f[ r^* = L\, r, \qquad z^* = L\, z, \qquad t^* = T\, t, \f]

\f[ G_i^* = g\, G_i, \qquad B_i^* = \frac{U\mu_{ref}}{L^2}\, B_i, \qquad p^* = \frac{\mu_{ref} U}{L}\, p, \qquad Q^* = \frac{U}{L}\, Q. \f]

where we note that the pressure and the variable body force have been non-dimensionalised on the viscous scale. \f$ \mu_{ref} \f$ and \f$ \rho_{ref} \f$ (used below) are reference values for the fluid viscosity and density, respectively. In single-fluid problems, they are identical to the viscosity \f$ \mu \f$ and density \f$ \rho \f$ of the (one and only) fluid in the problem.

The non-dimensional form of the axisymmetric Navier-Stokes equations is then given by

\f[ R_{\rho} Re\left(St\frac{\partial u_r}{\partial t} + {u_r}\frac{\partial u_r}{\partial r} - \frac{{u_{\theta}}^2}{r} + {u_z}\frac{\partial u_r}{\partial z} \right) = B_r\left(r,z,t\right)+ R_\rho \frac{Re}{Fr} G_r + \frac{1}{r} \frac{\partial\left({r}\sigma_{rr}\right)}{\partial r} - \frac{\sigma_{\theta\theta}}{r} + \frac{\partial\sigma_{rz}}{\partial z}, \f]

\f[ R_{\rho} Re\left(St\frac{\partial u_z}{\partial t} + {u_r}\frac{\partial u_z}{\partial r} + {u_z}\frac{\partial u_z}{\partial z} \right) = B_z\left(r,z,t\right)+ R_\rho \frac{Re}{Fr} G_z+ \frac{1}{r}\frac{\partial\left({r}\sigma_{zr}\right)}{\partial r} + \frac{\partial\sigma_{zz}}{\partial z}, \f]

\f[ R_{\rho} Re\left(St\frac{\partial u_{\theta}}{\partial t} + {u_r}\frac{\partial u_{\theta}}{\partial r} + \frac{u_r u_{\theta}}{r} +{u_z}\frac{\partial u_{\theta}}{\partial z} \right)= B_\theta\left(r,z,t\right)+ R_\rho \frac{Re}{Fr} G_\theta+ \frac{1}{r}\frac{\partial\left({r}\sigma_{\theta r}\right)}{\partial r} + \frac{\sigma_{r\theta}}{r} + \frac{\partial\sigma_{\theta z}}{\partial z}, \f]

and

\f[ \frac{1}{r}\frac{\partial\left(ru_r\right)}{\partial r} + \frac{\partial u_z}{\partial z} = Q. \f]

Here the non-dimensional, symmetric stress tensor is defined as:

\f[ \sigma_{rr} = -p + 2R_\mu \frac{\partial u_r}{\partial r}, \qquad \sigma_{\theta\theta} = -p +2R_\mu \frac{u_r}{r}, \f]

\f[ \sigma_{zz} = -p + 2R_\mu \frac{\partial u_z}{\partial z}, \qquad \sigma_{rz} = R_\mu \left(\frac{\partial u_r}{\partial z} + \frac{\partial u_z}{\partial r}\right), \f]

\f[ \sigma_{\theta r} = R_\mu r \frac{\partial}{\partial r}\left(\frac{u_{\theta}}{r}\right), \qquad \sigma_{\theta z} = R_\mu \frac{\partial u_{\theta}}{\partial z}, \f]

and the dimensionless parameters

\f[ Re = \frac{UL\rho_{ref}}{\mu_{ref}}, \qquad St = \frac{L}{UT}, \qquad Fr = \frac{U^2}{gL}, \f]

are the Reynolds number, Strouhal number and Froude number
respectively. \f$ R_\rho=\rho/\rho_{ref} \f$ and \f$ R_\mu
=\mu/\mu_{ref}\f$ represent the ratios of the fluid's density and its
dynamic viscosity, relative to the density and viscosity values used
to form the non-dimensional parameters (By default, \f$ R_\rho = R_\mu
= 1 \f$ ; other values tend to be used in problems involving multiple
fluids).

The above equations are typically augmented by Dirichlet boundary conditions
for (some of) the velocity components. On boundaries where 
no velocity boundary conditions are applied, the flow satisfies the
"traction free" natural boundary condition
\f$ t_i = 0 \f$. For example, in the spin-up problem no condition is
applied to the \f$ z \f$-component of the velocity on the symmetry
boundary, which means that the traction in this direction, \f$ t_z \f$,
is equal to zero.

If the velocity is prescribed along the entire domain boundary, 
the fluid pressure \f$ p \f$ is only determined up to an arbitrary
constant. This indeterminacy may be overcome by prescribing the 
value of the pressure at a single point in the domain.

<HR>
<HR>

\section implementation Implementation

\c oomph-lib provides two LBB-stable isoparametric axisymmetric
Navier-Stokes elements that are based on the \c QElement<2,3> family of 
geometric finite elements. They are nine-node quadrilateral elements
which only differ in the way in which the pressure is represented. In
\c AxisymmetricQCrouzeixRaviartElements the pressure is represented by
a discontinuous, piecewise bi-linear function which ensures that the
continuity equation is satisfied within each element. \c
AxisymmetricQTaylorHoodElements represent the pressure by a
globally-continuous, piecewise bi-linear interpolation between the
pressure values that are stored at the elements' four corner nodes.

Apart from the fact that it only makes sense to have axisymmetric
Navier-Stokes elements implemented in 2D, the only difference between
the axisymmetric and non-axisymmetric versions of these elements is
the equations, which are implemented in cylindrical polar coordinates
as opposed to cartesians. The nodal positions are
given by the radial and axial coordinates
\f[ x_0 = r, \qquad x_1 = z, \f]
and the velocity components are stored as the first three nodal values
such that
\f[ u_0 = u_r, \qquad u_1 = u_z, \qquad u_2 = u_{\theta}. \f]
In all other respects the axisymmetric versions of these elements are
the same as the non-axisymmetric versions which are discussed in
detail in the <A
HREF="../../../navier_stokes/driven_cavity/html/index.html#element_types">
2D driven cavity problem</A>. Also included here is information on the
various <A
HREF="../../../navier_stokes/driven_cavity/html/index.html#params">
non-dimensional parameters and their default values</A>.

<HR>
<HR>

\section example The example problem

We will illustrate the solution of the axisymmetric Navier-Stokes
equations using the example of the spin-up problem. The key feature of
this problem is the fact that the flow field approaches a "trivial"
solution (rigid body rotation) which can be fully-resolved by the
discretisation. In that case, equidistribution of the error
(normalised by the norm of the global error which tends to zero!)
leads to strong uniform mesh refinement as the solution approaches the
trivial solution. To avoid this, it is possible to set a constant
reference value error norm.

<CENTER>
<TABLE>
<TR> 
<TD>
\n
<CENTER>
<B>The axisymmetric spin-up problem in a rectangular domain.</B>
</CENTER> 
\n
Solve
\f[
Re\left(\frac{\partial u_r}{\partial t} + {u_r}\frac{\partial u_r}{\partial r}
- \frac{{u_{\theta}}^2}{r} + {u_z}\frac{\partial u_r}{\partial z} \right)
= \frac{1}{r} \frac{\partial\left({r}\sigma_{rr}\right)}{\partial r}
- \frac{\sigma_{\theta\theta}}{r} + \frac{\partial\sigma_{rz}}{\partial z}, 
\f]
\f[
Re\left(\frac{\partial u_z}{\partial t} + {u_r}\frac{\partial u_z}{\partial r}
+ {u_z}\frac{\partial u_z}{\partial z} \right)
= \frac{1}{r}\frac{\partial\left({r}\sigma_{zr}\right)}{\partial r}
+ \frac{\partial\sigma_{zz}}{\partial z}, 
\f]
\f[
Re\left(\frac{\partial u_{\theta}}{\partial t}
+ {u_r}\frac{\partial u_{\theta}}{\partial r} + \frac{u_r u_{\theta}}{r}
+ {u_z}\frac{\partial u_{\theta}}{\partial z} \right)
= \frac{1}{r}\frac{\partial\left({r}\sigma_{\theta r}\right)}{\partial
r} + \frac{\sigma_{r\theta}}{r} + \frac{\partial\sigma_{\theta z}}{\partial z},
 \ \ \ \ \ \ \ \ \ \ @E[AxisymmetricNavierStokes]@
\f] 
and
\f[
\frac{1}{r}\frac{\partial\left(ru_r\right)}{\partial r} + \frac{\partial u_z}{\partial z} = 0,
\f]
in the rectangular domain \f$ D = \{ r \in [0.0,1.0], \; z \in [0.0,1.3] \} \f$,
subject to the Dirichlet boundary conditions:
\f[
\left. \mathbf{u}\right|_{\partial D} = \left. (u_r, u_z,
u_{\theta})\right|_{\partial D} = (0, 0, r\Omega)
\ \ \ \ \ \ \ \ \ \ @E[AxisymmetricNavierStokes_BC1]@
\f]
on the bottom, right and top boundaries and 
\f[
u_r = u_{\theta} = 0
\ \ \ \ \ \ \ \ \ \ @E[AxisymmetricNavierStokes_BC2]@
\f]
on the left boundary, \f$ r=0 \f$. The \f$ z \f$-component of the
velocity on this boundary is traction-free, which corresponds to the
symmetry condition \f$ \partial u_z /\partial r = 0 \f$.

</TD>
</TR>
</TABLE>  
</CENTER>

<HR>
<HR>

\section results Results

Figure 1.1 below shows contour plots of the azimuthal
velocity component and the pressure distribution with superimposed
streamlines, computed with axisymmetric Taylor-Hood elements for \f$ Re = 5
\f$, and taken from <A HREF="../figures/spin_up_stream.avi">this
animation</A>. Figure 1.2 shows "carpet plots" of the velocity
components and pressure fields, taken from <A
HREF="../figures/spin_up_carpet.avi">this animation</A>.

@I w 0.75\textwidth spin_up_stream "Plot of the velocity and pressure fields computed with axisymmetric Taylor-Hood elements for Re = 5. " 

@I w 0.75\textwidth spin_up_carpet "Carpet plot of the velocity and pressure fields computed with axisymmetric Taylor-Hood elements for Re = 5. " 

<HR>
<HR>

\section namespace Global parameters and functions

The Reynolds number is the only non-dimensional parameter
needed in this problem. However, the unsteady term in the momentum
equations is multiplied by the Wormersley number (the product of the
Reynolds and Strouhal numbers) and has a default value of zero,
which gives steady flow. Since our problem is time-dependent we must
therefore also set the Wormersley number to be equal to the
Reynolds number (corresponding to \f$ St = 1 \f$). As usual, we define
these quantities in a namespace:

\dontinclude spin_up.cc
\skipline start_of_namespace
\until End of namespace

<HR>
<HR>

\section main The driver code

We start by specifying the (non-dimensional) length of time we want to
run the simulation for and the size of the timestep. Because all driver
codes are run as part of \c oomph-lib's self-testing routines we allow
the user to pass a command line argument to the executable which sets
the maximum time to some lower value.

\skipline start_of_main
\until t_max = 0.02

Next we specify the dimensions of the mesh and the number of elements
in the radial and azimuthal directions. We also set the maximum and
minimum mesh refinement levels.

\skipline Number of elements in radial (r) direction
\until minimum_ref_level

We build the problem using \c
RefineableAxisymmetricQTaylorHoodElements and the \c BDF<2>
timestepper, before calling \c unsteady_run(...). This function solves
the system at each timestep using the \c 
Problem::unsteady_newton_solve(...) function before documenting the result.

\skipline Doing RefineableAxisymmetricQTaylorHoodElements
\until End of RefineableAxisymmetricQTaylorHoodElements

Finally, we repeat the process with \c RefineableAxisymmetricQCrouzeixRaviartElements.

\skipline Doing RefineableAxisymmetricQCrouzeixRaviartElements
\until End of main

<HR>
<HR>

\section problem The problem class

The \c Problem class for our unsteady axisymmetric Navier-Stokes
problem is very similar to that used in the <A
HREF="../../../navier_stokes/rayleigh_channel/html/index.html">Rayleigh
channel example</A>. We specify the type of the element and the type
of the timestepper (assumed to be a member of the \c BDF family) as
template parameters, before passing the number of elements and domain
length in both coordinate directions to the problem constructor.

\dontinclude spin_up.cc
\skipline start_of_problem_class
\until ~RefineableRotatingCylinderProblem()

No action is needed before or after solving, but we (re-)set the
boundary conditions before each timestep by overloading
\c Problem::actions_before_implicit_timestep(). This is to ensure that
all newly-created nodes are given the correct boundary conditions.
On the three solid boundaries (\f$ r = 1.0 \f$, \f$ z = 0.0 \f$ and
\f$ z = 1.3 \f$) we set the radial and axial velocities to zero so
that there is no penetration of the wall by the fluid or flow along
it. To simulate the domain rotating around the axis \f$ r = 0 \f$ we set
the azimuthal velocity at each node along these boundaries to be equal
to the radial position of the node. On the symmetry boundary (\f$ r =
0 \f$) we set the radial and azimuthal velocities to zero but leave
the axial compoment unconstrained. As discussed above, not applying
a velocity boundary condition causes the flow to satisfy the "traction
free" natural boundary condition; in this case, \f$ t_z = 0 \f$. This
corresponds to the symmetry condition \f$ \partial u_z /\partial r = 0 \f$.

\skipline Update before solve
\until End of actions_before_implicit_timestep

In Navier-Stokes problems in which the velocity is prescribed along
the entire domain boundary, the pressure is only determined up an
arbitrary constant, making it necessary to "pin" one pressure
value. If the pinned pressure degree of freedom is associated with
an element that is unrefined during the mesh adaptation, the pinned
degree of freedom may no longer exist in the adapted problem. We
therefore use the function \c Problem::actions_after_adapt() to
ensure that precisely one pressure degree of freedom is pinned when
re-solving the adapted problem. Additionally, the possible presence
of hanging nodes in an adapted mesh requires special treatment for
elements (e.g. Taylor-Hood elements) in which the pressure is
represented by a low-order  interpolation between a subset of the
element's nodal values. The function \c
AxisymmetricNavierStokesEquations::pin_redundant_nodal_pressures(...)
performs the required tasks. The technical details of these functions
are discussed in detail in <A
HREF="../../../navier_stokes/adaptive_driven_cavity/html/index.html">an
earlier tutorial</A>.

\skipline After adaptation
\until End of actions_after_adapt

Next we set the initial conditions for the problem. We loop over all
nodes in the mesh and set each of the three velocity components to
zero. No initial conditions are required for the pressure. We then
call the function \c Problem::assign_initial_values_impulsive() which copies
the current values at each of the nodes into the required number of
history values for the timestepper in question.
This corresponds to an impulsive start, as for all time \f$ t \leq 0
\f$ none of the fluid is moving. At the first
timestep, the solid domain boundaries are immediately moving with a speed
corresponding to their radial distance from the symmetry boundary.
\c Problem::set_initial_condition() is called after each mesh adaptation on
the first timestep only. This means that any newly-created nodes
obtain their values from the actual (analytical) initial
conditions rather than from interpolation of the values of
previously-existing nodes.

\skipline Set initial conditions
\until End of set_initial_condition

We provide an access function to the specific mesh and define the
post-processing function \c doc_solution(...).

\skipline Access function for the specific mesh
\until doc_solution

The function \c unsteady_run(...), discussed below, performs the
timestepping and documents the solution in the directory specified by
\c dir_name.

\skipline Do unsteady run
\until minimum_ref_level

Finally, we provide a helper function
\c fix_pressure(...) which pins a pressure value in a specified element
and assigns a specific value. The problem's only member data contains
an output stream in which we record the time-trace of the solution.

\skipline private
\until End of problem class

<HR>
<HR>

\section constructor The problem constructor

We start by building the timestepper, determining its type from the
class's second template argument, and pass a pointer to it to 
the problem, using the function \c Problem::add_time_stepper_pt(...).

\skipline start_of_constructor
\until add_time_stepper_pt

Next we build the adaptive mesh and specify an error estimator, which
will be used to perform automated spatial adaptivity. We pass this to
the mesh.

\skipline Build and assign mesh
\until spatial_error_estimator_pt()

We pin the radial and azimuthal velocity components on all boundaries,
and the axial component on the three solid boundaries.

\skipline -----
\until End of loop over mesh boundaries

We pass the pointers to the Reynolds and Womersley numbers,
\f$ Re \f$ and \f$ Re\, St \f$ , and the pointer to the global time
object (created when we called \c Problem::add_time_stepper_pt(...)
above) to the elements. Because we know that the mesh will remain
stationary we can disable the ALE formulation of the unsteady
equations by calling \c
AxisymmetricNavierStokesEquations::disable_ALE(). This suppresses
the additional computation required to calculate the correction to the Eulerian
time-derivative \f$ \partial u /\partial t \f$ which is required if
the mesh is moving, and is discussed in detail <A HREF="../../../optimisation/html/index.html#ale">here</A>.

\skipline -----
\until End of loop over elements

Since no traction boundary conditions are
applied anywhere, the pressure is only determined up to an arbitrary
constant. For the reasons discussed above we pin any redundant
pressure degrees of freedom caused by hanging nodes and then ensure a
unique solution by pinning a single pressure value. Finally, we set up
the equation numbering scheme using the function \c
Problem::assign_eqn_numbers().

\skipline Pin redundant pressure dofs
\until End of constructor

<HR>
<HR>

\section doc Post-processing

As expected, this member function documents the computed
solution. First we record the following parameters in the trace file:
- the value of the continuous time,
- the maximum permitted elemental error (above which the element will
be refined),
- the minimum permitted elemental error (below which the element will
be unrefined), and
- the maximum/minimum actual errors across all elements in the present solution
(before re-solving on an adapted mesh).

\skipline start_of_doc_solution
\until min_error()

We then output the computed solution, and include \c Tecplot instructions
that generate a blue line in the top-left corner of the plot to
indicate how time progresses during the simulation.

\skipline ofstream
\until End of doc_solution

<HR>
<HR>

\section timestepping The timestepping loop

The function \c unsteady_run(...) is used to perform the timestepping
procedure. We start by creating a \c DocInfo object to store the
output directory and the label for the output files.

\skipline start_of_unsteady_run
\until doc_info.number()=0

Next we open the trace file and write a suitable header for the
visualisation with \c Tecplot.

\skipline Open trace file
\until std::endl

Before using any of \c oomph-lib's timestepping functions, the timestep
\f$ dt \f$ must be passed to the problem's timestepping routines by calling
the function \c Problem::initialise_dt(...) which sets the weights for
all timesteppers in the problem. Next we assign the initial conditions
by calling \c Problem::set_initial_condition(), which was discussed above.

\skipline Initialise timestep
\until set_initial_condition

The maximum and minimum permitted errors (which determine whether or
not an element will be refined/unrefined) are overridden, as are the
maximum and minimum mesh refinement levels, from which the maximum
number of allowed adaptations per timestep can be determined. The mesh
is then refined uniformly until it reaches the minimum refinement level.

\skipline Override the maximum
\until refine_uniformly()

We determine the number of timesteps to be performed and document the
initial conditions. A flag, \c first_timestep, is initialised and set
to true. This flag will be passed to \c
Problem::unsteady_newton_solve(...), and when set to true instructs the
code to re-assign the initial conditions after every mesh adaptation.

\skipline Determine number of timesteps
\until first_timestep

As mentioned above, the flow field approaches a "trivial" solution
(rigid body rotation) which can be fully-resolved by the
discretisation, and equidistribution of the error leads to stong
uniform mesh refinement despite the fact that the solution is already
fully converged. To avoid this we prescribe a reference flux.

\skipline Specify normalising factor explicitly
\until reference_flux_norm()

Finally, we perform the actual timestepping and document the solution
after every timestep.

\skipline Timestepping loop
\until End of unsteady_run

<HR>
<HR>


\section comments Comments and Exercises

\subsection bcs Boundary conditions

In our driver code we reset the boundary conditions for the problem
before each Newton solve. This is done to ensure that any
new boundary nodes created during mesh refinement are explicitly given
the correct boundary conditions. However, the function that actually
creates the new nodes, \c RefineableQElement<2>::build(...),
automatically assigns new nodes with values by interpolating within the father
element. Since in our case the boundary conditions are linear, there
is in fact no need to reset them at any point during
the simulation, since new boundary nodes would be given precisely the
correct values by interpolation. Resetting the boundary conditions is
only strictly necessary, therefore, in cases where:

-# the boundary conditions are given by a function which is of higher
   order than the shape functions used by the finite element, or
-# the boundary conditions are time-dependant.

Specifying the boundary conditions in the constructor, however, is not
an option since at time \f$ t = 0 \f$ the initial conditions are such
that the velocity is zero everywhere. Therefore the simplest (and most
robust) way to assign the boundary conditions is in fact inside the \c
actions_before_implicit_timestep() function, as we do in the driver
code, even though it is not
strictly necessary to reset them once they have been set at time \f$ t
= dt \f$.

\subsection ics Initial conditions

Similarly, we repeatedly call the \c set_initial_condition() function
after each mesh adaptation during the first timestep. This is done to
ensure that the exact initial conditions are given to newly created
nodes during mesh refinement. Again, this is not strictly necessary in our
case since \c RefineableQElement<2>::build(...) assigns new nodes with
current/history values by interpolation of the current/history
values stored at the nodes of the father element; because our
initial conditions are that the fluid velocity is and always has been
zero everywhere, these conditions will be exactly picked up by the
interpolation. However, should the initial conditions be given by an
analytical function of higher order than the shape functions used by
the finite elements, it would indeed be necessary to explicitly
provide newly created nodes with the exact initial conditions during
the first timestep.

\subsection exercises Exercises

-# Remove the function \c set_initial_condition() entirely from the
   driver code (do not just leave it empty!), so that the initial
   conditions are not constantly reset during the first timestep.
   Confirm that the code still produces approximately the same
   results. Why does it not produce precisely the same results?
-# Restore \c set_initial_condition() to  its original state, but
   remove the call to \c assign_initial_values_impulsive(). Confirm
   that the code still produces precisely the same results. Why are
   exactly the same results produced this time?

<HR>
<HR>

\section sources Source files for this tutorial
- The source files for this tutorial are located in the directory:\n\n
<CENTER>
<A HREF="../../../../demo_drivers/axisym_navier_stokes/spin_up/">
demo_drivers/axisym_navier_stokes/spin_up/
</A>
</CENTER>\n
- The driver code is: \n\n
<CENTER>
<A HREF="../../../../demo_drivers/axisym_navier_stokes/spin_up/spin_up.cc">
demo_drivers/axisym_navier_stokes/spin_up/spin_up.cc
</A>
</CENTER>
.