\mainpage A discussion on oomph-lib's Block Preconditioning Framework


In this document we discuss \c oomph-libs block preconditioning
framework. We describe the functionality of the framework by starting with 
discussing the implementation of a simple block diagonal preconditioner, 
a block triangular preconditioner, and finally a preconditioner for the 
solution of (pseudo-)solid mechanics problems with prescribed boundary motions.
The aim of the block preconditioning framework is to provide a simple 
environment to facilitate the implementation of distributed block 
preconditioners which in particular allows existing (block) preconditioners to 
be reused to create in hierarchical fashion new block preconditioners for 
multi-physics problems. For example, in the pseudo-solid preconditioner 
(considered in this document) we reuse existing general purpose block 
preconditioners for the subsidiary problems.


\section theory Theoretical Background

In \c oomph-lib, all problems are solved by Newton's method,
which requires the repeated solution of linear systems of the form

\f[
J\;{\bf \delta x}=-{\bf r}
\f]

for the Newton correction \f$\bf \delta x\f$ where \f$J\f$ is the
Jacobian matrix and \f$\bf r\f$ is the vector of residuals. (Left) 
preconditioning represents a transformation of the original linear system to

\f[
P^{-1}J\;{\bf \delta x}=-P^{-1}{\bf r}
\f]

introduced with the aim of accelerating the convergence of Krylov subspace 
iterative methods such as GMRES or CG. The application of the preconditioner 
requires the solution of

\f[
P{\bf z}={\bf y}
\f]

for \f$\bf z\f$ at each Krylov iteration.

Block preconditioning requires special enumeration schemes for the unknowns 
(equivalent to reordering the linear systems) where all the unknowns 
corresponding to each type of DOF are grouped together and enumerated 
consecutively. This leads to a natural block structure of the linear systems.

For instance, linear elasticity problems (discussed <a href="../../../linear_elasticity/periodic_load/html/index.html">here</A>) involve the solid (the nodal positions in the solid domain) degrees of freedom (DOFs). Consider the two-dimensional case, we begin by reordering the linear system to group together the two types of DOF 

\f[
\left[ 
\begin{array}{cc}
S_{xx}&S_{xy}\\
S_{xy}&S_{yy}
\end{array}
\right]
\left[ 
\begin{array}{c}
\bf \delta x_x\\
\bf \delta x_y\\
\end{array}
\right]
=
-
\left[
\begin{array}{c}
\bf r_x\\
\bf r_y\\
\end{array}
\right],
\f]

The block diagonal preconditiner of the form 
\f[
P_{diag}=
\left[
\begin{array}{cc}
S_{xx}& \\
      &S_{yy}
\end{array}
\right]
\f]
is obtained by omitting the off-diagonal blocks from the Jacobian.

The application of the preconditioner requires the solution of the linear system

\f[
\left[
\begin{array}{cc}
S_{xx}& \\
      &S_{yy}
\end{array}
\right]
\left[
\begin{array}{c}
\bf z_x\\
\bf z_y\\
\end{array}
\right]
=
\left[
\begin{array}{c}
\bf y_x\\
\bf y_y
\end{array}
\right],
\f]

the two sub-blocks are solved directly.

\section implementation Framework Overview

The above example shows that the application of block preconditioners
require several generic steps:

-# The classification of the DOFs.
-# The application of subsidiary preconditioning operators.

The following subsections describe how these tasks are performed
within \c oomph-lib's block preconditioning framework.

\subsection block_preconditionable_elements Block Preconditionable Elements

The classification of DOFs is implemented at an elemental level. The class \c GeneralisedElement
contains two broken virtual methods that must be re-implemented to
label the DOFs with their type. The methods are:

- \c GeneralisedElement::ndof_types() must return the number of DOF types
  associated with an element.
- \c GeneralisedElement::get_dof_numbers_for_unknowns(...) must return a list of pairs
  comprising a map from global equation number to DOF type for all unknowns
  in the element.

These are already implemented for many elements. For instance the two-dimensional FSI channel with leaflet problem has two types of element:

- \c RefineableQTaylorHoodElement<2> are the fluid elements. They have three types of DOF; \f$x\f$-velocity DOFs are labelled \c 0, \f$y\f$-velocity DOFs are labelled \c 1 and
  the pressure DOFs are labelled \c 2.
- \c FSIHermiteBeamElement are the wall elements and have one type of
  DOF (the nodal position) labelled \c 0.

The linear elasticity elements are made block-preconditionable with a wrapper
around the element implemented in the driver code.

\dontinclude two_d_linear_elasticity_with_simple_block_diagonal_preconditioner.cc
\skipline  start_of_mylinearelasticityelement
\until };
Thus, in the \c MyLinearElasticityElement<2> we have two types of DOF; corresponding to the \f$x\f$ and \f$y\f$ directions. They are enumerated \c 0 and \c 2 respectively.

\subsection dof_types_and_block_types DOF Types and Block Types

In the block diagonal preconditioner for the two-dimensional linear elasticity problem, there are two block types. There are also two DOF types. However, in more complicated preconditioners, such as the <a href="../../../preconditioners/lsc_navier_stokes/html/index.html"> Least-Squares Commutator (LSC) Navier-Stokes preconditioner</A>, there are more DOF types than there are block types. The relationship between DOF types, block types, elemental DOF type classification and meshes are:

- \b Elemental \b DOF \b type \b classification: Each element classifies it's own DOF type in the function \c get_dof_numbers_for_unknowns(...). In the case of \c MyLinearElasticityElement<2> elements, the DOF types are classified as \c 0 and \c 1. For \c QTaylorHoodElement<2> elements, the DOF types are classified as \c 0 and \c 1 for the \f$x\f$ and \f$y\f$-velocities, and \c 2 for the pressure \f$p\f$. 

- \b Role \b of \b mehes: Each mesh acts as a container for a set of DOF type classifications for a particular element. If two different elements types are put in to the same mesh, then their \c ndof_types() should return the same number and their DOF type classifcations will be treated the same. For example, the \c QTaylorHoodElement<2> classifies the DOF types as follows:
 - \c 0 \f$x\f$-velocity
 - \c 1 \f$y\f$-velocity
 - \c 2 \f$p\f$-pressure
 .
 If we wish to impose parallel outflow along a boundary, we attach \c ImposeParallelOutflowElement<ELEMENT>, see <a href="../../../navier_stokes/vmtk_fluid/html/index.html"> demo problem: Steady finite-Reynolds-number flow through an iliac bifurcation </A>, these \c FaceElements classifies the bulk DOF types as follows:
 - \c 0 \f$x\f$-constrained velocity
 - \c 1 \f$y\f$-constrained velocity
 - \c 2 \f$L\f$-Lagrange multiplier
 .
 Although the \c ndof_types() for these two different elements are the same, there are clearly six distinct DOF types. To ensure that the block preconditioning framework treats these as different DOF types, we must have two meshes for the two different type of elements. If we put the two elements in the same mesh, then the block preconditioning framework will not distinguish between the two \c 0 DOF types, \c 1 DOF types and \c 2 DOF types.
- \b DOF \b types \b in \b the \b block \b preconditioner: The different meshes instructs the block preconditioning framework how to order the DOF types (the \c ndof_types() function provides an offset). For example, consider the above \c vmtk problem, the first mesh (the bulk mesh) says the first three DOF types are \c 0 , \c 1 and \c 2 (we know that this corresponds to the \f$x\f$ and \f$y\f$-velocities and pressure). At this stage the offset is \c 0 and the DOF types in the block preconditioner are \c 0+0 , \c 1+0 and \c 2+0. The second mesh (the surface mesh) also has DOF types \c 0 , \c 1 and \c 2, but because it is a different mesh, the offset is now updated to the sum of the \c ndof_types() of the first element in all previous meshes (hence it is vital that the \c ndof_types() of all the elements in a single mesh is the same, although the elements may be different), in this case it is \c 3. The DOF types in the block preconditioner for the surface mesh DOF types are \c 0+3 , \c 1+3 \c 2+3 (which we know corresponds to the constrained \f$x\f$ and \f$y\f$-velocities and the Lagrange multiplier DOF type). It is important to note that the order of the meshes determines how the DOF types are enumerated in the block preconditioner, the block preconditioner should handle the ordering of the meshes, the user should use functions such as \c set_navier_stokes_mesh(...) in the case of the \c NavierStokesSchurComplementPreconditioner.
Note: Each DOF can be classified more than once. The classification should be the last mesh visited by the block preconditioning framework. This should not be an issue if you do not have discontinuous boundary conditions.
- \b Block \b types: The block types are the sub-blocks of matrices the block preconditioner works with. They may contain more than one DOF type or be as fine grain as the number of DOF types. Note: There can not be more block types than there are DOF types in the block preconditioner. For example, in case of the the LSC preconditioner (in 2D) we have three DOF types (\f$x\f$ and \f$y\f$-velocities and pressure), but it works with just two block types (velocity block and pressure block). The setup of the block types are handled by the function... \c block_setup(...) ! The setup of the blocks and DOF types will be discussed in more detail later on.

\subsection subsidiary_preconditioners Master and Subsidiary Preconditioners

Consider the again the <a href="../../../preconditioners/lsc_navier_stokes/html/index.html"> Least-Squares Commutator (LSC) Navier-Stokes preconditioner</A>.
If we decide to approximate the \f$ {\bf F}\f$ block (the momentum block) by the diagonal blocks, we can pass the block diagonal preconditioner discussed in <a href="../../../mpi/distributed_general_purpose_block_preconditioners/html/index.html">(Distributed) General-Purpose Block Preconditioners</A> for the LSC preconditioner to use as a subsidiary preconditioner via the function \c set_f_preconditioner(...). We can do the same with the pressure solve with the function \c set_p_preconditioner(...). We refer to these preconditioners as subsidiary preconditioners. \c Oomph-lib's block preconditioning framework facilitates the the reuse of existing preconditioners as subsidiary preconditioners.


It is important to note that we do not need to consider the \b block structure of subsidiary block preconditioners when developing master preconditioners. However, the master preconditioner must know the DOF type ordering of the subsidiary preconditioner. For example, if the LSC preconditioner is a subsidiary preconditioner (as is the case of the FSI preconditioner), the FSI preconditioner must ensure that the last DOF type given to the LSC preconditioner is the pressure DOF type.


\section using_the_simple_block_preconditioner Using The Simple Block Preconditioner

We begin our discussion of the implementation details by demonstrating how to use the preconditioner (implemented in the class \c SimpleBlockDiagonalPreconditioner) in an actual driver code (\c two_d_linear_elasticity_with_simple_block_diagonal_preconditioner.cc).

In the problem constructor, we construct the solver and preconditioner combination. We specify the GMRES iterative solver, and, if available, use the distributed version implemented in \c TrilinosAztecOOSolver.

\dontinclude two_d_linear_elasticity_with_simple_block_diagonal_preconditioner.cc
\skipline // Create the solver
\until linear_solver_pt() = Solver_pt;

Then we construct an instance of the preconditioner. This linear elasticity problem contains one types of element used for preconditioning (see \ref block_preconditionable_elements ). There also exists \c LinearElasticityTractionElement, but in this case the block preconditioner does not require the surface mesh since the bulk mesh contains all the DOFs that needs to be classified and \c MyLinearElasticityElement does classify all the DOF in the bulk mesh. We store
the different element types in seperate meshes. In this context meshes
are simply containers for elements. Only the bulk mesh is passed to
the preconditioner. Finally, the preconditioner is passed to the 
solver.

\dontinclude two_d_linear_elasticity_with_simple_block_diagonal_preconditioner.cc
\skipline // Create the preconditioner
\until preconditioner_pt()=Prec_pt;

In the main function,
\dontinclude two_d_linear_elasticity_with_simple_block_diagonal_preconditioner.cc
\skipline  start_of_main
\until {

we create an instance of the  problem which problem can now be solved in the normal \c oomph-lib fashion:

\dontinclude two_d_linear_elasticity_with_simple_block_diagonal_preconditioner.cc
\skipline // Set up doc info
\until problem.doc_solution(doc_info);


\section implementing_a_block_diagonal_preconditioner The Implementation of a block diagonal preconditioner

We discuss the implementation of a block preconditioner within
\c oomph-lib's block preconditioning framework. In particular, we will address three fundamental tasks:

- How to identify and classify the DOFs in the underlying \c Problem.
- How to extract subsidiary matrix blocks from the full Jacobian.
- How to recycle existing preconditioning operators within new preconditioners.


We implement the block diagonal preconditioner in the
class \c SimpleBlockDiagonalPreconditioner. This class inherits
from the base class \c BlockPreconditioner which provides the generic functionality required for common block preconditioning operations.


\dontinclude simple_block_preconditioners.h
\skipline start_of_simple_block_diagonal_preconditioner_class
\until {

This preconditioner requires a \c Vector of \c Preconditioner pointers for each diagonal block matrix.

\dontinclude simple_block_preconditioners.h
\skipline Vector of SuperLU preconditioner pointers
\until Diagonal_block_preconditioner_pt;

\subsection constructor Constructor

The constructor is usually used to initialised variables. In this case, there is nothing to initialise!

\dontinclude simple_block_preconditioners.h
\skipline Constructor for SimpleBlockDiagonalPreconditioner 
\until end_of_constructor

\subsection setup Preconditioner Setup

Like all preconditioners, \c BlockPreconditioners have two key
methods, \c setup(...) and \c preconditioner_solve(...) both of which
are discussed in more detail in the <a href="../../../linear_solvers/html/index.html">
Linear Solvers Tutorial</A>. We begin by 
considering \c setup(...).

\dontinclude simple_block_preconditioners.h
\skipline start_of_setup_for_SimpleBlockDiagonalPreconditioner
\until ::setup()


At the simplest level, \c Meshes are just containers for elements. To
enable the \c BlockPreconditioner to differentiate between
different elements, each type of element must be stored in a
separate mesh. The order of the meshes determine the order of the DOF types.
Therefore, in more sophisticated preconditioners, the preconditioner usually handles the calls to \c set_nmesh(...) and \c set_mesh(...) functions. For this simplistic case, the \c set_nmesh(...) and \c set_mesh(...) functions were called in the driver code.

Passing the meshes to \c BlockPreconditioner gives the framework access to the
meshes and allows the preconditioner writer access to the 
number of DOF types associated with the elements in
each mesh. 

\subsection block_setup block_setup(...)
The next step is to define a mapping from DOF number to block
number. This preconditioner uses every DOF type as block types.
That is to say, if the Jacobian takes the form 
\f[
J =
\left[
\begin{array}{cc}
S_{xx}&S_{xy} \\
S_{yx}&S_{yy}
\end{array}
\right],
\f]
then the preconditioner is
\f[
P_{diag} =
\left[
\begin{array}{cc}
S_{xx}& \\
      &S_{yy}
\end{array}
\right].
\f]
This is achieved by calling the function \c block_setup(...) with no arguments. By default, this has the same effect as calling \c block_setup(...) with the identity \c block_to_dof_map \c = \c [ \c 0 \c 1 \c ].

\dontinclude simple_block_preconditioners.h
\skipline Set up the block look up scheme
\until this->block_setup();

\subsubsection combining_dof_types Combining DOF types

If we want a block type to consist of more than one DOF type, then we can provide a \c dof_to_block_map to the function \c block_setup(...) describing the mapping we want. For example, if we extend the example above so there are three DOF types

\subsubsection reordering_block_types Re-ordering block types

The next step is to set up the subsidiary
operators required by the preconditioner. 


We start with the solid subsidiary preconditioner (\f$\tilde S\f$). We  extract
the solid subsidary matrix \f$S\f$ from the Jacobian using the \c
BlockPreconditioner method \c get_block(...) and then set up the solid
subsidiary preconditioner:

\dontinclude fsi_channel_with_leaflet.cc
\skipline First the solid preconditioner
\until delete solid_matrix_pt;

Dealing with the fluid subsidiary preconditioner (\f$\tilde F\f$) is slightly more complicated -- this is
because a fluid subsidiary preconditioner is a block preconditioner itself. A subsidiary block preconditioner requires access to
the data structures in its master block preconditioner and the subset of
master preconditioner DOF types that it operates on.

This is done in two steps:

-# First we must turn the \c NavierStokesSchurComplementPreconditioner into a subsidiary 
block preconditioner. We assemble a list a fluid DOF types in this
preconditioner, and pass this list to the Navier-Stokes preconditioner
to indicate that
DOF type \c i in the (master) FSI preconditioner is DOF type \c i in
the (subsidiary) fluid preconditioner (for \c i \c = \c 0, \c 1, \c 2)
(Note that the fact that this mapping is the identity mapping is a
result of choosing the fluid mesh to be mesh \c 0; in general the index of \c ns_dof_list corresponds to the DOF type number in the Navier Stokes subsidiary preconditioner and the value corresponds to the index in this master preconditioner).
\dontinclude fsi_channel_with_leaflet.cc
\skipline Next the fluid preconditioner
\until turn_into_subsidiary_block_preconditioner(this,ns_dof_list);
-# Now we set up the \c NavierStokesSchurComplementPreconditioner.
We pass the Navier-Stokes mesh to the the
subsidiary preconditioner and set up the operator. Note that the
pointer to the full FSI Jacobian is passed to the subsidiary block
preconditioner. This allows the subsidiary preconditioner to extract
the relevant sub-blocks, using the lookup schemes established by the
call to \c  turn_into_subsidiary_block_preconditioner(...).
\dontinclude fsi_channel_with_leaflet.cc
\skipline Setup the NavierStokesSchurComplement preconditioner.
\until Navier_stokes_preconditioner_pt->setup();

The final operator to set up is the matrix-vector product. This mirrors
the set up of the solid subsidiary preconditioner. First the subsidiary
matrix is extracted from the Jacobian and then the operator is set up:

\dontinclude fsi_channel_with_leaflet.cc
\skipline Finally the fluid onto solid matrix vector product operator
\until delete fluid_onto_solid_matrix_pt;

The FSI preconditioner is now ready to be used. 

\subsection solve Preconditioner Solve

Next we consider the \c preconditioner_solve(...) method which applies the action of the preconditioner to the input vector \f$\bf y\f$ and returns the result in \f$\bf z\f$.

\dontinclude fsi_channel_with_leaflet.cc
\skipline start_of_preconditioner_solve
\until DoubleVector &z)

In this section we follow the four steps outlined at the end of the \ref theory section.

The first step is to apply the Navier-Stokes preconditioner \f$\tilde
F\f$ to the fluid elements \c y_f of \c y. Since \f$\tilde F\f$ is a 
subisidiary block preconditioner  we apply it to the full-length
 \c y and \c z vectors which contain both the fluid and solid unknowns. The block preconditioner infrastructure utilised 
within the \c NavierStokesSchurComplementPreconditioner will ensure that the 
preconditioner only operates on fluid DOFs.

\dontinclude fsi_channel_with_leaflet.cc
\skipline Fluid Subsidiary Preconditioner
\until Navier_stokes_preconditioner_pt->preconditioner_solve(y,z);

The fluid elements \c z_f of the vector \c z will now have been updated to
contain the action of the SchurComplement preconditioner on the fluid elements \c y_f of
the vector \c y.


To apply the fluid-solid coupling matrix vector product \f$C_{sf}\f$, we must first
copy the fluid elements from \c z into another vector \c z_f. We then apply
the matrix-vector product operator to  \c z_f and store the result in a
vector \c w. Finally, we subtract \c w from the solid residuals \c y_s and store the
result in \c w to complete the application of the matrix-vector product.

\dontinclude fsi_channel_with_leaflet.cc
\skipline Fluid Onto Solid Matrix Vector Product Operator
\until w = y_s;

The final stage of the preconditioning operation is to apply the solid
subsidiary preconditioner \f$\tilde S\f$ to \c
w and return the result to \c z. We note that because the solid subsidiary
preconditioner is not a block preconditioner, the preconditioner solve
method must be called with the solid block vectors. The result is then
copied to the full-length vector \c z which contains the fluid and solid DOFs.

\dontinclude fsi_channel_with_leaflet.cc
\skipline Solid Subsidiary Preconditioner
\until this->return_block_vector(1,z_s,z);


\section Parallelisation

We note that the above discussion did not address the parallelisation of the preconditioner. This is because the subsidiary
operators ( \c NavierStokesSchurComplementPreconditioner, \c
SuperLUPreconditioner and \c MatrixVectorProduct) are all parallel
operators, and given that the action of the \c BlockPreconditioner
framework is parallelised, the parallelisation of this preconditioner
requires no more than running the executable under MPI on multiple processes.
